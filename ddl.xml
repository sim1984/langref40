<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="ddl" xml:lang="ru">
    <info>
        <title>Операторы DDL</title>
    </info>

    <para>Data Definition Language (DDL) — язык описания данных. С помощью этого подмножества языка
        создаются, модифицируются и удаляются объекты базы данных (т.е. Метаданные). </para>


    <section xml:id="ddl-database">
        <info>
            <title>DATABASE</title>
        </info>

        <para>В данном разделе описываются вопросы создания базы данных, подключения к существующей
            базе данных, изменения структуры файлов, перевод базы данных в состояние, необходимое
            для безопасного резервного копирования, и обратно и удаления базы данных. </para>

        <section xml:id="ddl-database-create">
            <info>
                <title>CREATE DATABASE</title>
                <keywordset>
                    <keyword>CREATE DATABASE</keyword>
                    <keyword>CREATE SCHEMA</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE DATABASE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой базы данных.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>                     
CREATE {DATABASE | SCHEMA} '<replaceable>&lt;filespec&gt;</replaceable>'
  [USER <replaceable>username</replaceable> [PASSWORD '<replaceable>password</replaceable>'] [ROLE <replaceable>rolename</replaceable>]]
  [PAGE_SIZE [=] <replaceable>size</replaceable>]
  [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]
  [SET NAMES '<replaceable>charset</replaceable>']
  [DEFAULT CHARACTER SET <replaceable>default_charset</replaceable>
  [COLLATION <replaceable>collation</replaceable>]]
  [<replaceable>&lt;sec_file&gt;</replaceable> [<replaceable>&lt;sec_file&gt;</replaceable> ...]]
  [DIFFERENCE FILE '<replaceable>diff_file</replaceable>'];

<replaceable>&lt;filespec&gt;</replaceable> ::= [<replaceable>&lt;server_spec&gt;</replaceable>]{<replaceable>filepath</replaceable> | <replaceable>db_alias</replaceable>}

<replaceable>&lt;server_spec&gt;</replaceable> ::= 
    <replaceable>host</replaceable>[\<replaceable>port</replaceable> | <replaceable>service</replaceable>]: 
  | \\<replaceable>host</replaceable>[@<replaceable>port</replaceable> | <replaceable>service</replaceable>]\ 
  | <replaceable>&lt;protocol&gt;</replaceable>://[<replaceable>host</replaceable>[:<replaceable>port</replaceable> | <replaceable>service</replaceable>]/]

<replaceable>&lt;protocol&gt;</replaceable> = inet | inet4 | inet6 | wnet | xnet

<replaceable>&lt;sec_file&gt;</replaceable> ::= FILE '<replaceable>filepath</replaceable>'
  [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]] [STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>]              
                  
</programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE DATABASE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="colArgument" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="colDesc" colnum="2" colwidth="2.8*" align="left"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>filespec</replaceable></entry>
                                <entry>
                                    <para>Спецификация первичного файла базы данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>server_spec</replaceable></entry>
                                <entry>
                                    <para>Спецификация удалённого сервера. Включает в себя имя
                                        сервера и протокол. Необходима, если база данных создаётся
                                        на удалённом сервере.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>filepath</replaceable></entry>
                                <entry>
                                    <para>Полный путь и имя файла, включая расширение. Имя файла
                                        должно быть задано в соответствии со спецификой используемой
                                        платформы.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>db_alias</replaceable></entry>
                                <entry>
                                    <para>Псевдоним (alias) базы данных, присутствующий в файле
                                            <filename>databases.conf</filename></para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>host</replaceable></entry>
                                <entry>
                                    <para>Имя сервера или IP адрес, на котором создаётся база
                                        данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>port</replaceable></entry>
                                <entry>
                                    <para>Номер порта, который слушает удалённый сервер (параметр
                                            <parameter>RemoteServicePort</parameter> файла
                                            <filename>firebird.conf</filename>).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>service</replaceable></entry>
                                <entry><para>Имя сервиса. Должно совпадать со значением параметра
                                            <parameter>RemoteServiceName</parameter> файла
                                            <filename>firebird.conf</filename>.</para></entry>
                            </row>
                            <row>
                                <entry><replaceable>protocol</replaceable></entry>
                                <entry>
                                    <para>Наименование протокола.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>username</replaceable></entry>
                                <entry>
                                    <para>Имя пользователя-владельца базы данных. Может быть
                                        заключено в одинарные или двойные кавычки. Если имя
                                        пользователя заключено в двойные кавычки, то оно
                                        чувствительно к регистру.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>password</replaceable></entry>
                                <entry>
                                    <para>Пароль пользователя-владельца базы данных. Чувствительно к
                                        регистру.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>role</replaceable></entry>
                                <entry>
                                    <para>Имя роли, права которой могут учитываться при создании
                                        базы данных. Может быть заключено в одинарные или двойные
                                        кавычки. Если имя роли заключено в двойные кавычки, то оно
                                        чувствительно к регистру.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>size</replaceable></entry>
                                <entry>
                                    <para>Размер страницы для базы данных. Допустимые значения 4096,
                                        8192, 16384, 32768. Размер страницы по умолчанию
                                        8192.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>num</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер первичного или вторичного файла в
                                        страницах.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Задаёт набор символов подключения, доступного после
                                        успешного создания базы данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>default_charset</replaceable></entry>
                                <entry>
                                    <para>Задаёт набор символов по умолчанию для строковых типов
                                        данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Сортировка для набора символов по умолчанию.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>sec_file</replaceable></entry>
                                <entry>
                                    <para>Спецификация вторичного файла.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>pagenum</replaceable></entry>
                                <entry>
                                    <para>Номер страницы, с которой начинается вторичный файл базы
                                        данных. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>diff_file</replaceable></entry>
                                <entry>
                                    <para>Путь и имя дельта файла. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE DATABASE</database> создаёт новую базу данных. Вы можете
                использовать <database>CREATE DATABASE</database> или <database>CREATE
                    SCHEMA</database>. Это синонимы. </para>
            <para>База данных может состоять из одного или нескольких файлов. Первый, основной, файл
                называется первичным, остальные файлы — вторичными. </para>
            <note>
                <para>В настоящее время многофайловые базы данных являются атавизмом. Многофайловые
                    базы данных имеет смысл использовать на старых файловых системах, в которых
                    существует ограничение на размер любого файла. Например, в FAT32 нельзя создать
                    файл больше 4х гигабайт. </para>
            </note>
            <para>Спецификация первичного файла — имя файла базы данных и его расширение с указанием
                к нему полного пути в соответствии с правилами используемой операционной системы.
                При создании базы данных файл базы данных должен отсутствовать. В противном случае
                будет выдано сообщение об ошибке и база данных не будет создана. Если полный путь к
                базе данных не указан, то база данных будет создана в одном из системных каталогов.
                В каком именно зависит от операционной системы. </para>
            <section xml:id="ddl-database-create-aliasedb">
                <title>Использование псевдонимов БД</title>
                <para>Вместо полного пути к первичному файлу базы можно использовать псевдонимы
                    (aliases). Псевдонимы описываются в файле <filename>databases.conf</filename> в
                    формате:
                    <programlisting>  
<replaceable>alias</replaceable> = <replaceable>filepath</replaceable>                    
                </programlisting>
                </para>
                <note>
                    <para>Помимо указания псевдонимов для базы данных в этом файле можно задать
                        параметры уровня базы данных для каждой описываемой базы данных. Эти
                        параметры задаются в фигурных скобках сразу после объявления
                        псевдонима.</para>
                </note>
            </section>
            <section xml:id="ddl-database-create-remotely">
                <title>Создание БД на удалённом сервере</title>
                <para>При создании базы данных на удалённом сервере необходимо указать спецификацию
                    удалённого сервера. Спецификация удалённого сервера зависит от используемого
                    протокола. </para>
                <para>Если вы при создании базы данных используете протокол TCP/IP, то спецификация
                    первичного файла должна выглядеть следующим образом:
                    <programlisting>  
<replaceable>host</replaceable>[/<replaceable>port</replaceable> | <replaceable>service</replaceable>]:{<replaceable>filepath</replaceable> | <replaceable>db_alias</replaceable>}                   
                </programlisting>
                </para>
                <para>Если вы при создании базы данных используете протокол под названием
                    именованные каналы (Name Pipes), то спецификация первичного файла должна
                    выглядеть следующим образом.
                    <programlisting>  
\\<replaceable>host</replaceable>[@<replaceable>port</replaceable> | <replaceable>service</replaceable>]\{<replaceable>filepath</replaceable> | <replaceable>db_alias</replaceable>}                   
                </programlisting>
                </para>
                <para>Существует также унифицированный URL-подобный синтаксис спецификации
                    удалённого сервера. В этом синтаксисе первым параметром указывается наименование
                    протокола, далее указывается имя сервера или IP адрес, номер порта и путь к
                    первичному файлу базы данных или псевдоним. В качестве протокола можно указать
                    следующие значения:<itemizedlist>
                        <listitem>
                            <para>INET — TCP/IP (сначала пробует подключится по протоколу TCP/IP v6,
                                если не получилось, то TCP/IP v4);</para>
                        </listitem>
                        <listitem>
                            <para>INET4 — TCP/IP v4;</para>
                        </listitem>
                        <listitem>
                            <para>INET6 — TCP/IP v6;</para>
                        </listitem>
                        <listitem>
                            <para>WNET — NetBEUI или протокол именованных каналов;</para>
                        </listitem>
                        <listitem>
                            <para>XNET — локальный протокол.</para>
                        </listitem>
                    </itemizedlist>
                    <programlisting>  
<replaceable>protocol</replaceable>://[<replaceable>host</replaceable>[:<replaceable>port</replaceable> | <replaceable>service</replaceable>]/]{<replaceable>filepath</replaceable> | <replaceable>db_alias</replaceable>}                   
                </programlisting>
                </para>
            </section>
            <section xml:id="ddl-database-create-optionals">
                <title>Необязательные параметры CREATE DATABASE</title>

                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>USER</secondary>
                </indexterm>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>PASSWORD</secondary>
                </indexterm>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>ROLE</secondary>
                </indexterm>
                <para>Необязательные предложения <database>USER</database> и
                        <database>PASSWORD</database> задают, соответственно, имя и пароль
                    пользователя присутствующего в базе данных безопасности
                        (<filename>security4.fdb</filename> или той, что указана в параметре
                        <parameter>SecurityDatabase</parameter>). Пользователя и пароль можно не
                    указывать, если установлены переменные окружения <envar>ISC_USER</envar> и
                        <envar>ISC_PASSWORD</envar>. Необязательное предложение ROLE задаёт имя роли
                    (обычно это RDB$ADMIN), права которой будут учитываться при создании базы
                    данных. Роль должна быть назначена пользователю в соответствующей базе данных
                    безопасности. </para>
                <para>Пользователь, указанный при создании базы данных, будет её владельцем. </para>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>PAGE_SIZE</secondary>
                </indexterm>
                <para>Необязательное предложение <database>PAGE_SIZE</database> задаёт размер
                    страницы базы данных. Этот размер будет установлен для первичного файла и всех
                    вторичных файлов базы данных. При вводе размера страницы БД меньшего, чем 4096,
                    он будет автоматически изменён на 4096. Другие числа (не равные 4096, 8192,
                    16384 или 32768) будут изменены на ближайшее меньшее из поддерживаемых значений.
                    Если размер страницы базы данных не указан, то по умолчанию принимается значение
                    8192. </para>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>LENGTH</secondary>
                </indexterm>
                <para>Необязательное предложение <database>LENGTH</database> задаёт максимальный
                    размер первичного или вторичного файла базы данных в страницах. При создании
                    базы данных её первичный или вторичный файл будут занимать минимально
                    необходимое количество страниц для хранения системных данных, не зависимо от
                    величины, установленной в предложении <database>LENGHT</database>. Для
                    единственного или последнего (в многофайловой базе данных) файла значение
                        <database>LENGTH</database> никак не влияет на его размер. Файл будет
                    автоматически увеличивать свой размер по мере необходимости. </para>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>SET NAMES</secondary>
                </indexterm>
                <para>Необязательное предложение <database>SET NAMES</database> задаёт набор
                    символов подключения, доступного после успешного создания базы данных. По
                    умолчанию используется набор символов NONE. </para>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>DEFAULT CHARACTER SET</secondary>
                </indexterm>
                <para>Необязательное предложение <database>DEFAULT CHARACTER SET</database> задаёт
                    набор символов по умолчанию для строковых типов данных. Наборы символов
                    применяются для типов <database class="datatype">CHAR</database>, <database
                        class="datatype">VARCHAR</database> и <database class="datatype"
                        >BLOB</database>. По умолчанию используется набор символов NONE. Для набора
                    символов по умолчанию можно также указать сортировку по умолчанию
                        (<database>COLLATION</database>). В этом случае сортировка станет
                    умалчиваемой для набора символов по умолчанию (т.е. для всей БД за исключением
                    случаев использования других наборов символов). </para>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>STARTING AT</secondary>
                </indexterm>
                <para>Предложение <database>STARTING AT</database> задаёт номер страницы базы
                    данных, с которой должен начинаться следующий файл базы данных. Когда предыдущий
                    файл будет полностью заполнен данными в соответствии с заданным номером
                    страницы, система начнёт помещать вновь добавляемые данные в следующий файл базы
                    данных. </para>
                <indexterm>
                    <primary>CREATE DATABASE</primary>
                    <secondary>DIFFERENCE FILE</secondary>
                </indexterm>
                <para>Необязательное предложение <database>DIFFERENCE FILE</database> задаёт путь и
                    имя дельта файла, в который будут записываться изменения, внесённые в БД после
                    перевода её в режим <quote>безопасного копирования</quote>
                        (<quote>copy-safe</quote>) путём выполнения команды ALTER DATABASE BEGIN
                    BACKUP. Полное описание данного параметра см. в <link
                        linkend="ddl-database-alter">ALTER DATABASE</link>. </para>
                <para>Для того чтобы база данных была создана в нужном вам диалекте SQL, следует
                    перед выполнением оператора создания базы данных задать нужный диалект, выполнив
                    оператор SET SQL DIALECT. По умолчанию база данных создаётся в 3 диалекте.
                </para>
            </section>
            <section xml:id="ddl-database-create-who">
                <title>Кто может создать базу данных?</title>

                <para>Выполнить оператор CREATE DATABASE могут: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link>;</para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE DATABASE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
            <section xml:id="ddl-database-create-examples">
                <title>Примеры</title>

                <example>
                    <title>Создание базы данных в операционной системе Windows</title>

                    <para>Создание базы данных в операционной системе Windows расположенной на диске
                        D с размером страницы 8192. Владельцем базы данных будет пользователь
                        wizard. База данных будет в 1 диалекте, и использовать набор символов по
                        умолчанию WIN1251.
                        <programlisting language="sql">  
SET SQL DIALECT 1;
CREATE DATABASE 'D:\test.fdb'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET WIN1251;                
</programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание базы данных в операционной системе Linux</title>

                    <para>Создание базы данных в операционной системе Linux с размером страницы
                        4096. Владельцем базы данных будет пользователь wizard. База данных будет в
                        3 диалекте, и использовать набор символов по умолчанию UTF8 с умалчиваемой
                        сортировкой UNICODE_CI_AI.
                        <programlisting language="sql">  
CREATE DATABASE '/home/firebird/test.fdb'
USER "wizard" PASSWORD 'player' ROLE 'RDB$ADMIN'
PAGE_SIZE = 4096
DEFAULT CHARACTER SET UTF8 COLLATION UNICODE_CI_AI;                
</programlisting>
                    </para>
                </example>
                <important>
                    <para>В данном случае при создании базы данных будет учитываться регистр
                        символов для имени пользователя, потому что оно указано в двойных
                        кавычках.</para>
                </important>
                <example>
                    <title>Создание базы данных на удалённом сервере</title>

                    <para>Создание базы данных на удалённом сервере baseserver расположенном по
                        пути, на который ссылается псевдоним test, описанный в файле
                            <filename>databases.conf</filename>. Используется протокол TCP.
                        Владельцем базы данных будет пользователь wizard.
                        <programlisting language="sql">  
CREATE DATABASE 'baseserver:test'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET UTF8;                 
</programlisting>
                        То же самое с использованием унифицированного URL-подобного синтаксиса
                        задания спецификации удалённого сервера.
                        <programlisting language="sql">  
CREATE DATABASE 'inet://baseserver:3050/test'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET UTF8;                 
</programlisting>
                        или
                        <programlisting language="sql">  
CREATE DATABASE 'inet://baseserver:gds_db/test'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET UTF8;                 
</programlisting>
                        При использовании доменных имён может быть полезно указать какой именно из
                        протоколов IP v4 или IP v6 вы хотите использовать.
                        <programlisting language="sql">  
CREATE DATABASE 'inet4://baseserver/test'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET UTF8;                 
</programlisting>
                        или
                        <programlisting language="sql">  
CREATE DATABASE 'inet6://baseserver/test'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET UTF8;                 
</programlisting>
                        Создание базы данных с указанием IP адреса (IPv4) вместо указания имени
                        сервера.
                        <programlisting language="sql">  
CREATE DATABASE '127:0:0:1:test'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET UTF8;                 
</programlisting>
                        Создание базы данных с указанием IP адреса (IPv6) вместо указания имени
                        сервера.
                        <programlisting language="sql">  
CREATE DATABASE '[::1]:test'
USER wizard PASSWORD 'player' ROLE RDB$ADMIN
DEFAULT CHARACTER SET UTF8;                 
</programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание многофайловой базы данных</title>

                    <para>Создание базы данных в 3 диалекте с набором символов по умолчанию UTF8.
                        Первичный файл будет содержать 10000 страниц с размером страницы 8192. Как
                        только в процессе работы с базой данных первичный файл будет заполнен, СУБД
                        будет помещать новые данные во вторичный файл
                        <filename>test.fdb2</filename>. Аналогичные действия будут происходить и со
                        вторым вторичным файлом. Размер последнего файла будет увеличиваться до тех
                        пор, пока это позволяет используемая операционная система или пока не будет
                        исчерпана память на внешнем носителе.
                        <programlisting language="sql">  
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER wizard PASSWORD 'player' ROLE 'RDB$ADMIN'
PAGE_SIZE = 8192
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
STARTING AT PAGE 10001
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;                  
</programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание многофайловой базы данных 2</title>

                    <para>Создание базы данных в 3 диалекте с набором символов по умолчанию UTF8.
                        Первичный файл будет содержать 10000 страниц с размером страницы 8192. Как
                        только в процессе работы с базой данных первичный файл будет заполнен, СУБД
                        будет помещать новые данные во вторичный файл
                        <filename>test.fdb2</filename>. Аналогичные действия будут происходить и со
                        вторым вторичным файлом.
                        <programlisting language="sql">  
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER wizard PASSWORD 'player' ROLE 'RDB$ADMIN'
PAGE_SIZE = 8192
LENGTH 10000 PAGES
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;                 
</programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-database-alter">ALTER DATABASE</link>, <link
                            linkend="ddl-database-drop">DROP DATABASE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-database-alter">
            <info>
                <title>ALTER DATABASE</title>
                <keywordset>
                    <keyword>ALTER DATABASE</keyword>
                    <keyword>ALTER SCHEMA</keyword>
                    <keyword>ADD DIFFERENCE FILE</keyword>
                    <keyword>DROP DIFFERENCE FILE</keyword>
                    <keyword>BEGIN BACKUP</keyword>
                    <keyword>END BACKUP</keyword>
                    <keyword>SET DEFAULT CHARACTER SET</keyword>
                    <keyword>SET DEFAULT SQL SECURITY</keyword>
                    <keyword>SET LINGER TO</keyword>
                    <keyword>DROP LINGER</keyword>
                    <keyword>ENCRYPT WITH</keyword>
                    <keyword>DECRYPT</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>ALTER DATABASE</primary>
            </indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение структуры файлов базы данных, переключение её в состояние
                        <quote>безопасное для копирования</quote> или изменение некоторых свойств
                    базы данных. </para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting> 
ALTER {DATABASE | SCHEMA}
    {<replaceable>&lt;add_sec_clause&gt;</replaceable> [<replaceable>&lt;add_sec_clausee&gt;</replaceable> ...]}
  | {ADD DIFFERENCE FILE '<replaceable>diff_file</replaceable>' | DROP DIFFERENCE FILE}
  | {{BEGIN | END} BACKUP}
  | {SET DEFAULT CHARACTER SET <replaceable>charset</replaceable>}
  | {SET DEFAULT SQL SECURITY {DEFINER | INVOKER}}
  | {SET LINGER TO <replaceable>seconds</replaceable> | DROP LINGER}
  | {ENCRYPT WITH <replaceable>plugin_name</replaceable> [KEY <replaceable>key_name</replaceable>] | DECRYPT};

<replaceable>&lt;add_sec_clause&gt;</replaceable> ::= ADD FILE <replaceable>&lt;sec_file&gt;</replaceable> 

<replaceable>&lt;sec_file&gt;</replaceable> ::= '<replaceable>filepath</replaceable>'
  [STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>]
  [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]
</programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER DATABASE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>add_sec_clause</replaceable></entry>
                                <entry>
                                    <para>Инструкция для добавления вторичного файла базы
                                        данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>sec_file</replaceable></entry>
                                <entry>
                                    <para>Спецификация вторичного файла.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>filepath</replaceable></entry>
                                <entry>
                                    <para>Полный путь и имя дельта файла или вторичного файла базы
                                        данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>pagenum</replaceable></entry>
                                <entry>
                                    <para>Номер страницы, с которой начинается вторичный файл базы
                                        данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>num</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер вторичного файла в страницах.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>diff_file</replaceable></entry>
                                <entry>
                                    <para>Путь и имя дельта файла.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Новый набор символов по умолчанию для базы данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>seconds</replaceable></entry>
                                <entry>
                                    <para>Задержка в секундах.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>plugin_name</replaceable></entry>
                                <entry>
                                    <para>Имя плагина шифрования.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>key_name</replaceable></entry>
                                <entry>
                                    <para>Имя ключа шифрования.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>ALTER DATABASE</database> изменяет структуру файлов базы данных
                или переключает её в состояние <quote>безопасное для копирования</quote>. </para>
            <section xml:id="ddl-database-alter-addfile">
                <title>Добавление вторичного файла</title>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>ADD FILE</secondary>
                </indexterm>
                <para>Предложение <database>ADD FILE</database> добавляет к базе данных вторичный
                    файл. Для вторичного файла необходимо указывать полный путь к файлу и имя
                    вторичного файла. Описание вторичного файла аналогично тому, что описано в
                    операторе CREATE DATABASE. </para>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Добавление вторичного файла в базу данных</title>

                            <para>Как только в предыдущем первичном или вторичных файлах будет
                                заполнено 30000 страниц, СУБД будет помещать данные во вторичный
                                файл <filename>test4.fdb</filename>.
                                <programlisting language="sql">  
ALTER DATABASE 
ADD FILE 'D:\test.fdb4'
STARTING PAGE 30001;                
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="ddl-database-alter-add_diffile">
                <title>Изменение пути и имени дельта файла</title>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>ADD DIFFERENCE FILE</secondary>
                </indexterm>
                <para>Предложение <database>ADD DIFFERENCE FILE</database> задаёт путь и имя дельта
                    файла, в который будут записываться изменения, внесённые в базу данных после
                    перевода её в режим <quote>безопасного копирования</quote>
                        (<quote>copy-safe</quote>). Этот оператор в действительности не добавляет
                    файла. Он просто переопределяет умалчиваемые имя и путь файла дельты. Для
                    изменения существующих установок необходимо сначала удалить ранее указанное
                    описание файла дельты с помощью оператора DROP DIFFERENCE FILE, а затем задать
                    новое описание файла дельты. Если не переопределять путь и имя файла дельты, то
                    он будет иметь тот же путь и имя, что и БД, но с расширением
                        <filename>.delta</filename>. </para>
                <note>
                    <para>При задании относительного пути или только имени файла дельты он будет
                        создаваться в текущем каталоге сервера. Для операционных систем Windows это
                        системный каталог. </para>
                </note>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>DROP DIFFERENCE FILE</secondary>
                </indexterm>
                <para>Предложение <database>DROP DIFFERENCE FILE</database> удаляет описание (путь и
                    имя) файла дельты, заданное ранее командой <database>ADD DIFFERENCE
                        FILE</database>. На самом деле при выполнении этого оператора файл не
                    удаляется. Он удаляет путь и имя файла дельты и при последующем переводе БД в
                    режим <quote>безопасного копирования</quote> будут использованы значения по
                    умолчанию (т.е. тот же путь и имя что и у файла БД, но с расширением
                        <filename>.delta</filename>). </para>
                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Установка пути и имени файла дельты</title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE 
ADD DIFFERENCE FILE 'D:\test.diff';                
</programlisting>
                            </para>
                        </example>
                        <example>
                            <title>Удаление описание файла дельты</title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE 
DROP DIFFERENCE FILE;              
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="ddl-database-alter-backup">
                <title>Перевод базы данных в режим <quote>безопасного копирования</quote></title>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>BEGIN BACKUP</secondary>
                </indexterm>
                <para>Предложение <database>BEGIN BACKUP</database> предназначено для перевода базы
                    данных в режим <quote>безопасного копирования</quote>
                    (<quote>copy-safe</quote>). Этот оператор <quote>замораживает</quote> основной
                    файл базы данных, что позволяет безопасно делать резервную копию средствами
                    файловой системы, даже если пользователи подключены и выполняют операции с
                    данными. При этом все изменения, вносимые пользователями в базу данных, будут
                    записаны в отдельный файл, так называемый дельта файл (<emphasis role="italic"
                        >delta file</emphasis>). </para>
                <note>
                    <para>Оператор BEGIN BACKUP, не смотря на синтаксис, не начинает резервное
                        копирование базы данных, а лишь создаёт условия для его осуществления.
                    </para>
                </note>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>END BACKUP</secondary>
                </indexterm>
                <para>Предложение <database>END BACKUP</database> предназначено для перевода базы
                    данных из режима <quote>безопасного копирования</quote>
                        (<quote>copy-safe</quote>) в режим нормального функционирования. Этот
                    оператор объединяет файл дельты с основным файлом базы данных и восстанавливает
                    нормальное состояние работы, таким образом, закрывая возможность создания
                    безопасных резервных копий средствами файловой системы. (При этом безопасное
                    резервное копирование с помощью утилиты <application>gbak</application> остаётся
                    доступным). </para>
                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Перевод базы данных в режим <quote>безопасного
                                    копирования</quote></title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE 
BEGIN BACKUP;           
</programlisting>
                            </para>
                        </example>
                        <example>
                            <title>Возвращение базы данных в режим нормального функционирования из
                                режима <quote>безопасного копирования</quote></title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE 
END BACKUP;         
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="ddl-database-alter-charset">
                <title>Изменение набора символов по умолчанию</title>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>SET DEFAULT CHARACTER SET</secondary>
                </indexterm>
                <para>Предложение <database>SET DEFAULT CHARACTER SET</database> изменяет набор
                    символов по умолчанию для базы данных. Это изменение не затрагивает существующие
                    данные. Новый набор символов по умолчанию будет использоваться только в
                    последующих DDL командах, кроме того для них будет использоваться сортировка по
                    умолчанию для нового набора символов.</para>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Изменение набора символов по умолчанию для базы данных</title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE SET DEFAULT CHARACTER SET WIN1251;         
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="ddl-database-alter-security">
                <title>Изменение контекста безопасности по умолчанию</title>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>SET DEFAULT SQL SECURITY</secondary>
                </indexterm>
                <para>Начиная с Firebird 4.0 появилась возможность указывать объектам метаданных с
                    какими привилегиями они будут выполняться: вызывающего или определяющего
                    пользователя. Для этого используется предложение <database>SQL
                        SECURITY</database>, которое можно указать для таблицы, триггера, процедуры,
                    функции или пакета. Если выбрана опция INVOKER, то объект метаданных будет
                    выполняться с привилегиями вызывающего пользователя. Если выбрана опция DEFINER,
                    то объект метаданных будет выполняться с привилегиями определяющего пользователя
                    (владельца). Если при создании PSQL модуля или таблицы предложение SQL SECURITY
                    не задано, то по умолчанию используется опция INVOKER.</para>
                <para>Предложение <database>SET DEFAULT SQL SECURITY</database> изменяет контекст
                    безопасности с которым по умолчанию создаются PSQL модули (хранимые процедуры,
                    функции и пакеты).</para>
                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Изменение контекста безопасности по умолчанию</title>

                            <para>После выполнения данного оператора PSQL модули по умолчанию будут
                                создаваться с опцией SQL SECURITY DEFINER</para>
                            <para>
                                <programlisting language="sql">
ALTER DATABASE SET DEFAULT SQL SECURITY DEFINER;
                </programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="ddl-database-alter-linger">
                <title>LINGER</title>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>SET LINGER</secondary>
                </indexterm>
                <para>Предложение <database>SET LINGER</database> позволяет установить задержку
                    закрытия базы данных. Этот механизм позволяет ядру SuperServer, сохранять базу
                    данных в открытом состоянии в течение некоторого времени после того как
                    последние соединение закрыто, т.е. иметь механизм задержки закрытия базы данных.
                    Это может помочь улучшить производительность и уменьшить издержки в случаях,
                    когда база данных часто открывается и закрывается, сохраняя при этом ресурсы
                        <quote>разогретыми</quote> до следующего открытия. </para>
                <tip>
                    <para>Такой режим может быть полезен для Web приложений, в которых коннект к
                        базе обычно <quote>живёт</quote> очень короткое время. </para>
                </tip>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>DROP LINGER</secondary>
                </indexterm>
                <para>Предложение <database>DROP LINGER</database> удаляет задержку и возвращает
                    базу данных к нормальному состоянию (без задержки). Эта команда эквивалентна
                    установки задержки в 0. </para>
                <tip>
                    <para>Удаление LINGER не самое лучшее решение для временной необходимости его
                        отключения для некоторых разовых действий, требующих принудительного
                        завершения работы сервера. Утилита <application>gfix</application> теперь
                        имеет переключатель <option>-NoLinger</option>, который сразу закроет
                        указанную базу данных, после того как последнего соединения не стало,
                        независимо от установок LINGER в базе данных. Установка LINGER будет
                        сохранена и нормально отработает в следующий раз. </para>
                    <para>Кроме того, одноразовое переопределение доступно также через сервисы API,
                        с использованием тега isc_spb_prp_nolinger, например (в такой строке): </para>
                    <para>
                        <programlisting>
fbsvcmgr host:service_mgr user sysdba password xxx
action_properties dbname employee prp_nolinger                    
                </programlisting>
                    </para>
                </tip>
                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Установка задержки в 30 секунд</title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE SET LINGER 30;         
</programlisting>
                            </para>
                        </example>
                        <example>
                            <title>Удаление задержки</title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE DROP LINGER;         
</programlisting>
                            </para>
                            <para>или</para>
                            <para>
                                <programlisting language="sql">  
ALTER DATABASE SET LINGER 0;         
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="ddl-database-alter-encrypt">
                <title>Шифрование базы данных</title>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>ENCRYPT WITH</secondary>
                </indexterm>
                <para>Предложение <database>ENCRYPT WITH</database> шифрует базу данных с помощью
                    указанного плагина шифрования. Шифрование начинается сразу после этого оператора
                    и будет выполняться в фоновом режиме. Нормальная работа с базами данных не
                    нарушается во время шифрования. </para>
                <note>
                    <para>Процесс шифрования может быть проконтролирован с помощью поля
                        MON$CRYPT_PAGE в псевдо-таблице MON$DATABASE или просмотрен на странице
                        заголовка базы данных с помощью <command>gstat -e</command>. </para>
                    <para>
                        <command>gstat –h</command> также будет предоставлять ограниченную
                        информацию о состоянии шифрования. </para>
                    <para>Например, следующий запрос
                        <programlisting language="sql">
select MON$CRYPT_PAGE * 100 / MON$PAGES from MON$DATABASE                  
                </programlisting>
                        будет отображать процент завершения процесса шифрования. </para>
                </note>
                <para>Необязательное предложение KEY позволяет передать имя ключа для плагина
                    шифрования. Что делать с этим именем ключа решает плагин.</para>
                <indexterm>
                    <primary>ALTER DATABASE</primary>
                    <secondary>DECRYPT</secondary>
                </indexterm>
                <para>Предложение <database>DECRYPT</database> дешифрует базу данных. </para>
                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Шифрование базы данных</title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE ENCRYPT WITH DbCrypt;         
</programlisting>
                            </para>
                        </example>
                        <example>
                            <title>Дешифрование базы данных</title>

                            <para>
                                <programlisting language="sql">  
ALTER DATABASE DECRYPT;         
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="ddl-database-alter-who">
                <title>Кто может выполнить ALTER DATABASE?</title>

                <para>Выполнить оператор <database>ALTER DATABASE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link>;</para>
                        </listitem>
                        <listitem>
                            <para>Владелец базы данных; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER DATABASE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-database-create">CREATE DATABASE</link>, <link
                            linkend="ddl-database-drop">DROP DATABASE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-database-drop">
            <info>
                <title>DROP DATABASE</title>

                <keywordset>
                    <keyword>DROP DATABASE</keyword>
                </keywordset>
            </info>

            <indexterm><primary>DROP DATABASE</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Удаление текущей базы данных. </para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting> 
DROP DATABASE;
                    </programlisting>
                </para>
            </formalpara>

            <para>Оператор <database>DROP DATABASE</database> удаляет текущую базу данных. Перед
                удалением базы данных, к ней необходимо присоединиться. Оператор удаляет первичный,
                все вторичные файлы и все файлы теневых копий. </para>
            <section xml:id="ddl-database-drop-who">
                <title>Кто может удалить базу данных?</title>

                <para>Выполнить оператор <database>DROP DATABASE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link>;</para>
                        </listitem>
                        <listitem>
                            <para>Владелец базы данных; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP DATABASE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-database-drop-examples">
                <title>Примеры</title>

                <example>
                    <title>Удаление базы данных</title>

                    <para>Удаление базы данных, к которой подключен клиент.</para>
                    <para>
                        <programlisting language="sql">  
DROP DATABASE;
</programlisting>
                    </para>
                </example>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-database-create">CREATE DATABASE</link>, <link
                            linkend="ddl-database-alter">ALTER DATABASE</link>. </para>

                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-shadow">
        <info>
            <title>SHADOW</title>
            <keywordset>
                <keyword>SHADOW</keyword>
            </keywordset>
        </info>
        <para>Теневая копия (shadow — дословно тень) является точной страничной копией базы данных.
            После создания теневой копии все изменения, сделанные в базе данных, сразу же отражаются
            и в теневой копии. Если по каким либо причинам первичный файл базы данных станет
            недоступным, то СУБД переключится на теневую копию. </para>
        <para>В данном разделе рассматриваются вопросы создания и удаления теневых копий.</para>
        <note>
            <para>Это относится только к текущим операциям с базой данных, но не к новым
                подключениям. В случае поломки исходной базы данных администратор БД должен
                восстановить изначальные файлы базы данных, в том числе и с помощью файлов теневых
                копий. Только после этого будет возможно подключение новых клиентов.</para>
        </note>
        <section xml:id="ddl-shadow-create">
            <info>
                <title>CREATE SHADOW</title>
                <keywordset>
                    <keyword>CREATE SHADOW</keyword>
                    <keyword>AUTO</keyword>
                    <keyword>MANUAL</keyword>
                    <keyword>CONDITIONAL</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CREATE SHADOW</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Создание теневой копии.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>  
CREATE SHADOW <replaceable>sh_num</replaceable> [AUTO | MANUAL] [CONDITIONAL]
  '<replaceable>filepath</replaceable>' [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]]
  [<replaceable>&lt;secondary_file&gt;</replaceable>];

<replaceable>&lt;secondary_file&gt;</replaceable> ::= 
  FILE '<replaceable>filepath</replaceable>'
  LENGTH [=] <replaceable>num</replaceable> [PAGE[S]] | STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>
                    
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE SHADOW</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>sh_num</replaceable></entry>
                                <entry>
                                    <para>Номер теневой копии – положительное число,
                                        идентифицирующее набор файлов теневой копии.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>filepath</replaceable></entry>
                                <entry>
                                    <para>Имя файла и путь к нему в соответствии с требованиями
                                        ОС.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>num</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер теневой копии в страницах.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>secondary_file</replaceable></entry>
                                <entry>
                                    <para>Спецификация вторичного файла.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>page_num</replaceable></entry>
                                <entry>
                                    <para>Номер страницы, с которой должен начинаться вторичный файл
                                        копии.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE SHADOW</database> создаёт новую теневую копию. Теневая
                копия начинает дублировать базу данных сразу в момент создания этой копии. </para>
            <para>Теневые копии, как и база данных, могут состоять из нескольких файлов. Количество
                и размер файлов теневых копий не связано с количеством и размером файлов базы
                данных. </para>
            <para>Для файлов теневой копии размер страницы устанавливается равным размеру страницы
                базы данных и не может быть изменён.</para>
            <para>Если по каким либо причинам файл базы данных становится недоступным, то система
                преобразует тень в копию базы данных и переключается на неё. Теневая копия
                становится недоступной. Что будет дальше зависит от выбранного режима.</para>
            <section xml:id="ddl-shadow-create-mode">
                <title>Режимы AUTO и MANUAL</title>
                <indexterm>
                    <primary>CREATE SHADOW</primary>
                    <secondary>AUTO</secondary>
                </indexterm>
                <para>Когда теневая копия преобразуется в базу данных она становится недоступной.
                    Теневая копия может также стать недоступной если будет удалён её файл, или
                    закончится место на диске, где она расположена, или если этот диск
                    повреждён.</para>

                <para><itemizedlist>
                        <listitem>
                            <para>Если выбран режим AUTO (значение по умолчанию), то в случае, когда
                                теневая копия становится недоступной, автоматически прекращается
                                использование этой копии и из базы данных удаляются все ссылки на
                                нее. Работа с базой данных продолжается обычным образом без
                                осуществления копирования в данную теневую копию.</para>
                            <para>Если указано ключевое слово CONDITIONAL, то система будет пытаться
                                создать новую теневую копию. чтобы заменить потерянную. Это не
                                всегда возможно, тогда вам потребуется создать новую тень вручную.
                            </para>
                        </listitem>
                        <listitem>
                            <para>Если выбран режим MANUAL, то в случае, когда теневая копия
                                становится недоступной, все попытки соединения с базой данных и
                                обращения к ней будут вызывать сообщение об ошибке до тех пор, пока
                                теневая копия не станет доступной или пока не будет удалена
                                администратором БД с помощью оператора DROP SHADOW.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <indexterm>
                    <primary>CREATE SHADOW</primary>
                    <secondary>MANUAL</secondary>
                </indexterm>
            </section>

            <section xml:id="ddl-shadow-create-options">
                <title>Необязательные параметры CREATE SHADOW</title>
                <indexterm>
                    <primary>CREATE SHADOW</primary>
                    <secondary>LENGTH</secondary>
                </indexterm>
                <para>Необязательное предложение LENGTH задаёт максимальный размер первичного или
                    вторичного файла теневой копии в страницах. Для единственного или последнего
                    файла теневой копии значение LENGTH никак не влияет на его размер. Файл будет
                    автоматически увеличивать свой размер по мере необходимости. </para>
                <indexterm>
                    <primary>CREATE SHADOW</primary>
                    <secondary>STARTING AT</secondary>
                </indexterm>
                <para>Предложение STARTING AT задаёт номер страницы теневой копии, с которой должен
                    начинаться следующий файл теневой копии. Когда предыдущий файл будет полностью
                    заполнен данными в соответствии с заданным номером страницы, система начнёт
                    помещать вновь добавляемые данные в следующий файл теневой копии. </para>
            </section>
            <section xml:id="ddl-shadow-create-who">
                <title>Кто может создать теневую копию?</title>

                <para>Выполнить оператор <database>CREATE SHADOW</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link>;</para>
                        </listitem>
                        <listitem>
                            <para>Владелец базы данных; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER DATABASE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-shadow-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание теневую копию базы данных с номером 1</title>

                    <para>
                        <programlisting language="sql">  
CREATE SHADOW 1 'g:\data\test.shd';
</programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание многофайловой теневой копии</title>

                    <para>
                        <programlisting language="sql">  
CREATE SHADOW 2 'g:\data\test.sh1' 
LENGTH 8000 PAGES
FILE 'g:\data\test.sh2';
</programlisting>
                    </para>
                </example>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-database-create">CREATE DATABASE</link>, <link
                            linkend="ddl-database-alter">ALTER DATABASE</link>, <link
                            linkend="ddl-shadow-drop">DROP SHADOW</link>. </para>

                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-shadow-drop">
            <info>
                <title>DROP SHADOW</title>
                <keywordset>
                    <keyword>DROP SHADOW</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP SHADOW</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление теневой копии.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
DROP SHADOW <replaceable>number</replaceable> [{PRESERVE | DELETE} FILE];
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора DROP SHADOW</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>number</replaceable></entry>
                                <entry>
                                    <para>Номер теневой копии — положительное число,
                                        идентифицирующее набор файлов теневой копии.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>DROP SHADOW</database> удаляет указанную теневую копию из базы
                данных, с которой установлено текущее соединение. При удалении теневой копии
                прекращается процесс дублирования данных в эту копию. Если указана опция DELETE
                FILE, то будут также удалены и все связанные файлы с этой теневой копией. Если
                указана опция PRESERVE FILE, то файлы останутся не тронутыми. Это может быть
                полезно, если вы делаете резервную копию с теневого файла. Умолчательной является
                опция DELETE FILE.</para>
            <section xml:id="ddl-shadow-drop-who">
                <title>Кто может удалить теневую копию?</title>

                <para>Выполнить оператор <database>DROP SHADOW</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link>;</para>
                        </listitem>
                        <listitem>
                            <para>Владелец базы данных; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER DATABASE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-shadow-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление теневой копии с номером 1</title>

                    <para>
                        <programlisting language="sql">  
DROP SHADOW 1;
</programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-shadow-create">CREATE SHADOW</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-domain">
        <info>
            <title>DOMAIN</title>
            <keywordset>
                <keyword>DOMAIN</keyword>
            </keywordset>
        </info>
        <para>Домен (Domain) — один из объектов реляционной базы данных, при создании которого можно
            задать некоторые характеристики, а затем использовать ссылку на домен при определении
            столбцов таблиц, объявлении локальных переменных, входных и выходных аргументов в
            модулях PSQL. </para>
        <para>В данном разделе рассматриваются синтаксис операторов создания, модификации и удаления
            доменов. Подробное описание доменов и их использования можно прочесть в главе <link
                linkend="types-domain">Пользовательские типы данных — домены</link>. </para>
        <section xml:id="ddl-domain-create">
            <info>
                <title>CREATE DOMAIN</title>
                <keywordset>
                    <keyword>CREATE DOMAIN</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE DOMAIN</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового домена.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CREATE DOMAIN <replaceable>name</replaceable> [AS] <replaceable>&lt;datatype&gt;</replaceable>
  [DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>}]
  [NOT NULL] [CHECK (<replaceable>&lt;dom_condition&gt;</replaceable>)]
  [COLLATE <replaceable>collation</replaceable>];

<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | BOOLEAN [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {FLOAT | DOUBLE PRECISION} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {DATE | TIME | TIMESTAMP} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [<replaceable>&lt;array_dim&gt;</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] 
    [(<replaceable>size</replaceable>)] [<replaceable>&lt;array_dim&gt;</replaceable>]
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])] 

<replaceable>&lt;array_dim&gt;</replaceable> ::= <emphasis role="bold">[</emphasis>[<replaceable>x</replaceable>:]<replaceable>y</replaceable> [,[<replaceable>x</replaceable>:]<replaceable>y</replaceable> ...]<emphasis role="bold">]</emphasis>

<replaceable>&lt;dom_condition&gt;</replaceable> ::= {
    <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] BETWEEN <replaceable>&lt;val&gt;</replaceable> AND <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] IN (<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...] | <replaceable>&lt;select_list&gt;</replaceable>)
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] NULL
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] DISTINCT <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] CONTAINING <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] STARTING [WITH] <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] LIKE <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>]
  | <replaceable>&lt;val&gt;</replaceable> [NOT] SIMILAR TO <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>]
  | <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> {ALL | SOME | ANY} (<replaceable>&lt;select_list&gt;</replaceable>)
  | [NOT] EXISTS (<replaceable>&lt;select_expr&gt;</replaceable>)
  | [NOT] SINGULAR (<replaceable>&lt;select_expr&gt;</replaceable>)
  | (<replaceable>&lt;dom_condition&gt;</replaceable>)
  | NOT <replaceable>&lt;dom_condition&gt;</replaceable>
  | <replaceable>&lt;dom_condition&gt;</replaceable> OR <replaceable>&lt;dom_condition&gt;</replaceable>
  | <replaceable>&lt;dom_condition&gt;</replaceable> AND <replaceable>&lt;dom_condition&gt;</replaceable>
}

<replaceable>&lt;operator&gt;</replaceable> ::= {= | &lt; | &gt; | &lt;= | &gt;= | !&lt; | !&gt; | &lt;&gt; | !=}

<replaceable>&lt;val&gt;</replaceable> ::= {
    VALUE
  | <replaceable>literal</replaceable>
  | <replaceable>&lt;context_var&gt;</replaceable>
  | <replaceable>&lt;expression&gt;</replaceable>
  | NULL
  | NEXT VALUE FOR <replaceable>genname</replaceable>
  | GEN_ID(<replaceable>genname</replaceable>, <replaceable>&lt;val&gt;</replaceable>)
  | CAST(<replaceable>&lt;val&gt;</replaceable> AS <replaceable>&lt;datatype&gt;</replaceable>)
  | (<replaceable>&lt;select_one&gt;</replaceable>)
  | func(<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...])
}
</programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE DOMAIN</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>name</replaceable></entry>
                                <entry>
                                    <para>Имя домена. Может содержать до 63 символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>datatype</replaceable></entry>
                                <entry>
                                    <para>Тип данных SQL. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>literal</replaceable></entry>
                                <entry>
                                    <para>Литерал. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>context_var</replaceable></entry>
                                <entry>
                                    <para>Любая контекстная переменная, тип которой совместим с
                                        типом данных  домена.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>dom_condition</replaceable></entry>
                                <entry>
                                    <para>Условие домена. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Порядок сортировки. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>array_dim</replaceable></entry>
                                <entry>
                                    <para>Размерность массива. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>x</replaceable></entry>
                                <entry>
                                    <para>Начальный номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>y</replaceable></entry>
                                <entry>
                                    <para>Последний номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. От 1 до 18. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>scale</replaceable></entry>
                                <entry>
                                    <para>Масштаб. От 0 до 18, должно быть меньше или равно
                                            <replaceable>precision</replaceable>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>size</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер строки в символах. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Набор символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_num</replaceable></entry>
                                <entry>
                                    <para>Номер подтипа BLOB. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_name</replaceable></entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>seglen</replaceable></entry>
                                <entry>
                                    <para>Размер сегмента, не может превышать 65535. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>val</replaceable></entry>
                                <entry>
                                    <para>Значение. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_one</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        только одну строку. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_list</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_expr</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий несколько столбцов и
                                        возвращающий ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>experssion</replaceable></entry>
                                <entry>
                                    <para>Выражение. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>genname</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора). </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>func</replaceable></entry>
                                <entry>
                                    <para>Скалярная функция. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE DOMAIN</database> создаёт новый домен.</para>
            <para>В качестве типа домена можно использовать любой тип данных SQL. Для любого типа
                данных кроме BLOB можно указать размерность массива, если домен должен быть
                массивом. Размерность массива указывается в квадратных скобках. Чтобы не перепутать
                их с символами, означающими необязательные элементы, они выделены жирным шрифтом.
                При указании размерности массива указываются два числа через двоеточие. Первое число
                означает начальный номер элемента массива, второе – конечный. Если указано только
                одно число, то оно означает последний номер в элементе массива, а первым номером
                считается 1. Если у массива два и более измерения, то они перечисляются через
                запятую.</para>
            <indexterm>
                <primary>CREATE DOMAIN</primary>
                <secondary>CHARACTER SET</secondary>
            </indexterm>
            <para>Для типов <database class="datatype">CHAR</database>, <database class="datatype"
                    >VARCHAR</database> и <database class="datatype">BLOB</database> с подтипом text
                можно указать набор символов в предложении <database>CHARACTER SET</database>. Если
                набор символов не указан, то по умолчанию принимается тот набор символов, который
                был указан при создании базы данных.</para>
            <warning>
                <para>Если же при создании базы данных не был указан набор символов, то при создании
                    домена по умолчанию принимается набор символов NONE. В этом случае данные
                    хранятся и извлекаются, так как они были поданы. В столбец, основанный на таком
                    домене, можно загружать данные в любой кодировке, но невозможно загрузить эти
                    данные в столбец с другой кодировкой. Транслитерация не выполняется между
                    исходными и конечными кодировками, что может приводить к ошибкам. </para>
            </warning>
            <indexterm>
                <primary>CREATE DOMAIN</primary>
                <secondary>DEFAULT</secondary>
            </indexterm>
            <para>Необязательное предложение <database>DEFAULT</database> позволяет указать значение
                по умолчанию для домена. Это значение будет помещено в столбец таблицы, который
                ссылает на данный домен, при выполнении оператора <database>INSERT</database>, если
                значение не будет указано для этого столбца. Локальные переменные и аргументы PSQL
                модулей, которые ссылаются на этот домен, будут инициализированы значением по
                умолчанию. В качестве значения по умолчанию может быть литерал совместимый по типу,
                неизвестное значение NULL и контекстная переменная, тип которой совместим с типом
                домена.</para>
            <indexterm>
                <primary>CREATE DOMAIN</primary>
                <secondary>NOT NULL</secondary>
            </indexterm>
            <para>Предложение <database>NOT NULL</database> запрещает столбцам и переменным,
                основанным на домене, присваивать значение NULL. </para>
            <indexterm>
                <primary>CREATE DOMAIN</primary>
                <secondary>CHECK</secondary>
            </indexterm>
            <para>Необязательное предложение <database>CHECK</database> задаёт ограничение домена.
                Ограничение домена задаёт условия, которому должны удовлетворять значения столбцов
                таблицы или переменных, которые ссылаются на данный домен. Условие должно быть
                помещено в круглые скобки. Условие — это логическое выражение, называемое также
                предикат, которое может возвращать значения TRUE (истина), FALSE (ложь) и UNKNOWN
                (неизвестно). Условие считается выполненным, если предикат возвращает значение TRUE
                или UNKNOWN (эквивалент NULL). Если предикат возвращает FALSE, то значение не будет
                принято. </para>
            <para>Ключевое слово <database>VALUE</database> в ограничении домена является
                заменителем столбца таблицы, который основан на данном домене, или переменной PSQL
                модуля. Оно содержит значение, присваиваемое переменной или столбцу таблицы.
                Ключевое слово VALUE может быть использовано в любом месте ограничения
                    <database>CHECK</database>, но обычно его используют в левой части условия. </para>
            <indexterm>
                <primary>CREATE DOMAIN</primary>
                <secondary>COLLATE</secondary>
            </indexterm>
            <para>Необязательное предложение <database>COLLATE</database> позволяет задать порядок
                сортировки, если домен основан на одном из строковых типов данных (за исключением
                    <database class="datatype">BLOB</database>). Если порядок сортировки не указан,
                то по умолчанию принимается порядок сортировки умалчиваемый для указанного набора
                сортировки при создании домена. </para>
            <section xml:id="ddl-domain-create-who">
                <title>Кто может создать домен?</title>

                <para>Выполнить оператор <database>CREATE DOMAIN</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE DOMAIN</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший домен, становится его владельцем.</para>
            </section>
            <section xml:id="ddl-domain-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание домена, который может принимать значения больше 1000.</title>

                    <para><programlisting language="sql"> 
<![CDATA[                     
CREATE DOMAIN CUSTNO AS
INTEGER DEFAULT 10000
CHECK (VALUE > 1000);  
]]>  
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание домена, который может принимать значения 'Да' и 'Нет'.</title>

                    <para><programlisting language="sql"> 
CREATE DOMAIN D_BOOLEAN AS
CHAR(3) CHECK (VALUE IN ('Да', 'Нет'));                   
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание домена с набором символов UTF8 и порядком сортировки
                        UNICODE_CI_AI.</title>

                    <para><programlisting language="sql"> 
CREATE DOMAIN FIRSTNAME AS
VARCHAR(30) CHARACTER SET UTF8
COLLATE UNICODE_CI_AI;                  
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание домена со значением по умолчанию.</title>

                    <para><programlisting language="sql"> 
CREATE DOMAIN D_DATE AS
DATE DEFAULT CURRENT_DATE
NOT NULL;                
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание домена, определённого как массив из 2 элементов.</title>

                    <para>Создание домена, определённого как массив из 2 элементов типа NUMERIC(18,
                        3), нумерация элементов начинается с 1.</para>
                    <para><programlisting language="sql"> 
CREATE DOMAIN D_POINT AS
NUMERIC(18, 3) [2];               
                </programlisting>
                    </para>
                </example>
                <note>
                    <para>Вы можете использовать домены определённые как массив только для
                        определения столбцов таблиц. Вы не можете использовать такие домены для
                        определения локальных переменных и аргументов PSQL модулей.</para>
                </note>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-domain-alter">ALTER DOMAIN</link>, <link
                            linkend="ddl-domain-drop">DROP DOMAIN</link>. </para>

                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-domain-alter">
            <info>
                <title>ALTER DOMAIN</title>
                <keywordset>
                    <keyword>ALTER DOMAIN</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
            </indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Изменение текущих характеристик домена или его переименование.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>  
ALTER DOMAIN <replaceable>name</replaceable>
  [{TO <replaceable>new_name</replaceable>}]
  [{SET DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>} | 
    DROP DEFAULT}]
  [{SET | DROP} NOT NULL]
  [{ADD [CONSTRAINT] CHECK (<replaceable>&lt;dom_condition&gt;</replaceable>) | 
    DROP CONSTRAINT}]
  [{TYPE <replaceable>&lt;datatype&gt;</replaceable>}];


<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | BOOLEAN [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {FLOAT | DOUBLE PRECISION} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {DATE | TIME | TIMESTAMP} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [<replaceable>&lt;array_dim&gt;</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] 
    [(<replaceable>size</replaceable>)] [<replaceable>&lt;array_dim&gt;</replaceable>]
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])] 

<replaceable>&lt;array_dim&gt;</replaceable> ::= <emphasis role="bold">[</emphasis><replaceable>x</replaceable>:<replaceable>y</replaceable> [,<replaceable>x</replaceable>:<replaceable>y</replaceable> ...]<emphasis role="bold">]</emphasis>

<replaceable>&lt;dom_condition&gt;</replaceable> ::= {
    <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] BETWEEN <replaceable>&lt;val&gt;</replaceable> AND <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] IN (<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...] | <replaceable>&lt;select_list&gt;</replaceable>)
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] NULL
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] DISTINCT <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] CONTAINING <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] STARTING [WITH] <replaceable>&lt;val&gt;</replaceable>
  | <replaceable>&lt;val&gt;</replaceable> [NOT] LIKE <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>]
  | <replaceable>&lt;val&gt;</replaceable> [NOT] SIMILAR TO <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>]
  | <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> {ALL | SOME | ANY} (<replaceable>&lt;select_list&gt;</replaceable>)
  | [NOT] EXISTS (<replaceable>&lt;select_expr&gt;</replaceable>)
  | [NOT] SINGULAR (<replaceable>&lt;select_expr&gt;</replaceable>)
  | (<replaceable>&lt;dom_condition&gt;</replaceable>)
  | NOT <replaceable>&lt;dom_condition&gt;</replaceable>
  | <replaceable>&lt;dom_condition&gt;</replaceable> OR <replaceable>&lt;dom_condition&gt;</replaceable>
  | <replaceable>&lt;dom_condition&gt;</replaceable> AND <replaceable>&lt;dom_condition&gt;</replaceable>
}

<replaceable>&lt;operator&gt;</replaceable> ::= {= | &lt; | &gt; | &lt;= | &gt;= | !&lt; | !&gt; | &lt;&gt; | !=}

<replaceable>&lt;val&gt;</replaceable> ::= {
    VALUE
  | <replaceable>literal</replaceable>
  | <replaceable>&lt;context_var&gt;</replaceable>
  | <replaceable>&lt;expression&gt;</replaceable>
  | NULL
  | NEXT VALUE FOR <replaceable>genname</replaceable>
  | GEN_ID(<replaceable>genname</replaceable>, <replaceable>&lt;val&gt;</replaceable>)
  | CAST(<replaceable>&lt;val&gt;</replaceable> AS <replaceable>&lt;datatype&gt;</replaceable>)
  | (<replaceable>&lt;select_one&gt;</replaceable>)
  | func(<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...])
}
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER DOMAIN</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>name</replaceable></entry>
                                <entry>
                                    <para>Имя домена.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>new_name</replaceable></entry>
                                <entry>
                                    <para>Новое имя домена. Может содержать до 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>datatype</replaceable></entry>
                                <entry>
                                    <para>Тип данных SQL. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>literal</replaceable></entry>
                                <entry>
                                    <para>Литерал. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>context_var</replaceable></entry>
                                <entry>
                                    <para>Любая контекстная переменная, тип которой совместим с
                                        типом данных  домена.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>dom_condition</replaceable></entry>
                                <entry>
                                    <para>Условие домена. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Порядок сортировки. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>array_dim</replaceable></entry>
                                <entry>
                                    <para>Размерность массива. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>x</replaceable></entry>
                                <entry>
                                    <para>Начальный номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>y</replaceable></entry>
                                <entry>
                                    <para>Последний номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. От 1 до 18. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>scale</replaceable></entry>
                                <entry>
                                    <para>Масштаб. От 0 до 18, должно быть меньше или равно
                                            <replaceable>precision</replaceable>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>size</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер строки в символах. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Набор символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_num</replaceable></entry>
                                <entry>
                                    <para>Номер подтипа BLOB. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_name</replaceable></entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>seglen</replaceable></entry>
                                <entry>
                                    <para>Размер сегмента, не может превышать 65535. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>val</replaceable></entry>
                                <entry>
                                    <para>Значение. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_one</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        только одну строку. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_list</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_expr</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий несколько столбцов и
                                        возвращающий ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>experssion</replaceable></entry>
                                <entry>
                                    <para>Выражение. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>genname</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора). </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>func</replaceable></entry>
                                <entry>
                                    <para>Скалярная функция. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>ALTER DOMAIN</database> изменяет текущие характеристики домена,
                в том числе и его имя. В одном операторе <database>ALTER DOMAIN</database> можно
                выполнить любое количество изменений домена.</para>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>TO</secondary>
            </indexterm>
            <para>Предложение TO позволяет переименовать домен. Имя домена можно изменить, если не
                существует зависимостей от этого домена, т.е. столбцов таблиц, локальных переменных
                и аргументов процедур, ссылающихся на данный домен. </para>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>SET DEFAULT</secondary>
            </indexterm>
            <para>Предложение <database>SET DEFAULT</database> позволяет установить новое значение
                по умолчанию. Если домен уже содержал значение по умолчанию, то установка нового
                значения по умолчанию не требует предварительного удаления старого.</para>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>DROP DEFAULT</secondary>
            </indexterm>
            <para>Предложение <database>DROP DEFAULT</database> удаляет ранее установленное для
                домена значение по умолчанию. В этом случае значением по умолчанию становится
                значение NULL. </para>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>ADD [CONSTRAINT] CHECK</secondary>
            </indexterm>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>DROP [CONSTRAINT] CHECK</secondary>
            </indexterm>
            <para>Предложение ADD [CONSTRAINT] CHECK добавляет условие ограничения домена. Если
                домен уже содержал ограничение <database>CHECK</database>, то его предварительно
                необходимо удалить с помощью предложения DROP [CONSTRAINT] CHECK. </para>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>TYPE</secondary>
            </indexterm>
            <para>Предложение <database>TYPE</database> позволяет изменить тип домена на другой
                допустимый тип. Не допустимы любые изменения типа, которые могут привести к потере
                данных. Например, количество символов в новом типе для домена не может быть меньше,
                чем было установлено ранее.</para>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>SET NOT NULL</secondary>
            </indexterm>
            <indexterm>
                <primary>ALTER DOMAIN</primary>
                <secondary>DROP NOT NULL</secondary>
            </indexterm>
            <para>Предложение <database>SET NOT NULL</database> устанавливает ограничение NOT NULL
                для домена. В этом случае для переменных и столбцах базирующихся на домене значение
                NULL не допускается. Предложение <database>DROP NOT NULL</database> удаляет
                ограничение NOT NULL для домена. </para>
            <note>
                <para>Успешная установка ограничения NOT NULL для домена происходит только после
                    полной проверки данных таблиц, столбцы которых базируются на домене. Это может
                    занять довольно длительное время. </para>
            </note>
            <warning>
                <para>При изменении описания домена, существующий PSQL код, может стать
                    некорректным. Информация о том, как это обнаружить, находится в приложении <link
                        linkend="valid">Поле RDB$VALID_BLR</link>. </para>
            </warning>
            <section xml:id="ddl-domain-alter-cannot">
                <title>Что не может изменить ALTER DOMAIN</title>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>Если домен был объявлен как массив, то изменить ни его тип, ни
                                размерность нельзя. Также нет возможности изменить любой другой тип
                                на тип массив.</para>
                        </listitem>
                        <listitem>
                            <para>Не существует способа изменить сортировку по умолчанию. В этом
                                случае необходимо удалить домен и пересоздать его с новыми
                                атрибутами.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
            <section xml:id="ddl-domain-alter-who">
                <title>Кто может изменить домен?</title>

                <para>Выполнить оператор <database>ALTER DOMAIN</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец домена; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY DOMAIN</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-domain-alter-exapmles">
                <title>Примеры</title>

                <example>
                    <title>Изменение значения по умолчанию для домена.</title>

                    <para>
                        <programlisting language="sql"> 
ALTER DOMAIN CUSTNO
INTEGER DEFAULT 2000;       
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Переименование домена.</title>

                    <para>
                        <programlisting language="sql"> 
ALTER DOMAIN D_BOOLEAN TO D_BOOL;       
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Удаление значения по умолчанию и добавления ограничения для
                        домена.</title>

                    <para>
                        <programlisting language="sql"> 
<![CDATA[                     
ALTER DOMAIN D_DATE
DROP DEFAULT
ADD CONSTRAINT CHECK (VALUE >= date '01.01.2000');  
]]>  
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение ограничения домена.</title>

                    <para>
                        <programlisting language="sql"> 
ALTER DOMAIN D_DATE
DROP CONSTRAINT;

ALTER DOMAIN D_DATE
ADD CONSTRAINT CHECK 
(VALUE BETWEEN date '01.01.1900' AND date '31.12.2100');     
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение типа домена.</title>

                    <para>
                        <programlisting language="sql"> 
ALTER DOMAIN FIRSTNAME
TYPE VARCHAR(50) CHARACTER SET UTF8;     
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Добавление ограничения NOT NULL для домена.</title>

                    <para>
                        <programlisting language="sql"> 
ALTER DOMAIN FIRSTNAME SET NOT NULL;     
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-domain-create">CREATE DOMAIN</link>, <link
                            linkend="ddl-domain-drop">DROP DOMAIN</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-domain-drop">
            <info>
                <title>DROP DOMAIN</title>
                <keywordset>
                    <keyword>DROP DOMAIN</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP DOMAIN</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление существующего домена.</para>
            </formalpara>
            <formalpara>
                <info>
                    <title>Доступно в:</title>
                </info>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting> 
DROP DOMAIN <replaceable>domain_name</replaceable>;                    
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP DOMAIN</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>domain_name</replaceable></entry>
                                <entry>
                                    <para>Имя домена.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>DROP DOMAIN</database> удаляет домен, существующий в базе
                данных. Невозможно удалить домен, на который ссылаются столбцы таблиц базы данных
                или если он был задействован в одном из PSQL модулей. Чтобы удалить такой домен
                необходимо удалить из таблиц все столбцы, ссылающиеся на домен и удалить все ссылки
                на домен из PSQL модулей.</para>
            <section xml:id="ddl-domain-drop-who">
                <title>Кто может удалить домен?</title>

                <para>Выполнить оператор <database>DROP DOMAIN</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец домена; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY DOMAIN</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>

            <section xml:id="ddl-domain-drop-exapmles">
                <title>Примеры</title>
                <example>
                    <title>Удаление домена</title>
                    <para><programlisting language="sql">
DROP DOMAIN COUNTRYNAME;                    
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-domain-create">CREATE DOMAIN</link>, <link
                            linkend="ddl-domain-alter">ALTER DOMAIN</link>. </para>

                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-table">
        <info>
            <title>TABLE</title>
            <keywordset>
                <keyword>TABLE</keyword>
            </keywordset>
        </info>
        <para>Firebird — это реляционная СУБД. Данные в таких базах хранятся в таблицах. Таблица –
            это плоская двухмерная структура, содержащая произвольное количество строк (row). Строки
            таблицы часто называют записями (record). Все строки таблицы имеют одинаковую структуру
            и состоят из столбцов (column). Столбцы таблицы часто называют полями (fields). Таблица
            должна иметь хотя бы один столбец. С каждым столбцом связан определённый тип данных SQL. </para>
        <para>В данном разделе рассматриваются вопросы создания, модификации и удаления таблиц базы
            данных. </para>
        <section xml:id="ddl-table-create">
            <info>
                <title>CREATE TABLE</title>
                <keywordset>
                    <keyword>CREATE TABLE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE TABLE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой таблицы.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE [GLOBAL TEMPORARY] TABLE <replaceable>tablename</replaceable>
  [EXTERNAL [FILE] '<replaceable>&lt;filespec&gt;</replaceable>']
  (<replaceable>&lt;col_def&gt;</replaceable> [, <replaceable>&lt;col_def&gt;</replaceable> | <replaceable>&lt;tconstraint&gt;</replaceable> ...])  
  [ON COMMIT {DELETE | PRESERVE} ROWS]
  [SQL SECURITY {DEFINER | INVOKER}]   

<replaceable>&lt;col_def&gt;</replaceable> ::= <replaceable>&lt;regular_col_def&gt;</replaceable> | <replaceable>&lt;computed_col_def&gt;</replaceable> | <replaceable>&lt;identity_col_def&gt;</replaceable>        
                    
<replaceable>&lt;regular_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> { <replaceable>&lt;datatype&gt;</replaceable> | <replaceable>domainname</replaceable> } 
  [DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>}] 
  [NOT NULL]     
  [<replaceable>&lt;col_constraint&gt;</replaceable>]
  [COLLATE <replaceable>collation_name</replaceable>]        
  
                    
<replaceable>&lt;computed_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] 
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<replaceable>&lt;expression&gt;</replaceable>) 
                    
<replaceable>&lt;identity_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] 
  GENERATED {ALWAYS | BY DEFAULT} AS IDENTITY [(<replaceable>&lt;identity column options&gt;</replaceable>)] 
  [<replaceable>&lt;col_constraint&gt;</replaceable>]  
                    
<replaceable>&lt;identity column options&gt;</replaceable> ::=     
  <replaceable>&lt;identity column option&gt;</replaceable> [<replaceable>&lt;identity column option&gt;</replaceable>]

<replaceable>&lt;identity column option&gt;</replaceable> ::=
    START WITH <replaceable>startvalue</replaceable>
  | INCREMENT [BY] <replaceable>incrementvalue</replaceable>
                    
<replaceable>&lt;datatype&gt;</replaceable> ::= {
    {SMALLINT | INT[EGER] | BIGINT} [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | BOOLEAN [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {FLOAT | DOUBLE PRECISION} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {DATE | TIME | TIMESTAMP} [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)] 
      [<replaceable>&lt;array_dim&gt;</replaceable>] [CHARACTER SET <replaceable>charset_name</replaceable>] 
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
      [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
      [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset_name</replaceable>]   
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])] 
}
    
<replaceable>&lt;array_dim&gt;</replaceable> ::= <emphasis role="bold">[</emphasis>[<replaceable>m</replaceable>:]<replaceable>n</replaceable> [,[<replaceable>m</replaceable>:]<replaceable>n</replaceable> ...]<emphasis role="bold">]</emphasis>       
                    
<replaceable>&lt;col_constraint&gt;</replaceable> ::= [CONSTRAINT <replaceable>constr_name</replaceable>] 
{   UNIQUE [<replaceable>&lt;using_index&gt;</replaceable>] 
  | PRIMARY KEY [<replaceable>&lt;using_index&gt;</replaceable>] 
  | REFERENCES other_table [(<replaceable>other_col</replaceable>)] [<replaceable>&lt;using_index&gt;</replaceable>] 
      [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
      [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
  | CHECK (<replaceable>&lt;check_condition&gt;</replaceable>) 
}          

<replaceable>&lt;tconstraint&gt;</replaceable> ::= [CONSTRAINT <replaceable>constr_name</replaceable>] 
{   UNIQUE (<replaceable>&lt;col_list&gt;</replaceable>) [<replaceable>&lt;using_index&gt;</replaceable>] 
  | PRIMARY KEY (<replaceable>&lt;col_list&gt;</replaceable>) [<replaceable>&lt;using_index&gt;</replaceable>] 
  | FOREIGN KEY (<replaceable>&lt;col_list&gt;</replaceable>) 
    REFERENCES <replaceable>other_table</replaceable> [(<replaceable>&lt;col_list&gt;</replaceable>)] [<replaceable>&lt;using_index&gt;</replaceable>] 
      [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
      [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
  | CHECK (<replaceable>&lt;check_condition&gt;</replaceable>) 
}    

<replaceable>&lt;col_list&gt;</replaceable> ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]

<replaceable>&lt;using_index&gt;</replaceable> ::= USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>indexname</replaceable>   

<replaceable>&lt;check_condition&gt;</replaceable> ::= { 
    <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] BETWEEN <replaceable>&lt;val&gt;</replaceable> AND <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] IN (<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...] | <replaceable>&lt;select_list&gt;</replaceable>) 
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] NULL 
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] DISTINCT <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] CONTAINING <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] STARTING [WITH] <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] LIKE <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>] 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] SIMILAR TO <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>] 
  | <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> {ALL | SOME | ANY} (<replaceable>&lt;select_list&gt;</replaceable>) 
  | [NOT] EXISTS (<replaceable>&lt;select_expr&gt;</replaceable>) 
  | [NOT] SINGULAR (<replaceable>&lt;select_expr&gt;</replaceable>)   
  | (<replaceable>&lt;check_condition&gt;</replaceable>)   
  | NOT <replaceable>&lt;check_condition&gt;</replaceable>   
  | <replaceable>&lt;check_condition&gt;</replaceable> OR <replaceable>&lt;check_condition&gt;</replaceable>   
  | <replaceable>&lt;check_condition&gt;</replaceable> AND <replaceable>&lt;check_condition&gt;</replaceable> 
}    
 
<replaceable>&lt;operator&gt;</replaceable> ::= 
  &lt;&gt; | != | ^=  | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^> | ~>     
                    
<replaceable>&lt;val&gt;</replaceable> ::=  
    <replaceable>colname</replaceable> [<emphasis role="bold">[</emphasis><replaceable>&lt;array_idx&gt;</replaceable> [, <replaceable>&lt;array_idx&gt;</replaceable> ...]<emphasis role="bold">]</emphasis>] 
  | <replaceable>literal</replaceable>   
  | <replaceable>&lt;context_var&gt;</replaceable>   
  | <replaceable>&lt;expression&gt;</replaceable>   
  | NULL   
  | NEXT VALUE FOR <replaceable>genname</replaceable>   
  | GEN_ID(<replaceable>genname</replaceable>, <replaceable>&lt;val&gt;</replaceable>)   
  | CAST(<replaceable>&lt;val&gt;</replaceable> AS <replaceable>&lt;datatype&gt;</replaceable>)   
  | (<replaceable>&lt;select_one&gt;</replaceable>)   
  | <replaceable>func</replaceable>(<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...])   
     
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE TABLE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <replaceable>tablename</replaceable>
                                </entry>
                                <entry>
                                    <para>Имя таблицы, может содержать до 63 символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>filespec</replaceable>
                                </entry>
                                <entry>
                                    <para>Спецификация файла (только для внешних таблиц). </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>colname</replaceable>
                                </entry>
                                <entry>
                                    <para>Имя столбца таблицы, может содержать до 63 символов.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>datatype</replaceable>
                                </entry>
                                <entry>
                                    <para>Тип данных SQL. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>domain_name</replaceable>
                                </entry>
                                <entry>
                                    <para>Имя домена. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>startvalue</replaceable>
                                </entry>
                                <entry>
                                    <para>Начальное значение столбца идентификации. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>identityvalue</replaceable>
                                </entry>
                                <entry>Приращение столбца идентификации. Не может быть равно
                                    0.</entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>col_constraint</replaceable>
                                </entry>
                                <entry>
                                    <para>Ограничение столбца. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>tconstraint</replaceable>
                                </entry>
                                <entry>
                                    <para>Ограничение таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>constr_name</replaceable>
                                </entry>
                                <entry>
                                    <para>Имя ограничения, может содержать до 63 символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>other_table</replaceable>
                                </entry>
                                <entry>
                                    <para>Имя таблицы, на которую ссылается внешний ключ.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>other_col</replaceable>
                                </entry>
                                <entry>
                                    <para>Столбец таблицы, на которую ссылается внешний ключ.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>literal</replaceable>
                                </entry>
                                <entry>
                                    <para>Литерал. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>context_var</replaceable>
                                </entry>
                                <entry>
                                    <para>Любая контекстная переменная, тип которой совместим с
                                        типом данных  столбца. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>check_condition</replaceable>
                                </entry>
                                <entry>
                                    <para>Условие проверки ограничения. Выполняется, если
                                        оценивается как TRUE или NULL/UNKNOWN.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>collation_name</replaceable>
                                </entry>
                                <entry>
                                    <para>Порядок сортировки. Необходимо указывать если вы хотите
                                        чтобы порядок сортировки для столбца отличался от порядка
                                        сортировки для набора символов по умолчанию этого столбца.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>array_dim</replaceable>
                                </entry>
                                <entry>
                                    <para>Размерность массива. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>m</replaceable>
                                </entry>
                                <entry>
                                    <para>Начальный номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>n</replaceable>
                                </entry>
                                <entry>
                                    <para>Последний номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>precision</replaceable>
                                </entry>
                                <entry>
                                    <para>Точность. От 1 до 18. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>scale</replaceable>
                                </entry>
                                <entry>
                                    <para>Масштаб. От 0 до 18, должно быть меньше или равно
                                            <replaceable>precision</replaceable>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>size</replaceable>
                                </entry>
                                <entry>
                                    <para>Максимальный размер строки в символах. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>charset_name</replaceable>
                                </entry>
                                <entry>
                                    <para>Набор символов. Необходимо указывать, если вы хотите чтобы
                                        набор символов столбца отличался от набора символов по
                                        умолчанию для базы данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>subtype_num</replaceable>
                                </entry>
                                <entry>
                                    <para>Номер подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>subtype_name</replaceable>
                                </entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>seglen</replaceable>
                                </entry>
                                <entry>
                                    <para>Размер сегмента, не может превышать 65535. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>val</replaceable>
                                </entry>
                                <entry>
                                    <para>Значение. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>select_one</replaceable>
                                </entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        только одну строку. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>select_list</replaceable>
                                </entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>select_expr</replaceable>
                                </entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий несколько столбцов и
                                        возвращающий ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>experssion</replaceable>
                                </entry>
                                <entry>
                                    <para>Выражение. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>genname</replaceable>
                                </entry>
                                <entry>
                                    <para>Имя последовательности (генератора). </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>func</replaceable>
                                </entry>
                                <entry>
                                    <para>Скалярная функция. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE TABLE</database> создаёт новую таблицу. Имя таблицы
                должно быть уникальным среди имён всех таблиц, представлений (VIEWs) и хранимых
                процедур базы данных. </para>
            <para>Таблица может содержать, по меньшей мере, один столбец и произвольное количество
                ограничений таблицы.</para>
            <para>Имя столбца должно быть уникальным для создаваемой таблицы. Для столбца
                обязательно должен быть указан либо тип данных, либо имя домена, характеристики
                которого будут скопированы для столбца, либо должно быть указано, что столбец
                является вычисляемым.</para>
            <para>В качестве типа столбца можно использовать любой тип данных SQL. </para>
            <section xml:id="ddl-table-create-column-character">
                <title>Символьные столбцы</title>

                <para>Для типов <database class="datatype">CHAR</database>, <database
                        class="datatype">VARCHAR</database> и <database class="datatype"
                        >BLOB</database> с подтипом TEXT можно указать набор символов в предложении
                        <database>CHARACTER SET</database>. Если набор символов не указан, то по
                    умолчанию принимается тот набор символов, что был указан при создании базы
                    данных. Если же при создании базы данных не был указан набор символов, то по
                    умолчанию принимается набор символов NONE. В этом случае данные хранятся и
                    извлекаются, так как они были поданы. В столбец можно загружать данные в любой
                    кодировке, но невозможно загрузить эти данные в столбец с другой кодировкой.
                    Транслитерация между исходными и конечными кодировками не выполняется, что может
                    приводить к ошибкам.</para>
                <para>Необязательное предложение <database>COLLATE</database> позволяет задать
                    порядок сортировки для строковых типов данных (за исключением <database
                        class="datatype">BLOB</database>). Если порядок сортировки не указан, то по
                    умолчанию принимается порядок сортировки по умолчанию для указанного набора
                    сортировки.</para>
            </section>
            <section xml:id="ddl-table-create-column-nullable">
                <title>Ограничение NOT NULL</title>

                <para>По умолчанию столбец может принимать значение NULL.</para>
                <para>Необязательное предложение <database>NOT NULL</database> указывает, что
                    столбцу не может быть присвоено значение NULL.</para>
            </section>
            <section xml:id="ddl-table-create-column-default">
                <title>Значение по умолчанию</title>

                <para>Необязательное предложение <database>DEFAULT</database> позволяет указать
                    значение по умолчанию для столбца таблицы. Это значение будет помещено в столбец
                    таблицы при выполнении оператора <database>INSERT</database>, если значение не
                    будет указано для этого столбца. В качестве значения по умолчанию может быть
                    литерал совместимый по типу, неизвестное значение NULL или контекстная
                    переменная, тип которой совместим с типом столбца. Если значение по умолчанию
                    явно не устанавливается, то подразумевается пустое значение, NULL. Использование
                    выражений в значении по умолчанию недопустимо.</para>
            </section>
            <section xml:id="ddl-table-create-column-domain">
                <title>Столбцы основанные на домене</title>

                <para>Для определения столбца, можно воспользоваться ранее описанным доменом. Если
                    определение столбца основано на домене, оно может включать новое значение по
                    умолчанию, дополнительные ограничения <database>CHECK</database>, предложение
                        <database>COLLATE</database>, которые перекрывают значения указанные при
                    определении домена. Определение такого столбца может включать дополнительные
                    ограничения столбца, например NOT NULL, если домен его ещё не содержит.</para>
                <important>
                    <para>Следует обратить внимание на то, что если в определении домена было
                        указано <database>NOT NULL</database>, на уровне столбца невозможно
                        определить допустимость использования в нем значения NULL. Если вы хотите
                        чтобы на основе домена можно было определять столбцы допускающие
                        псевдозначение NULL и не допускающее его, то хорошей практикой является
                        создание домена допускающего NULL и указание ограничения <database>NOT
                            NULL</database> у столбцов таблицы там где это необходимо.</para>
                </important>
            </section>
            <section xml:id="ddl-table-create-column-identity">
                <title>Столбцы идентификации (автоинкремент)</title>
                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>IDENTITY</secondary>
                </indexterm>
                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>GENERATED ALWAYS AS IDENTITY</secondary>
                </indexterm>

                <para>Столбец идентификации представляет собой столбец, связанный с внутренним
                    генератором последовательностей. Столбцы идентификации могут быть определены
                    либо с помощью предложения <database>GENERATED BY DEFAULT AS
                    IDENTITY</database>, либо предложения <database>GENERATED ALWAYS AS
                        IDENTITY</database>.</para>
                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>GENERATED BY DEFAULT AS IDENTITY</secondary>
                </indexterm>
                <para>Если столбец идентификации задан как GENERATED BY DEFAULT, то его значение
                    будет увеличиваться и использовано как значение по умолчанию при каждой вставке,
                    только в том случае, если значение этого столбца не задано явно.</para>
                <para>Чтобы использовать сгенерированное по умолчанию значение, необходимо либо
                    указать ключевое слово DEFAULT при вставке в столбец идентификации, или просто
                    не упоминать столбец идентификации в списке столбцов для вставки. В противном
                    случае будет использовано указанное вами значение. Например: <informalexample>
                        <para><programlisting language="sql"><![CDATA[                    
CREATE TABLE greetings (
  id INT GENERATED BY DEFAULT AS IDENTITY, 
  name CHAR(50));
	
-- specify value "1":
INSERT INTO greetings VALUES (1, 'hi');

-- use generated default
INSERT INTO greetings VALUES (DEFAULT, 'salut');

-- use generated default
INSERT INTO greetings(ch) VALUES ('bonjour'); 
]]></programlisting></para>
                    </informalexample>
                    <note>
                        <para>Это поведение может быть изменено в операторе INSERT если указана
                            директива <database>OVERRIDING USER VALUE</database>. Подробнее см.
                        </para>
                    </note>
                </para>
                <para>Если столбец идентификации задан как GENERATED ALWAYS, то его значение будет
                    увеличиваться при каждой вставке. При попытке явно присвоить значение столбца
                    идентификации в операторе INSERT, будет выдано сообщение об ошибке. В операторе
                    INSERT вы можете указать ключевое слово DEFAULT вместо значения для столбца
                    идентификации. <informalexample>
                        <para><programlisting language="sql"><![CDATA[                    
create table greetings (
  id INT GENERATED ALWAYS AS IDENTITY, 
  name CHAR(50));
	
INSERT INTO greetings VALUES (DEFAULT, 'hello');

INSERT INTO greetings(ch) VALUES ('bonjour');
]]></programlisting></para>
                    </informalexample>
                </para>
                <note>
                    <para>Это поведение может быть изменено в операторе INSERT если указана
                        директива <database>OVERRIDING SYSTEM VALUE</database>. Подробнее см.
                    </para>
                </note>
                <para>Необязательное предложение <database>START WITH</database> позволяет указать
                    начальное значение отличное от нуля. Предложение INCREMENT [BY] устанавливает
                    значение приращения. Значение приращения должно быть отлично от 0. По умолчанию
                    значение приращения равно 1.</para>
                <formalpara>
                    <title>Правила</title>
                    <para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>Тип данных столбца идентификации должен быть целым числом с
                                    нулевым масштабом. Допустимыми типами являются SMALLINT,
                                    INTEGER, BIGINT, NUMERIC(x,0) и DECIMAL(x,0);</para>
                            </listitem>
                            <listitem>
                                <para>Идентификационный столбец не может иметь DEFAULT и COMPUTED
                                    значений.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </formalpara>
                <note>
                    <para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>Идентификационный столбец может быть изменён, чтобы стать
                                    обычным столбцом. Обычный столбец не может быть изменён, чтобы
                                    стать идентификационным.</para>
                            </listitem>
                            <listitem>
                                <para>Идентификационные столбцы неявно являются NOT NULL
                                    столбцами.</para>
                            </listitem>
                            <listitem>
                                <para>Уникальность не обеспечивается автоматически. Ограничения
                                    UNIQUE или PRIMARY KEY требуются для гарантии
                                    уникальности.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </note>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="dml-insert-overriding">Директива OVERRIDING</link>. </para>
                </formalpara>
            </section>
            <section xml:id="ddl-table-create-column-computed">
                <title>Вычисляемые поля</title>

                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>COMPUTED BY</secondary>
                </indexterm>
                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>GENERATED ALWAYS AS</secondary>
                </indexterm>
                <para>Вычисляемые поля могут быть определены с помощью предложения COMPUTED [BY] или
                        <database>GENERATED ALWAYS AS</database> (согласно стандарту SQL-2003). Они
                    эквивалентны по смыслу. Для вычисляемых полей не требуется описывать тип данных
                    (но допустимо), СУБД вычисляет подходящий тип в результате анализа выражения. В
                    выражении требуется указать корректную операцию для типов данных столбцов,
                    входящих в его состав. При явном указании типа столбца для вычисляемого поля
                    результат вычисления приводится к указанному типу, то есть, например, результат
                    числового выражения можно вывести как строку. Вычисление выражения происходит
                    для каждой строки выбранных данных, если в операторе выборки данных SELECT,
                    присутствует такой столбец.</para>
                <tip>
                    <para>Вместо использования вычисляемого столбца в ряде случаев имеет смысл
                        использовать обычный столбец, значение которого рассчитывается в триггерах
                        на добавление и обновление данных. Это может снизить производительность
                        вставки/модификации записей, но повысит производительность выборки
                        данных.</para>
                </tip>
                <section xml:id="ddl-table-create-column-computed-sql_security">
                    <title>Контекст безопасности</title>
                    <indexterm>
                        <primary>CREATE TABLE</primary>
                        <secondary>COMPUTED BY</secondary>
                        <tertiary>SQL SECURITY</tertiary>
                    </indexterm>
                    <indexterm>
                        <primary>CREATE TABLE</primary>
                        <secondary>GENERATED ALWAYS AS</secondary>
                        <tertiary>SQL SECURITY</tertiary>
                    </indexterm>
                    <para>Необязательное предложение SQL SECURITY в спецификации таблицы позволяет
                        задать с какими привилегиями вычисляются вычисляемые столбцы. Если выбрана
                        опция INVOKER, то вычисляемые столбцы вычисляются с привилегиями вызывающего
                        пользователя. Если выбрана опция DEFINER, то вычисляемые столбцы вычисляются
                        с привилегиями определяющего пользователя (владельца). По умолчанию
                        вычисляемые столбцы вычисляются с привилегиями вызывающего пользователя.
                        Кроме триггеры наследуют контекст безопасности таблицы, если он не
                        переопределён у самих триггеров.</para>
                    <tip>
                        <para>Контекст безопасности по умолчанию для вновь создаваемых объектов
                            метаданных можно изменить с помощью оператора
                            <programlisting>
ALTER DATABASE SET DEFAULT SQL SECURITY {DEFINER | INVOKER}
                </programlisting>
                        </para>
                    </tip>
                </section>
            </section>
            <section xml:id="ddl-table-create-column-array">
                <title>Столбцы типа массив</title>

                <para>Для любого типа данных кроме <database class="datatype">BLOB</database> можно
                    указать размерность массива, если столбец должен быть массивом. Размерность
                    массива указывается в квадратных скобках. Чтобы не перепутать их с символами,
                    означающими необязательные элементы, они выделены жирным шрифтом. При указании
                    размерности массива указываются два числа через двоеточие. Первое число означает
                    начальный номер элемента массива, второе — конечный. Если указано только одно
                    число, то оно означает последний номер в элементе массива, а первым номером
                    считается 1. Для многомерного массива размерности массива перечисляются через
                    запятую.</para>
            </section>
            <section xml:id="ddl-table-create-constraints">
                <title>Ограничения</title>

                <para>Существуют четыре вида ограничений:</para>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>первичный ключ (<database>PRIMARY KEY</database>);</para>
                        </listitem>
                        <listitem>
                            <para>уникальный ключ (<database>UNIQUE</database>);</para>
                        </listitem>
                        <listitem>
                            <para>внешний ключ (<database>REFERENCES</database> или
                                    <database>FOREIGN KEY</database>);</para>
                        </listitem>
                        <listitem>
                            <para>проверочное ограничение (<database>CHECK</database>).</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>Ограничения могут быть указаны на уровне столбца (<quote>ограничения
                        столбцов</quote>) или на уровне таблицы (<quote>табличные
                        ограничения</quote>). Ограничения уровня таблицы необходимы, когда ключи
                    (ограничение уникальности, первичный ключ или внешний ключ) должны быть
                    сформированы по нескольким столбцам, или, когда ограничение CHECK включает
                    несколько столбцов, т.е. действует на уровне записи. Синтаксис для некоторых
                    типов ограничений может незначительно отличаться в зависимости от того
                    определяется ограничение на уровне столбца или на уровне таблицы.</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Ограничение на уровне столбца указывается после определения других
                                характеристик столбца. Оно может включать только столбец указанный в
                                этом определении.</para>
                        </listitem>
                        <listitem>
                            <para>Ограничения на уровне таблицы указываются после определений всех
                                столбцов. Ограничения таблицы являются более универсальным способом
                                записи ограничений, поскольку позволяют ограничение более чем для
                                одного столбца таблицы.</para>
                        </listitem>
                        <listitem>
                            <para>Вы можете смешивать ограничения столбцов и ограничения таблиц в
                                одном операторе <database>CREATE TABLE</database>.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>Системой автоматически создаётся индекс для первичного ключа (PRIMARY KEY),
                    уникального ключа (UNIQUE KEY) и внешнего ключа (REFERENCES для ограничения
                    уровня столбца, и FOREIGN KEY REFERENCES для ограничения уровня таблицы).</para>

                <section xml:id="ddl-table-create-constraints-named-index">
                    <title>Имена для ограничений и их индексов</title>

                    <para>Если имя ограничения не задано, то оно автоматически будет сгенерировано
                        системой. </para>

                    <para>Ограничения уровня столбца и их индексы автоматически именуются следующим
                        образом: <itemizedlist>
                            <listitem>
                                <para>Имена ограничений имеют следующий вид
                                            <database>INTEG_<replaceable>n</replaceable></database>,
                                    где <replaceable>n</replaceable> представлено одним или
                                    несколькими числами;</para>
                            </listitem>
                            <listitem>
                                <para>Имена индексов имеют вид
                                            <database>RDB$PRIMARY<replaceable>n</replaceable></database>
                                    (для индекса первичного ключа),
                                            <database>RDB$FOREIGN<replaceable>n</replaceable></database>
                                    (для индекса внешнего ключа) или
                                            <database>RDB$<replaceable>n</replaceable></database>
                                    (для индекса уникального ключа), где
                                        <replaceable>n</replaceable> представлено одним или
                                    несколькими числами;</para>
                            </listitem>
                        </itemizedlist></para>
                    <para>Схемы автоматического формирования имён для ограничений уровня таблицы и
                        их индексов одинаковы.</para>
                    <section xml:id="ddl-table-create-constraints-named">
                        <title>Именованные ограничения</title>

                        <indexterm>
                            <primary>CREATE TABLE</primary>
                            <secondary>CONSTRAINT</secondary>
                        </indexterm>

                        <para>Имя ограничения можно задать явно, если указать его в необязательном
                            предложении <database>CONSTRAINT</database>. По умолчанию имя индекса
                            ограничения будет тем же самым, что и самого ограничения. Если для
                            индекса необходимо задать другое имя, то его можно указать в предложении
                                <database>USING</database>.</para>
                    </section>
                    <!-- named constraints -->
                    <section xml:id="ddl-table-create-constraints-using">
                        <title>Предложение USING</title>
                        <indexterm>
                            <primary>CREATE TABLE</primary>
                            <secondary>CONSTRAINT</secondary>
                            <tertiary>USING</tertiary>
                        </indexterm>

                        <para>Предложение <database>USING</database> позволяет задать определённое
                            пользователем имя автоматически создаваемого индекса для ограничения, и
                            опционально определить, какой это будет индекс — по возрастанию (по
                            умолчанию) или по убыванию.</para>
                    </section>
                    <!-- using clause -->
                </section>
                <!-- names for constraints and their indexes -->
                <section xml:id="ddl-table-create-constraints-PK">
                    <title>Первичный ключ (PRIMARY KEY)</title>
                    <indexterm>
                        <primary>CREATE TABLE</primary>
                        <secondary>PRIMARY KEY</secondary>
                    </indexterm>

                    <para>Ограничение первичного ключа <database>PRIMARY KEY</database> строится на
                        поле с заданным ограничением <database>NOT NULL</database> и требует
                        уникальности значений столбца. Таблица может иметь только один первичный
                        ключ. </para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para>Первичный ключ по единственному столбцу может быть определён
                                    как на уровне столбца, так и на уровне таблицы.</para>
                            </listitem>
                            <listitem>
                                <para>Первичный ключ по нескольким столбцам может быть определён
                                    только на уровне таблицы.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </section>
                <!-- primary key -->

                <section xml:id="ddl-table-create-constraints-unique">
                    <title>Ограничение уникальности (UNIQUE)</title>
                    <indexterm>
                        <primary>CREATE TABLE</primary>
                        <secondary>UNIQUE</secondary>
                    </indexterm>

                    <para>Ограничение уникального ключа <database>UNIQUE</database> задаёт для
                        значений столбца требование уникальности содержимого. Таблица может
                        содержать любое количество уникальных ключей.</para>

                    <para>Как и первичный ключ, ограничение уникальности может быть определено на
                        нескольких столбцах. В этом случае вы должны определять его как ограничение
                        уровня таблицы.</para>

                    <section xml:id="ddl-table-create-constraints-unique-null">
                        <title>NULL в уникальных ключах</title>

                        <para>Согласно стандарту SQL-99 Firebird допускает одно или более значений
                            NULL в столбце на который наложено ограничение
                                <database>UNIQUE</database>. Это позволяет определить ограничение
                                <database>UNIQUE</database> на столбцах, которые не имеют
                            ограничения <database>NOT NULL</database>.</para>

                        <para>Для уникальных ключей, содержащих несколько столбцов, логика немного
                            сложнее:</para>
                        <para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Разрешено множество записей со значением NULL во всех
                                        столбцах ключа;</para>
                                </listitem>
                                <listitem>
                                    <para>Разрешено множество записей с различными комбинациями null
                                        и not-null значений в ключах;</para>
                                </listitem>
                                <listitem>
                                    <para>Разрешено множество записей, в которых в одном из столбцов
                                        уникального ключа содержится значение NULL, а остальные
                                        столбцы заполнены значениями и эти значения различны хотя бы
                                        в одном из них;</para>
                                </listitem>
                                <listitem>
                                    <para>Разрешено множество записей, в которых в одном из столбцов
                                        уникального ключа содержится значение NULL, а остальные
                                        столбцы заполнены значениями, и эти значения имеют
                                        совпадения хотя бы в одном из них.</para>
                                </listitem>
                            </itemizedlist>
                        </para>
                        <para>Это можно резюмировать следующим примером:
                            <programlisting language="sql">
RECREATE TABLE t( x int, y int, z int, unique(x,y,z));
INSERT INTO t values( NULL, 1, 1 );
INSERT INTO t values( NULL, NULL, 1 );
INSERT INTO t values( NULL, NULL, NULL );
INSERT INTO t values( NULL, NULL, NULL ); -- Разрешено
INSERT INTO t values( NULL, NULL, 1 ); -- Запрещено                    
                </programlisting>
                        </para>
                    </section>
                    <!-- NULL in Unique Keys -->
                </section>
                <!-- unique -->

                <section xml:id="ddl-table-create-constraints-FK">
                    <title>Внешний ключ (FOREIGN KEY)</title>
                    <indexterm>
                        <primary>CREATE TABLE</primary>
                        <secondary>REFERENCES</secondary>
                    </indexterm>
                    <indexterm>
                        <primary>CREATE TABLE</primary>
                        <secondary>FOREIGN KEY</secondary>
                    </indexterm>

                    <para>Ограничение внешнего ключа гарантирует, что столбец (столбцы) участник
                        может содержать только те значения, которые существуют в указанном столбце
                        (столбцах) главной таблицы. Эти ссылочные столбцы часто называют столбцами
                        назначения. Они должны быть первичным ключом или уникальный ключом в целевой
                        таблице. Они могут не иметь ограничения NOT NULL, если они входят в
                        ограничение уникального ключа.</para>

                    <para>Столбцы внешнего ключа не требуют ограничения NOT NULL.</para>

                    <para>На уровне столбца ограничение внешнего ключа определяется с использование
                        м ключевого слова <database>REFERENCES</database>.
                        <programlisting language="sql">
... ,
ARTIFACT_ID INTEGER REFERENCES COLLECTION (ARTIFACT_ID),                        
                    </programlisting>
                    </para>
                    <para>В этом примере столбец ARTIFACT_ID ссылается на столбец с тем же именем в
                        таблице COLLECTION.</para>
                    <para>На уровне таблицы могут быть определены внешний ключ над одним или
                        несколькими столбцами. Для внешние ключи над несколькими столбцами можно
                        определить только на уровне таблицы.</para>
                    <para>Синтаксис определения внешнего ключа на уровне таблицы несколько
                        отличается. После определения всех столбцов, с их ограничения уровня
                        столбца, вы можете определить именованное ограничение внешнего ключа уровня
                        таблицы, используя ключевые слова <database>FOREIGN KEY</database> и имён
                        столбцов для которых оно применяется:
                        <programlisting language="sql">
... ,
CONSTRAINT FK_ARTSOURCE FOREIGN KEY(DEALER_ID, COUNTRY)
  REFERENCES DEALER (DEALER_ID, COUNTRY),                      
                    </programlisting>
                    </para>
                    <para>Обратите внимание на то, что имена столбцов в целевой (master) таблице
                        могут отличаться от тех что указаны во внешнем ключе.</para>
                    <note>
                        <para>Если целевые столбцы не указаны, то внешний ключ автоматически
                            ссылается на столбцы первичного ключа целевой таблицы.</para>
                    </note>

                    <section xml:id="ddl-table-create-constraints-FK-actions">
                        <title>Действия внешнего ключа</title>

                        <para>Для обеспечения дополнительной целостности данных можно указать
                            необязательные опции, которые обеспечат согласованность данных между
                            родительскими и дочерними таблицами по заданным правилам:<itemizedlist>
                                <listitem>
                                    <indexterm>
                                        <primary>CREATE TABLE</primary>
                                        <secondary>REFERENCES</secondary>
                                        <tertiary>ON UPDATE</tertiary>
                                    </indexterm>
                                    <para>Предложение <database>ON UPDATE</database> определяет, что
                                        произойдёт с записями подчинённой таблицы при изменении
                                        значения первичного/уникального ключа в строке главной
                                        таблицы.</para>
                                </listitem>
                                <listitem>
                                    <indexterm>
                                        <primary>CREATE TABLE</primary>
                                        <secondary>REFERENCES</secondary>
                                        <tertiary>ON DELETE</tertiary>
                                    </indexterm>
                                    <para>Предложение <database>ON DELETE</database> определяет, что
                                        произойдёт с записями подчинённой таблицы при удалении
                                        соответствующей строки главной таблицы.</para>
                                </listitem>
                            </itemizedlist></para>


                        <para>Для обеспечения ссылочной целостности внешнего ключа, когда изменяется
                            или удаляется значение связанного первичного или уникального ключа,
                            могут быть выполнены следующие действия:</para>
                        <para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para><database>NO ACTION</database> (по умолчанию) — не будет
                                        выполнено никаких действий;</para>
                                </listitem>
                                <listitem>
                                    <para><database>CASCADE</database> — при изменении или удалении
                                        значения первичного ключа над значением внешнего ключа будут
                                        произведены те же действия. При выполнении удаления строки в
                                        главной таблице в подчинённой таблице должны быть удалены
                                        все записи, имеющие те же значения внешнего ключа, что и
                                        значение первичного (уникального) ключа удалённой строки
                                        главной таблицы. При выполнении обновления записи главной
                                        таблицы в подчинённой таблице должны быть изменены все
                                        значения внешнего ключа, имеющие те же значения, что и
                                        значение первичного (уникального) ключа изменяемой строки
                                        главной таблицы;</para>
                                </listitem>
                                <listitem>
                                    <para><database>SET DEFAULT</database> — значения внешнего ключа
                                        всех соответствующих строк в подчинённой таблице
                                        устанавливаются в значение по умолчанию, заданное в
                                        предложении DEFAULT для этого столбца;</para>
                                </listitem>
                                <listitem>
                                    <para><database>SET NULL</database> — значения внешнего ключа
                                        всех соответствующих строк в подчинённой таблице
                                        устанавливаются в пустое значение NULL.</para>
                                </listitem>
                            </itemizedlist>
                        </para>
                        <formalpara>
                            <title>Пример:</title>
                            <para>
                                <informalexample>
                                    <para>
                                        <programlisting language="sql">                                        
CONSTRAINT FK_ORDERS_CUST
FOREIGN KEY (CUSTOMER) REFERENCES CUSTOMERS (ID)
ON UPDATE CASCADE ON DELETE SET NULL
</programlisting>
                                    </para>
                                </informalexample>
                            </para>
                        </formalpara>
                    </section>
                    <!-- foreign key actions -->
                </section>
                <!-- foreign key -->

                <section xml:id="ddl-table-create-constraints-check">
                    <title>Ограничение CHECK</title>
                    <indexterm>
                        <primary>CREATE TABLE</primary>
                        <secondary>CHECK</secondary>
                    </indexterm>
                    <para>Ограничение <database>CHECK</database> задаёт условие, которому должны
                        удовлетворять значения, помещаемые в данный столбец. Условие — это
                        логическое выражение, называемое также предикат, которое может возвращать
                        значения TRUE (истина), FALSE (ложь) и UNKNOWN (неизвестно). Условие
                        считается выполненным, если предикат возвращает значение TRUE или UNKNOWN
                        (эквивалент NULL). Если предикат возвращает FALSE, то значение не будет
                        принято. Это условие используется при добавлении в таблицу новой строки
                        (оператор INSERT) и при изменении существующего значения столбца таблицы
                        (оператор UPDATE), а также операторов, в которых может произойти одно из
                        этих действий (UPDATE OR INSERT, MERGE).</para>
                    <important>
                        <para>При использовании предложения CHECK для столбца, базирующегося на
                            домене, следует помнить, что выражение в CHECK лишь дополняет условие
                            проверки, которое может уже быть определено в домене.</para>
                    </important>
                    <para>На уровне столбца выражение в предложении <database>CHECK</database>
                        ссылается на входящее значение с помощью ключевого слова
                            <database>VALUE</database>, так же как предложение
                            <database>CHECK</database> в определении домена. На уровне таблицы
                        выражение в предложении <database>CHECK</database> ссылается на входящее
                        значение по идентификатору столбца. </para>
                    <formalpara>
                        <title>Примеры:</title>
                        <para>
                            <example>
                                <title>CHECK ограничения уровня столбца и уровня таблицы</title>
                                <para>
                                    <programlisting language="sql">
CREATE TABLE PLACES (
  ...
  LAT DECIMAL(9, 6) CHECK (ABS(LAT) &lt;= 90),
  LON DECIMAL(9, 6) CHECK (ABS(LON) &lt;= 180),
  ...
  CONSTRAINT CHK_POLES CHECK (ABS(LAT) &lt; 90 OR LON = 0)
);               
                </programlisting>
                                </para>
                            </example>
                        </para>
                    </formalpara>
                </section>
                <!-- check constraint -->
            </section>
            <!-- constraints -->
            <section xml:id="ddl-table-create-who">
                <title>Кто может создать таблицу?</title>

                <para>Выполнить оператор <database>CREATE TABLE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE TABLE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший таблицу, становится её владельцем.</para>

            </section>

            <section xml:id="ddl-table-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание таблицы</title>
                    <para><programlisting language="sql">
CREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);                    
                </programlisting></para>
                </example>
                <example>
                    <title>Создание таблицы с заданием именованного первичного и уникального
                        ключей</title>
                    <para><programlisting language="sql">
CREATE TABLE STOCK (
  MODEL SMALLINT NOT NULL CONSTRAINT PK_STOCK PRIMARY KEY,
  MODELNAME CHAR(10) NOT NULL,
  ITEMID INTEGER NOT NULL,
  CONSTRAINT MOD_UNIQUE UNIQUE (MODELNAME, ITEMID));                   
                </programlisting></para>
                </example>
                <example>
                    <title>Таблица с полем массивом</title>
                    <para><programlisting language="sql">
<![CDATA[                    
CREATE TABLE JOB (
    JOB_CODE         JOBCODE NOT NULL,
    JOB_GRADE        JOBGRADE NOT NULL,
    JOB_COUNTRY      COUNTRYNAME,
    JOB_TITLE        VARCHAR(25) NOT NULL,
    MIN_SALARY       NUMERIC(18, 2) DEFAULT 0 NOT NULL,
    MAX_SALARY       NUMERIC(18, 2) NOT NULL,
    JOB_REQUIREMENT  BLOB SUB_TYPE 1,
    LANGUAGE_REQ     VARCHAR(15) [1:5],
    PRIMARY KEY (JOB_CODE, JOB_GRADE, JOB_COUNTRY),
    FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY)
      ON UPDATE CASCADE
      ON DELETE SET NULL,
    CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY) 
);  
]]>  
                </programlisting></para>
                </example>
                <example>
                    <title>Создание таблицы с ограничением первичного, внешнего и уникального ключа
                        для которых заданы пользовательские имена индексов</title>
                    <para><programlisting language="sql">
CREATE TABLE PROJECT (
    PROJ_ID    PROJNO NOT NULL,
    PROJ_NAME  VARCHAR(20) NOT NULL UNIQUE 
      USING DESC INDEX IDX_PROJNAME,
    PROJ_DESC    BLOB SUB_TYPE 1,
    TEAM_LEADER  EMPNO,
    PRODUCT      PRODTYPE,
    CONSTRAINT PK_PROJECT PRIMARY KEY (PROJ_ID) 
      USING INDEX IDX_PROJ_ID,
    FOREIGN KEY (TEAM_LEADER) REFERENCES EMPLOYEE (EMP_NO) 
      USING INDEX IDX_LEADER
);                  
                </programlisting></para>
                </example>
                <example>
                    <title>Создание таблицы со столбцом идентификации BY DEFAULT</title>
                    <para><programlisting language="sql">
CREATE TABLE objects (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(15)
);

INSERT INTO objects (name) VALUES ('Table');
INSERT INTO objects (name) VALUES ('Book');
INSERT INTO objects (id, name) VALUES (10, 'Computer');

SELECT * FROM objects;
</programlisting>
                        <screen>
ID           NAME
============ ===============
           1 Table
           2 Book
          10 Computer
</screen>
                    </para>
                </example>
                <example>
                    <title>Создание таблицы со столбцом идентификации ALWAYS</title>
                    <para><programlisting language="sql">
CREATE TABLE objects (
  id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name VARCHAR(15)
);

INSERT INTO objects (name) VALUES ('Table');
INSERT INTO objects (name) VALUES ('Book');
INSERT INTO objects (id, name) VALUES (DEFAULT, 'Computer');

SELECT * FROM objects;
</programlisting>
                        <screen>
ID           NAME
============ ===============
           1 Table
           2 Book
           3 Computer
</screen>
                    </para>
                </example>                
                <example>
                    <title>Создание таблицы со столбцом идентификации с начальным значением равным
                        10 и приращением равным 2</title>
                    <para><programlisting language="sql">
CREATE TABLE objects (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY (STER WITH 10 INCREMENT BY 2) PRIMARY KEY,
  name VARCHAR(15)
);

INSERT INTO objects (name) VALUES ('Table');
INSERT INTO objects (name) VALUES ('Book');
</programlisting>
                        <screen>
ID           NAME
============ ===============
          12 Table
          14 Book
</screen>
                    </para>
                </example>
                <example>
                    <title>Создание таблицы с вычисляемыми полями</title>
                    <para><programlisting language="sql">
CREATE TABLE SALARY_HISTORY (
    EMP_NO          EMPNO NOT NULL,
    CHANGE_DATE     TIMESTAMP DEFAULT 'NOW' NOT NULL,
    UPDATER_ID      VARCHAR(20) NOT NULL,
    OLD_SALARY      SALARY NOT NULL,
    PERCENT_CHANGE  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    SALARY_CHANGE   GENERATED ALWAYS AS 
      (OLD_SALARY * PERCENT_CHANGE / 100),
    NEW_SALARY      COMPUTED BY 
      (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
);                   
                </programlisting></para>
                    <para>Поле SALARY_CHANGE объявлено согласно стандарту SQL::2003, поле NEW_SALARY
                        в классическом стиле объявления вычисляемых полей в Firebird.</para>
                    <para><programlisting language="sql">
CREATE TABLE SALARY_HISTORY 
(
    EMP_NO          EMPNO NOT NULL,
    CHANGE_DATE     TIMESTAMP DEFAULT 'NOW' NOT NULL,
    UPDATER_ID      VARCHAR(20) NOT NULL,
    OLD_SALARY      SALARY NOT NULL,
    PERCENT_CHANGE  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    SALARY_CHANGE   GENERATED ALWAYS AS 
      (OLD_SALARY * PERCENT_CHANGE / 100),
    NEW_SALARY      COMPUTED BY 
      (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
)
SQL SECURITY DEFINER;                   
                </programlisting></para>
                    <para>Тоже самое, но вычисляемые столбцы вычисляются с правами определяющего
                        пользователя (владельца таблицы). Кроме триггеры наследуют контекст
                        безопасности таблицы, если он не переопределён у самих триггеров.</para>
                </example>
            </section>
            <section xml:id="ddl-table-create-gtt">
                <info>
                    <title>Глобальные временные таблицы (GTT)</title>
                    <keywordset>
                        <keyword>GTT</keyword>
                        <keyword>GLOBAL TEMPORARY</keyword>
                        <keyword>ON COMMIT DELETE ROWS</keyword>
                        <keyword>ON COMMIT PRESERVE ROWS</keyword>
                    </keywordset>
                </info>

                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>GLOBAL TEMPORARY</secondary>
                    <tertiary>ON COMMIT DELETE ROWS</tertiary>
                </indexterm>
                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>GLOBAL TEMPORARY</secondary>
                    <tertiary>ON COMMIT PRESERVE ROWS</tertiary>
                </indexterm>
                <para>Глобальные временные таблицы (в дальнейшем сокращённо <abbrev>GTT</abbrev>)
                    так же, как и обычные таблицы, являются постоянными метаданными, но данные в них
                    ограничены по времени существования транзакцией (значение по умолчанию) или
                    соединением с БД. Каждая транзакция или соединение имеет свой собственный
                    экземпляр GTT с данными, изолированный от всех остальных. Экземпляры создаются
                    только при условии обращения к GTT, и данные в ней удаляются при завершении
                    транзакции или отключении от БД. Метаданные GTT могут быть изменены или удалены
                    с помощью инструкций ALTER TABLE и DROP TABLE.</para>
                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
CREATE GLOBAL TEMPORARY TABLE <replaceable>name</replaceable>
  (<replaceable>&lt;column_def&gt;</replaceable> [, {<replaceable>&lt;column_def&gt;</replaceable> | <replaceable>&lt;table_constraint&gt;</replaceable>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS] 
  [SQL SECURITY {DEFINER | INVOKER}]                 
                </programlisting>
                    </para>
                </formalpara>

                <note>
                    <para>Если в операторе создания глобальной временной таблицы указано
                        необязательное предложение <database>ON COMMIT DELETE ROWS</database>, то
                        будет создана GTT транзакционного уровня (по умолчанию). При указании
                        предложения <database>ON COMMIT PRESERVE ROWS</database> — будет создана GTT
                        уровня соединения с базой данных.</para>
                    <para>Предложение EXTERNAL [FILE] нельзя использовать для глобальной временной
                        таблицы.</para>
                </note>
                <section>
                    <title>Ограничения GTT</title>
                    <para>GTT обаладают всеми атрибутами обычных таблиц (ключи, внешние ключи,
                        индексы и триггеры), но имеют ряд ограничений:</para>
                    <para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>GTT и обычные таблицы не могут ссылаться друг на друга;</para>
                            </listitem>
                            <listitem>
                                <para>GTT уровня соединения (<quote>PRESERVE ROWS</quote>) GTT не
                                    могут ссылаться на GTT транзакционного уровня (<quote>DELETE
                                        ROWS</quote>);</para>
                            </listitem>
                            <listitem>
                                <para>Ограничения домена не могут ссылаться на любую GTT;</para>
                            </listitem>
                            <listitem>
                                <para>Уничтожения экземпляра GTT в конце своего жизненного цикла не
                                    вызывает срабатывания триггеров до/после удаления.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <tip>
                        <para> В существующей базе данных не всегда легко отличить обычную таблицу
                            от GTT, или GTT транзакционного уровня от GTT уровня соединения.
                            Используйте следующий запрос для определения типа таблицы:
                            <programlisting language="sql">
SELECT t.rdb$type_name
FROM rdb$relations r
JOIN rdb$types t ON r.rdb$relation_type = t.rdb$type
WHERE t.rdb$field_name = 'RDB$RELATION_TYPE'
  AND r.rdb$relation_name = 'TABLENAME'                     
                                </programlisting>
                        </para>
                        <para>Для просмотра информации о типах всех таблиц используйте запрос:
                            <programlisting language="sql">
SELECT r.rdb$relation_name, t.rdb$type_name
FROM rdb$relations r
JOIN rdb$types t ON r.rdb$relation_type = t.rdb$type
WHERE t.rdb$field_name = 'RDB$RELATION_TYPE'
  AND coalesce (r.rdb$system_flag, 0) = 0                  
                                </programlisting>
                        </para>
                        <para>Поле RDB$TYPE_NAME будет отображать PERSISTENT для обычной таблицы,
                            VIEW для представления, GLOBAL_TEMPORARY_PRESERVE для GTT уровня
                            соединения, и GLOBAL_TEMPORARY_DELETE для GTT уровня транзакции.</para>
                    </tip>
                </section>
                <section xml:id="ddl-table-create-gtt-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Создание глобальной временной таблицы уровня соединения</title>
                        <para><programlisting language="sql">
CREATE GLOBAL TEMPORARY TABLE MYCONNGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP);
ON COMMIT PRESERVE ROWS;                   
                </programlisting></para>
                    </example>
                    <example>
                        <title>Создание глобальной временной таблицы уровня транзакции ссылающейся
                            внешним ключом на глобальную временную таблицу уровня
                            соединения.</title>
                        <para><programlisting language="sql">
CREATE GLOBAL TEMPORARY TABLE MYTXGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    PARENT_ID INTEGER NOT NULL REFERENCES MYCONNGTT(ID),
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP);                  
                </programlisting></para>
                    </example>
                </section>
            </section>

            <section xml:id="ddl-table-create-external">
                <title>Внешние таблицы</title>

                <indexterm>
                    <primary>CREATE TABLE</primary>
                    <secondary>EXTERNAL</secondary>
                </indexterm>
                <para>Необязательное предложение EXTERNAL [FILE] указывает, что таблица хранится вне
                    базы данных во внешнем текстовом файле. Столбцы таблицы, хранящейся во внешнем
                    файле, могут быть любого типа за исключением BLOB и массивов с любым типом
                    данных. </para>
                <para>Над таблицей, хранящейся во внешнем файле, допустимы только операции
                    добавления новых строк (INSERT) и выборки (SELECT) данных. Операции же изменения
                    существующих данных (UPDATE) или удаления строк такой таблицы (DELETE) не могут
                    быть выполнены. </para>
                <para>Внешняя таблица не может содержать ограничений первичного, внешнего и
                    уникального ключа. Для полей такой таблицы невозможно создать индексы. </para>
                <para>Файл с внешней таблицей должен располагаться на устройстве хранения, физически
                    расположенном на сервере, на котором расположена СУБД. Если параметр
                        <parameter>ExternalFileAccess</parameter> в файле конфигурации
                        <filename>firebird.conf</filename> содержит <function>Restrict</function>,
                    то файл внешней таблицы должен находится в одном из каталогов, указанных в
                    качестве аргумента <function>Restrict</function>. Если при обращении к таблице
                    Firebird не находит файла, то он создаёт его при первом обращении. </para>
                <important>
                    <para>Возможность использования для таблиц внешних файлов зависит от установки
                        значения параметра <parameter>ExternalFileAccess</parameter> в файле
                        конфигурации <filename>firebird.conf</filename>: <itemizedlist>
                            <listitem>
                                <para>Если он установлен в значение <function>None</function>, то
                                    запрещён любой доступ к внешнему файлу.</para>
                            </listitem>
                            <listitem>
                                <para>Значение <function>Restrict</function> рекомендуется для
                                    ограничения доступа к внешним файлам только каталогами,
                                    созданными специально для этой цели администратором сервера.
                                    Например: <itemizedlist spacing="compact">
                                        <listitem>
                                            <para><function>ExternalFileAccess = Restrict
                                                  externalfiles</function> ограничит доступ
                                                директорией <filename>externalfiles</filename>
                                                корневого каталога Firebird. </para>
                                        </listitem>
                                        <listitem>
                                            <para><function>ExternalFileAccess =
                                                  d:\databases\outfiles; e:\infiles</function>
                                                ограничит доступ только двумя директориями Windows.
                                                Обратите внимание, что любые пути являющиеся
                                                отображением сетевых путей не будут работать. Также
                                                не будут работать пути заключённые в одинарные или
                                                двойные кавычки.</para>
                                        </listitem>
                                    </itemizedlist></para>
                            </listitem>
                            <listitem>
                                <para>Значение <function>Full</function> позволяет доступ к внешним
                                    файлам в любом месте файловой системы хоста. Это создаёт
                                    уязвимость и не рекомендуется к использованию.</para>
                            </listitem>
                        </itemizedlist></para>
                </important>

                <section xml:id="ddl-table-ext-format">
                    <title>Формат внешних файлов</title>

                    <para>Внешняя таблица имеет формат <quote>строк</quote> c фиксированной длинной.
                        Нет никаких разделителей полей: границы полей и строк определяются
                        максимальными размерами в байтах в определении каждого поля. Это необходимо
                        помнить и при определении структуры внешней таблицы, и при проектировании
                        входного файла для внешней таблицы, в которую должны импортироваться данные
                        из другого приложения. Например, широко распространённый формат
                            <quote>.csv</quote>, не может быть использован в качестве входного
                        файла, и не может быть получен непосредственно как внешний файл.</para>

                    <para>Самым полезным типом данных для столбцов внешних таблиц является тип CHAR
                        с фиксированной длинной, длинна должна подходить под данные с которыми
                        необходимо работать. Числовые типы и даты легко преобразуются в них, строки
                        получаются как есть, в то время как, если данные не читаются другой базой
                        данных Firebird, то родные типы могут быть нераспознаваемыми дня внешних
                        приложений и являться для них <quote>абракадаброй</quote>.</para>
                    <para>Конечно, существуют способы манипулирования типами данных так, чтобы
                        создавать выходные файлы из Firebird, которые могут быть непосредственно
                        прочитаны как входные файлы в других приложениях, используя хранимые
                        процедуры с использованием внешних таблиц или без них. Описания этих методов
                        выходит за рамки данного руководства. Здесь мы приведём лишь некоторые
                        рекомендации и советы для создания и работы с простыми текстовыми файлами,
                        поскольку внешняя таблица часто используется как простой способ для создания
                        или чтения транзакционно-независимого журнала. Эти файлы могут быть
                        прочитаны в оффлайн режиме текстовым редактором или приложением
                        аудита.</para>

                    <section xml:id="ddl-table-ext-format-delimiter">
                        <title>Разделитель строк</title>

                        <para>Как правило, внешние файлы более удобны если строки разделены
                            разделителем, в виде последовательности "новой строки", которая может
                            быть распознана приложением на предназначенной платформе. Для Windows —
                            это двухбайтная 'CRLF' последовательность, возврат каретки (ASCII код
                            13) и перевод строки (ASCII код 10). Для POSIX — LF обычно
                            самодостаточен, в некоторых MacOS X приложениях она может быть LFCR.
                            Существуют различные способы для автоматического заполнения столбца
                            разделителя. В нашем примере это сделано с помощью BEFORE INSERT
                            триггера и встроенной функции ASCII_CHAR.</para>
                    </section>
                </section>

                <section xml:id="ddl-table-create-external-examples">
                    <title>Примеры использования внешних таблиц</title>

                    <para>В нашем примере мы будем определять внешнюю таблицу журнала, которая может
                        быть использована в обработчике исключений внутри хранимой процедуры или
                        триггера. Внешняя таблица выбрана потому, что сообщения из любых
                        обрабатываемых исключений будут сохранены в журнале, даже если транзакция, в
                        которой был запущен процесс, будет откачена из-за другого необработанного
                        исключения. В целях демонстрации наша таблица содержит всего два столбца:
                        метку времени и текстовое сообщение. Третий столбец хранит разделитель
                        строки:
                        <programlisting language="sql">
CREATE TABLE ext_log
EXTERNAL FILE 'd:\externals\log_me.txt' (
   stamp   CHAR(24), 
   message CHAR(100),
   crlf    CHAR(2) -- Для Windows
);   

COMMIT;                
                </programlisting>
                    </para>
                    <para>Теперь создадим триггер, для автоматического сохранения метки времени и
                        разделителя строки, каждый раз когда сообщение записывается в таблицу:
                        <programlisting language="sql">
SET TERM ^;
CREATE TRIGGER bi_ext_log FOR ext_log
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (NEW.stamp IS NULL) THEN
    NEW.stamp = CAST (CURRENT_TIMESTAMP AS CHAR(24));
  NEW.crlf = ASCII_CHAR(13) || ASCII_CHAR(10);
END ^
COMMIT ^
SET TERM ;^               
                </programlisting>
                    </para>
                    <para>Вставка некоторых записей (это может быть сделано в обработчике
                        исключения):
                        <programlisting language="sql">
INSERT INTO ext_log (message)
VALUES('Shall I compare thee to a summer''s day?');
INSERT INTO ext_log (message)
VALUES('Thou art more lovely and more temperate');              
                </programlisting>
                    </para>
                    <para>Содержимое внешнего файла:
                        <screen>
2015-10-07 15:19:03.4110Shall I compare thee to a summer's day?
2015-10-07 15:19:58.7600Thou art more lovely and more temperate                        
                    </screen>
                    </para>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-table-alter">ALTER TABLE</link>, <link
                                linkend="ddl-table-alter">DROP TABLE</link>, <link
                                linkend="ddl-domain-create">CREATE DOMAIN</link>. </para>
                    </formalpara>
                </section>
            </section>
        </section>
        <section xml:id="ddl-table-alter">
            <info>
                <title>ALTER TABLE</title>
                <keywordset>
                    <keyword>ALTER TABLE</keyword>
                    <keyword>ALTER COLUMN</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>ALTER TABLE</primary>
            </indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение структуры таблицы.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
ALTER TABLE <replaceable>tablename</replaceable> 
  <replaceable>&lt;operation&gt;</replaceable> [, <replaceable>&lt;operation&gt;</replaceable>];       

<replaceable>&lt;operation&gt;</replaceable> ::=      
    ADD <replaceable>&lt;col_def&gt;</replaceable> 
  | ADD <replaceable>&lt;tconstraint&gt;</replaceable> 
  | DROP <replaceable>colname</replaceable>   
  | DROP CONSTRAINT <replaceable>constr_name</replaceable>   
  | DROP SQL SECURITY
  | ALTER [COLUMN] <replaceable>colname</replaceable> <replaceable>&lt;col_mod&gt;</replaceable>
  | ALTER SQL SECURITY {DEFINER | INVOKER}
                        
<replaceable>&lt;col_def&gt;</replaceable> ::= 
    <replaceable>&lt;regular_col_def&gt;</replaceable> 
  | <replaceable>&lt;computed_col_def&gt;</replaceable> 
  | <replaceable>&lt;identity_col_def&gt;</replaceable>                        

<replaceable>&lt;regular_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> { <replaceable>&lt;datatype&gt;</replaceable> | <replaceable>domainname</replaceable> }
  [DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>}]
  [NOT NULL]
  [<replaceable>&lt;col_constraint&gt;</replaceable>]
  [COLLATE <replaceable>collation_name</replaceable>]   


<replaceable>&lt;computed_col_def&gt;</replaceable>  ::=   
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] 
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<replaceable>&lt;expression&gt;</replaceable>)
                        
<replaceable>&lt;identity_col_def&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> [<replaceable>&lt;datatype&gt;</replaceable>] {ALWAYS | GENERATED BY} DEFAULT AS IDENTITY 
  [(START WITH <replaceable>startvalue</replaceable>)] [<replaceable>&lt;col_constraint&gt;</replaceable>]                          

<replaceable>&lt;col_mod&gt;</replaceable> ::= 
     TO <replaceable>newname</replaceable> 
  |  POSITION <replaceable>newpos</replaceable>   
  | <replaceable>&lt;regular_col_mod&gt;</replaceable> 
  | <replaceable>&lt;computed_col_mod&gt;</replaceable> 
  | <replaceable>&lt;identity_col_mod&gt;</replaceable> 

<replaceable>&lt;regular_col_mod&gt;</replaceable> ::=                      
  |  TYPE { <replaceable>&lt;datatype&gt;</replaceable>  | <replaceable>domainname</replaceable> }  
  |  SET DEFAULT {<replaceable>literal</replaceable> | NULL | <replaceable>&lt;context_var&gt;</replaceable>} 
  |  DROP DEFAULT 
  |  SET NOT NULL
  |  DROP NOT NULL  

<replaceable>&lt;computed_col_mod&gt;</replaceable> ::=
  [TYPE <replaceable>&lt;datatype&gt;</replaceable>] {GENERATED ALWAYS AS | COMPUTED [BY]} (<replaceable>&lt;expression&gt;</replaceable>)  

<replaceable>&lt;identity_col_mod&gt;</replaceable> ::=  
     <replaceable>&lt;alter identity column option&gt;</replaceable> ...
  |  SET GENERATED { ALWAYS | BY DEFAULT } [<replaceable>&lt;alter identity column option&gt;</replaceable> ...]
  |  DROP INDENITY
          
<replaceable>&lt;alter identity column option&gt;</replaceable> ::=
     RESTART [ WITH <replaceable>startvalue</replaceable> ]  
  |  SET INCREMENT [BY] <replaceable>incrementvalue</replaceable>                          

<replaceable>&lt;datatype&gt;</replaceable> ::= {
    {SMALLINT | INT[EGER] | BIGINT} [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | BOOLEAN [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {FLOAT | DOUBLE PRECISION} [<replaceable>&lt;array_dim&gt;</replaceable>]
  | {DATE | TIME | TIMESTAMP} [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)] 
      [<replaceable>&lt;array_dim&gt;</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>] 
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
      [<replaceable>&lt;array_dim&gt;</replaceable>] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] [SEGMENT SIZE <replaceable>seglen</replaceable>] 
      [CHARACTER SET <replaceable>charset</replaceable>]   
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])] 
}
    
<replaceable>&lt;array_dim&gt;</replaceable> ::= <emphasis role="bold">[</emphasis>[<replaceable>m</replaceable>:]<replaceable>n</replaceable> [,[<replaceable>m</replaceable>:]<replaceable>n</replaceable> ...]<emphasis role="bold">]</emphasis>        
                    
<replaceable>&lt;col_constraint&gt;</replaceable> ::= 
  [CONSTRAINT <replaceable>constr_name</replaceable>] 
  {   UNIQUE [<replaceable>&lt;using_index&gt;</replaceable>] 
    | PRIMARY KEY [<replaceable>&lt;using_index&gt;</replaceable>] 
    | REFERENCES other_table [(<replaceable>other_col</replaceable>)] [<replaceable>&lt;using_index&gt;</replaceable>] 
        [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
    | CHECK (<replaceable>&lt;check_condition&gt;</replaceable>) 
  }          

<replaceable>&lt;tconstraint&gt;</replaceable> ::= 
  [CONSTRAINT <replaceable>constr_name</replaceable>] 
  {   UNIQUE (<replaceable>&lt;col_list&gt;</replaceable>) [<replaceable>&lt;using_index&gt;</replaceable>] 
    | PRIMARY KEY (<replaceable>&lt;col_list&gt;</replaceable>) [<replaceable>&lt;using_index&gt;</replaceable>] 
    | FOREIGN KEY (<replaceable>&lt;col_list&gt;</replaceable>) 
      REFERENCES <replaceable>other_table</replaceable> [(<replaceable>&lt;col_list&gt;</replaceable>)] [<replaceable>&lt;using_index&gt;</replaceable>] 
        [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
        [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
    | CHECK (<replaceable>&lt;check_condition&gt;</replaceable>) 
  }    

<replaceable>&lt;col_list&gt;</replaceable> ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]   

<replaceable>&lt;using_index&gt;</replaceable> ::= USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>indexname</replaceable>   

<replaceable>&lt;check_condition&gt;</replaceable> ::= { 
    <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] BETWEEN <replaceable>&lt;val&gt;</replaceable> AND <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] IN (<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...] | <replaceable>&lt;select_list&gt;</replaceable>) 
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] NULL 
  | <replaceable>&lt;val&gt;</replaceable> IS [NOT] DISTINCT <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] CONTAINING <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] STARTING [WITH] <replaceable>&lt;val&gt;</replaceable> 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] LIKE <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>] 
  | <replaceable>&lt;val&gt;</replaceable> [NOT] SIMILAR TO <replaceable>&lt;val&gt;</replaceable> [ESCAPE <replaceable>&lt;val&gt;</replaceable>] 
  | <replaceable>&lt;val&gt;</replaceable> <replaceable>&lt;operator&gt;</replaceable> {ALL | SOME | ANY} (<replaceable>&lt;select_list&gt;</replaceable>) 
  | [NOT] EXISTS (<replaceable>&lt;select_expr&gt;</replaceable>) 
  | [NOT] SINGULAR (<replaceable>&lt;select_expr&gt;</replaceable>)   
  | (<replaceable>&lt;check_condition&gt;</replaceable>)   
  | NOT <replaceable>&lt;check_condition&gt;</replaceable>   
  | <replaceable>&lt;check_condition&gt;</replaceable> OR <replaceable>&lt;check_condition&gt;</replaceable>   
  | <replaceable>&lt;check_condition&gt;</replaceable> AND <replaceable>&lt;check_condition&gt;</replaceable> 
}    
 
<replaceable>&lt;operator&gt;</replaceable> ::= 
  &lt;&gt; | != | ^=  | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^> | ~>     
                    
<replaceable>&lt;val&gt;</replaceable> ::=  
    <replaceable>colname</replaceable> [<emphasis role="bold">[</emphasis><replaceable>&lt;array_idx&gt;</replaceable> [, <replaceable>&lt;array_idx&gt;</replaceable> ...]<emphasis role="bold">]</emphasis>] 
  | <replaceable>literal</replaceable>   
  | <replaceable>&lt;context_var&gt;</replaceable>   
  | <replaceable>&lt;expression&gt;</replaceable>   
  | NULL   
  | NEXT VALUE FOR <replaceable>genname</replaceable>   
  | GEN_ID(<replaceable>genname</replaceable>, <replaceable>&lt;val&gt;</replaceable>)   
  | CAST(<replaceable>&lt;val&gt;</replaceable> AS <replaceable>&lt;datatype&gt;</replaceable>)   
  | (<replaceable>&lt;select_one&gt;</replaceable>)   
  | <replaceable>func</replaceable>(<replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...])   
                       
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER TABLE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>tablename</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>operation</replaceable></entry>
                                <entry>
                                    <para>Одна из допустимых операций по изменению структуры
                                        таблицы.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>colname</replaceable></entry>
                                <entry>
                                    <para>Имя столбца таблицы, может содержать до 63 символов.
                                        Должно быть уникальным внутри таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>newname</replaceable></entry>
                                <entry>
                                    <para>Новое имя столбца таблицы, может содержать до 63 символов.
                                        Должно быть уникальным внутри таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>gencolname</replaceable></entry>
                                <entry>
                                    <para>Имя вычисляемого столбца таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>idencolname</replaceable></entry>
                                <entry>
                                    <para>Имя столбца идентификации. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>newpos</replaceable></entry>
                                <entry>
                                    <para>Новая позиция столбца в таблице. Целое число в диапазоне
                                        от 1 до количества столбцов таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>datatype</replaceable></entry>
                                <entry>
                                    <para>Тип данных SQL. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>domain_name</replaceable></entry>
                                <entry>
                                    <para>Имя домена. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>startvalue</replaceable></entry>
                                <entry>
                                    <para>Начальное значение столбца идентификации. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <replaceable>incrementvalue</replaceable>
                                </entry>
                                <entry> Значение приращения для столбца идентификации. Должно быть
                                    отлично от 0. </entry>
                            </row>
                            <row>
                                <entry><replaceable>col_constraint</replaceable></entry>
                                <entry>
                                    <para>Ограничение столбца. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>tconstraint</replaceable></entry>
                                <entry>
                                    <para>Ограничение таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>constr_name</replaceable></entry>
                                <entry>
                                    <para>Имя ограничения, может содержать до 63 символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>other_table</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы, на которую ссылается внешний ключ.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>other_col</replaceable></entry>
                                <entry>
                                    <para>Столбец таблицы, на которую ссылается внешний ключ.
                                    </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>literal</replaceable></entry>
                                <entry>
                                    <para>Литерал. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>context_var</replaceable></entry>
                                <entry>
                                    <para>Любая контекстная переменная, тип которой совместим с
                                        типом данных  столбца. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>check_condition</replaceable></entry>
                                <entry>
                                    <para>Условие проверки ограничения. Выполняется, если
                                        оценивается как TRUE или NULL/UNKNOWN.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation_name</replaceable></entry>
                                <entry>
                                    <para>Имя порядка сортировки. Необходимо указывать если вы
                                        хотите чтобы порядок сортировки для столбца отличался от
                                        порядка сортировки для набора символов по умолчанию этого
                                        столбца. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>array_dim</replaceable></entry>
                                <entry>
                                    <para>Размерность массива. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>n</replaceable></entry>
                                <entry>
                                    <para>Начальный номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>m</replaceable></entry>
                                <entry>
                                    <para>Последний номер элемента в массиве, положительное целое
                                        число. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. От 1 до 18. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>scale</replaceable></entry>
                                <entry>
                                    <para>Масштаб. От 0 до 18, должно быть меньше или равно
                                            <replaceable>precision</replaceable>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>size</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер строки в символах. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset_name</replaceable></entry>
                                <entry>
                                    <para>Имя набора символов. Необходимо указывать, если вы хотите
                                        чтобы набор символов столбца отличался от набора символов по
                                        умолчанию для базы данных. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_num</replaceable></entry>
                                <entry>
                                    <para>Номер подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_name</replaceable></entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>seglen</replaceable></entry>
                                <entry>
                                    <para>Размер сегмента, не может превышать 65535. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_one</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        только одну строку. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_list</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий один столбец и возвращающий
                                        ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_expr</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT выбирающий несколько столбцов и
                                        возвращающий ноль и более строк.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>experssion</replaceable></entry>
                                <entry>
                                    <para>Выражение. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>genname</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора). </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>func</replaceable></entry>
                                <entry>
                                    <para>Скалярная функция. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>ALTER TABLE</database> изменяет структуру существующей таблицы.
                Одиночный оператор <database>ALTER TABLE</database> позволяет производить множество
                операций добавления/удаления столбцов и ограничений, а также модификаций столбцов.
                Список операций выполняемых при модификации таблицы разделяется запятой. </para>
            <section xml:id="ddl-table-alter-versinc">
                <title>Счётчик форматов</title>
                <para>Некоторые изменения структуры таблицы увеличивают счётчик форматов,
                    закреплённый за каждой таблицей. Количество форматов для каждой таблицы
                    ограничено значением 255. После того, как счётчик форматов достигнет этого
                    значения, вы не сможете больше менять структуру таблицы. </para>
                <para>Для сброса счётчика форматов необходимо сделать резервное копирование и
                    восстановление базы данных (утилитой <application>gbak</application>). </para>
            </section>
            <section xml:id="ddl-table-alter-add">
                <title>Предложение ADD</title>
                <indexterm>
                    <primary>ALTER TABLE</primary>
                    <secondary>ADD</secondary>
                </indexterm>
                <indexterm>
                    <primary>ALTER TABLE</primary>
                    <secondary>ADD CONSTRAINT</secondary>
                </indexterm>
                <para>Предложение <database>ADD</database> позволяет добавить новый столбец или
                    новое ограничение таблицы. Синтаксис определения столбца и синтаксис описания
                    ограничения таблицы полностью совпадают с синтаксисом, описанным в операторе
                        <link linkend="ddl-table-create">CREATE TABLE</link>. </para>
                <formalpara>
                    <title>Воздействие на счётчик форматов:</title>
                    <para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>При каждом добавлении нового столбца номер формата
                                    увеличивается на единицу. </para>
                            </listitem>
                            <listitem>
                                <para>Добавление нового ограничения таблицы не влечёт за собой
                                    увеличение номера формата.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </formalpara>
                <note>
                    <para>При добавлении нового столбца, не допускающего значения NULL, в таблицу с
                        данными необходимо также установить значение по умолчанию с помощью
                        предложения <database>DEFAULT</database>. Дело в том, что в этом случае
                        также происходит проверка данных на допустимость. А поскольку при добавлении
                        нового столбца, он для всех строк таблицы содержит значение NULL, будет
                        сгенерировано исключение. </para>
                </note>
                <warning>
                    <para>Будьте осторожны, при добавлении нового ограничения
                            <database>CHECK</database> не осуществляется проверка соответствия ему
                        ранее внесённых данных. Поэтому перед добавлением такого ограничения
                        рекомендуем производить предварительную проверку данных в таблице. </para>
                </warning>
            </section>

            <section xml:id="ddl-table-alter-drop">
                <title>Предложение DROP</title>
                <indexterm>
                    <primary>ALTER TABLE</primary>
                    <secondary>DROP</secondary>
                </indexterm>
                <para>Предложение <database>DROP</database> удаляет указанный столбец таблицы.
                    Столбец таблицы не может быть удалён, если от него существуют зависимости.
                    Другими словами для успешного удаления столбца на него должны отсутствовать
                    ссылки. Ссылки на столбец могут содержаться: <itemizedlist spacing="compact">
                        <listitem>
                            <para>в ограничениях столбцов или таблицы;</para>
                        </listitem>
                        <listitem>
                            <para>в индексах;</para>
                        </listitem>
                        <listitem>
                            <para>в хранимых процедурах и триггерах;</para>
                        </listitem>
                        <listitem>
                            <para>в представлениях.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>При каждом удалении столбца номер формата увеличивается на единицу. </para>
            </section>

            <section xml:id="ddl-table-alter-drop-constraint">
                <title>Предложение DROP CONSTRAINT</title>
                <indexterm>
                    <primary>ALTER TABLE</primary>
                    <secondary>DROP CONSTRAINT</secondary>
                </indexterm>
                <para>Предложение <database>DROP CONSTRAINT</database> удаляет указанное ограничение
                    столбца или таблицы. Ограничение первичного ключа или уникального ключа не могут
                    быть удалены, если они используются в ограничении внешнего ключа другой таблицы.
                    В этом случае, необходимо удалить ограничение <database>FOREIGN KEY</database>
                    до удаления <database>PRIMARY KEY</database> или <database>UNIQUE</database>
                    ключа, на которые оно ссылается. </para>
                <para>Удаление ограничения столбца или ограничения таблицы не влечёт за собой
                    увеличение номера формата. </para>
            </section>

            <section xml:id="ddl-table-alter-drop-sql_security">
                <title>Предложение DROP SQL SECURITY</title>
                <indexterm>
                    <primary>ALTER TABLE</primary>
                    <secondary>DROP SQL SECURITY</secondary>
                </indexterm>
                <para>Предложение <database>DROP SQL SECURITY</database> удаляет контекст
                    безопасности для таблицы. После удаления контекста безопасности вычисляемые
                    столбцы таблицы будут вычисляться с привилегиями вызывающего пользователя.
                    Триггеры также будут выполняться с привилегиями вызывающего пользователя. если
                    их контекст безопасности не переопределён в триггере явно.</para>
            </section>

            <section xml:id="ddl-table-alter-alter-column">
                <title>Предложение ALTER [COLUMN]</title>
                <indexterm>
                    <primary>ALTER TABLE</primary>
                    <secondary>ALTER [COLUMN]</secondary>
                </indexterm>
                <para>Предложение ALTER [COLUMN] позволяет изменить следующие характеристики
                    существующих столбцов: <itemizedlist spacing="compact">
                        <listitem>
                            <para>изменение имени (не изменяет номер формата);</para>
                        </listitem>
                        <listitem>
                            <para>изменение типа данных (увеличивает номер формата на
                                единицу);</para>
                        </listitem>
                        <listitem>
                            <para>изменение позиции столбца в списке столбцов таблицы (не изменяет
                                номер формата);</para>
                        </listitem>
                        <listitem>
                            <para>удаление значения по умолчанию столбца (не изменяет номер
                                формата);</para>
                        </listitem>
                        <listitem>
                            <para>добавление значения по умолчанию столбца (не изменяет номер
                                формата);</para>
                        </listitem>
                        <listitem>
                            <para>изменение типа и выражения для вычисляемого столбца (не изменяет
                                номер формата);</para>
                        </listitem>
                        <listitem>
                            <para>добавление ограничения NOT NULL (не изменяет номера
                                формата);</para>
                        </listitem>
                        <listitem>
                            <para>удаление ограничения NOT NULL (не изменяет номера формата).</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <section xml:id="ddl-table-alter-alter-column-to">
                    <title>Переименование столбца</title>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>TO</tertiary>
                    </indexterm>
                    <para>Ключевое слово TO переименовывает существующий столбец. Новое имя столбца
                        не должно присутствовать в таблице. </para>
                    <para>Невозможно изменение имени столбца, если этот столбец включён в какое-либо
                        ограничение — первичный или уникальный ключ, внешний ключ, ограничение
                        столбца или проверочное ограничение таблицы CHECK. Имя столбца также нельзя
                        изменить, если этот столбец таблицы используется в каком-либо триггере, в
                        хранимой процедуре или представлении. </para>
                </section>
                <section xml:id="ddl-table-alter-alter-column-type">
                    <title>Изменение типа столбца</title>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>TYPE</tertiary>
                    </indexterm>
                    <para>Ключевое слово <database>TYPE</database> изменяет тип существующего
                        столбца на другой допустимый тип. Не допустимы любые изменения типа, которые
                        могут привести к потере данных. Например, количество символов в новом типе
                        для столбца не может быть меньше, чем было установлено ранее. </para>
                    <para>Если столбец был объявлен как массив, то изменить ни его тип, ни
                        размерность нельзя.</para>
                    <para>Нельзя изменить тип данных у столбца, который принимает участие в связке
                        внешний ключ / первичный (уникальный) ключ.</para>
                </section>
                <section xml:id="ddl-table-alter-alter-column-position">
                    <title>Изменение позиции столбца</title>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>POSITION</tertiary>
                    </indexterm>
                    <para>Ключевое слово <database>POSITION</database> изменяет позицию
                        существующего столбца. Позиции столбцов нумеруются с единицы.</para>
                    <para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>Если будет задан номер позиции меньше 1, то будет выдано
                                    соответствующее сообщение об ошибке.</para>
                            </listitem>
                            <listitem>
                                <para>Если будет задан номер позиции, превышающий количество
                                    столбцов в таблице, то изменения не будут выполнены, но ни
                                    ошибки, ни предупреждения не последуют.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </section>
                <section xml:id="ddl-table-alter-alter-column-default">
                    <title>Установка и удаление значения по умолчанию</title>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>DROP DEFAULT</tertiary>
                    </indexterm>
                    <para>Предложение <database>DROP DEFAULT</database> удаляет значение по
                        умолчанию для столбца таблицы. </para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para>Если столбец основан на домене со значением по умолчанию —
                                    доменное значение перекроет это удаление.</para>
                            </listitem>
                            <listitem>
                                <para>Если удаление значения по умолчанию производится над столбцом,
                                    у которого нет значения по умолчанию, или чьё значение по
                                    умолчанию основано на домене, то это приведёт к ошибке
                                    выполнения данного оператора.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>SET DEFAULT</tertiary>
                    </indexterm>
                    <para>Предложение <database>SET DEFAULT</database> устанавливает значение по
                        умолчанию для столбца таблицы. Если столбец уже имел значение по умолчанию,
                        то оно будет заменено новым. Значение по умолчанию для столбца всегда
                        перекрывает доменное значение по умолчанию.</para>
                </section>
                <section xml:id="ddl-table-alter-alter-column-nullable">
                    <title>Установка и удаление ограничения NOT NULL</title>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>SET NOT NULL</tertiary>
                    </indexterm>
                    <para>Предложение <database>SET NOT NULL</database> добавляет ограничение NOT
                        NULL для столбца таблицы. </para>
                    <note>
                        <para>Успешное добавление ограничения NOT NULL происходит, только после
                            полной проверки данных таблицы, для того чтобы убедится что столбец не
                            содержит значений NULL. </para>
                        <para>Явное ограничение NOT NULL на столбце, базирующегося на домене,
                            преобладает над установками домена. В этом случае изменение домена для
                            допустимости значения NULL, не распространяется на столбец таблицы.
                        </para>
                    </note>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>DROP NOT NULL</tertiary>
                    </indexterm>
                    <para>Предложение <database>DROP NOT NULL</database> удаляет ограничение NOT
                        NULL для столбца таблицы. Если столбец основан на домене с ограничением NOT
                        NULL, то ограничение домена перекроет это удаление.</para>
                </section>
                <section xml:id="ddl-table-alter-alter-column-identity">
                    <title>Изменение столбцов идентификации</title>
                    <para>Для столбцов идентификации позволено изменять способ генерации, начальное
                        значение и значение приращения. </para>
                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>SET GENERATED</tertiary>
                    </indexterm>
                    <para>Предложение SET GENERATED позволяет изменить способ генерации столбца
                        идентификации. Существует два способа генерации столбца идентификации:<itemizedlist>
                            <listitem>
                                <para>BY DEFAULT столбцы позволяют переписать сгенерированное
                                    системой значение в операторах INSERT, UPDATE OR INSERT, MERGE
                                    просто указав значение этого столбца в списке значений.</para>
                            </listitem>
                            <listitem>
                                <para>ALWAYS столбцы не позволяют переписать сгенерированное
                                    системой значение, при попытке переписать значение такого
                                    столбца идентификации будет выдана ошибка. Переписать значение
                                    этого столбца в операторе INSERT можно только при указании
                                    директивы <link linkend="dml-insert-overriding">OVERRIDING
                                        SYSTEM VALUE</link>.</para>
                            </listitem>
                        </itemizedlist></para>

                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>RESTART [WITH]</tertiary>
                    </indexterm>
                    <para>Если указано только предложение <database>RESTART</database>, то
                        происходит сброс значения генератора в ноль. Необязательное предложение WITH
                        позволяет указать для нового значения внутреннего генератора отличное от
                        нуля значение. </para>

                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>SET INCREMENT [BY]</tertiary>
                    </indexterm>
                    <para>Предложение SET INCREMENT [BY] позволяет изменить значение приращения
                        столбца идентификации. Значение приращения должно быть отлично от 0.</para>

                    <indexterm>
                        <primary>ALTER TABLE</primary>
                        <secondary>ALTER [COLUMN]</secondary>
                        <tertiary>DROP IDENTITY</tertiary>
                    </indexterm>
                    <para>Предложение DROP IDENTITY удаляет связанный со столбцом идентификации
                        системную последовательность и преобразует его в обычный столбец.</para>
                </section>
                <section xml:id="ddl-table-alter-alter-column-computed">
                    <title>Изменение вычисляемых столбцов</title>
                    <para>Для вычисляемых столбцов (<database>GENERATED ALWAYS AS</database> или
                            <database>COMPUTED BY</database>) позволяется изменить тип и выражение
                        вычисляемого столбца. Невозможно изменить обычный столбец на вычисляемый и
                        наоборот. </para>
                </section>
                <section xml:id="ddl-table-alter-alter-column-cannot">
                    <title>Не изменяемые атрибуты</title>
                    <para>На данный момент не существует возможности изменить сортировку по
                        умолчанию. </para>
                </section>
            </section>
            <section xml:id="ddl-table-alter-sql_security">
                <title>Предложение ALTER SQL SECURITY</title>
                <indexterm>
                    <primary>ALTER TABLE</primary>
                    <secondary>ALTER SQL SECURITY</secondary>
                </indexterm>
                <para>Предложение <database>ALTER SQL SECURITY</database> позволяет изменить
                    привилегии с которыми вычисляются вычисляемые столбцы. Если выбрана опция
                    INVOKER, то вычисляемые столбцы вычисляются с привилегиями вызывающего
                    пользователя. Если выбрана опция DEFINER, то вычисляемые столбцы вычисляются с
                    привилегиями определяющего пользователя (владельца). По умолчанию вычисляемые
                    столбцы вычисляются с привилегиями вызывающего пользователя. Кроме триггеры
                    наследуют контекст безопасности таблицы, если он не переопределён у самих
                    триггеров.</para>
            </section>
            <section xml:id="ddl-table-alter-who">
                <title>Кто может изменить таблицу?</title>

                <para>Выполнить оператор <database>ALTER TABLE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY TABLE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-table-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Добавление столбца в таблицу</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE COUNTRY
ADD CAPITAL VARCHAR(25);
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Добавление столбца с ограничением уникальности и удаление другого
                        столбца</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25) UNIQUE,
  DROP CURRENCY;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение привилегий с которыми будут вычисляться вычисляемые столбцы и
                        выполняться триггеры, если в них не переопределён контекст
                        безопасности</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE COUNTRY
ALTER SQL SECURITY DEFINER;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Добавление столбца с ограничением NOT NULL</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE OBJECTS
ADD QUANTITY INT DEFAULT 1 NOT NULL;
                </programlisting>
                    </para>
                </example>
                <note>
                    <para>Обратите внимание на предложение DEFAULT, которое обязательно при
                        добавлении ограничения NOT NULL, если в таблице есть данные.</para>
                </note>
                <example>
                    <title>Добавление проверочного ограничения и внешнего ключа</title>
                    <para>
                        <programlisting language="sql">
<![CDATA[                    
ALTER TABLE JOB
ADD CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY),
ADD FOREIGN KEY (JOB_COUNTRY) 
REFERENCES COUNTRY (COUNTRY);
]]>   
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Модификация сразу нескольких столбцов таблицы</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE STOCK
ALTER COLUMN MODEL SET DEFAULT 1,
ALTER COLUMN ITEMID TYPE BIGINT,
ALTER COLUMN ITEMID DROP NOT NULL,
ALTER COLUMN PROPID SET NOT NULL,
ALTER COLUMN MODELNAME TO NAME;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение способа генрации столбца идентификации</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE objects
ALTER ID SET GENERATED ALWAYS;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение текущего значения столбца идентификации</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE objects
ALTER ID RESTART WITH 100;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение приращения столбца идентификации</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE objects
ALTER ID SET INCREMENT BY 2;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение нескольких свойств столбца идентификации</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE objects
ALTER ID SET GENERATED ALWAYS RESTART SET INCREMENT BY 2;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Превращение столбца идентификации в обычный столбец</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE objects
ALTER ID DROP INDENTITY;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Изменение вычисляемых столбцов</title>
                    <para>
                        <programlisting language="sql">
ALTER TABLE SALARY_HISTORY
ALTER NEW_SALARY GENERATED ALWAYS 
AS (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100),
ALTER SALARY_CHANGE COMPUTED 
BY (OLD_SALARY * PERCENT_CHANGE / 100);
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-table-create">CREATE TABLE</link>, <link
                            linkend="ddl-table-recreate">RECREATE TABLE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-table-drop">
            <info>
                <title>DROP TABLE</title>
                <keywordset>
                    <keyword>DROP TABLE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP TABLE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление существующей таблицы.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>


                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting> 
DROP TABLE <replaceable>tablename</replaceable>;                 
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP TABLE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>tablename</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>DROP TABLE</database> удаляет существующую таблицу. Если
                таблица имеет зависимости, то удаление не будет произведено. При удалении таблицы
                будут также удалены все триггеры на её события и индексы, построенные для её
                полей.</para>

            <section xml:id="ddl-table-drop-who">
                <title>Кто может удалить таблицу?</title>

                <para>Выполнить оператор <database>DROP TABLE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY TABLE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>

            <section xml:id="ddl-table-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление таблицы</title>
                    <para><programlisting language="sql">
DROP TABLE COUNTRY;
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-table-create">CREATE TABLE</link>, <link
                            linkend="ddl-table-recreate">RECREATE TABLE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-table-recreate">
            <info>
                <title>RECREATE TABLE</title>
                <keywordset>
                    <keyword>RECREATE TABLE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>RECREATE TABLE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой таблицы или пересоздание существующей.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>   
RECREATE [GLOBAL TEMPORARY] TABLE <replaceable>tablename</replaceable>        
  [EXTERNAL [FILE] '<replaceable>&lt;filespec&gt;</replaceable>'] 
  (<replaceable>&lt;col_def&gt;</replaceable> [, <replaceable>&lt;col_def&gt;</replaceable> | <replaceable>&lt;tconstraint&gt;</replaceable> ...])         
  [ON COMMIT {DELETE | PRESERVE} ROWS]
  [SQL SECURITY {DEFINER | INVOKER}]    
                 </programlisting></para>
            </formalpara>
            <para>Полное описание определений столбцов и ограничений таблицы смотрите в разделе
                    <link linkend="ddl-table-create">CREATE TABLE</link>.</para>

            <para>Создаёт или пересоздаёт таблицу. Если таблица с таким именем уже существует, то
                оператор <database>RECREATE TABLE</database> попытается удалить её и создать новую.
                Оператор <database>RECREATE TABLE</database> не выполнится, если существующая
                таблица имеет зависимости.</para>

            <section xml:id="ddl-table-recreate-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание или пересоздание таблицы</title>
                    <para><programlisting language="sql">
RECREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-table-create">CREATE TABLE</link>, <link
                            linkend="ddl-table-drop">DROP TABLE</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-index">
        <info>
            <title>INDEX</title>
            <keywordset>
                <keyword>INDEX</keyword>
            </keywordset>
        </info>
        <para>Индекс (index) — объект базы данных, предназначенный для ускорения выборки данных из
            таблицы и/или для ускорения упорядочения результатов выборки данных из таблицы. Кроме
            того, индексы используются для обеспечения ограничений целостности — <database>PRIMARY
                KEY</database>, <database>FOREIGN KEY</database>,
            <database>UNIQUE</database>.</para>
        <para>В данном разделе описываются вопросы создания индексов, перевода их в
            активное/неактивное состояние, удаление индексов и сбор статистики (пересчёт
            селективности) для индексов.</para>
        <section xml:id="ddl-index-create">
            <info>
                <title>CREATE INDEX</title>
                <keywordset>
                    <keyword>CREATE INDEX</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE INDEX</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание индекса для таблицы.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting> 
CREATE [UNIQUE] [ASC[ENDING] | DESC[ENDING]] 
INDEX <replaceable>indexname</replaceable> ON <replaceable>tablename</replaceable> 
{(<replaceable>col</replaceable> [, <replaceable>col</replaceable> …]) | COMPUTED BY (<replaceable>&lt;expression&gt;</replaceable>)};                   
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE INDEX</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>indexname</replaceable></entry>
                                <entry>
                                    <para>Имя индекса. Может содержать до 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>tablename</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы, для которой строится индекс.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>col</replaceable></entry>
                                <entry>
                                    <para>Столбец таблицы. В качестве столбцов не могут быть
                                        использованы поля типа BLOB, ARRAY и вычисляемые
                                        поля.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>expression</replaceable></entry>
                                <entry>
                                    <para>Выражение, содержащее столбцы таблицы.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE INDEX</database> создаёт индекс для таблицы, который
                может быть использован для ускорения поиска, сортировки и/или группирования. Кроме
                того, индекс может быть использован при определении ограничений, таких как первичный
                ключ, внешний ключ или ограничениях уникальности. Индекс может быть построен на
                столбцах любого типа кроме <database class="datatype">BLOB</database> и массивов.
                Имя индекса должно быть уникальным среди всех имён индексов.</para>
            <note>
                <title>Индексы в ключах</title>
                <para>При добавлении ограничений первичного ключа, внешнего ключа или ограничения
                    уникальности будет неявно создан одноименный индекс. Так, например, при
                    выполнении следующего оператора будет неявно создан индекс PK_COUNTRY. </para>
                <para><programlisting language="sql">
ALTER TABLE COUNTRY 
ADD CONSTRAINT PK_COUNTRY PRIMARY KEY (ID);                    
                </programlisting></para>
            </note>
            <section xml:id="ddl-index-unique">
                <title>Уникальные индексы</title>
                <indexterm>
                    <primary>CREATE INDEX</primary>
                    <secondary>UNIQUE</secondary>
                </indexterm>
                <para>Если при создании индекса указано ключевое слово <database>UNIQUE</database>,
                    то индекс гарантирует уникальность значений ключей. Такой индекс называется
                    уникальным. Уникальный индекс не является ограничением уникальности. </para>
                <para>Уникальные индексы не могут содержать дубликаты значений ключей (или дубликаты
                    комбинаций значений ключей в случае составного, многоколоночного или
                    многосегментного индекса). Дубликаты значения NULL допускаются в соответствии со
                    стандартом SQL-99 (в том числе и в многосегментном индексе).</para>
            </section>
            <section xml:id="ddl-index-direction">
                <title>Направление индекса</title>
                <indexterm>
                    <primary>CREATE INDEX</primary>
                    <secondary>ASC[ENDING]</secondary>
                </indexterm>
                <indexterm>
                    <primary>CREATE INDEX</primary>
                    <secondary>DESC[ENDING]</secondary>
                </indexterm>
                <para>Все индексы в Firebird являются однонаправленными. Индекс может быть построен
                    в восходящем и нисходящем порядке. Ключевые слова ASC[ENDING] (сокращённо ASC) и
                    DESC[ENDING] используются для указания направленности индекса. По умолчанию
                    создаётся восходящий ASC[ENDING] индекс. Допускается одновременное определение
                    восходящего и низходящего индекса на одном и том же столбце или наборе
                    ключей.</para>
                <tip>
                    <para>Убывающий (DESC[ENDING]) индекс может быть полезен при поиске наивысших
                        значений (максимум, последнее и т.д.)</para>
                </tip>
            </section>
            <section xml:id="ddl-index-computed">
                <title>Вычисляемые индексы или индексы по выражению</title>
                <indexterm>
                    <primary>CREATE INDEX</primary>
                    <secondary>COMPUTED BY</secondary>
                </indexterm>
                <para>При создании индекса вместо одного или нескольких столбцов вы также можете
                    указать одно выражение, используя предложение COMPUTED BY. Такой индекс
                    называется вычисляемым или индексом по выражению. Вычисляемые индексы
                    используются в запросах, в которых условие в предложениях WHERE, ORDER BY или
                    GROUP BY в точности совпадает с выражением в определении индекса. Выражение в
                    вычисляемом индексе может использовать несколько столбцов таблицы. </para>
                <note>
                    <para>Не смотря на то, что можно создать вычисляемый индекс по вычисляемому
                        полю, использоваться такой индекс не будет.</para>
                </note>
            </section>
            <section xml:id="ddl-index-keylimits">
                <title>Ограничения на индексы</title>
                <para>Максимальная длина ключа индекса ограничена 1/4 размера страницы. </para>
                <section xml:id="ddl-index-keylimits-char">
                    <title>Ограничения на длину индексируемой строки</title>
                    <para>Максимальная длина индексируемой строки на 9 байтов меньше, чем
                        максимальная длина ключа. Максимальная длина индексируемой строки зависит от
                        размера страницы и набора символов. </para>
                    <para>
                        <table frame="all">
                            <title>Длина индексируемой строки и набор символов</title>
                            <tgroup cols="6">
                                <colspec colname="c1" colnum="1" colwidth="1.0*" align="center"/>
                                <colspec colname="c2" colnum="2" colwidth="1.0*" align="center"/>
                                <colspec colname="c3" colnum="3" colwidth="1.0*" align="center"/>
                                <colspec colname="c4" colnum="4" colwidth="1.0*" align="center"/>
                                <colspec colname="c5" colnum="5" colwidth="1.0*" align="center"/>
                                <colspec colname="c6" colnum="6" colwidth="1.0*" align="center"/>
                                <thead>
                                    <row>
                                        <entry morerows="1">Размер страницы</entry>
                                        <entry namest="c2" nameend="c6">Максимальная длина
                                            индексируемой строки для набора символов, байт/символ
                                        </entry>
                                    </row>
                                    <row>
                                        <entry>1</entry>
                                        <entry>2</entry>
                                        <entry>3</entry>
                                        <entry>4</entry>
                                        <entry>6</entry>
                                    </row>
                                </thead>
                                <tbody>
                                    <row>
                                        <entry> 4096 </entry>
                                        <entry> 1015 </entry>
                                        <entry> 507 </entry>
                                        <entry> 338 </entry>
                                        <entry> 253 </entry>
                                        <entry> 169 </entry>
                                    </row>
                                    <row>
                                        <entry> 8192 </entry>
                                        <entry> 2039 </entry>
                                        <entry> 1019 </entry>
                                        <entry> 679 </entry>
                                        <entry> 509 </entry>
                                        <entry> 339 </entry>
                                    </row>
                                    <row>
                                        <entry> 16384 </entry>
                                        <entry> 4087 </entry>
                                        <entry> 2043 </entry>
                                        <entry> 1362 </entry>
                                        <entry> 1021 </entry>
                                        <entry> 682 </entry>
                                    </row>
                                    <row>
                                        <entry> 32768 </entry>
                                        <entry> 9183 </entry>
                                        <entry> 4087 </entry>
                                        <entry> 2721 </entry>
                                        <entry> 2039 </entry>
                                        <entry> 1356 </entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </table>
                    </para>
                </section>
            </section>
            <section xml:id="ddl-index-limitpertable">
                <title>Максимальное количество индексов на таблицу</title>
                <para>Для каждой таблицы максимально возможное количество индексов ограничено и
                    зависит от размера страницы и количества столбцов в индексе. </para>
                <para>
                    <table frame="all">
                        <title>Число индексов и количество столбцов</title>
                        <tgroup cols="4">
                            <colspec colname="c1" colnum="1" colwidth="1.0*" align="center"/>
                            <colspec colname="c2" colnum="2" colwidth="1.0*" align="center"/>
                            <colspec colname="c3" colnum="3" colwidth="1.0*" align="center"/>
                            <colspec colname="c4" colnum="4" colwidth="1.0*" align="center"/>
                            <thead>
                                <row>
                                    <entry morerows="1"> Размер страницы </entry>
                                    <entry namest="c2" nameend="c4"> Число индексов в зависимости от
                                        количества столбцов в индексе </entry>
                                </row>
                                <row>
                                    <entry> 1 </entry>
                                    <entry> 2 </entry>
                                    <entry> 3 </entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry> 4096 </entry>
                                    <entry> 203 </entry>
                                    <entry> 145 </entry>
                                    <entry> 113 </entry>
                                </row>
                                <row>
                                    <entry> 8192 </entry>
                                    <entry> 408 </entry>
                                    <entry> 291 </entry>
                                    <entry> 227 </entry>
                                </row>
                                <row>
                                    <entry> 16384 </entry>
                                    <entry> 818 </entry>
                                    <entry> 584 </entry>
                                    <entry> 454 </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
            </section>
            <section xml:id="ddl-index-create-who">
                <title>Кто может создать индекс?</title>

                <para>Выполнить оператор <database>CREATE INDEX</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы, для которой создаётся индекс; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY TABLE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-index-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание индекса</title>
                    <para><programlisting language="sql">
CREATE INDEX IDX_UPDATER ON SALARY_HISTORY (UPDATER_ID);                    
                </programlisting></para>
                </example>
                <example>
                    <title>Создание индекса с сортировкой ключей по убыванию</title>
                    <para><programlisting language="sql">
CREATE DESCENDING INDEX IDX_CHANGE 
ON SALARY_HISTORY (CHANGE_DATE);                  
                </programlisting></para>
                </example>
                <example>
                    <title>Создание многосегментного индекса</title>
                    <para><programlisting language="sql">
CREATE INDEX IDX_SALESTAT ON SALES (ORDER_STATUS, PAID);                   
                </programlisting></para>
                </example>
                <example>
                    <title>Создание индекса, не допускающего дубликаты значений</title>
                    <para><programlisting language="sql">
CREATE UNIQUE INDEX UNQ_COUNTRY_NAME ON COUNTRY (NAME);                   
                </programlisting></para>
                </example>
                <example>
                    <title>Создание вычисляемого индекса</title>
                    <para><programlisting language="sql">
CREATE INDEX IDX_NAME_UPPER ON PERSONS 
COMPUTED BY (UPPER (NAME));                  
                </programlisting></para>
                    <para>Такой индекс может быть использован для регистронезависимого поиска. </para>
                    <para><programlisting language="sql">
SELECT * 
FROM PERSONS 
WHERE UPPER(NAME) STARTING WITH UPPER('Iv');                
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-index-alter">ALTER INDEX</link>, <link
                            linkend="ddl-index-drop">DROP INDEX</link>. </para>

                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-index-alter">
            <info>
                <title>ALTER INDEX</title>
                <keywordset>
                    <keyword>ALTER INDEX</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER INDEX</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Перевод индекса в активное/неактивное состояние, перестройка индекса.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting> 
ALTER INDEX <replaceable>indexname</replaceable> {ACTIVE | INACTIVE};                 
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER INDEX</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>indexname</replaceable></entry>
                                <entry>
                                    <para>Имя индекса.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>ALTER INDEX</database> переводит индекс в активное/неактивное
                состояние. Возможность изменения структуры и порядка сортировки ключей этот оператор
                не предусматривает. </para>

            <para><itemizedlist>
                    <listitem>
                        <para>При выборе опции <database>INACTIVE</database>, индекс переводится из
                            активного в неактивное состояние. Перевод индекса в неактивное состояние
                            по своему действию похоже на команду <database>DROP INDEX</database> за
                            исключением того, что определение индекса сохраняется в базе данных.
                            Невозможно перевести в неактивное состояние индекс участвующий в
                            ограничении.</para>
                        <para>Активный индекс может быть отключен, только если отсутствуют запросы
                            использующие этот индекс, иначе будет возвращена ошибка <quote>object in
                                use</quote>.</para>
                        <para>Активация неактивного индекс также безопасна. Тем не менее, если есть
                            активные транзакции, модифицирующие таблицу, то транзакция, содержащая
                            оператор <database>ALTER INDEX</database> потерпит неудачу, если она
                            имеет атрибут NO WAIT. Если транзакция находится в режиме WAIT, то она
                            будет ждать завершения параллельных транзакций.</para>
                        <para>С другой стороны, если наш оператор <database>ALTER INDEX</database>
                            начинает перестраивать индекс на <database>COMMIT</database>, то другие
                            транзакции, изменяющие эту таблицу, потерпят неудачу или будут ожидать в
                            соответствии с их WAIT/NO WAIT атрибутами. Та же самая ситуация будет и
                            при выполнении <database>CREATE INDEX</database>.</para>
                        <tip>
                            <para>Перевод индекса в неактивное состояние может быть полезен при
                                массовой вставке, модификации или удалении записей из таблицы, для
                                которой этот индекс построен. </para>
                        </tip>
                    </listitem>
                    <listitem>
                        <para>При выборе альтернативы <database>ACTIVE</database> индекс переводится
                            из неактивного состояния в активное. При переводе индекса из неактивного
                            состояния в активное индекс перестраивается.</para>
                        <tip>
                            <para>Даже если индекс находится в активном состоянии оператор
                                    <database>ALTER INDEX ... ACTIVE</database> всё равно
                                перестраивает индекс. Таким образом, эту команду можно использовать
                                как часть обслуживания БД, для индексов большой таблицы в которую
                                происходят частые вставки, обновления и удаления. для перестройки
                                индексов, автоматически созданных для ограничений <database>PRIMARY
                                    KEY</database>, <database>FOREIGN KEY</database>,
                                    <database>UNIQUE</database>, для которых выполнение оператора
                                    <database>ALTER INDEX ... INACTIVE</database> невозможно.
                            </para>
                        </tip>
                    </listitem>
                </itemizedlist>
            </para>
            <section xml:id="ddl-index-alter-active-constr-use">
                <title>Использование ALTER INDEX для индексов ограничений</title>

                <para>Принудительный перевод индексов созданных для ограничений <database>PRIMARY
                        KEY</database>, <database>FOREIGN KEY</database> и
                        <database>UNIQUE</database> не допускается. Тем не менее, выполнение
                    оператора <database>ALTER INDEX ... INACTIVE</database> работает так же хорошо
                    для индексов ограничений как и другие инструменты для других индексов.</para>
            </section>
            <section xml:id="ddl-index-alter-who">
                <title>Кто может выполнить ALTER INDEX?</title>

                <para>Выполнить оператор <database>ALTER INDEX</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы, для которой построен индекс; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY TABLE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-index-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Перевод индекса в неактивное состояние</title>
                    <para>
                        <programlisting language="sql">
ALTER INDEX IDX_UPDATER INACTIVE;                   
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Возврат индекса в активное состояние</title>
                    <para>
                        <programlisting language="sql">
ALTER INDEX IDX_UPDATER ACTIVE;                 
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-index-create">CREATE INDEX</link>, <link
                            linkend="ddl-index-drop">DROP INDEX</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-index-drop">
            <info>
                <title>DROP INDEX</title>
                <keywordset>
                    <keyword>DROP INDEX</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>DROP INDEX</primary>
            </indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Удаление индекса из базы данных.</para>
            </formalpara>

            <formalpara>
                <info>
                    <title>Доступно в:</title>
                </info>
                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting> 
DROP INDEX <replaceable>indexname</replaceable>;                 
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP INDEX</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>indexname</replaceable></entry>
                                <entry>
                                    <para>Имя индекса.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>DROP INDEX</database> удаляет существующий индекс из базы
                данных. При наличии зависимостей для существующего индекса (если он используется в
                ограничении) удаление не будет выполнено.</para>
            <section xml:id="ddl-index-drop-who">
                <title>Кто может удалить индекс?</title>

                <para>Выполнить оператор <database>DROP INDEX</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы, для которой построен индекс; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY TABLE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-index-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление индекса</title>
                    <para>
                        <programlisting language="sql">
DROP INDEX IDX_UPDATER;                  
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-index-create">CREATE INDEX</link>, <link
                            linkend="ddl-index-alter">ALTER INDEX</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-index-stat">
            <info>
                <title>SET STATISTICS</title>
                <keywordset>
                    <keyword>SET STATISTICS</keyword>
                </keywordset>
            </info>
            <indexterm><primary>SET STATISTICS</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Пересчёт селективности индекса.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting> 
SET STATISTICS INDEX <replaceable>indexname</replaceable>;                 
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора SET STATISTICS</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>indexname</replaceable></entry>
                                <entry>
                                    <para>Имя индекса.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>SET STATISTICS</database> пересчитывает значение селективности
                для указанного индекса.</para>
            <section xml:id="ddl-index-selectivity">
                <title>Селективность индекса</title>
                <para>Селективность (избирательность) индекса — это оценочное количество строк,
                    которые могут быть выбраны при поиске по каждому значению индекса. Уникальный
                    индекс имеет максимальную селективность, поскольку при его использовании
                    невозможно выбрать более одной строки для каждого значения ключа индекса.
                    Актуальность селективности индекса важна для выбора наиболее оптимального плана
                    выполнения запросов оптимизатором.</para>
                <para>Пересчёт селективности индекса может потребоваться после массовой вставки,
                    модификации или удалении большого количества записей из таблицы, поскольку она
                    становится неактуальной.</para>
                <note>
                    <para>Отметим, что в Firebird статистика индексов автоматически не
                        пересчитывается ни после массовых изменений данных, ни при каких либо других
                        условиях. При создании (CREATE) или его активации (<database>ALTER INDEX
                            ACTIVE</database>) статистика индекса полностью соответствует его
                        содержимому. </para>
                </note>
                <para>Пересчёт селективности индекса может быть выполнен под высоко параллельной
                    нагрузкой без риска его повреждения. Тем не менее, следует помнить, что при
                    высоком параллелизме рассчитанная статистика может устареть, как только
                    закончится выполнение оператора <database>SET STATISTICS</database>.</para>
            </section>

            <section xml:id="ddl-index-stat-who">
                <title>Кто может обновить статистику?</title>

                <para>Выполнить оператор <database>SET STATISTICS</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы, для которой построен индекс; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY TABLE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>

            <section xml:id="ddl-index-stat-examples">
                <title>Примеры</title>
                <example>
                    <title>пересчёт селективности индекса</title>
                    <para><programlisting language="sql">
SET STATISTICS INDEX IDX_UPDATER;                  
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-index-create">CREATE INDEX</link>, <link
                            linkend="ddl-index-alter">ALTER INDEX</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-view">
        <info>
            <title>VIEW</title>
            <keywordset>
                <keyword>VIEW</keyword>
            </keywordset>
        </info>
        <para>Представление (view) — виртуальная таблица, которая по своей сути является именованным
            запросом SELECT выборки данных произвольной сложности. Выборка данных может
            осуществляться из одной и более таблиц, других представлений, а также селективных
            хранимых процедур. </para>
        <para>В отличие от обычных таблиц реляционных баз данных, представление не является
            самостоятельным набором данных, хранящимся в базе данных. Результат в виде набора данных
            динамически создаётся при обращении к представлению. </para>
        <para>Метаданные представлений доступны для генерации двоичного кода хранимых процедур,
            функций, пакетов и триггеров так, как будто они являются обычной таблицей, хранящей
            постоянные данные.</para>
        <section xml:id="ddl-view-create">
            <info>
                <title>CREATE VIEW</title>
                <keywordset>
                    <keyword>CREATE VIEW</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE VIEW</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового представления.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE VIEW <replaceable>viewname</replaceable> [<replaceable>&lt;full_column_list&gt;</replaceable>] 
AS <replaceable>&lt;select_statement&gt;</replaceable>
[WITH CHECK OPTION];

<replaceable>&lt;full_column_list&gt;</replaceable> ::= (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE VIEW</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>viewname</replaceable></entry>
                                <entry>
                                    <para>Имя представления. Может содержать до 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_statement</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>full_column_list</replaceable></entry>
                                <entry>
                                    <para>Список столбцов представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>colname</replaceable></entry>
                                <entry>
                                    <para>Имя столбца представления. Дубликаты имён столбцов не
                                        позволяются.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE VIEW</database> создаёт новое представление. Имя
                представления должно быть уникальным среди имён всех представлений, таблиц и
                хранимых процедур базы данных. </para>
            <para>После имени создаваемого представления может идти список имён столбцов, получаемых
                в результате обращения к представлению. Имена в списке могут быть никак не связаны с
                именами столбцов базовых таблиц. При этом их количество должно точно соответствовать
                количеству столбцов в списке выбора главного оператора SELECT представления. </para>
            <para>Если список столбцов представления отсутствует, то будут использоваться имена
                столбцов базовых таблиц или псевдонимов (алиасов) полей оператора SELECT. Если имена
                полей повторяются или присутствуют выражения столбцов без псевдонимов, которые
                делают невозможным получение допустимого списка столбцов, то создание представления
                завершается ошибкой.</para>
            <para>Количество столбцов в списке столбцов представления должно совпадать с количеством
                столбцов указанном в списке выбора оператора SELECT указанного в определении
                представления.</para>
            <note>
                <title>Дополнительные моменты:</title>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>Если указан полный список столбцов, то задание псевдонимов в
                                операторе SELECT не имеет смысла, поскольку они будут переопределены
                                именами из списка столбцов;</para>
                        </listitem>
                        <listitem>
                            <para>Список столбцов необязателен при условии, что все столбцы в
                                операторе SELECT имеют явное имя, и эти имена будут уникальными в
                                списке столбцов.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </note>

            <section xml:id="ddl-view-updatable">
                <title>Обновляемые представления</title>
                <para>Представление может быть обновляемым и только для чтения. Если представление
                    обновляемое, то данные, полученные при обращении к такому представлению, можно
                    изменить при помощи DML операторов INSERT, UPDATE, DELETE, UPDATE OR INSERT,
                    MERGE. Изменения, выполняемые над представлением, применяются к базовой
                    таблице(ам). </para>
                <para>Представление только для чтения можно сделать обновляемым при помощи
                    вспомогательных триггеров. После того как на представлении будет определён один
                    или несколько триггеров, то изменения не будут автоматически попадать в базовую
                    таблицу, даже если перед этим представление было обновляемым. В этом случае
                    ответственность за обновление (удаление или вставку) записей базовых таблиц,
                    лежит на программисте, определяющем триггеры.</para>
                <para>Для того чтобы представление было обновляемым, необходимо выполнение следующих
                    условий: <itemizedlist spacing="compact">
                        <listitem>
                            <para>оператор выборки SELECT обращается только к одной таблице или
                                одному изменяемому представлению;</para>
                        </listitem>
                        <listitem>
                            <para>оператор выборки SELECT не должен обращаться к хранимым
                                процедурам;</para>
                        </listitem>
                        <listitem>
                            <para>все столбцы базовой таблицы или обновляемого представления,
                                которые не присутствуют в данном представлении, должны удовлетворять
                                одному из следующих условий: <itemizedlist spacing="compact">
                                    <listitem>
                                        <para>позволять значение NULL</para>
                                    </listitem>
                                    <listitem>
                                        <para>NOT NULL столбцы должны иметь значение по
                                            умолчанию</para>
                                    </listitem>
                                    <listitem>
                                        <para>значение NOT NULL столбцов должны быть
                                            инициализированы в триггерах базовых таблиц</para>
                                    </listitem>
                                </itemizedlist></para>
                        </listitem>
                        <listitem>
                            <para>оператор выборки <database>SELECT</database> не содержит полей
                                определённых через подзапросы или другие выражения;</para>
                        </listitem>
                        <listitem>
                            <para>оператор выборки <database>SELECT</database> не содержит полей
                                определённых через агрегатные функции (MIN, MAX, AVG, COUNT, LIST),
                                статистические функции (CORR, COVAR_POP, COVAR_SAMP и др.), функции
                                линейной регрессии (REGR_AVGX, REGR_AVGY и др.) и все виды оконных
                                функций;</para>
                        </listitem>
                        <listitem>
                            <para>оператор выборки <database>SELECT</database> не содержит
                                предложений <database>ORDER BY</database>, <database>GROUP
                                    BY</database>, <database>HAVING</database>;</para>
                        </listitem>
                        <listitem>
                            <para>оператор выборки <database>SELECT</database> не содержит ключевого
                                слова DISTINCT и ограничений количества строк с помощью ROWS,
                                FIRST/SKIP, OFFSET/FETCH.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>

            <section xml:id="ddl-view-checkoptions">
                <title>WITH CHECK OPTIONS</title>
                <indexterm>
                    <primary>CREATE VIEW</primary>
                    <secondary>WITH CHECK OPTIONS</secondary>
                </indexterm>
                <para>Необязательное предложение <database>WITH CHECK OPTIONS</database> задаёт для
                    изменяемого представления требования проверки вновь введённых или модифицируемых
                    данных условию, указанному в предложении WHERE оператора выборки SELECT. При
                    попытке вставки новой записи или модификации записи проверяется, выполняется ли
                    для этой записи условие в предложении WHERE, если условие не выполняется, то
                    вставка/модификация не выполняется и будет выдано соответствующее
                    диагностическое сообщение. </para>
                <para>Предложение <database>WITH CHECK OPTION</database> может задаваться в
                    операторе создания представления только в том случае, если в главном операторе
                    SELECT представления указано предложение WHERE. Иначе будет выдано сообщение об
                    ошибке. </para>

                <note>
                    <para> Если используется предложение <database>WITH CHECK OPTIONS</database>, то
                        система проверяет входные значение на соответствие условию в предложении
                        WHERE до того как они будут переданы в базовую таблицу. Таким образом, если
                        входные значения не проходят проверку, то предложения DEFAULT или триггеры
                        на базовой таблице, не могут исправить входные значения, поскольку действия
                        никогда не будут выполнены. </para>
                    <para>Кроме того, поля представления не указанные в операторе INSERT передаются
                        в базовую таблицу как значения NULL, независимо от их наличия или отсутствия
                        в предложении WHERE. В результате значения по умолчанию, определённые на
                        таких полях базовой таблицы, не будут применены. С другой стороны, триггеры
                        будут вызываться и работать как ожидалось.</para>
                    <para>Для представлений у которых отсутствует предложение <database>WITH CHECK
                            OPTIONS</database>, поля, отсутствующие в операторе INSERT, не
                        передаются вовсе, поэтому любые значения по умолчанию будут
                        применены.</para>
                </note>
            </section>

            <section xml:id="ddl-view-create-sql_security">
                <title>Контекст безопасности</title>
                <para>Выполнение SQL кода представлений всегда осуществляется с привилегиями
                    определяющего пользователя (владельца).</para>
            </section>

            <section xml:id="ddl-view-create-who">
                <title>Кто может создать представление?</title>

                <para>Выполнить оператор <database>CREATE VIEW</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE VIEW</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший представление, становится его владельцем. </para>

                <para>Для создания представления пользователями, которые не имеют административных
                    привилегий, необходимы также привилегии на чтение (SELECT) данных из базовых
                    таблиц и представлений, и привилегии на выполнение (EXECUTE) используемых
                    селективных хранимых процедур.</para>

                <para>Для разрешения вставки, обновления и удаления через представление, необходимо
                    чтобы создатель (владелец) представления имел привилегии INSERT, UPDATE и DELETE
                    на базовые объекты метаданных.</para>

                <para>Предоставить привилегии на представление другим пользователям возможно только
                    если владелец представления сам имеет эти привилегии на базовых объектах. Она
                    будет всегда, если владелец представления является владельцем базовых объектов
                    метаданных.</para>
            </section>
            <section xml:id="ddl-view-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание представления</title>
                    <para><programlisting language="sql">
<![CDATA[                    
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY < 15000; 
]]> 
                </programlisting></para>
                </example>
                <example>
                    <title>Создание представления с проверкой условия фильтрации</title>
                    <para>Создание представления возвращающего столбцы JOB_CODE и JOB_TITLE только
                        для тех работ, где MAX_SALARY меньше $15000. При вставке новой записи или
                        изменении существующей будет осуществляться проверка условия MAX_SALARY &lt;
                        15000, если условие не выполняется, то вставка/изменение будет отвергнуто. <programlisting language="sql">
<![CDATA[                          
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY < 15000
WITH CHECK OPTIONS;  
]]> 
                </programlisting></para>
                </example>
                <example>
                    <title>Создание представления с использованием списка столбцов</title>
                    <para><programlisting language="sql">
CREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS 
SELECT 
  CODE_PRICE,
  COST,
  COST * 1.1
FROM PRICE;     
                </programlisting></para>
                </example>
                <example>
                    <title>Создание представления с использованием псевдонимов полей</title>
                    <para><programlisting language="sql">
CREATE VIEW PRICE_WITH_MARKUP AS 
SELECT 
  CODE_PRICE,
  COST,
  COST * 1.1 AS COST_WITH_MARKUP
FROM PRICE;      
                </programlisting></para>
                </example>
                <example>
                    <title>Создание необновляемого представления с использованием хранимой
                        процедуры</title>
                    <para><programlisting language="sql">
CREATE VIEW GOODS_PRICE AS
SELECT
    goods.name AS goodsname,
    price.cost AS cost,
    b.quantity AS quantity
FROM
    goods
    JOIN price ON goods.code_goods = price.code_goods
    LEFT JOIN sp_get_balance(goods.code_goods) b ON 1 = 1;      
                </programlisting></para>
                </example>
                <example>
                    <title>Создание обновляемого представления с использованием триггеров</title>
                    <para><programlisting language="sql">
-- базовые таблицы                    
RECREATE TABLE t_films(id INT PRIMARY KEY, title VARCHAR(100));
RECREATE TABLE t_sound(id INT PRIMARY KEY, audio BLOB);
RECREATE TABLE t_video(id INT PRIMARY KEY, video BLOB);
COMMIT;

-- создание необновляемого представления
RECREATE VIEW v_films AS
  SELECT f.id, f.title, s.audio, v.video
  FROM t_films f
  LEFT JOIN t_sound s ON f.id = s.id
  LEFT JOIN t_video v ON f.id = v.id;   

/* Для того чтобы сделать представление обновляемым создадим
   триггер, который будет производить манипуляции над базовыми 
   таблицами. 
*/
SET TERM ^;
CREATE OR ALTER TRIGGER v_films_biud FOR v_films
ACTIVE BEFORE INSERT OR UPDATE OR DELETE POSITION 0 AS
BEGIN
  IF (INSERTING) THEN 
    new.id = COALESCE(new.id, GEN_ID(g_films, 1));
  IF (NOT DELETING) THEN
  BEGIN
    UPDATE OR INSERT INTO t_films(id, title) 
    VALUES(new.id, new.title)
    MATCHING(id);
    
    UPDATE OR INSERT INTO t_sound(id, audio) 
    VALUES(new.id, new.audio)
    MATCHING(id);
    
    UPDATE OR INSERT INTO t_video(id, video) 
    VALUES(new.id, new.video)
    MATCHING(id);
 END
 ELSE
 BEGIN
   DELETE FROM t_films WHERE id = old.id;
   DELETE FROM t_sound WHERE id = old.id;
   DELETE FROM t_video WHERE id = old.id;
 END
END^
SET TERM ;^

/* 
 * Теперь мы можем производить манипуляции над
 * этим представлением как будто мы работаем с таблицей
 */   
INSERT INTO v_films(title, audio, video) 
VALUES('007 coordinates skyfall', 'pif-paf!', 'oh! waw!');
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-view-alter">ALTER VIEW</link>, <link
                            linkend="ddl-view-createoralter">CREATE OR ALTER VIEW</link>, <link
                            linkend="ddl-view-recreate">RECREATE VIEW</link>, <link
                            linkend="ddl-view-drop">DROP VIEW</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-view-alter">
            <info>
                <title>ALTER VIEW</title>
                <keywordset>
                    <keyword>ALTER VIEW</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER VIEW</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение существующего представления.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
ALTER VIEW <replaceable>viewname</replaceable> [<replaceable>&lt;full_column_list&gt;</replaceable>] 
AS <replaceable>&lt;select_statement&gt;</replaceable>
[WITH CHECK OPTION];

<replaceable>&lt;full_column_list&gt;</replaceable> ::= (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER VIEW</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>viewname</replaceable></entry>
                                <entry>
                                    <para>Имя существующего представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_statement</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>full_column_list</replaceable></entry>
                                <entry>
                                    <para>Список столбцов представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>colname</replaceable></entry>
                                <entry>
                                    <para>Имя столбца представления. Дубликаты имён столбцов не
                                        позволяются.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>ALTER VIEW</database> изменяет определение существующего
                представления, существующие права на представления и зависимости при этом
                сохраняются. Синтаксис оператора <database>ALTER VIEW</database> полностью
                аналогичен синтаксису оператора <database>CREATE VIEW</database>. </para>
            <warning>
                <para>Будьте осторожны при изменении количества столбцов представления. Существующий
                    код приложения может стать неработоспособным. Кроме того, PSQL модули,
                    использующие изменённое представление, могут стать некорректными. Информация о
                    том, как это обнаружить, находится в приложении <link linkend="valid">Поле
                        RDB$VALID_BLR</link>.</para>
            </warning>
            <section xml:id="ddl-view-alter-who">
                <title>Кто может изменить представление?</title>

                <para>Выполнить оператор <database>ALTER VIEW</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец представления; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY VIEW</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-view-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Изменение представления</title>
                    <para><programlisting language="sql">
ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS 
SELECT 
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-view-create">CREATE VIEW</link>, <link
                            linkend="ddl-view-createoralter">CREATE OR ALTER VIEW</link>, <link
                            linkend="ddl-view-recreate">RECREATE VIEW</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-view-createoralter">
            <info>
                <title>CREATE OR ALTER VIEW</title>
                <keywordset>
                    <keyword>CREATE OR ALTER VIEW</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE OR ALTER VIEW</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового или изменение существующего представления.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE OR ALTER VIEW <replaceable>viewname</replaceable> [<replaceable>&lt;full_column_list&gt;</replaceable>] 
AS <replaceable>&lt;select_statement&gt;</replaceable>
[WITH CHECK OPTION];

<replaceable>&lt;full_column_list&gt;</replaceable> ::= (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE OR ALTER VIEW</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>viewname</replaceable></entry>
                                <entry>
                                    <para>Имя представления. Может содержать до 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_statement</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>full_column_list</replaceable></entry>
                                <entry>
                                    <para>Список столбцов представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>colname</replaceable></entry>
                                <entry>
                                    <para>Имя столбца представления. Дубликаты имён столбцов не
                                        позволяются.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE OR ALTER VIEW</database> создаёт представление, если оно
                не существует. В противном случае он изменит представление с сохранением
                существующих зависимостей. </para>
            <section xml:id="ddl-view-createoralter-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание нового или изменение существующего представления </title>
                    <para><programlisting language="sql">
CREATE OR ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS 
SELECT 
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-view-create">CREATE VIEW</link>, <link
                            linkend="ddl-view-alter">ALTER VIEW</link>, <link
                            linkend="ddl-view-recreate">RECREATE VIEW</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-view-drop">
            <info>
                <title>DROP VIEW</title>
                <keywordset>
                    <keyword>DROP VIEW</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP VIEW</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление существующего представления.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
DROP VIEW <replaceable>viewname</replaceable>;
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP VIEW</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>viewname</replaceable></entry>
                                <entry>
                                    <para>Имя представления.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>DROP VIEW</database> удаляет существующее представление. Если
                представление имеет зависимости, то удаление не будет произведено. </para>
            <section xml:id="ddl-view-drop-who">
                <title>Кто может удалить представление?</title>

                <para>Выполнить оператор <database>DROP VIEW</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец представления; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY VIEW</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-view-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление представления</title>
                    <para><programlisting language="sql">
DROP VIEW PRICE_WITH_MARKUP;
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-view-create">CREATE VIEW</link>, <link
                            linkend="ddl-view-recreate">RECREATE VIEW</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-view-recreate">
            <info>
                <title>RECREATE VIEW</title>
                <keywordset>
                    <keyword>RECREATE VIEW</keyword>
                </keywordset>
            </info>
            <indexterm><primary>RECREATE VIEW</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового или пересоздание существующего представления.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
RECREATE VIEW <replaceable>viewname</replaceable> [<replaceable>&lt;full_column_list&gt;</replaceable>] 
AS <replaceable>&lt;select_statement&gt;</replaceable>
[WITH CHECK OPTION];

<replaceable>&lt;full_column_list&gt;</replaceable> ::= (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора RECREATE VIEW</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>viewname</replaceable></entry>
                                <entry>
                                    <para>Имя представления. Может содержать до 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_statement</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>full_column_list</replaceable></entry>
                                <entry>
                                    <para>Список столбцов представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>colname</replaceable></entry>
                                <entry>
                                    <para>Имя столбца представления. Дубликаты имён столбцов не
                                        позволяются.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Создаёт или пересоздаёт представление. Если представление с таким именем уже
                существует, то оператор <database>RECREATE VIEW</database> попытается удалить его и
                создать новое. Оператор <database>RECREATE VIEW</database> не выполнится, если
                существующее представление имеет зависимости. </para>

            <section xml:id="ddl-view-recreate-examples">
                <title>Примеры:</title>
                <example>
                    <title>Создание нового или пересоздание существующего представления</title>
                    <para><programlisting language="sql">
RECREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS 
SELECT 
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-view-create">CREATE VIEW</link>, <link
                            linkend="ddl-view-createoralter">CREATE OR VIEW</link>, <link
                            linkend="ddl-view-drop">DROP VIEW</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-trigger">
        <info>
            <title>TRIGGER</title>
            <keywordset>
                <keyword>TRIGGER</keyword>
            </keywordset>
        </info>
        <para>Триггер (trigger) — это хранимая процедура особого типа, которая не вызывается
            непосредственно, а исполнение которой обусловлено наступлением одного из событий,
            относящегося к одной конкретной таблице (представлению), или наступлению одного из
            событий базы данных. </para>
        <section xml:id="ddl-trigger-create">
            <info>
                <title>CREATE TRIGGER</title>
                <keywordset>
                    <keyword>CREATE TRIGGER</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE TRIGGER</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового триггера.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE TRIGGER <replaceable>trigname</replaceable> {   
    <replaceable>&lt;relation_trigger_legacy&gt;</replaceable>
  | <replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>
  | <replaceable>&lt;database_trigger&gt;</replaceable> 
  | <replaceable>&lt;ddl_trigger&gt;</replaceable> }                  
<replaceable>&lt;routine body&gt;</replaceable> 
  

<replaceable>&lt;relation_trigger_legacy&gt;</replaceable> ::= 
  FOR {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
  [POSITION <replaceable>number</replaceable>]

<replaceable>&lt;relation_trigger_sql2003&gt;</replaceable> ::= 
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
  [POSITION <replaceable>number</replaceable>]
  ON {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}

<replaceable>&lt;database_trigger&gt;</replaceable> ::= 
  [ACTIVE | INACTIVE] 
  ON <replaceable>db_event</replaceable>
  [POSITION <replaceable>number</replaceable>]
                    
<replaceable>&lt;ddl_trigger&gt;</replaceable> ::=  
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <replaceable>&lt;ddl_events&gt;</replaceable>
  [POSITION <replaceable>number</replaceable>]                    

<replaceable>&lt;mutation_list&gt;</replaceable> ::= <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable>]]

<replaceable>&lt;mutation&gt;</replaceable> ::= { INSERT | UPDATE | DELETE }

<replaceable>&lt;db_event&gt;</replaceable> ::= { 
    CONNECT 
  | DISCONNECT 
  | TRANSACTION START 
  | TRANSACTION COMMIT 
  | TRANSACTION ROLLBACK 
}

<replaceable>&lt;ddl_events&gt;</replaceable> ::= {
    ANY DDL STATEMENT
  | <replaceable>&lt;ddl_event_item&gt;</replaceable> [{OR <replaceable>&lt;ddl_event_item&gt;</replaceable>} ...]
}

<replaceable>&lt;ddl_event_item&gt;</replaceable> ::=
    CREATE TABLE | ALTER TABLE | DROP TABLE
  | CREATE PROCEDURE | ALTER PROCEDURE | DROP PROCEDURE
  | CREATE FUNCTION | ALTER FUNCTION | DROP FUNCTION
  | CREATE TRIGGER | ALTER TRIGGER | DROP TRIGGER
  | CREATE EXCEPTION | ALTER EXCEPTION | DROP EXCEPTION
  | CREATE VIEW | ALTER VIEW | DROP VIEW
  | CREATE DOMAIN | ALTER DOMAIN | DROP DOMAIN
  | CREATE ROLE | ALTER ROLE | DROP ROLE
  | CREATE SEQUENCE | ALTER SEQUENCE | DROP SEQUENCE
  | CREATE USER | ALTER USER | DROP USER
  | CREATE INDEX | ALTER INDEX | DROP INDEX
  | CREATE COLLATION | DROP COLLATION
  | ALTER CHARACTER SET
  | CREATE PACKAGE | ALTER PACKAGE | DROP PACKAGE
  | CREATE PACKAGE BODY | DROP PACKAGE BODY 
  | CREATE MAPPING | ALTER MAPPING | DROP MAPPING

<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
  <replaceable>&lt;declare_var&gt;</replaceable>; |      
  <replaceable>&lt;declare_cursor&gt;</replaceable>; |     
  <replaceable>&lt;declare_subfunc&gt;</replaceable> |     
  <replaceable>&lt;declare_subproc&gt;</replaceable> 

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> 

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]' 
                       </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE TRIGGER</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.33*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.67*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>trigname</replaceable></entry>
                                <entry>
                                    <para>Имя триггера. Может содержать до 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>relation_trigger_legacy</replaceable></entry>
                                <entry>
                                    <para>Объявление табличного триггера (унаследованное). </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>relation_trigger_sql2003</replaceable></entry>
                                <entry>
                                    <para>Объявление табличного триггера согласно стандарту
                                        SQL-2003. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>database_trigger</replaceable></entry>
                                <entry>
                                    <para>Объявление триггера базы данных. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>ddl_trigger</replaceable></entry>
                                <entry>
                                    <para>Объявление DDL триггера. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>tablename</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>viewname</replaceable></entry>
                                <entry>
                                    <para>Имя представления. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>mutation_list</replaceable></entry>
                                <entry>
                                    <para>Список событий таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>mutation</replaceable></entry>
                                <entry>
                                    <para>Одно из событий таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>db_event</replaceable></entry>
                                <entry>
                                    <para>Событие соединения или транзакции. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>ddl_events</replaceable></entry>
                                <entry>
                                    <para>Список событий изменения метаданных. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>ddl_event_item</replaceable></entry>
                                <entry>
                                    <para>Одно из событий изменения метаданных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>number</replaceable></entry>
                                <entry>
                                    <para>Порядок срабатывания триггера. От 0 до 32767.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declarations</replaceable></entry>
                                <entry>
                                    <para>Секция объявления локальных переменных и именованных
                                        курсоров. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>PSQL_statments</replaceable></entry>
                                <entry>
                                    <para>Операторы языка PSQL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор CREATE TRIGGER создаёт новый триггер. Триггер может быть создан для
                события (или событий) отношения (таблицы или представления), для события (событий)
                изменения метаданных или для одного из событий базы данных.</para>
            <para>Оператор CREATE TRIGGER как и его родственники <database>ALTER TRIGGER</database>,
                    <database>CREATE OR ALTER TRIGGER</database> и <database>RECREATE
                    TRIGGER</database> являются составными операторами, содержащими заголовок и
                тело.</para>
            <para>Заголовок определяет имя триггера, а также содержит имя отношения (для табличных
                триггеров), фазу триггера, событие (или события) на которые срабатывает триггер и
                позицию. Имя триггера должно быть уникальным среди имён других триггеров.</para>
            <section xml:id="ddl-trigger-create-sql_security">
                <title>Контекст безопасности</title>
                <indexterm>
                    <primary>CREATE TRIGGER</primary>
                    <secondary>SQL SECURITY</secondary>
                </indexterm>
                <para>Необязательное предложение SQL SECURITY позволяет задать с какими привилегиями
                    выполняется триггер. Если выбрана опция INVOKER, то триггер выполняется с
                    привилегиями вызывающего пользователя. Если выбрана опция DEFINER, то триггер
                    выполняется с привилегиями определяющего пользователя (владельца). Эти
                    привилегии будут дополнены привилегиями выданные самому триггеру с помощью
                    оператора GRANT. По умолчанию триггер наследует контекст безопасности указанный
                    для таблицы. Триггера на события базы данных по умолчанию выполняются с
                    привилегиями определяющего пользователя (владельца).</para>
            </section>
            <section xml:id="ddl-trigger-create-body">
                <title>Тело триггера</title>
                <para>Тело триггера состоит из необязательных объявлений локальных переменных,
                    подпрограмм и именованных курсоров, и одного или нескольких операторов или
                    блоков операторов, заключённых во внешнем блоке, который начинается с ключевого
                    слова BEGIN и заканчивается ключевым словом END. Объявления и внутренние
                    операторы завершаются точкой с запятой (;).</para>
            </section>
            <section xml:id="ddl-trigger-term">
                <title>Терминатор оператора</title>

                <para>Некоторые редакторы SQL-операторов — в частности утилита
                        <application>isql</application>, которая идёт в комплекте с Firebird, и
                    возможно некоторые сторонние редакторы — используют внутреннее соглашение,
                    которое требует, чтобы все операторы были завершены с точкой с запятой.</para>
                <para>Это создает конфликт с синтаксисом PSQL при кодировании в этих средах. Если вы
                    не знакомы с этой проблемой и её решением, пожалуйста, изучите детали в главе
                    PSQL в разделе, озаглавленном <link linkend="psql-setterm">Изменение терминатора
                        в <application>isql</application></link>.</para>

            </section>
            <section xml:id="ddl-trigger-create-table">
                <title>DML триггеры (на таблицу или представление)</title>

                <para>DML триггеры выполняются на уровне строки (записи) каждый раз, когда
                    изменяется образ строки. Они могут быть определены и для таблиц и
                    представлений.</para>

                <section xml:id="ddl-trigger-table-forms">
                    <title>Форма объявления</title>
                    <para>Объявление DML триггера существует в двух вариантах: <itemizedlist>
                            <listitem>
                                <para>своеобразная, унаследованная форма;</para>
                            </listitem>
                            <listitem>
                                <para>SQL-2003 совместимая (рекомендуемая).</para>
                            </listitem>
                        </itemizedlist></para>
                    <para>В настоящее время рекомендуется использовать SQL-2003 совместимую форму. </para>
                    <para>Для DML триггера обязательно указывается фаза и одно или несколько
                        событий.</para>
                </section>
                <section xml:id="ddl-trigger-state">
                    <title>Состояние триггера</title>
                    <para>Триггер может быть в одном из двух состояний активном (ACTIVE) или
                        неактивном (INACTIVE). Запускаются только активные триггеры. По умолчанию
                        триггеры создаются в активном состоянии.</para>
                </section>
                <section xml:id="ddl-trigger-table-phase">
                    <title>Фаза</title>
                    <para>Триггер может выполняться в одной из двух фаз, связанных с запрошенными
                        изменениями состояния данных. Ключевое слово BEFORE означает, что триггер
                        вызывается до наступления соответствующего события (событий, если их указано
                        несколько), AFTER — после наступления события (событий). </para>
                </section>
                <section xml:id="ddl-trigger-table-events">
                    <title>События</title>
                    <para>Для DML триггера может быть указано одно из событий таблицы
                        (представления) — INSERT (добавление), UPDATE (изменение), DELETE (удаление)
                        — или несколько событий, разделённых ключевым словом OR, при которых
                        вызывается триггер. При создании триггера каждое событие (INSERT, UPDATE или
                        DELETE) не должно упоминаться более одного раза.</para>
                    <para>Контекстные переменные <link linkend="internalfunc-contextvar-inserting"
                            >INSERTING</link>, <link linkend="internalfunc-contextvar-updating"
                            >UPDATING</link> и <link linkend="internalfunc-contextvar-deleting"
                            >DELETING</link> логического типа могут быть использованы в теле
                        триггера для определения события, которое вызвало срабатывание
                        триггера.</para>
                </section>
                <section xml:id="ddl-trigger-position">
                    <title>Порядок срабатывания</title>
                    <para>Ключевое слово POSITION позволяет задать порядок, в котором будут
                        выполняться триггеры с одинаковой фазой и событием (или группы событий). По
                        умолчанию позиция равна 0. Если позиции для триггеров не заданы или
                        несколько триггеров имеют одно и то же значение позиции, то такие триггеры
                        будут выполняться в алфавитном порядке их имен.</para>
                </section>
                <section xml:id="ddl-trigger-table-body">
                    <title>Тело триггера</title>
                    <para>После ключевого слова AS следует тело триггера.</para>
                    <section xml:id="ddl-trigger-declare">
                        <title>Объявление локальных переменных, курсоров и подпрограмм</title>
                        <para>В необязательной секции <replaceable>declarations</replaceable>
                            описаны локальные переменные триггера, именованные курсоры и
                            подпрограммы (подпроцедуры и подфункции). Подробности вы можете
                            посмотреть в главе <quote>Процедурный язык PSQL</quote> в разделах <link
                                linkend="psql-operators-declare-var">DECLARE VARIABLE</link> и <link
                                linkend="psql-operators-declare-cursor">DECLARE CURSOR</link>, <link
                                linkend="psql-operators-declare-procedure">DECLARE PROCEDURE</link>,
                                <link linkend="psql-operators-declare-function">DECLARE
                                FUNCTION</link>.</para>
                        <para>После необязательной секции деклараций обязательно следует составной
                            оператор. Составной оператор состоит из одного или нескольких PSQL
                            операторов, заключенных между ключевыми словами BEGIN и END. Составной
                            оператор может содержать один или несколько других составных операторов.
                            Вложеность ограничена 512 уровнями. Любой из BEGIN ... END блоков может
                            быть пустым, в том числе и главный блок.</para>
                    </section>
                </section>
                <section xml:id="ddl-trigger-external">
                    <title>Внешние триггеры</title>

                    <indexterm>
                        <primary>CREATE TRIGGER</primary>
                        <secondary>EXTERNAL NAME</secondary>
                    </indexterm>
                    <indexterm>
                        <primary>CREATE TRIGGER</primary>
                        <secondary>ENGINE</secondary>
                    </indexterm>
                    <para>Триггер может быть расположена во внешнем модуле. В этом случае вместо
                        тела триггера указывается место его расположения во внешнем модуле с помощью
                        предложения <database>EXTERNAL NAME</database>. Аргументом этого предложения
                        является строка, в которой через разделитель указано имя внешнего модуля,
                        имя процедуры внутри модуля и определённая пользователем информация. В
                        предложении <database>ENGINE</database> указывается имя движка для обработки
                        подключения внешних модулей. В Firebird для работы с внешними модулями
                        используется движок UDR. </para>
                </section>
                <section xml:id="ddl-trigger-table-create-who">
                    <title>Кто может создать DML триггер?</title>

                    <para>DML триггеры могут создать: <itemizedlist spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец таблицы (представления); </para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>ALTER ANY {TABLE |
                                        VIEW}</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>
                <section xml:id="ddl-trigger-table-create-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Создание DML триггера в Legacy стиле</title>
                        <para><programlisting language="sql">
CREATE TRIGGER SET_CUST_NO FOR CUSTOMER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CUST_NO IS NULL) THEN
    NEW.CUST_NO = GEN_ID(CUST_NO_GEN, 1);
END             
                </programlisting></para>
                    </example>
                    <example>
                        <title>Создание DML триггера согласно стандарту SQL-2003</title>
                        <para><programlisting language="sql">
CREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END           
                </programlisting></para>
                    </example>
                    <example>
                        <title>Создание DML триггера выполняющегося с правами определяющего
                            пользователя</title>
                        <para><programlisting language="sql">
CREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
SQL SECURITY DEFINER
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END           
                </programlisting></para>
                    </example>
                    <example>
                        <title>Создание DML триггера на несколько событий</title>
                        <para><programlisting language="sql">
CREATE TRIGGER TR_CUST_LOG
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
ON CUSTOMER
AS
BEGIN
  INSERT INTO CHANGE_LOG (LOG_ID,
                          ID_TABLE,
                          TABLE_NAME,
                          MUTATION)
  VALUES (NEXT VALUE FOR SEQ_CHANGE_LOG,
          OLD.CUST_NO,
          'CUSTOMER',
          CASE
            WHEN INSERTING THEN 'INSERT'
            WHEN UPDATING  THEN 'UPDATE'
            WHEN DELETING  THEN 'DELETE'
          END);
END         
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-trigger-alter">ALTER TRIGGER</link>, <link
                                linkend="ddl-trigger-drop">DROP TRIGGER</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-trigger-create-db">
                <title>Триггеры на событие базы данных</title>

                <para>Триггер может быть создан для одного из событий базы данных: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para>CONNECT (соединение с базой данных);</para>
                        </listitem>
                        <listitem>
                            <para>DISCONNECT (отсоединение от базы данных);</para>
                        </listitem>
                        <listitem>
                            <para>TRANSACTION START (старт транзакции); </para>
                        </listitem>
                        <listitem>
                            <para>TRANSACTION COMMIT (подтверждение транзакции); </para>
                        </listitem>
                        <listitem>
                            <para>TRANSACTION ROLLBACK (откат транзакции). </para>
                        </listitem>
                    </itemizedlist></para>
                <para>Указать для триггера несколько событий базы данных невозможно.</para>
                <section xml:id="ddl-trigger-db-exception">
                    <title>Выполнение триггеров на событие базы данных и обработка
                        исключений</title>
                    <para>Триггера на события CONNECT и DISCONNECT выполняются в специально
                        созданной для этого транзакции. Если при обработке триггера не было вызвано
                        исключение, то транзакция подтверждается. Не перехваченные исключения
                        откатят транзакцию и: <itemizedlist spacing="compact">
                            <listitem>
                                <para>в случае триггера на событие CONNECT соединение разрывается, а
                                    исключения возвращается клиенту;</para>
                            </listitem>
                            <listitem>
                                <para>для триггера на событие DISCONNECT соединение разрывается, как
                                    это и предусмотрено, но исключения не возвращается клиенту.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>Триггера на событие TRANSACTION срабатывают при старте транзакции, её
                        подтверждении или отмене. Не перехваченные исключения обрабатываются в
                        зависимости от типа события TRANSACTION: <itemizedlist spacing="compact">
                            <listitem>
                                <para>для события START исключение возвращается клиенту, а
                                    транзакция отменяется;</para>
                            </listitem>
                            <listitem>
                                <para>для события COMMIT исключение возвращается клиенту, действия,
                                    выполненные триггером, и транзакция отменяются;</para>
                            </listitem>
                            <listitem>
                                <para>для события ROLLBACK исключение не возвращается клиенту, а
                                    транзакция, как и предусмотрено, отменяется.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <section>
                        <title>Ловушки</title>
                        <para>Из вышеизложенного следует, что нет прямого способа узнать, какой
                            триггер (DISCONNECT или ROLLBACK) вызвал исключение. Также ясно, что вы
                            не сможете подключиться к базе данных в случае исключения в триггере на
                            событие CONNECT, а также отменяется старт транзакции при исключении в
                            триггере на событие TRANSACTION START. В обоих случаях база данных
                            эффективно блокируется до тех пор, пока вы не отключите триггеры базы
                            данных и не исправите ошибочный код.</para>
                        <simplesect xml:id="ddl-trigger-db-suppression">
                            <title>Отключение триггеров</title>

                            <para>В некоторые утилиты командной строки Firebird были добавлены новые
                                ключи для отключения триггеров на базу данных:
                                <screen>
gbak -nodbtriggers
isql -nodbtriggers
nbackup -T
                    </screen>
                                Эти ключи могут использоваться только SYSDBA или владельцем базы
                                данных. </para>
                        </simplesect>
                    </section>
                </section>
                <section xml:id="ddl-trigger-db-two-phase">
                    <title>Двухфазное подтверждение транзакций</title>
                    <para>В случае двухфазных транзакций триггеры на событие TRANSACTION START
                        срабатывают в фазе подготовки (prepare), а не в фазе commit.</para>
                </section>
                <section xml:id="ddl-trigger-db-сaveats">
                    <title>Предостережения</title>
                    <para>
                        <orderedlist>
                            <listitem>
                                <para>Триггеры для событий базы данных DISCONNECT и ROLLBACK не
                                    будут вызваны при отключении клиентов через таблицы мониторинга
                                    (DELETE FROM MON$ATTACHMENTS).</para>
                            </listitem>
                            <listitem>
                                <para>Использование оператора IN AUTONOMOUS TRANSACTION DO в
                                    триггерах на событие базы данных связанные с транзакциями
                                    (COMMIT, ROLLBACK, START) может привести к его
                                    зацикливанию.</para>
                            </listitem>
                        </orderedlist>
                    </para>
                </section>
                <section xml:id="ddl-trigger-db-сreate-who">
                    <title>Кто может создать триггеры на события базы данных?</title>


                    <para>Триггеры для событий базы данных могут создать: <itemizedlist
                            spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец базы данных;</para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>ALTER
                                    DATABASE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>

                <section xml:id="ddl-trigger-db-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Создание триггера на событие подключения к БД для логирования
                            события</title>
                        <para><programlisting language="sql">
CREATE TRIGGER tr_log_connect
INACTIVE ON CONNECT POSITION 0
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_TIMESTAMP);
END              
                </programlisting></para>
                    </example>
                    <example>
                        <title>Создание триггера на событие подключения к БД для контроля
                            доступа</title>
                        <para><programlisting language="sql">
<![CDATA[                         
CREATE EXCEPTION E_INCORRECT_WORKTIME 'Рабочий день ещё не начался';

CREATE TRIGGER TR_LIMIT_WORKTIME ACTIVE 
ON CONNECT POSITION 1
AS
BEGIN
  IF ((CURRENT_USER <> 'SYSDBA') AND
      NOT (CURRENT_TIME BETWEEN time '9:00' AND time '17:00')) THEN
     EXCEPTION E_INCORRECT_WORKTIME;
END
]]>
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>


                        <para>
                            <link linkend="ddl-trigger-alter">ALTER TRIGGER</link>, <link
                                linkend="ddl-trigger-drop">DROP TRIGGER</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-trigger-create-ddl">
                <title>Триггеры на события изменения метаданных</title>

                <para>Триггеры на события изменения метаданных (DDL триггеры) предназначены для
                    обеспечения ограничений, которые будут распространены на пользователей, которые
                    пытаются создать, изменить или удалить DDL объект. Другое их назначение —
                    ведение журнала изменений метаданных.</para>
                <para>Триггеры на события изменения метаданных являются одним из подвидов триггеров
                    на события базы данных.</para>
                <para>Особенности: <orderedlist>
                        <listitem>
                            <para>BEFORE триггеры запускаются до изменений в системных таблицах.
                                AFTER триггеры запускаются после изменений в системных таблицах.
                            </para>
                        </listitem>
                        <listitem>
                            <para>Когда оператор DDL запускает триггер, в котором возбуждается
                                исключение (BEFORE или AFTER, преднамеренно или неумышленно),
                                оператор не будет фиксирован. Т.е. исключения могут использоваться,
                                чтобы гарантировать, что оператор DDL будет отменен, если некоторые
                                условия не будут соблюдены. </para>
                        </listitem>
                        <listitem>
                            <para>Действия DDL триггеров выполняются только при фиксации транзакции,
                                в которой работает затронутая DDL команда. Никогда не забывайте о
                                том, что в AFTER триггере, возможно сделать только то, что возможно
                                сделать после DDL команды без автоматической фиксации транзакций. Вы
                                не можете, например, создать таблицу в триггере и использовать её
                                там. </para>
                        </listitem>
                        <listitem>
                            <para>Для операторов <database>CREATE OR ALTER</database>... триггер
                                срабатывает один раз для события CREATE или события ALTER, в
                                зависимости от того существовал ли ранее объект. Для операторов
                                RECREATE триггер вызывается для события DROP, если объект
                                существовал, и после этого для события CREATE. </para>
                        </listitem>
                        <listitem>
                            <para>Если объект метаданных не существует, то обычно триггеры на
                                события ALTER и DROP не запускаются. Исключения описаны в пункте 6.
                            </para>
                        </listitem>
                        <listitem>
                            <para>Исключением из правила 5 являются BEFORE ALTER/DROP USER триггеры,
                                которые будут вызваны, даже если имя пользователя не существует. Это
                                вызвано тем, что эти команды выполняются для базы данных
                                безопасности, для которой не делается проверка существования
                                пользователей перед их выполнением. Данное поведение, вероятно,
                                будет отличаться для встроенных пользователей, поэтому не пишите
                                код, который зависит от этого.</para>
                        </listitem>
                        <listitem>
                            <para>Если некоторое исключение возбуждено после того как начала
                                выполняться DDL команда и до того как запущен AFTER триггер, то
                                AFTER триггер не запускается. </para>
                        </listitem>
                        <listitem>
                            <para>Для процедур и функций в составе пакетов не запускаются
                                индивидуальные триггеры {CREATE | ALTER | DROP} {PROCEDURE |
                                FUNCTION}.</para>
                        </listitem>
                        <listitem>
                            <para>Оператор ALTER DOMAIN <replaceable>&lt;old name&gt;</replaceable>
                                TO <replaceable>&lt;new name&gt;</replaceable> устанавливает
                                контекстные переменные OLD_OBJECT_NAME и NEW_OBJECT_NAME в обоих
                                триггерах BEFORE и AFTER. Контекстная переменная OBJECT_NAME будет
                                содержать старое имя объекта метаданных в триггере BEFORE, и новое —
                                в триггере AFTER.</para>
                        </listitem>
                    </orderedlist></para>
                <para>Если в качестве события указано предложение ANY DDL STATEMENT, то триггер
                    будет вызван при наступлении любого из DDL событий.</para>
                <section xml:id="ddl-trigger-create-ddl-contextvar">
                    <title>Пространство имён DDL_TRIGGER</title>

                    <para>Во время работы DDL триггера доступно пространство имён DDL_TRIGGER для
                        использования в функции <database>RDB$GET_CONTEXT</database>. Его
                        использование также допустимо в хранимых процедурах и функциях, вызванных
                        триггерами DDL.</para>
                    <para>Контекст DDL_TRIGGER работает как стек. Перед возбуждением DDL триггера,
                        значения, относящиеся к выполняемой команде, помещаются в этот стек. После
                        завершения работы триггера значения выталкиваются. Таким образом. В случае
                        каскадных DDL операторов, когда каждая пользовательская DDL команда
                        возбуждает DDL триггер, и этот триггер запускает другие DDL команды, с
                        помощью <database>EXECUTE STATEMENT</database>, значения переменных в
                        пространстве имён DDL_TRIGGER будут соответствовать команде, которая вызвала
                        последний DDL триггер в стеке вызовов.</para>
                    <section>
                        <title>Переменные доступные в пространстве имён DDL_TRIGGER</title>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>EVENT_TYPE – тип события (CREATE, ALTER, DROP)</para>
                                </listitem>
                                <listitem>
                                    <para>OBJECT_TYPE – тип объекта (TABLE, VIEW и д.р.) </para>
                                </listitem>
                                <listitem>
                                    <para>DDL_EVENT – имя события (<replaceable>&lt;ddl event
                                            item&gt;</replaceable>), </para>
                                    <para>где <replaceable>&lt;ddl event item&gt;</replaceable> =
                                        EVENT_TYPE || ' ' || OBJECT_TYPE </para>
                                </listitem>
                                <listitem>
                                    <para>OBJECT_NAME – имя объекта метаданных</para>
                                </listitem>
                                <listitem>
                                    <para>OLD_OBJECT_NAME – имя объекта метаданных до
                                        переименования</para>
                                </listitem>
                                <listitem>
                                    <para>NEW_OBJECT_NAME – имя объекта метаданных после
                                        переименования </para>
                                </listitem>
                                <listitem>
                                    <para>SQL_TEXT – текст SQL запроса </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </section>
                </section>
                <section xml:id="ddl-trigger-ddl-suppression">
                    <title>Отключение триггеров</title>

                    <para>В некоторые утилиты командной строки Firebird были добавлены новые ключи
                        для отключения триггеров на базу данных:
                        <screen>
gbak -nodbtriggers
isql -nodbtriggers
nbackup -T
                    </screen>
                        Эти ключи могут использоваться только SYSDBA или владельцем базы данных.
                    </para>
                </section>
                <section xml:id="ddl-trigger-create-ddl-who">
                    <title>Кто может создать триггеры на события изменения метаданных?</title>

                    <para>Триггеры на события изменения метаданных могут создать: <itemizedlist
                            spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец базы данных;</para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>ALTER
                                    DATABASE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>
                <section xml:id="ddl-trigger-create-ddl-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Контроль наименования объектов базы данных с помощью DDL
                            триггера</title>
                        <para><programlisting language="sql">
CREATE EXCEPTION e_invalid_sp_name 
  'Неверное имя хранимой процедуры (должно начинаться с SP_)';

SET TERM !;

CREATE TRIGGER trig_ddl_sp BEFORE CREATE PROCEDURE
AS
BEGIN
  IF (rdb$get_context('DDL_TRIGGER', 'OBJECT_NAME') 
      NOT STARTING 'SP_') THEN
    EXCEPTION e_invalid_sp_name;
END!

-- Test
CREATE PROCEDURE sp_test
AS
BEGIN
END!

CREATE PROCEDURE test
AS
BEGIN
END!
</programlisting>
                            <screen>                        
-- Statement failed, SQLSTATE = 42000
-- exception 1
-- -E_INVALID_SP_NAME
-- -Неверное имя хранимой процедуры (должно начинаться с SP_)
-- -At trigger 'TRIG_DDL_SP' line: 4, col: 5
</screen>
                            <programlisting language="sql">
SET TERM ;!          
                </programlisting></para>
                    </example>
                    <example>
                        <title>Контроль безопасности DDL операторов</title>
                        <para><programlisting language="sql">
CREATE EXCEPTION e_access_denied 'Access denied';

SET TERM !;

CREATE TRIGGER trig_ddl BEFORE ANY DDL STATEMENT
AS
BEGIN
  IF (current_user &lt;&gt; 'SUPER_USER') THEN
    EXCEPTION e_access_denied;
END!

-- Test
CREATE PROCEDURE sp_test
AS
BEGIN
END!
</programlisting>
                            <screen>
-- The last command raises this exception and procedure SP_TEST is not created
-- Statement failed, SQLSTATE = 42000
-- exception 1
-- -E_ACCESS_DENIED
-- -Access denied
-- -At trigger 'TRIG_DDL' line: 4, col: 5
</screen>
                            <programlisting language="sql">
SET TERM ;!         
                </programlisting></para>
                    </example>
                    <note>
                        <para>В Firebird существуют привилегии на DDL операторы, поэтому прибегать к
                            написанию DDL триггера нужно только в случае, если того же самого
                            эффекта невозможно достичь стандартными методами.</para>
                    </note>
                    <example>
                        <title>Использование DDL триггеров для регистрации событий изменения
                            метаданных</title>
                        <para><programlisting language="sql">
CREATE SEQUENCE ddl_seq;

CREATE TABLE ddl_log (
  id BIGINT NOT NULL PRIMARY KEY,
  moment TIMESTAMP NOT NULL,
  user_name VARCHAR(63) NOT NULL,
  event_type VARCHAR(25) NOT NULL,
  object_type VARCHAR(25) NOT NULL,
  ddl_event VARCHAR(25) NOT NULL,
  object_name VARCHAR(63) NOT NULL,
  old_object_name VARCHAR(63),
  new_object_name VARCHAR(63),
  sql_text BLOB sub_type text NOT NULL,
  ok CHAR(1) NOT NULL
);

SET TERM !;

CREATE TRIGGER trig_ddl_log_before BEFORE ANY DDL STATEMENT
AS
  DECLARE id TYPE OF COLUMN ddl_log.id;
BEGIN
  -- Мы должны производить изменения в AUTONOMOUS TRANSACTION, 
  -- таким образом, если произойдёт исключение и команда
  -- не будет запущена, она всё равно будет зарегистрирована.
  IN AUTONOMOUS TRANSACTION DO
  BEGIN
    INSERT INTO ddl_log (
      id, moment, user_name, event_type, object_type, ddl_event, 
      object_name, old_object_name, new_object_name, sql_text, ok)
    VALUES (NEXT VALUE FOR ddl_seq, 
            current_timestamp, current_user,
            rdb$get_context('DDL_TRIGGER', 'EVENT_TYPE'),
            rdb$get_context('DDL_TRIGGER', 'OBJECT_TYPE'),
            rdb$get_context('DDL_TRIGGER', 'DDL_EVENT'),
            rdb$get_context('DDL_TRIGGER', 'OBJECT_NAME'),
            rdb$get_context('DDL_TRIGGER', 'OLD_OBJECT_NAME'),
            rdb$get_context('DDL_TRIGGER', 'NEW_OBJECT_NAME'),
            rdb$get_context('DDL_TRIGGER', 'SQL_TEXT'),
            'N')
    RETURNING id INTO id;
    rdb$set_context('USER_SESSION', 'trig_ddl_log_id', id);
  END
END!

-- Примечание: 
-- созданный выше триггер будет запущен для этой DDL. 
-- Хорошей идеей является использование –nodbtriggers
-- при работе с ним
CREATE TRIGGER trig_ddl_log_after AFTER ANY DDL STATEMENT
AS
BEGIN
  -- Здесь нам требуется автономная транзакция, 
  -- потому что в оригинальной транзакции
  -- мы не увидим запись, вставленную в 
  -- BEFORE триггере в автономной транзакции, 
  -- если пользовательская транзакции не запущена
  -- с режимом изоляции  READ COMMITTED.
  IN AUTONOMOUS TRANSACTION DO
    UPDATE ddl_log SET ok = 'Y'
    WHERE 
      id = rdb$get_context('USER_SESSION', 'trig_ddl_log_id');
END!

COMMIT!

SET TERM ;!

-- Удаляем запись о создании trig_ddl_log_after.
DELETE FROM ddl_log;
COMMIT;

-- Тест

-- Эта команда будет зарегистрирована единожды
-- (т.к. T1 не существует, RECREATE вызовет событие CREATE) 
-- с OK = Y.
RECREATE TABLE t1 (
  n1 INTEGER,
  n2 INTEGER
);

-- Оператор не выполнится, т.к. T1 уже существует, 
-- таким образом OK будет иметь значение N.
CREATE TABLE t1 (
  n1 INTEGER,
  n2 INTEGER
);

-- T2 не существует. Это действие не будет зарегистрировано.
DROP TABLE t2;

-- Это действие будет зарегистрировано дважды
-- (т.к. T1 существует, действие RECREATE рассматривается 
-- как DROP и CREATE) с полем OK = Y.
RECREATE TABLE t1 (
  n INTEGER
);

CREATE DOMAIN dom1 AS INTEGER;

ALTER DOMAIN dom1 TYPE BIGINT;

ALTER DOMAIN dom1 TO dom2;

COMMIT;

SELECT 
  id, 
  ddl_event, 
  object_name as name, 
  old_object_name as old_name, 
  new_object_name as new_name, 
  sql_text, 
  ok
FROM ddl_log 
ORDER BY id;         
                </programlisting></para>
                        <para>
                            <informaltable frame="all">
                                <tgroup cols="7">
                                    <colspec colname="c1" colnum="1" colwidth="0.12*"/>
                                    <colspec colname="c2" colnum="2" colwidth="0.63*"/>
                                    <colspec colname="c3" colnum="3" colwidth="0.32*"/>
                                    <colspec colname="c4" colnum="4" colwidth="0.46*"/>
                                    <colspec colname="c5" colnum="5" colwidth="0.46*"/>
                                    <colspec colname="c6" colnum="6" colwidth="1.0*"/>
                                    <colspec colname="c7" colnum="7" colwidth="0.15*"/>
                                    <thead>
                                        <row>
                                            <entry align="center">ID</entry>
                                            <entry align="center">DDL_EVENT</entry>
                                            <entry align="center">NAME</entry>
                                            <entry align="center">OLD_NAME</entry>
                                            <entry align="center">NEW_NAME</entry>
                                            <entry align="center">SQL_TEXT</entry>
                                            <entry align="center">OK</entry>
                                        </row>
                                    </thead>
                                    <tbody>
                                        <row>
                                            <entry>2</entry>
                                            <entry>CREATE TABLE</entry>
                                            <entry>T1</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>
                                                <programlisting>
RECREATE TABLE t1 (
  n1 INTEGER,
  n2 INTEGER
)                                               
</programlisting>
                                            </entry>
                                            <entry>Y</entry>
                                        </row>
                                        <row>
                                            <entry>3</entry>
                                            <entry>CREATE TABLE</entry>
                                            <entry>T1</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>
                                                <programlisting>
CREATE TABLE t1 (
  n1 INTEGER,
  n2 INTEGER
)                                                
</programlisting>
                                            </entry>
                                            <entry>N</entry>
                                        </row>
                                        <row>
                                            <entry>4</entry>
                                            <entry>DROP TABLE</entry>
                                            <entry>T1</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>
                                                <programlisting>
RECREATE TABLE t1 (
  n INTEGER
)                                              
</programlisting>
                                            </entry>
                                            <entry>Y</entry>
                                        </row>
                                        <row>
                                            <entry>5</entry>
                                            <entry>CREATE TABLE</entry>
                                            <entry>T1</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>
                                                <programlisting>
RECREATE TABLE t1 (
  n INTEGER
)                                              
</programlisting>
                                            </entry>
                                            <entry>Y</entry>
                                        </row>
                                        <row>
                                            <entry>6</entry>
                                            <entry>CREATE DOMAIN</entry>
                                            <entry>DOM1</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>
                                                <programlisting>
CREATE DOMAIN dom1 
  AS INTEGER                                             
</programlisting>
                                            </entry>
                                            <entry>Y</entry>
                                        </row>
                                        <row>
                                            <entry>7</entry>
                                            <entry>ALTER DOMAIN</entry>
                                            <entry>DOM1</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>&lt;null&gt;</entry>
                                            <entry>
                                                <programlisting>
ALTER DOMAIN dom1 
  TYPE BIGINT                                            
</programlisting>
                                            </entry>
                                            <entry>Y</entry>
                                        </row>
                                        <row>
                                            <entry>8</entry>
                                            <entry>ALTER DOMAIN</entry>
                                            <entry>DOM1</entry>
                                            <entry>DOM1</entry>
                                            <entry>DOM2</entry>
                                            <entry>
                                                <programlisting>
ALTER DOMAIN dom1 
  TO dom2                                           
</programlisting>
                                            </entry>
                                            <entry>Y</entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </informaltable>
                        </para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-trigger-alter">ALTER TRIGGER</link>, <link
                                linkend="ddl-trigger-drop">DROP TRIGGER</link>. </para>
                    </formalpara>
                </section>
            </section>
        </section>
        <section xml:id="ddl-trigger-alter">
            <info>
                <title>ALTER TRIGGER</title>
                <keywordset>
                    <keyword>ALTER TRIGGER</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER TRIGGER</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение существующего триггера.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
ALTER TRIGGER <replaceable>trigname</replaceable> 
[ACTIVE | INACTIVE]
[{BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>]
[POSITION <replaceable>number</replaceable>]
[SQL SECURITY {DEFINER | INVOKER} | DROP SQL SECURITY]
[<replaceable>&lt;routine body&gt;</replaceable>] 

<replaceable>&lt;mutation_list&gt;</replaceable> ::= <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable>]]

<replaceable>&lt;mutation&gt;</replaceable> ::= { INSERT | UPDATE | DELETE }
   
                       </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER TRIGGER</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>trigname</replaceable></entry>
                                <entry>
                                    <para>Имя триггера.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>mutation_list</replaceable></entry>
                                <entry>
                                    <para>Список событий таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>mutation</replaceable></entry>
                                <entry>
                                    <para>Одно из событий таблицы. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>number</replaceable></entry>
                                <entry>
                                    <para>Порядок срабатывания триггера. От 0 до 32767.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>routine_body</replaceable></entry>
                                <entry>
                                    <para>Тело триггера</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>ALTER TRIGGER</database> позволяет изменять заголовок и/или
                тело триггера.</para>
            <section xml:id="ddl-trigger-alter-changes">
                <title>Допустимые изменения</title>
                <para>В операторе изменения триггера можно изменить:<itemizedlist>
                        <listitem>
                            <para>Состояние активности (ACTIVE | INACTIVE);</para>
                        </listitem>
                        <listitem>
                            <para>Фазу (BEFORE | AFTER);</para>
                        </listitem>
                        <listitem>
                            <para>Событие(я);</para>
                        </listitem>
                        <listitem>
                            <para>Позицию срабатывания;</para>
                        </listitem>
                        <listitem>
                            <para>Контекст безопасности, т.е. с какими привилегиями выполняется
                                триггер: вызывающего пользователя (SQL SECURITY INVOKER),
                                определяющего пользователя (SQL SECURITY DEFINER) или наследует у
                                таблицы (DROP SQL SECURITY);</para>
                        </listitem>
                        <listitem>
                            <para>Код тела триггера.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Если какой-либо элемент не указан, то он остаётся без изменений.</para>
                <note>
                    <para>DML триггер невозможно изменить в триггер на событие базы данных и
                        наоборот.</para>
                    <para>Событие в триггере базы данных невозможно изменить.</para>
                </note>
                <tip>
                    <title>Помните</title>
                    <para>Триггер с ключевым словом BEFORE наступает до соответствующего события, с
                        ключевым словом AFTER — после соответствующего события.</para>
                    <para>Один DML триггер может содержать более одного события (INSERT, UPDATE,
                        DELETE). События должны быть разделены ключевым словом OR. Каждое из событий
                        может быть указано не более одного раза.</para>
                    <para>Ключевое слово POSITION позволяет задать дополнительный порядок выполнения
                        с одинаковыми фазой и событием. По умолчанию позиция равна 0. Если позиция
                        не задана, или если несколько триггеров имеют один и тот же номер позиции,
                        то триггеры будут выполнены в алфавитном порядке их наименований.</para>
                </tip>
            </section>
            <section xml:id="ddl-trigger-alter-who">
                <title>Кто может изменить триггеры?</title>

                <para>DML триггеры могут изменить: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы (представления); </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY {TABLE |
                                    VIEW}</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>


                <para>Триггеры для событий базы данных и триггеры событий на изменение метаданных
                    могут изменить: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец базы данных;</para>
                        </listitem>
                        <listitem>
                            <para>Пользователь, имеющий привилегию ALTER DATABASE.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
            <section xml:id="ddl-trigger-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Отключение (перевод в неактивное состояние) триггера</title>
                    <para><programlisting language="sql">
ALTER TRIGGER set_cust_no INACTIVE;            
                </programlisting></para>
                </example>
                <example>
                    <title>Изменение позиции триггера</title>
                    <para><programlisting language="sql">
ALTER TRIGGER set_cust_no POSITION 14;          
                </programlisting></para>
                </example>
                <example>
                    <title>Перевод триггера в неактивное состояние и изменение списка
                        событий</title>
                    <para><programlisting language="sql">
ALTER TRIGGER TR_CUST_LOG
INACTIVE AFTER INSERT OR UPDATE;       
                </programlisting></para>
                </example>
                <example>
                    <title>Изменение контекста безопасности триггера</title>
                    <para>После выполнения данного оператора триггер будет выполняться с
                        привилегиями определяющего пользователя
                        (владельца).<programlisting language="sql">
ALTER TRIGGER TR_CUST_LOG
SQL SECURITY DEFINER;       
                </programlisting></para>
                </example>
                <example>
                    <title>Удаление контекста безопасности триггера</title>
                    <para>После удаления контекста безопасности триггера, триггер выполняется с
                        привилегиями унаследованными от таблицы. Если у таблицы не определён
                        контекст безопасности, то триггер будет выполняться с привилегиями
                        вызывающего
                        пользователя.<programlisting language="sql">
ALTER TRIGGER TR_CUST_LOG
DROP SQL SECURITY;       
                </programlisting></para>
                </example>
                <example>
                    <title>Перевод триггера в активное состояние, изменение его позиции и его
                        тела</title>
                    <para><programlisting language="sql">
ALTER TRIGGER tr_log_connect
ACTIVE POSITION 1
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ROLENAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_ROLE,
          CURRENT_TIMESTAMP);
END      
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-trigger-create">CREATE TRIGGER</link>, <link
                            linkend="ddl-trigger-createoralter">CREATE OR ALTER TRIGGER</link>,
                            <link linkend="ddl-trigger-recreate">RECREATE TRIGGER</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-trigger-createoralter">
            <info>
                <title>CREATE OR ALTER TRIGGER</title>
                <keywordset>
                    <keyword>CREATE OR ALTER TRIGGER</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE OR ALTER TRIGGER</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового или изменение существующего триггера.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE OR ALTER TRIGGER <replaceable>trigname</replaceable> {   
    <replaceable>&lt;relation_trigger_legacy&gt;</replaceable>
  | <replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>
  | <replaceable>&lt;database_trigger&gt;</replaceable> 
  | <replaceable>&lt;ddl_trigger&gt;</replaceable> }
<replaceable>&lt;routine body&gt;</replaceable>
                       </programlisting>
                    Полное описание оператора см. <link linkend="ddl-trigger-create">CREATE
                        TRIGGER</link>. </para>
            </formalpara>

            <para>Оператор <database>CREATE OR ALTER TRIGGER</database> создаёт новый триггер, если
                он не существует, или изменяет и перекомпилирует его в противном случае, при этом
                существующие права и зависимости сохраняются.</para>

            <section xml:id="ddl-trigger-createoralter-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание нового или изменение существующего триггера</title>
                    <para><programlisting language="sql">
CREATE OR ALTER TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END              
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-trigger-create">CREATE TRIGGER</link>, <link
                            linkend="ddl-trigger-alter">ALTER TRIGGER</link>, <link
                            linkend="ddl-trigger-recreate">RECREATE TRIGGER</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-trigger-drop">
            <info>
                <title>DROP TRIGGER</title>
                <keywordset>
                    <keyword>DROP TRIGGER</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP TRIGGER</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление существующего триггера.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
DROP TRIGGER <replaceable>trigname</replaceable>  
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP TRIGGER</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>trigname</replaceable></entry>
                                <entry>
                                    <para>Имя триггера.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>DROP TRIGGER</database> удаляет существующий триггер.</para>
            <section xml:id="ddl-trigger-drop-who">
                <title>Кто может удалить триггеры?</title>

                <para>DML триггеры могут удалить: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец таблицы (представления); </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY {TABLE |
                                    VIEW}</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>


                <para>Триггеры для событий базы данных и триггеры событий на изменение метаданных
                    могут удалить: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец базы данных;</para>
                        </listitem>
                        <listitem>
                            <para>Пользователь, имеющий привилегию ALTER DATABASE.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
            <section xml:id="ddl-trigger-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление триггера</title>
                    <para><programlisting language="sql">
DROP TRIGGER set_cust_no;                
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-trigger-create">CREATE TRIGGER</link>, <link
                            linkend="ddl-trigger-alter">ALTER TRIGGER</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-trigger-recreate">
            <info>
                <title>RECREATE TRIGGER</title>
                <keywordset>
                    <keyword>RECREATE TRIGGER</keyword>
                </keywordset>
            </info>
            <indexterm><primary>RECREATE TRIGGER</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового или пересоздание существующего триггера.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
RECREATE TRIGGER <replaceable>trigname</replaceable> {   
    <replaceable>&lt;relation_trigger_legacy&gt;</replaceable>
  | <replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>
  | <replaceable>&lt;database_trigger&gt;</replaceable> 
  | <replaceable>&lt;ddl_trigger&gt;</replaceable> }
<replaceable>&lt;routine body&gt;</replaceable>
                       </programlisting>
                    Полное описание оператора см. <link linkend="ddl-trigger-create">CREATE
                        TRIGGER</link>. </para>
            </formalpara>

            <para>Оператор RECREATE TRIGGER создаёт новый триггер, если триггер с указанным именем
                не существует, в противном случае оператор RECREATE TRIGGER попытается удалить его и
                создать новый.</para>

            <section xml:id="ddl-trigger-recreate-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание или пересоздание триггера</title>
                    <para><programlisting language="sql">
RECREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END              
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-trigger-create">CREATE TRIGGER</link>, <link
                            linkend="ddl-trigger-drop">DROP TRIGGER</link>, <link
                            linkend="ddl-trigger-createoralter">CREATE OR ALTER TRIGGER</link>.
                    </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-procedure">
        <info>
            <title>PROCEDURE</title>
            <keywordset>
                <keyword>PROCEDURE</keyword>
            </keywordset>
        </info>
        <para>Хранимая процедура (ХП) — это программный модуль, который может быть вызван с клиента,
            из другой процедуры, функции, выполнимого блока (executable block) или триггера.
            Хранимые процедуры, хранимые функции, исполняемые блоки и триггеры пишутся на
            процедурном языке SQL (PSQL). Большинство операторов SQL доступно и в PSQL, иногда с
            ограничениями или расширениями. Заметными исключениями являются DDL и операторы
            управления транзакциями.</para>
        <para>Хранимые процедуры могут принимать и возвращать множество параметров.</para>
        <section xml:id="ddl-procedure-create">
            <info>
                <title>CREATE PROCEDURE</title>
                <keywordset>
                    <keyword>CREATE PROCEDURE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE PROCEDURE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой хранимой функции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE PROCEDURE <replaceable>procname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])    
<replaceable>&lt;routine body&gt;</replaceable> 
  
<replaceable>&lt;inparam&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [{= | DEFAULT} <replaceable>&lt;value&gt;</replaceable>]  

<replaceable>&lt;outparam&gt;</replaceable>  ::=  <replaceable>&lt;param_decl&gt;</replaceable>  
                    
<replaceable>&lt;value&gt;</replaceable> ::=  {<replaceable>literal</replaceable> | NULL | <replaceable>context_var</replaceable>} 
                    
<replaceable>&lt;param_decl&gt;</replaceable> ::= <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
                    
<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'    

<replaceable>&lt;type&gt;</replaceable> ::= <replaceable>&lt;datatype&gt;</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable> 
                    
<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} 
  | BOOLEAN 
  | {FLOAT | DOUBLE PRECISION} 
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])]                     

<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
  <replaceable>&lt;declare_var&gt;</replaceable>; |      
  <replaceable>&lt;declare_cursor&gt;</replaceable>; |     
  <replaceable>&lt;declare_subfunc&gt;</replaceable> |     
  <replaceable>&lt;declare_subproc&gt;</replaceable> 

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> 

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]' 
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE PROCEDURE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>procname</replaceable></entry>
                                <entry>
                                    <para>Имя хранимой процедуры. Может содержать до 63
                                        символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>inparam</replaceable></entry>
                                <entry>
                                    <para>Описание входного параметра.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>outparam</replaceable></entry>
                                <entry>
                                    <para>Описание выходного параметра.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declarations</replaceable></entry>
                                <entry>
                                    <para>Секция объявления локальных переменных, именованных
                                        курсоров, подпроцедур и подфункций.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_var</replaceable></entry>
                                <entry>
                                    <para>Объявление локальной переменной. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_cursor</replaceable></entry>
                                <entry>
                                    <para>Объявление именованного курсора. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_subfunc</replaceable></entry>
                                <entry>
                                    <para>Объявление подпрограммы – функции.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_subproc</replaceable></entry>
                                <entry>
                                    <para>Объявление подпрограммы – процедуры. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>literal</replaceable></entry>
                                <entry>
                                    <para>Литерал, совместимый по типу с параметром. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>context_var</replaceable></entry>
                                <entry>
                                    <para>Любая контекстная переменная, тип которой совместим с
                                        типом параметра. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>paramname</replaceable></entry>
                                <entry>
                                    <para>Имя входного или выходного параметра процедуры. Может
                                        содержать до 63 символов. Имя параметра должно быть
                                        уникальным среди входных и  выходных параметров процедуры, а
                                        также её локальных переменных. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>module name</replaceable></entry>
                                <entry>
                                    <para>Имя внешнего модуля, в котором расположена функция.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>routine name</replaceable></entry>
                                <entry>
                                    <para>Внутреннее имя функции внутри внешнего модуля. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>misc info</replaceable></entry>
                                <entry>
                                    <para>Определяемая пользователем информация для передачи в
                                        функцию внешнего модуля. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>engine</replaceable></entry>
                                <entry>
                                    <para>Имя движка для использования внешних функций. Обычно
                                        указывается имя UDR. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>datatype</replaceable></entry>
                                <entry>
                                    <para>Тип данных SQL.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Порядок сортировки.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>domain</replaceable></entry>
                                <entry>
                                    <para>Домен.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>rel</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы или представления. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>col</replaceable></entry>
                                <entry>
                                    <para>Имя столбца таблицы или представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Общее количество значащих цифр, которое способен сохранить
                                        параметр (от 1 до 18).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>scale</replaceable></entry>
                                <entry>
                                    <para>Количество цифр после десятичной точки. От 0 до 18, должно
                                        быть меньше или равно
                                        <replaceable>precision</replaceable>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>size</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер строки в символах.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Набор символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_num</replaceable></entry>
                                <entry>
                                    <para>Номер подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_name</replaceable></entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>seqlen</replaceable></entry>
                                <entry>
                                    <para>Размер сегмента, не может превышать 65535. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор CREATE PROCEDURE создаёт новую хранимую процедуру. Имя хранимой процедуры
                должно быть уникальным среди имён всех хранимых процедур, таблиц и представлений
                базы данных. </para>
            <note>
                <para>Желательно также, чтобы имя хранимой процедуры было уникальным и среди имён
                    процедур расположенных в PSQL пакетах (package), хотя это и допустимо. Дело в
                    том, что в настоящее время вы не сможете вызвать функцию/процедуру из
                    глобального пространства имён внутри пакета, если в пакете объявлена одноименная
                    функция/процедура. В этом случае всегда будет вызвана процедура/функция пакета.
                </para>
            </note>
            <para>CREATE PROCEDURE является составным оператором, состоящий из заголовка и тела. </para>
            <para>Заголовок определяет имя хранимой процедуры и объявляет входные и выходные
                параметры, если они должны быть возвращены процедурой.</para>
            <para>Тело процедуры состоит из необязательных объявлений локальных переменных,
                подпрограмм и именованных курсоров, и одного или нескольких операторов, или блоков
                операторов, заключённых во внешнем блоке, который начинается с ключевого слова
                BEGIN, и завершается ключевым словом END. Объявления локальных переменных и
                именованных курсоров, а также внутренние операторы должны завершаться точкой с
                запятой (;).</para>
            <section xml:id="ddl-procedure-term">
                <title>Терминатор оператора</title>

                <para>Некоторые редакторы SQL-операторов — в частности утилита
                        <application>isql</application>, которая идёт в комплекте с Firebird, и
                    возможно некоторые сторонние редакторы — используют внутреннее соглашение,
                    которое требует, чтобы все операторы были завершены с точкой с запятой.</para>
                <para>Это создает конфликт с синтаксисом PSQL при кодировании в этих средах. Если вы
                    не знакомы с этой проблемой и её решением, пожалуйста, изучите детали в главе
                    PSQL в разделе, озаглавленном <link linkend="psql-setterm">Изменение терминатора
                        в <application>isql</application></link>.</para>

            </section>
            <section xml:id="ddl-procedure-create-params">
                <title>Параметры</title>
                <para>У каждого параметра указывается тип данных. Кроме того, для параметра можно
                    указать ограничение NOT NULL, тем самым запретив передавать в него значение
                    NULL.</para>
                <para>Для параметра строкового типа существует возможность задать порядок сортировки
                    с помощью предложения COLLATE.</para>

                <section xml:id="ddl-procedure-create-params-in">
                    <title>Входные параметры</title>
                    <para>Входные параметры заключаются в скобки после имени хранимой процедуры. Они
                        передаются в процедуру по значению, то есть любые изменения входных
                        параметров внутри процедуры никак не повлияет на значения этих параметров в
                        вызывающей программе.</para>
                    <para>Входные параметры могут иметь значение по умолчанию. Параметры, для
                        которых заданы значения, должны располагаться в конце списка
                        параметров.</para>
                </section>

                <section xml:id="ddl-procedure-create-params-out">
                    <title>Выходные параметры</title>
                    <para>Необязательное предложение RETURNS позволяет задать список выходных
                        параметров хранимой процедуры.</para>
                </section>

                <section xml:id="ddl-procedure-create-params-domain">
                    <title>Использование доменов при объявлении параметров</title>
                    <para>В качестве типа параметра можно указать имя домена. В этом случае,
                        параметр будет наследовать все характеристики домена.</para>
                    <para>Если перед названием домена дополнительно используется предложение
                            <database>TYPE OF</database>, то используется только тип данных домена —
                        не проверяется (не используется) его ограничение (если оно есть в домене) на
                        NOT NULL, CHECK ограничения и/или значения по умолчанию. Если домен
                        текстового типа, то всегда используется его набор символов и порядок
                        сортировки.</para>
                </section>
                <section xml:id="ddl-procedure-create-params-typeofcolumn">
                    <title>Использование типа столбца при объявлении параметров</title>
                    <para>Входные и выходные параметры можно объявлять, используя тип данных
                        столбцов существующих таблиц и представлений. Для этого используется
                        предложение <database>TYPE OF COLUMN</database>, после которого указывается
                        имя таблицы или представления и через точку имя столбца.</para>
                    <para>При использовании <database>TYPE OF COLUMN</database> наследуется только
                        тип данных, а в случае строковых типов ещё и набор символов, и порядок
                        сортировки. Ограничения и значения по умолчанию столбца никогда не
                        используются. </para>
                </section>
            </section>
            <section xml:id="ddl-procedure-create-sql_security">
                <title>Контекст безопасности</title>
                <indexterm>
                    <primary>CREATE PROCEDURE</primary>
                    <secondary>SQL SECURITY</secondary>
                </indexterm>
                <para>Необязательное предложение SQL SECURITY позволяет задать с какими привилегиями
                    выполняется хранимая процедура. Если выбрана опция INVOKER, то хранимая
                    процедура выполняется с привилегиями вызывающего пользователя. Если выбрана
                    опция DEFINER, то хранимая процедура выполняется с привилегиями определяющего
                    пользователя (владельца ХП). Эти привилегии будут дополнены привилегиями
                    выданные самой хранимой процедуре с помощью оператора GRANT. По умолчанию
                    хранимая процедура выполняется с привилегиями вызывающего пользователя.</para>
                <tip>
                    <para>Контекст безопасности по умолчанию для вновь создаваемых объектов
                        метаданных можно изменить с помощью оператора
                        <programlisting>
ALTER DATABASE SET DEFAULT SQL SECURITY {DEFINER | INVOKER}
                </programlisting>
                    </para>
                </tip>
            </section>
            <section xml:id="ddl-procedure-create-body">
                <title>Тело хранимой процедуры</title>
                <para>После ключевого слова AS следует тело хранимой процедуры.</para>
                <section xml:id="ddl-procedure-create-declare">
                    <title>Объявление локальных переменных, курсоров и подпрограмм</title>
                    <para>В необязательной секции <replaceable>declarations</replaceable> описаны
                        локальные переменные процедуры, подпрограммы и именованные курсоры. В
                        отношении спецификации типа данных локальные переменные подчиняются тем же
                        правилам, что и входные и выходные параметры процедуры. Подробности вы
                        можете посмотреть в главе <quote>Процедурный язык PSQL</quote> в разделах
                            <link linkend="psql-operators-declare-var">DECLARE VARIABLE</link> и
                            <link linkend="psql-operators-declare-cursor">DECLARE CURSOR</link>,
                            <link linkend="psql-operators-declare-procedure">DECLARE
                            PROCEDURE</link>, <link linkend="psql-operators-declare-function"
                            >DECLARE FUNCTION</link>.</para>
                    <para>После необязательной секции деклараций обязательно следует составной
                        оператор. Составной оператор состоит из одного или нескольких PSQL
                        операторов, заключенных между ключевыми словами BEGIN и END. Составной
                        оператор может содержать один или несколько других составных операторов.
                        Вложеность ограничена 512 уровнями. Любой из BEGIN ... END блоков может быть
                        пустым, в том числе и главный блок.</para>
                </section>
            </section>
            <section xml:id="ddl-procedure-create-external">
                <title>Внешние хранимые процедуры</title>

                <indexterm>
                    <primary>CREATE PROCEDURE</primary>
                    <secondary>EXTERNAL NAME</secondary>
                </indexterm>
                <indexterm>
                    <primary>CREATE PROCEDURE</primary>
                    <secondary>ENGINE</secondary>
                </indexterm>
                <para>Хранимая процедура может быть расположена во внешнем модуле. В этом случае
                    вместо тела процедуры указывается место её расположения во внешнем модуле с
                    помощью предложения EXTERNAL NAME. Аргументом этого предложения является строка,
                    в которой через разделитель указано имя внешнего модуля, имя процедуры внутри
                    модуля и определённая пользователем информация. В предложении ENGINE указывается
                    имя движка для обработки подключения внешних модулей. В Firebird для работы с
                    внешними модулями используется движок UDR. </para>
            </section>
            <section xml:id="ddl-procedure-create-who">
                <title>Кто может создать хранимую процедуру?</title>

                <para>Выполнить оператор <database>CREATE PROCEDURE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE PROCEDURE</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший хранимую процедуру, становится её владельцем.</para>
            </section>
            <section xml:id="ddl-procedure-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание хранимой процедуры</title>
                    <para><programlisting language="sql">
CREATE PROCEDURE ADD_BREED (
  NAME D_BREEDNAME, /* Наследуются характеристики домена */
  NAME_EN TYPE OF D_BREEDNAME, /* Наследуется только тип домена */
  SHORTNAME TYPE OF COLUMN BREED.SHORTNAME, /* Наследуется тип столбца таблицы */
  REMARK VARCHAR(120) CHARACTER SET WIN1251 COLLATE PXW_CYRL,
  CODE_ANIMAL INT NOT NULL DEFAULT 1
)
RETURNS (
  CODE_BREED INT
)
AS
BEGIN
  INSERT INTO BREED (
    CODE_ANIMAL, NAME, NAME_EN, SHORTNAME, REMARK)
  VALUES (
    :CODE_ANIMAL, :NAME, :NAME_EN, :SHORTNAME, :REMARK)
  RETURNING CODE_BREED INTO CODE_BREED;
END                  
                </programlisting></para>
                    <para>Тоже самое, но процедура будет выполнятся с правами определяющего
                        пользователя (владельца процедуры).</para>
                    <para><programlisting language="sql">
CREATE PROCEDURE ADD_BREED (
  NAME D_BREEDNAME, /* Наследуются характеристики домена */
  NAME_EN TYPE OF D_BREEDNAME, /* Наследуется только тип домена */
  SHORTNAME TYPE OF COLUMN BREED.SHORTNAME, /* Наследуется тип столбца таблицы */
  REMARK VARCHAR(120) CHARACTER SET WIN1251 COLLATE PXW_CYRL,
  CODE_ANIMAL INT NOT NULL DEFAULT 1
)
RETURNS (
  CODE_BREED INT
)
SQL SECURITY DEFINER
AS
BEGIN
  INSERT INTO BREED (
    CODE_ANIMAL, NAME, NAME_EN, SHORTNAME, REMARK)
  VALUES (
    :CODE_ANIMAL, :NAME, :NAME_EN, :SHORTNAME, :REMARK)
  RETURNING CODE_BREED INTO CODE_BREED;
END                  
                </programlisting></para>
                </example>
                <example>
                    <title>Создание внешней хранимой процедуры</title>
                    <para>Создание процедуры находящейся во внешнем модуле (UDR). Реализация
                        процедуры расположена во внешнем модуле udrcpp_example. Имя процедуры внутри
                        модуля —
                        gen_rows.<programlisting language="sql">
CREATE PROCEDURE gen_rows (
    start_n INTEGER NOT NULL,
    end_n INTEGER NOT NULL
) RETURNS (
    n INTEGER NOT NULL
)
    EXTERNAL NAME 'udrcpp_example!gen_rows'
    ENGINE udr;           
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-procedure-createoralter">CREATE OR ALTER
                        PROCEDURE</link>, <link linkend="ddl-procedure-alter">ALTER
                        PROCEDURE</link>, <link linkend="ddl-procedure-recreate">RECREATE
                            PROCEDURE</link>, <link linkend="ddl-procedure-drop">DROP
                            PROCEDURE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-procedure-alter">
            <info>
                <title>ALTER PROCEDURE</title>
                <keywordset>
                    <keyword>ALTER PROCEDURE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER PROCEDURE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение существующей хранимой процедуры.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
ALTER PROCEDURE <replaceable>procname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])                           
<replaceable>&lt;routine body&gt;</replaceable>  
                       </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Подробнее см.</title>

                <para>
                    <link linkend="ddl-procedure-create">CREATE PROCEDURE</link>. </para>
            </formalpara>

            <para>Оператор ALTER PROCEDURE позволяет изменять состав и характеристики входных и
                выходных параметров, локальных переменных, именованных курсоров и тело хранимой
                процедуры. Для внешних процедур (UDR) вы можете изменить точку входа и имя движка.
                После выполнения существующие привилегии и зависимости сохраняются. </para>
            <warning>
                <para>Будьте осторожны при изменении количества и типов входных и выходных
                    параметров хранимых процедур. Существующий код приложения может стать
                    неработоспособным из-за того, что формат вызова процедуры несовместим с новым
                    описанием параметров. Кроме того, PSQL модули, использующие изменённую хранимую
                    процедуру, могут стать некорректными. Информация о том, как это обнаружить,
                    находится в приложении <link linkend="valid">Поле RDB$VALID_BLR</link>. </para>
            </warning>
            <section xml:id="ddl-procedure-alter-who">
                <title>Кто может изменить хранимую процедуру?</title>

                <para>Выполнить оператор <database>ALTER PROCEDURE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец хранимой процедуры; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY
                                    PROCEDURE</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-procedure-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Изменение хранимой процедуры</title>
                    <para><programlisting language="sql">
ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END                
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-procedure-create">CREATE PROCEDURE</link>, <link
                            linkend="ddl-procedure-createoralter">CREATE OR ALTER PROCEDURE</link>,
                            <link linkend="ddl-procedure-recreate">RECREATE PROCEDURE</link>, <link
                            linkend="ddl-procedure-drop">DROP PROCEDURE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-procedure-createoralter">
            <info>
                <title>CREATE OR ALTER PROCEDURE</title>
                <keywordset>
                    <keyword>CREATE OR ALTER PROCEDURE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE OR ALTER PROCEDURE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой или изменение существующей хранимой процедуры.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE OR ALTER PROCEDURE <replaceable>procname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])                        
<replaceable>&lt;routine body&gt;</replaceable>   
                       </programlisting></para>
            </formalpara>
            <formalpara>
                <title>Подробнее см.</title>

                <para>
                    <link linkend="ddl-procedure-create">CREATE PROCEDURE</link>. </para>
            </formalpara>

            <para>Оператор CREATE OR ALTER PROCEDURE создаёт новую или изменяет существующую
                хранимую процедуру. Если хранимая процедура не существует, то она будет создана с
                использованием предложения CREATE PROCEDURE. Если она уже существует, то она будет
                изменена и откомпилирована, при этом существующие привилегии и зависимости
                сохраняются. </para>

            <section xml:id="ddl-procedure-createoralter-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание или изменение хранимой процедуры </title>
                    <para><programlisting language="sql">
CREATE OR ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END                
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-procedure-create">CREATE PROCEDURE</link>, <link
                            linkend="ddl-procedure-alter">ALTER PROCEDURE</link>, <link
                            linkend="ddl-procedure-recreate">RECREATE PROCEDURE</link>, <link
                            linkend="ddl-procedure-drop">DROP PROCEDURE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-procedure-drop">
            <info>
                <title>DROP PROCEDURE</title>
                <keywordset>
                    <keyword>DROP PROCEDURE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP PROCEDURE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление существующей хранимой процедуры.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
DROP PROCEDURE <replaceable>procname</replaceable>  
                       </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP PROCEDURE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>procname</replaceable></entry>
                                <entry>Имя хранимой процедуры.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DROP PROCEDURE удаляет существующую хранимую процедуру. Если от хранимой
                процедуры существуют зависимости, то при попытке удаления такой процедуру будет
                выдана соответствующая ошибка. </para>
            <section xml:id="ddl-procedure-drop-who">
                <title>Кто может удалить хранимую процедуру?</title>

                <para>Выполнить оператор <database>DROP PROCEDURE</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец хранимой процедуры; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY
                                PROCEDURE</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-procedure-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление хранимой процедуры </title>
                    <para><programlisting language="sql">
DROP PROCEDURE GET_EMP_PROJ;               
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-procedure-create">CREATE PROCEDURE</link>, <link
                            linkend="ddl-procedure-recreate">RECREATE PROCEDURE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-procedure-recreate">
            <info>
                <title>RECREATE PROCEDURE</title>
                <keywordset>
                    <keyword>RECREATE PROCEDURE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>RECREATE PROCEDURE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой или пересоздание существующей хранимой процедуры.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
RECREATE PROCEDURE <replaceable>procname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])                        
<replaceable>&lt;routine body&gt;</replaceable> 
                       </programlisting></para>
            </formalpara>
            <formalpara>
                <title>Подробнее см.</title>

                <para>
                    <link linkend="ddl-procedure-create">CREATE PROCEDURE</link>. </para>
            </formalpara>

            <para>Оператор RECREATE PROCEDURE создаёт новую или пересоздаёт существующую хранимую
                процедуру. Если процедура с таким именем уже существует, то оператор попытается
                удалить её и создать новую процедуру. Операция закончится неудачей при подтверждении
                транзакции, если процедура имеет зависимости.</para>
            <note>
                <para>Имейте ввиду, что ошибки зависимостей не обнаруживаются до фазы подтверждения
                    транзакции.</para>
            </note>
            <para>После пересоздания процедуры привилегии на выполнение хранимой процедуры и
                привилегии самой хранимой процедуры не сохраняются. </para>

            <section xml:id="ddl-procedure-recreate-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание новой или пересоздание существующей хранимой процедуры</title>
                    <para><programlisting language="sql">
RECREATE PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END              
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-procedure-create">CREATE PROCEDURE</link>, <link
                            linkend="ddl-procedure-createoralter">CREATE OR ALTER PROCEDURE</link>,
                            <link linkend="ddl-procedure-drop">DROP PROCEDURE</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-function">
        <info>
            <title>FUNCTION</title>
            <keywordset>
                <keyword>FUNCTION</keyword>
            </keywordset>
        </info>
        <para>Хранимая функция является программой, хранящейся в области метаданных базы данных и
            выполняющейся на стороне сервера. К хранимой функции могут обращаться хранимые
            процедуры, хранимые функции (в том числе и сама к себе), триггеры и клиентские
            программы. При обращении хранимой функции самой к себе такая хранимая функция называется
            рекурсивной. </para>
        <para>В отличие от хранимых процедур хранимые функции всегда возвращают одно скалярное
            значение. Для возврата значения из хранимой функции используется оператор RETURN,
            который немедленно прекращает выполнение функции.</para>
        <section xml:id="ddl-function-create">
            <info>
                <title>CREATE FUNCTION</title>
                <keywordset>
                    <keyword>CREATE FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой хранимой функции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> 
[(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>]  
[DETERMINISTIC]  
<replaceable>&lt;routine body&gt;</replaceable> 
  
<replaceable>&lt;inparam&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [{= | DEFAULT} <replaceable>&lt;value&gt;</replaceable>]  
                    
<replaceable>&lt;value&gt;</replaceable> ::=  {<replaceable>literal</replaceable> | NULL | <replaceable>context_var</replaceable>} 
                    
<replaceable>&lt;param_decl&gt;</replaceable> ::= <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
                    
<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'    

<replaceable>&lt;type&gt;</replaceable> ::= <replaceable>&lt;datatype&gt;</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable> 
                    
<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} 
  | BOOLEAN 
  | {FLOAT | DOUBLE PRECISION} 
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])]                     

<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
  <replaceable>&lt;declare_var&gt;</replaceable>; |      
  <replaceable>&lt;declare_cursor&gt;</replaceable>; |     
  <replaceable>&lt;declare_subfunc&gt;</replaceable> |     
  <replaceable>&lt;declare_subproc&gt;</replaceable> 

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> 

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]' 
                    
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE FUNCTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>funcname</replaceable></entry>
                                <entry>
                                    <para>Имя хранимой функции. Может содержать до 63
                                        символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>inparam</replaceable></entry>
                                <entry>
                                    <para>Описание входного параметра.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declarations</replaceable></entry>
                                <entry>
                                    <para>Секция объявления локальных переменных, именованных
                                        курсоров, подпроцедур и подфункций.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_var</replaceable></entry>
                                <entry>
                                    <para>Объявление локальной переменной. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_cursor</replaceable></entry>
                                <entry>
                                    <para>Объявление именованного курсора. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_subfunc</replaceable></entry>
                                <entry>
                                    <para>Объявление подпрограммы – функции.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declare_subproc</replaceable></entry>
                                <entry>
                                    <para>Объявление подпрограммы – процедуры. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>literal</replaceable></entry>
                                <entry>
                                    <para>Литерал, совместимый по типу с параметром.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>context_var</replaceable></entry>
                                <entry>
                                    <para>Любая контекстная переменная, тип которой совместим с
                                        типом параметра. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>paramname</replaceable></entry>
                                <entry>
                                    <para>Имя входного параметра функции. Может содержать до 63
                                        символов. Имя параметра должно быть уникальным среди входных
                                        параметров функции, а также её локальных переменных. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>module name</replaceable></entry>
                                <entry>
                                    <para>Имя внешнего модуля, в котором расположена функция.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>routine name</replaceable></entry>
                                <entry>
                                    <para>Внутреннее имя функции внутри внешнего модуля. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>misc info</replaceable></entry>
                                <entry>
                                    <para>Определяемая пользователем информация для передачи в
                                        функцию внешнего модуля. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>engine</replaceable></entry>
                                <entry>
                                    <para>Имя движка для использования внешних функций. Обычно
                                        указывается имя UDR. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>datatype</replaceable></entry>
                                <entry>
                                    <para>Тип данных SQL.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Порядок сортировки.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>domain</replaceable></entry>
                                <entry>
                                    <para>Домен.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>rel</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы или представления. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>col</replaceable></entry>
                                <entry>
                                    <para>Имя столбца таблицы или представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Общее количество значащих цифр, которое способен сохранить
                                        параметр (от 1 до 18).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>scale</replaceable></entry>
                                <entry>
                                    <para>Количество цифр после десятичной точки. От 0 до 18, должно
                                        быть меньше или равно
                                        <replaceable>precision</replaceable>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>size</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер строки в символах.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Набор символов. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_num</replaceable></entry>
                                <entry>
                                    <para>Номер подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_name</replaceable></entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>seqlen</replaceable></entry>
                                <entry>
                                    <para>Размер сегмента, не может превышать 65535. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор <database>CREATE FUNCTION</database> создаёт новую хранимую функцию. Имя
                хранимой функции должно быть уникальным среди имён всех хранимых функций и внешних
                (UDF) функций. Если только это не внутренняя функция (<quote>подпрограмма</quote>).
                Для внутренних функций достаточно уникальности только в рамках модулей, которые их
                    <quote>охватывают</quote>. </para>
            <note>
                <para>Желательно также, чтобы имя хранимой функции было уникальным и среди имён
                    функций расположенных в PSQL пакетах (package), хотя это и допустимо. Дело в
                    том, что в настоящее время вы не сможете вызвать функцию/процедуру из
                    глобального пространства имён внутри пакета, если в пакете объявлена одноименная
                    функция/процедура. В этом случае всегда будет вызвана процедура/функция пакета.
                </para>
            </note>
            <para><database>CREATE FUNCTION</database> является составным оператором, состоящий из
                заголовка и тела. Заголовок определяет имя хранимой функции, объявляет входные
                параметры и тип возвращаемого значения. </para>
            <para>Тело функции состоит из необязательных объявлений локальных переменных,
                подпрограмм и именованных курсоров, и одного или нескольких операторов, или блоков
                операторов, заключённых во внешнем блоке, который начинается с ключевого слова
                BEGIN, и завершается ключевым словом END. Объявления локальных переменных и
                именованных курсоров, а также внутренние операторы должны завершаться точкой с
                запятой (;).</para>
            <section xml:id="ddl-function-term">
                <title>Терминатор оператора</title>

                <para>Некоторые редакторы SQL-операторов — в частности утилита
                        <application>isql</application>, которая идёт в комплекте с Firebird, и
                    возможно некоторые сторонние редакторы — используют внутреннее соглашение,
                    которое требует, чтобы все операторы были завершены с точкой с запятой.</para>
                <para>Это создает конфликт с синтаксисом PSQL при кодировании в этих средах. Если вы
                    не знакомы с этой проблемой и её решением, пожалуйста, изучите детали в главе
                    PSQL в разделе, озаглавленном <link linkend="psql-setterm">Изменение терминатора
                        в <application>isql</application></link>.</para>

            </section>
            <section xml:id="ddl-function-create-params">
                <title>Входные параметры</title>
                <para>Входные параметры заключаются в скобки после имени хранимой функции. Они
                    передаются в функцию по значению, то есть любые изменения входных параметров
                    внутри функции никак не повлияет на значения этих параметров в вызывающей
                    программе.</para>
                <para>У каждого параметра указывается тип данных. Кроме того, для параметра можно
                    указать ограничение NOT NULL, тем самым запретив передавать в него значение
                    NULL.</para>
                <para>Для параметра строкового типа существует возможность задать порядок сортировки
                    с помощью предложения COLLATE.</para>
                <para>Входные параметры могут иметь значение по умолчанию. Параметры, для которых
                    заданы значения, должны располагаться в конце списка параметров.</para>
            </section>

            <section xml:id="ddl-function-create-domain">
                <title>Использование доменов при объявлении параметров</title>
                <para>В качестве типа параметра можно указать имя домена. В этом случае, параметр
                    будет наследовать все характеристики домена.</para>
                <para>Если перед названием домена дополнительно используется предложение
                        <database>TYPE OF</database>, то используется только тип данных домена — не
                    проверяется (не используется) его ограничение (если оно есть в домене) на NOT
                    NULL, CHECK ограничения и/или значения по умолчанию. Если домен текстового типа,
                    то всегда используется его набор символов и порядок сортировки.</para>
            </section>
            <section xml:id="ddl-function-create-typeofcolumn">
                <title>Использование типа столбца при объявлении параметров</title>
                <para>Входные и выходные параметры можно объявлять, используя тип данных столбцов
                    существующих таблиц и представлений. Для этого используется предложение TYPE OF
                    COLUMN, после которого указывается имя таблицы или представления и через точку
                    имя столбца.</para>
                <para>При использовании <database>TYPE OF COLUMN</database> наследуется только тип
                    данных, а в случае строковых типов ещё и набор символов, и порядок сортировки.
                    Ограничения и значения по умолчанию столбца никогда не используются. </para>
            </section>

            <section xml:id="ddl-function-create-return">
                <title>Возвращаемое значение</title>
                <indexterm>
                    <primary>CREATE FUNCTION</primary>
                    <secondary>RETURNS</secondary>
                </indexterm>
                <para>Предложение <database>RETURNS</database> задаёт тип возвращаемого значения
                    хранимой функции. Если функция возвращает значение строкового типа, то
                    существует возможность задать порядок сортировки с помощью предложения COLLATE.
                    В качестве типа выходного значения можно указать имя домена, ссылку на его тип
                    (с помощью предложения <database>TYPE OF</database>) или ссылку на тип столбца
                    таблицы (с помощью предложения <database>TYPE OF COLUMN</database>). </para>
            </section>

            <section xml:id="ddl-function-create-deterministic">
                <title>Детерминированные функции</title>
                <indexterm>
                    <primary>CREATE FUNCTION</primary>
                    <secondary>DETERMINISTIC</secondary>
                </indexterm>
                <para>Необязательное предложение <database>DETERMINISTIC</database> указывает, что
                    функция детерминированная. Детерминированные функции каждый раз возвращают один
                    и тот же результат, если предоставлять им один и тот же набор входных значений.
                    Недетерминированные функции могут возвращать каждый раз разные результаты, даже
                    если предоставлять им один и тот же набор входных значений. Если для функции
                    указано, что она является детерминированной, то такая функция не вычисляется
                    заново, если она уже была вычислена однажды с данным набором входных аргументов,
                    а берет свои значения из кэша метаданных (если они там есть). </para>
                <note>
                    <para>На самом деле в текущей версии Firebird, не существует кэша хранимых
                        функций с маппингом входных аргументов на выходные значения. </para>
                    <para>Указание инструкции <database>DETERMINISTIC</database> на самом деле нечто
                        вроде <quote>обещания</quote>, что код функции будет возвращать одно и то
                        же. В данный момент детерминистическая функция считается инвариантом и
                        работает по тем же принципам, что и другие инварианты. Т.е. вычисляется и
                        кэшируется на уровне текущего выполнения данного запроса. </para>
                    <para>Это легко демонстрируется таким примером:
                        <programlisting language="sql">
CREATE FUNCTION FN_T
RETURNS DOUBLE PRECISION DETERMINISTIC
AS
BEGIN
  RETURN rand();
END

-- функция будет вычислена дважды и вернёт 2 разных значения
SELECT fn_t() FROM rdb$database
UNION ALL
SELECT fn_t() FROM rdb$database

-- функция будет вычислена единожды и вернёт 2 одинаковых значения
WITH t(n) AS (
  SELECT 1 FROM rdb$database
  UNION ALL
  SELECT 2 FROM rdb$database
)
SELECT n, fn_t() FROM t 
                       </programlisting>
                    </para>
                </note>
            </section>

            <section xml:id="ddl-function-create-sql_security">
                <title>Контекст безопасности</title>
                <indexterm>
                    <primary>CREATE FUNCTION</primary>
                    <secondary>SQL SECURITY</secondary>
                </indexterm>
                <para>Необязательное предложение SQL SECURITY позволяет задать с какими привилегиями
                    выполняется хранимая функция. Если выбрана опция INVOKER, то хранимая функция
                    выполняется с привилегиями вызывающего пользователя. Если выбрана опция DEFINER,
                    то хранимая функция выполняется с привилегиями определяющего пользователя
                    (владельца функции). Эти привилегии будут дополнены привилегиями выданные самой
                    хранимой функции с помощью оператора GRANT. По умолчанию хранимая функция
                    выполняется с привилегиями вызывающего пользователя.</para>
                <tip>
                    <para>Контекст безопасности по умолчанию для вновь создаваемых объектов
                        метаданных можно изменить с помощью оператора
                        <programlisting>
ALTER DATABASE SET DEFAULT SQL SECURITY {DEFINER | INVOKER}
                </programlisting>
                    </para>
                </tip>
            </section>

            <section xml:id="ddl-function-create-body">
                <title>Тело хранимой функции</title>
                <para>После ключевого слова AS следует тело хранимой функции.</para>
                <section xml:id="ddl-function-create-declare">
                    <title>Объявление локальных переменных, курсоров и подпрограмм</title>
                    <para>В необязательной секции <replaceable>declarations</replaceable> описаны
                        локальные переменные функции, именованные курсоры и подпрограммы
                        (подпроцедуры и подфункции). Локальные переменные подчиняются тем же
                        правилам что и входные параметры функции в отношении спецификации типа
                        данных. Подробности вы можете посмотреть в главе <quote>Процедурный язык
                            PSQL</quote> в разделах <link linkend="psql-operators-declare-var"
                            >DECLARE VARIABLE</link> и <link linkend="psql-operators-declare-cursor"
                            >DECLARE CURSOR</link>, <link linkend="psql-operators-declare-procedure"
                            >DECLARE PROCEDURE</link>, <link
                            linkend="psql-operators-declare-function">DECLARE
                        FUNCTION</link>.</para>
                    <para>После необязательной секции деклараций обязательно следует составной
                        оператор. Составной оператор состоит из одного или нескольких PSQL
                        операторов, заключенных между ключевыми словами BEGIN и END. Составной
                        оператор может содержать один или несколько других составных операторов.
                        Вложеность ограничена 512 уровнями. Любой из BEGIN ... END блоков может быть
                        пустым, в том числе и главный блок.</para>
                </section>
            </section>

            <section xml:id="ddl-function-create-external">
                <title>Внешние функции</title>
                <indexterm>
                    <primary>CREATE FUNCTION</primary>
                    <secondary>EXTERNAL NAME</secondary>
                </indexterm>
                <indexterm>
                    <primary>CREATE FUNCTION</primary>
                    <secondary>ENGINE</secondary>
                </indexterm>
                <para>Хранимая функция может быть расположена во внешнем модуле. В этом случае
                    вместо тела функции указывается место расположения функции во внешнем модуле с
                    помощью предложения EXTERNAL NAME. Аргументом этого предложения является строка,
                    в которой через разделитель указано имя внешнего модуля, имя функции внутри
                    модуля и определённая пользователем информация. В предложении ENGINE указывается
                    имя движка для обработки подключения внешних модулей. В Firebird для работы с
                    внешними модулями используется движок UDR. </para>
                <warning>
                    <para>Не следует путать внешние функции, объявленные как DECLARE EXTERNAL
                        FUNCTION, так же известные как UDF, с функциями расположенными во внешних
                        модулях объявленных как CREATE FUNCTION ... EXTERNAL NAME, называемых UDR
                        (User Defined Routine). Первые являются унаследованными (Legacy) из
                        предыдущих версий Firebird. Их возможности существенно уступают возможностям
                        нового типа внешних функций. </para>
                </warning>
            </section>
            <section xml:id="ddl-function-create-who">
                <title>Кто может создать функцию?</title>

                <para>Выполнить оператор <database>CREATE FUNCTION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE FUNCTION</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший хранимую функцию, становится её владельцем.</para>
            </section>
            <section xml:id="ddl-function-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание хранимой функции</title>
                    <para><programlisting language="sql">
CREATE FUNCTION ADD_INT(A INT, B INT DEFAULT 0) 
RETURNS INT
AS
BEGIN
  RETURN A+B;
END            
                </programlisting></para>
                    <para>Вызов в запросе:
                        <programlisting language="sql">
SELECT ADD_INT(2, 3) AS R FROM RDB$DATABASE          
                </programlisting></para>
                    <para>Вызов внутри PSQL кода, второй необязательный параметр не
                        указан:<programlisting language="sql">
MY_VAR = ADD_INT(A);         
                </programlisting></para>
                </example>
                <example>
                    <title>Создание детерминистической хранимой функции</title>
                    <para><programlisting language="sql">
CREATE FUNCTION FN_E() 
RETURNS DOUBLE PRECISION DETERMINISTIC
AS
BEGIN
  RETURN EXP(1);
END            
                </programlisting></para>
                </example>
                <example>
                    <title>Создание хранимой функции с параметрами типа столбца таблицы</title>
                    <para>Функция, возвращающая имя мнемоники по имени столбца и значения
                        мнемоники.<programlisting language="sql">
CREATE FUNCTION GET_MNEMONIC ( 
    AFIELD_NAME TYPE OF COLUMN RDB$TYPES.RDB$FIELD_NAME, 
    ATYPE TYPE OF COLUMN RDB$TYPES.RDB$TYPE) 
RETURNS TYPE OF COLUMN RDB$TYPES.RDB$TYPE_NAME 
AS 
BEGIN 
  RETURN (SELECT RDB$TYPE_NAME 
          FROM RDB$TYPES 
          WHERE RDB$FIELD_NAME = :AFIELD_NAME 
            AND RDB$TYPE = :ATYPE); 
END           
                </programlisting></para>
                    <para>Тоже самое, но хранимая функция будет выполняться с привилегиями
                        определяющего пользователя (владельца функции).
                        <programlisting language="sql">
CREATE FUNCTION GET_MNEMONIC ( 
    AFIELD_NAME TYPE OF COLUMN RDB$TYPES.RDB$FIELD_NAME, 
    ATYPE TYPE OF COLUMN RDB$TYPES.RDB$TYPE) 
RETURNS TYPE OF COLUMN RDB$TYPES.RDB$TYPE_NAME 
SQL SECURITY DEFINER
AS 
BEGIN 
  RETURN (SELECT RDB$TYPE_NAME 
          FROM RDB$TYPES 
          WHERE RDB$FIELD_NAME = :AFIELD_NAME 
            AND RDB$TYPE = :ATYPE); 
END           
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание внешней хранимой функции</title>
                    <para>Создание функции находящейся во внешнем модуле (UDR). Реализация функции
                        расположена во внешнем модуле udrcpp_example. Имя функции внутри модуля —
                        wait_event.<programlisting language="sql">
CREATE FUNCTION wait_event (
   event_name varchar(63) CHARACTER SET ascii
) RETURNS INTEGER
EXTERNAL NAME 'udrcpp_example!wait_event'
ENGINE udr           
                </programlisting></para>
                </example>
                <example>
                    <title>Создание хранимой функции содержащую подфункцию</title>
                    <para>Создание функции для перевода числа в 16-ричный формат.
                        <programlisting language="sql">
CREATE FUNCTION INT_TO_HEX (
    ANumber BIGINT,
    AByte_Per_Number SMALLINT = 8)
RETURNS CHAR(66)
AS
DECLARE VARIABLE xMod SMALLINT;
DECLARE VARIABLE xResult VARCHAR(64);
DECLARE FUNCTION TO_HEX(ANum SMALLINT) RETURNS CHAR
AS
BEGIN
  RETURN CASE ANum
           WHEN 0 THEN '0'
           WHEN 1 THEN '1'
           WHEN 2 THEN '2'
           WHEN 3 THEN '3'
           WHEN 4 THEN '4'
           WHEN 5 THEN '5'
           WHEN 6 THEN '6'
           WHEN 7 THEN '7'
           WHEN 8 THEN '8'
           WHEN 9 THEN '9'
           WHEN 10 THEN 'A'
           WHEN 11 THEN 'B'
           WHEN 12 THEN 'C'
           WHEN 13 THEN 'D'
           WHEN 14 THEN 'E'
           WHEN 15 THEN 'F'
           ELSE NULL
         END;
END
BEGIN
  xMod = MOD(ANumber, 16);
  ANumber = ANumber / 16;
  xResult = TO_HEX(xMod);
  WHILE (ANUMBER > 0) DO
  BEGIN
    xMod = MOD(ANumber, 16);
    ANumber = ANumber / 16;
    xResult = TO_HEX(xMod) || xResult;
  END
  RETURN '0x' || LPAD(xResult, AByte_Per_Number * 2, '0');
END          
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-function-createoralter">CREATE OR ALTER FUNCTION</link>,
                            <link linkend="ddl-function-alter">ALTER FUNCTION</link>, <link
                            linkend="ddl-function-recreate">RECREATE FUNCTION</link>, <link
                            linkend="ddl-function-drop">DROP FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-function-alter">
            <info>
                <title>ALTER FUNCTION</title>
                <keywordset>
                    <keyword>ALTER FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение существующей хранимой функции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
ALTER FUNCTION <replaceable>funcname</replaceable> 
[(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>]      
[DETERMINISTIC]
<replaceable>&lt;routine body&gt;</replaceable>   
                       </programlisting></para>
            </formalpara>
            <formalpara>
                <title>Подробнее см.</title>

                <para>
                    <link linkend="ddl-function-create">CREATE FUNCTION</link>. </para>
            </formalpara>

            <para>Оператор ALTER FUNCTION позволяет изменять состав и характеристики входных
                параметров, типа выходного значения, локальных переменных, именованных курсоров,
                подпрограмм и тело хранимой функции. Для внешних функций (UDR) вы можете изменить
                точку входа и имя движка. Внешние функции, объявленные как DECLARE EXTERNAL
                FUNCTION, так же известные как UDF, невозможно преобразовать в PSQL функции и
                наоборот. После выполнения существующие привилегии и зависимости сохраняются. </para>
            <note>
                <para>Будьте осторожны при изменении количества и типов входных параметров хранимых
                    функций. Существующий код приложения может стать неработоспособным из-за того,
                    что формат вызова функции несовместим с новым описанием параметров. Кроме того,
                    PSQL модули, использующие изменённую хранимую функцию, могут стать
                    некорректными. Информация о том, как это обнаружить, находится в приложении
                        <link linkend="valid">Поле RDB$VALID_BLR</link>. </para>
            </note>
            <section xml:id="ddl-function-alter-who">
                <title>Кто может изменить функцию?</title>

                <para>Выполнить оператор <database>ALTER FUNCTION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец хранимой функции; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY
                                FUNCTION</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-function-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Изменение хранимой функции</title>
                    <para><programlisting language="sql">
ALTER FUNCTION ADD_INT(A INT, B INT, C INT) 
RETURNS INT
AS
BEGIN
  RETURN A+B+C;
END           
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-function-create">CREATE FUNCTION</link>, <link
                            linkend="ddl-function-createoralter">CREATE OR ALTER FUNCTION</link>,
                            <link linkend="ddl-function-drop">DROP FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-function-createoralter">
            <info>
                <title>CREATE OR ALTER FUNCTION</title>
                <keywordset>
                    <keyword>CREATE OR ALTER FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE OR ALTER FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой или изменение существующей хранимой функции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
CREATE OR ALTER FUNCTION <replaceable>funcname</replaceable> 
[(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>]      
[DETERMINISTIC]
<replaceable>&lt;routine body&gt;</replaceable>   
                       </programlisting>
                </para>
            </formalpara>
            <formalpara>
                <title>Подробнее см.</title>

                <para>
                    <link linkend="ddl-function-create">CREATE FUNCTION</link>. </para>
            </formalpara>

            <para>Оператор CREATE OR ALTER FUNCTION создаёт новую или изменяет существующую хранимую
                функцию. Если хранимая функция не существует, то она будет создана с использованием
                предложения CREATE FUNCTION. Если она уже существует, то она будет изменена и
                перекомпилирована, при этом существующие привилегии и зависимости сохраняются. </para>

            <section xml:id="ddl-function-createoralter-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание новой или изменение существующей хранимой функции</title>
                    <para><programlisting language="sql">
CREATE OR ALTER FUNCTION ADD_INT(A INT, B INT DEFAULT 0) 
RETURNS INT
AS
BEGIN
  RETURN A+B;
END          
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-function-create">CREATE FUNCTION</link>, <link
                            linkend="ddl-function-alter">ALTER FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-function-drop">
            <info>
                <title>DROP FUNCTION</title>
                <keywordset>
                    <keyword>DROP FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление хранимой функции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
DROP FUNCTION <replaceable>funcname</replaceable>
                </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP FUNCTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>funcname</replaceable></entry>
                                <entry>Имя хранимой функции.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DROP FUNCTION удаляет существующую хранимую функцию. Если от хранимой
                функции существуют зависимости, то при попытке удаления такой функции будет выдана
                соответствующая ошибка. </para>

            <section xml:id="ddl-function-drop-who">
                <title>Кто может удалить функцию?</title>

                <para>Выполнить оператор <database>DROP FUNCTION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец хранимой функции; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY FUNCTION</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-function-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление хранимой функции</title>
                    <para><programlisting language="sql">
DROP FUNCTION ADD_INT;         
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-function-create">CREATE FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-function-recreate">
            <info>
                <title>RECREATE FUNCTION</title>
                <keywordset>
                    <keyword>RECREATE FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>RECREATE FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой или пересоздание существующей хранимой функции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
RECREATE FUNCTION <replaceable>funcname</replaceable> 
[(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>]      
[DETERMINISTIC]
<replaceable>&lt;routine body&gt;</replaceable>     
                       </programlisting></para>
            </formalpara>
            <formalpara>
                <title>Подробнее см.</title>

                <para>
                    <link linkend="ddl-function-create">CREATE FUNCTION</link>. </para>
            </formalpara>

            <para>Оператор RECREATE FUNCTION создаёт новую или пересоздаёт существующую хранимую
                функцию. Если функция с таким именем уже существует, то оператор попытается удалить
                её и создать новую функцию. Операция закончится неудачей при подтверждении
                транзакции, если функция имеет зависимости.</para>
            <note>
                <para>Имейте ввиду, что ошибки зависимостей не обнаруживаются до фазы подтверждения
                    транзакции.</para>
            </note>

            <para>После пересоздания функции привилегии на выполнение хранимой функции и привилегии
                самой хранимой функции не сохраняются. </para>

            <section xml:id="ddl-function-recreate-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание или пересоздание хранимой функции </title>
                    <para><programlisting language="sql">
RECREATE FUNCTION ADD_INT(A INT, B INT DEFAULT 0) 
RETURNS INT
AS
BEGIN
  RETURN A+B;
END        
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-function-create">CREATE FUNCTION</link>, <link
                            linkend="ddl-function-drop">DROP FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-package">
        <info>
            <title>PACKAGE</title>
            <keywordset>
                <keyword>PACKAGE</keyword>
            </keywordset>
        </info>
        <para>Пакет — группа процедур и функций, которая представляет собой один объект базы данных. </para>
        <para>Пакеты Firebird состоят из двух частей: заголовка (ключевое слово PACKAGE) и тела
            (ключевые слова PACKAGE BODY). Такое разделение очень сильно напоминает модули Delphi,
            заголовок соответствует интерфейсной части, а тело — части реализации.</para>
        <para>Сначала создаётся заголовок (CREATE PACKAGE), а затем — тело (CREATE PACKAGE
            BODY).</para>
        <section xml:id="ddl-package-header">
            <info>
                <title>PACKAGE</title>
                <keywordset>
                    <keyword>PACKAGE</keyword>
                </keywordset>
            </info>
            <section xml:id="ddl-package-create">
                <info>
                    <title>CREATE PACKAGE</title>
                    <keywordset>
                        <keyword>CREATE PACKAGE</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>CREATE PACKAGE</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Создание заголовка пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>

                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
CREATE PACKAGE <replaceable>package_name</replaceable>  
[<replaceable>&lt;rights clause&gt;</replaceable>]                            
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
END

<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}  

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]   
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                           

<replaceable>&lt;in_params&gt;</replaceable> ::= <replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...]

<replaceable>&lt;inparam&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [{= | DEFAULT} <replaceable>&lt;value&gt;</replaceable>]  
                                                        
<replaceable>&lt;value&gt;</replaceable> ::=  {<replaceable>literal</replaceable> | NULL | <replaceable>context_var</replaceable>} 

<replaceable>&lt;out_params&gt;</replaceable> ::= <replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...]

<replaceable>&lt;outparam&gt;</replaceable>  ::=  <replaceable>&lt;param_decl&gt;</replaceable> 
                    
<replaceable>&lt;param_decl&gt;</replaceable> ::= <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]

<replaceable>&lt;type&gt;</replaceable> ::= <replaceable>&lt;datatype&gt;</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable> 
                    
<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} 
  | BOOLEAN 
  | {FLOAT | DOUBLE PRECISION} 
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])] 
                                 
                        </programlisting>
                    </para>
                </formalpara>
                <para>
                    <table frame="all">
                        <title>Параметры оператора CREATE PACKAGE</title>
                        <?dbfo keep-together='auto'?>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>package_name</replaceable></entry>
                                    <entry>
                                        <para>Имя пакета. Может содержать до 63 символов.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>function_decl</replaceable></entry>
                                    <entry>
                                        <para>Объявление функции.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>procedure_decl</replaceable></entry>
                                    <entry>
                                        <para>Объявление процедуры.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>proc_name</replaceable></entry>
                                    <entry>
                                        <para>Имя процедуры. Может содержать до 63 символов.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>func_name</replaceable></entry>
                                    <entry>
                                        <para>Имя функции. Может содержать до 63 символов.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>inparam</replaceable></entry>
                                    <entry>
                                        <para>Описание входного параметра.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>outparam</replaceable></entry>
                                    <entry>
                                        <para>Описание выходного параметра.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>literal</replaceable></entry>
                                    <entry>
                                        <para>Литерал, совместимый по типу с параметром.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>context_var</replaceable></entry>
                                    <entry>
                                        <para>Любая контекстная переменная, тип которой совместим с
                                            типом параметра. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>paramname</replaceable></entry>
                                    <entry>
                                        <para>Имя входного или выходного параметра
                                            процедуры/функции. Может содержать до 63 символов. Имя
                                            параметра должно быть уникальным среди входных и 
                                            выходных параметров процедуры/функции, а также её
                                            локальных переменных. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>datatype</replaceable></entry>
                                    <entry>
                                        <para>Тип данных SQL. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>collation</replaceable></entry>
                                    <entry>
                                        <para>Порядок сортировки.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>domain</replaceable></entry>
                                    <entry>
                                        <para>Домен. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>rel</replaceable></entry>
                                    <entry>
                                        <para>Имя таблицы или представления.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>col</replaceable></entry>
                                    <entry>
                                        <para>Имя столбца таблицы или представления. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>precision</replaceable></entry>
                                    <entry>
                                        <para>Общее количество значащих цифр, которое способен
                                            сохранить параметр (от 1 до 18).</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>scale</replaceable></entry>
                                    <entry>
                                        <para>Количество цифр после десятичной точки. От 0 до 18,
                                            должно быть меньше или равно
                                                <replaceable>precision</replaceable>. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>size</replaceable></entry>
                                    <entry>
                                        <para>Максимальный размер строки в символах. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>charset</replaceable></entry>
                                    <entry>
                                        <para>Набор символов. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>subtype_num</replaceable></entry>
                                    <entry>
                                        <para>Номер подтипа BLOB. См. <link
                                                linkend="types-binary-blob-subtype">Подтипы
                                                BLOB</link>.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>subtype_name</replaceable></entry>
                                    <entry>
                                        <para>Мнемоника подтипа BLOB. См. <link
                                                linkend="types-binary-blob-subtype">Подтипы
                                                BLOB</link>.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>seqlen</replaceable></entry>
                                    <entry>
                                        <para>Размер сегмента, не может превышать 65535. </para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Оператор CREATE PACKAGE создаёт новый заголовок пакета. Имя пакета должно быть
                    уникальным среди имён всех пакетов.</para>
                <para>Процедуры и функции, объявленные в заголовке пакета, доступны вне тела пакета
                    через полный идентификатор имён процедур и функций
                        (<replaceable>package_name</replaceable>.<replaceable>procedure_name</replaceable>
                    и
                        <replaceable>package_name</replaceable>.<replaceable>function_name</replaceable>).
                    Процедуры и функции, определенные в теле пакета, но не объявленные в заголовке
                    пакета, не видны вне тела пакета.</para>
                <para>Имена процедур и функций, объявленные в заголовке пакета, должны быть
                    уникальны среди имён процедур и функций, объявленных в заголовке и теле
                    пакета.</para>
                <note>
                    <para>Желательно чтобы имена хранимых процедур и функций пакета не пересекались
                        с именами хранимых процедур и функций из глобального пространства имен, хотя
                        это и допустимо. Дело в том, что в настоящее время вы не сможете вызвать
                        функцию/процедуру из глобального пространства имён внутри пакета, если в
                        пакете объявлена одноименная функция/процедура. В этом случае всегда будет
                        вызвана процедура/функция пакета. </para>
                </note>
                <section xml:id="ddl-package-create-sql_security">
                    <title>Контекст безопасности</title>
                    <indexterm>
                        <primary>CREATE PACKAGE</primary>
                        <secondary>SQL SECURITY</secondary>
                    </indexterm>
                    <para>Необязательное предложение SQL SECURITY позволяет задать с какими
                        привилегиями выполняется процедуры и функции пакета. Если выбрана опция
                        INVOKER, то процедуры и функции пакета выполняются с привилегиями
                        вызывающего пользователя. Если выбрана опция DEFINER, то процедуры и функции
                        пакета выполняется с привилегиями определяющего пользователя (владельца
                        пакета). Эти привилегии будут дополнены привилегиями выданные самому пакету
                        с помощью оператора GRANT. По умолчанию процедуры и функции пакета
                        выполняются с привилегиями вызывающего пользователя. Переопределять контекст
                        безопасности для процедур и функций пакета запрещено.</para>
                    <tip>
                        <para>Контекст безопасности по умолчанию для вновь создаваемых объектов
                            метаданных можно изменить с помощью оператора
                            <programlisting>
ALTER DATABASE SET DEFAULT SQL SECURITY {DEFINER | INVOKER}
                </programlisting>
                        </para>
                    </tip>
                </section>
                <section xml:id="ddl-package-term">
                    <title>Терминатор оператора</title>

                    <para>Некоторые редакторы SQL-операторов — в частности утилита
                            <application>isql</application>, которая идёт в комплекте с Firebird, и
                        возможно некоторые сторонние редакторы — используют внутреннее соглашение,
                        которое требует, чтобы все операторы были завершены с точкой с
                        запятой.</para>
                    <para>Это создает конфликт с синтаксисом PSQL при кодировании в этих средах.
                        Если вы не знакомы с этой проблемой и её решением, пожалуйста, изучите
                        детали в главе PSQL в разделе, озаглавленном <link linkend="psql-setterm"
                            >Изменение терминатора в <application>isql</application></link>.</para>

                </section>
                <section xml:id="ddl-package-create-params">
                    <title>Параметры процедур и функций</title>
                    <para>У каждого параметра указывается тип данных. Кроме того, для параметра
                        можно указать ограничение NOT NULL, тем самым запретив передавать в него
                        значение NULL.</para>
                    <para>Для параметра строкового типа существует возможность задать порядок
                        сортировки с помощью предложения COLLATE.</para>

                    <section xml:id="ddl-package-create-params-in">
                        <title>Входные параметры</title>
                        <para>Входные параметры заключаются в скобки после имени хранимой процедуры.
                            Они передаются в процедуру по значению, то есть любые изменения входных
                            параметров внутри процедуры никак не повлияет на значения этих
                            параметров в вызывающей программе.</para>
                        <para>Входные параметры могут иметь значение по умолчанию. Параметры, для
                            которых заданы значения, должны располагаться в конце списка
                            параметров.</para>
                    </section>

                    <section xml:id="ddl-package-create-params-out">
                        <title>Выходные параметры</title>
                        <para>Для хранимых процедур список выходных параметров задаётся в
                            необязательное предложение RETURNS.</para>
                        <para>Для хранимых функций в обязательном предложении RETURNS задаётся тип
                            возвращаемого значения.</para>
                    </section>

                    <section xml:id="ddl-package-create-params-domain">
                        <title>Использование доменов при объявлении параметров</title>
                        <para>В качестве типа параметра можно указать имя домена. В этом случае,
                            параметр будет наследовать все характеристики домена.</para>
                        <para>Если перед названием домена дополнительно используется предложение
                                <database>TYPE OF</database>, то используется только тип данных
                            домена — не проверяется (не используется) его ограничение (если оно есть
                            в домене) на NOT NULL, CHECK ограничения и/или значения по умолчанию.
                            Если домен текстового типа, то всегда используется его набор символов и
                            порядок сортировки.</para>
                    </section>
                    <section xml:id="ddl-package-create-params-typeofcolumn">
                        <title>Использование типа столбца при объявлении параметров</title>
                        <para>Входные и выходные параметры можно объявлять, используя тип данных
                            столбцов существующих таблиц и представлений. Для этого используется
                            предложение <database>TYPE OF COLUMN</database>, после которого
                            указывается имя таблицы или представления и через точку имя
                            столбца.</para>
                        <para>При использовании <database>TYPE OF COLUMN</database> наследуется
                            только тип данных, а в случае строковых типов ещё и набор символов, и
                            порядок сортировки. Ограничения и значения по умолчанию столбца никогда
                            не используются. </para>
                    </section>
                </section>

                <section xml:id="ddl-package-create-func-determ">
                    <title>Детерминированные функции</title>
                    <para>Необязательное предложение <database>DETERMINISTIC</database> в объявлении
                        функции указывает, что функция детерминированная. Детерминированные функции
                        каждый раз возвращают один и тот же результат, если предоставлять им один и
                        тот же набор входных значений. Недетерминированные функции могут возвращать
                        каждый раз разные результаты, даже если предоставлять им один и тот же набор
                        входных значений. Если для функции указано, что она является
                        детерминированной, то такая функция не вычисляется заново, если она уже была
                        вычислена однажды с данным набором входных аргументов, а берет свои значения
                        из кэша метаданных (если они там есть).</para>
                    <note>
                        <para>На самом деле в текущей версии Firebird, не существует кэша хранимых
                            функций с маппингом входных аргументов на выходные значения.</para>
                        <para>Указание инструкции <database>DETERMINISTIC</database> на самом деле
                            нечто вроде <quote>обещания</quote>, что код функции будет возвращать
                            одно и то же. В данный момент детерминистическая функция считается
                            инвариантом и работает по тем же принципам, что и другие инварианты.
                            Т.е. вычисляется и кэшируется на уровне текущего выполнения данного
                            запроса.</para>
                    </note>
                </section>
                <section xml:id="ddl-package-create-who">
                    <title>Кто может создать пакет?</title>

                    <para>Выполнить оператор <database>CREATE PACKAGE</database> могут:
                            <itemizedlist spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>CREATE
                                    PACKAGE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                    <para>Пользователь, создавший заголовок пакета становится владельцем
                        пакета.</para>
                </section>
                <section xml:id="ddl-package-create-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Создание заголовка пакета </title>
                        <para><programlisting language="sql">
CREATE PACKAGE APP_VAR
AS
BEGIN
  FUNCTION GET_DATEBEGIN() RETURNS DATE DETERMINISTIC;
  FUNCTION GET_DATEEND() RETURNS DATE DETERMINISTIC;
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE DEFAULT CURRENT_DATE);
END       
                </programlisting></para>
                        <para>Тоже самое, но процедуры и функции пакета будут выполняться с правами
                            определяющего пользователя (владельца пакета).
                            <programlisting language="sql">
CREATE PACKAGE APP_VAR
SQL SECURITY DEFINER
AS
BEGIN
  FUNCTION GET_DATEBEGIN() RETURNS DATE DETERMINISTIC;
  FUNCTION GET_DATEEND() RETURNS DATE DETERMINISTIC;
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE DEFAULT CURRENT_DATE);
END       
                </programlisting>
                        </para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-body-create">CREATE PACKAGE BODY</link>,
                                <link linkend="ddl-package-alter">ALTER PACKAGE</link>, <link
                                linkend="ddl-package-drop">DROP PACKAGE</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-package-alter">
                <info>
                    <title>ALTER PACKAGE</title>
                    <keywordset>
                        <keyword>ALTER PACKAGE</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>ALTER PACKAGE</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Изменение заголовка пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>

                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
ALTER PACKAGE <replaceable>package_name</replaceable> 
[<replaceable>&lt;rights clause&gt;</replaceable>]                             
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
END

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]     
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                         
                        </programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>Подробнее см.</title>

                    <para>
                        <link linkend="ddl-package-create">CREATE PACKAGE</link>. </para>
                </formalpara>

                <para>Оператор ALTER PACKAGE изменяет заголовок пакета. Позволяется изменять
                    количество и состав процедур и функций, их входных и выходных параметров. При
                    этом исходный код тела пакета сохраняется. Состояние соответствия тела пакета
                    его заголовку отображается в столбце RDB$PACKAGES.RDB$VALID_BODY_FLAG.</para>
                <section xml:id="ddl-package-alter-who">
                    <title>Кто может изменить заголовок пакета?</title>

                    <para>Выполнить оператор <database>ALTER PACKAGE</database> могут: <itemizedlist
                            spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец пакета; </para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>ALTER ANY
                                        PACKAGE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>

                <section xml:id="ddl-package-alter-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Изменение заголовка пакета</title>
                        <para><programlisting language="sql">
ALTER PACKAGE APP_VAR
AS
BEGIN
  FUNCTION GET_DATEBEGIN() RETURNS DATE DETERMINISTIC;
  FUNCTION GET_DATEEND() RETURNS DATE DETERMINISTIC;
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE DEFAULT CURRENT_DATE);
END       
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-alter">CREATE PACKAGE</link>, <link
                                linkend="ddl-package-drop">DROP PACKAGE</link>, <link
                                linkend="ddl-package-body-alter">ALTER PACKAGE BODY</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-package-createoralter">
                <info>
                    <title>CREATE OR ALTER PACKAGE</title>
                    <keywordset>
                        <keyword>CREATE OR ALTER PACKAGE</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>CREATE OR ALTER PACKAGE</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Создание нового или изменение существующего заголовка пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>

                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
CREATE OR ALTER PACKAGE <replaceable>package_name</replaceable>  
[<replaceable>&lt;rights clause&gt;</replaceable>]                             
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
END

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]   
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)] 
                        </programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>Подробнее см.</title>

                    <para>
                        <link linkend="ddl-package-create">CREATE PACKAGE</link>. </para>
                </formalpara>

                <para>Оператор CREATE OR ALTER PACKAGE создаёт новый или изменяет существующий
                    заголовок пакета. Если заголовок пакета не существует, то он будет создан с
                    использованием предложения CREATE PACKAGE. Если он уже существует, то он будет
                    изменен и перекомпилирован, при этом существующие привилегии и зависимости
                    сохраняются. </para>

                <section xml:id="ddl-package-createoralter-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Создание нового или изменение существующего заголовка пакета</title>
                        <para><programlisting language="sql">
CREATE OR ALTER PACKAGE APP_VAR
AS
BEGIN
  FUNCTION GET_DATEBEGIN() RETURNS DATE DETERMINISTIC;
  FUNCTION GET_DATEEND() RETURNS DATE DETERMINISTIC;
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE DEFAULT CURRENT_DATE);
END       
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-alter">CREATE PACKAGE</link>, <link
                                linkend="ddl-package-alter">ALTER PACKAGE</link>, <link
                                linkend="ddl-package-body-alter">ALTER PACKAGE BODY</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-package-drop">
                <info>
                    <title>DROP PACKAGE</title>
                    <keywordset>
                        <keyword>DROP PACKAGE</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>DROP PACKAGE</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Удаление заголовка пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>

                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
DROP PACKAGE <replaceable>package_name</replaceable>    
                        </programlisting>
                    </para>
                </formalpara>
                <para>
                    <table frame="all">
                        <title>Параметры оператора DROP PACKAGE</title>
                        <?dbfo keep-together='auto'?>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>package_name</replaceable></entry>
                                    <entry>
                                        <para>Имя пакета.</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Оператор DROP PACKAGE удаляет существующий заголовок пакета. Перед удалением
                    заголовка пакета (DROP PACKAGE), необходимо выполнить удаление тела пакета (DROP
                    PACKAGE BODY), иначе будет выдана ошибка. Если от заголовка пакета существуют
                    зависимости, то при попытке удаления такого заголовка будет выдана
                    соответствующая ошибка.</para>
                <section xml:id="ddl-package-drop-who">
                    <title>Кто может удалить заголовок пакета?</title>

                    <para>Выполнить оператор <database>DROP PACKAGE</database> могут: <itemizedlist
                            spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец пакета; </para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>DROP ANY
                                        PACKAGE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>
                <section xml:id="ddl-package-drop-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Удаление заголовка пакета</title>
                        <para><programlisting language="sql">
DROP PACKAGE APP_VAR;      
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-alter">CREATE PACKAGE</link>, <link
                                linkend="ddl-package-alter">ALTER PACKAGE</link>, <link
                                linkend="ddl-package-body-alter">DROP PACKAGE BODY</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-package-recreate">
                <info>
                    <title>RECREATE PACKAGE</title>
                    <keywordset>
                        <keyword>RECREATE PACKAGE</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>RECREATE PACKAGE</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Создание нового или пересоздание существующего заголовка пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>

                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
RECREATE PACKAGE <replaceable>package_name</replaceable>  
[<replaceable>&lt;rights clause&gt;</replaceable>]                             
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
END

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]    
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                               
                        </programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>Подробнее см.</title>

                    <para>
                        <link linkend="ddl-package-create">CREATE PACKAGE</link>. </para>
                </formalpara>

                <para>Оператор RECREATE PACKAGE создаёт новый или пересоздаёт существующий заголовок
                    пакета. Если заголовок пакета с таким именем уже существует, то оператор
                    попытается удалить его и создать новый заголовок пакета. Пересоздать заголовок
                    пакета невозможно, если у существующей заголовка пакета имеются зависимости или
                    существует тело этого пакета. После пересоздания заголовка пакета привилегии на
                    выполнение подпрограмм пакета и привилегии самого пакета не сохраняются. </para>
                <section xml:id="ddl-package-recreate-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Создание нового или пересоздание существующего заголовка
                            пакета</title>
                        <para><programlisting language="sql">
RECREATE PACKAGE APP_VAR
AS
BEGIN
  FUNCTION GET_DATEBEGIN() RETURNS DATE DETERMINISTIC;
  FUNCTION GET_DATEEND() RETURNS DATE DETERMINISTIC;
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE DEFAULT CURRENT_DATE);
END       
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-alter">CREATE PACKAGE</link>, <link
                                linkend="ddl-package-drop">DROP PACKAGE</link>, <link
                                linkend="ddl-package-body-recreate">RECREATE PACKAGE BODY</link>.
                        </para>
                    </formalpara>
                </section>
            </section>
        </section>
        <section xml:id="ddl-package-body">
            <info>
                <title>PACKAGE BODY</title>
                <keywordset>
                    <keyword>PACKAGE BODY</keyword>
                </keywordset>
            </info>
            <section xml:id="ddl-package-body-create">
                <info>
                    <title>CREATE PACKAGE BODY</title>
                    <keywordset>
                        <keyword>CREATE PACKAGE BODY</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>CREATE PACKAGE BODY</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Создание тела пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
CREATE PACKAGE BODY <replaceable>package_name</replaceable>  
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
  [<replaceable>&lt;package_body_item&gt;</replaceable> ...]                                                        
END

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]    
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                           

<replaceable>&lt;package_body_item&gt;</replaceable> ::=
    <replaceable>&lt;function_impl&gt;</replaceable> 
  | <replaceable>&lt;procedure_impl&gt;</replaceable>

<replaceable>&lt;function_impl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC] 
  <replaceable>&lt;routine body&gt;</replaceable> 
      
<replaceable>&lt;procedure_impl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                             
  <replaceable>&lt;routine body&gt;</replaceable>                            

<replaceable>&lt;in_params&gt;</replaceable> ::= <replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...]

<replaceable>&lt;inparam&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [{= | DEFAULT} <replaceable>&lt;value&gt;</replaceable>]  
   
<replaceable>&lt;in_impl_params&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [, <replaceable>&lt;param_decl&gt;</replaceable> ...]  
   
<replaceable>&lt;value&gt;</replaceable> ::=  {<replaceable>literal</replaceable> | NULL | <replaceable>context_var</replaceable>} 

<replaceable>&lt;out_params&gt;</replaceable> ::= <replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...]

<replaceable>&lt;outparam&gt;</replaceable>  ::=  <replaceable>&lt;param_decl&gt;</replaceable> 
                    
<replaceable>&lt;param_decl&gt;</replaceable> ::= <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]

<replaceable>&lt;type&gt;</replaceable> ::= <replaceable>&lt;datatype&gt;</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable> 
                    
<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} 
  | BOOLEAN 
  | {FLOAT | DOUBLE PRECISION} 
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])] 
                                            
<replaceable>&lt;routine body&gt;</replaceable> ::= <replaceable>&lt;sql routine body&gt;</replaceable> | <replaceable>&lt;external body reference&gt;</replaceable>                   
    
<replaceable>&lt;sql routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                    

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
  <replaceable>&lt;declare_var&gt;</replaceable>; |      
  <replaceable>&lt;declare_cursor&gt;</replaceable>; |     
  <replaceable>&lt;declare_subfunc&gt;</replaceable> |     
  <replaceable>&lt;declare_subproc&gt;</replaceable> 

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> 

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'                             
                        
                        </programlisting>
                    </para>
                </formalpara>
                <para>
                    <table frame="all">
                        <title>Параметры оператора CREATE PACKAGE BODY</title>
                        <?dbfo keep-together='auto'?>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>package_name</replaceable></entry>
                                    <entry>
                                        <para>Имя пакета. Может содержать до 63 символов.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>function_decl</replaceable></entry>
                                    <entry>
                                        <para>Объявление функции.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>procedure_decl</replaceable></entry>
                                    <entry>
                                        <para>Объявление процедуры.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>function_impl</replaceable></entry>
                                    <entry>
                                        <para>Реализация функции.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>procedure_impl</replaceable></entry>
                                    <entry>
                                        <para>Реализация процедуры.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>proc_name</replaceable></entry>
                                    <entry>
                                        <para>Имя процедуры. Может содержать до 63 символов.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>func_name</replaceable></entry>
                                    <entry>
                                        <para>Имя функции. Может содержать до 63 символов.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>inparam</replaceable></entry>
                                    <entry>
                                        <para>Описание входного параметра.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>outparam</replaceable></entry>
                                    <entry>
                                        <para>Описание выходного параметра.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>declarations</replaceable></entry>
                                    <entry>
                                        <para>Секция объявления локальных переменных, именованных
                                            курсоров, подпроцедур и подфункций.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>declare_var</replaceable></entry>
                                    <entry>
                                        <para>Объявление локальной переменной.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>declare_cursor</replaceable></entry>
                                    <entry>
                                        <para>Объявление именованного курсора.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>declare_subfunc</replaceable></entry>
                                    <entry>
                                        <para>Объявление подпрограммы–функции.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>declare_subproc</replaceable></entry>
                                    <entry>
                                        <para>Объявление подпрограммы–процедуры.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>module name</replaceable></entry>
                                    <entry>
                                        <para>Имя внешнего модуля, в котором расположена
                                            процедура/функция.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>routine name</replaceable></entry>
                                    <entry>
                                        <para>Внутреннее имя процедуры/функции внутри внешнего
                                            модуля.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>misc info</replaceable></entry>
                                    <entry>
                                        <para>Определяемая пользователем информация для передачи в
                                            функцию внешнего модуля.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>engine</replaceable></entry>
                                    <entry>
                                        <para>Имя движка для использования внешних функций. Обычно
                                            указывается имя UDR.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>literal</replaceable></entry>
                                    <entry>
                                        <para>Литерал, совместимый по типу с параметром. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>context_var</replaceable></entry>
                                    <entry>
                                        <para>Любая контекстная переменная, тип которой совместим с
                                            типом параметра. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>paramname</replaceable></entry>
                                    <entry>
                                        <para>Имя входного или выходного параметра
                                            процедуры/функции. Может содержать до 63 символов. Имя
                                            параметра должно быть уникальным среди входных и 
                                            выходных параметров процедуры/функции, а также её
                                            локальных переменных. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>datatype</replaceable></entry>
                                    <entry>
                                        <para>Тип данных SQL. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>collation</replaceable></entry>
                                    <entry>
                                        <para>Порядок сортировки.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>domain</replaceable></entry>
                                    <entry>
                                        <para>Домен. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>rel</replaceable></entry>
                                    <entry>
                                        <para>Имя таблицы или представления.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>col</replaceable></entry>
                                    <entry>
                                        <para>Имя столбца таблицы или представления. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>precision</replaceable></entry>
                                    <entry>
                                        <para>Общее количество значащих цифр, которое способен
                                            сохранить параметр (от 1 до 18).</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>scale</replaceable></entry>
                                    <entry>
                                        <para>Количество цифр после десятичной точки. От 0 до 18,
                                            должно быть меньше или равно
                                                <replaceable>precision</replaceable>. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>size</replaceable></entry>
                                    <entry>
                                        <para>Максимальный размер строки в символах. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>charset</replaceable></entry>
                                    <entry>
                                        <para>Набор символов. </para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>subtype_num</replaceable></entry>
                                    <entry>
                                        <para>Номер подтипа BLOB. См. <link
                                                linkend="types-binary-blob-subtype">Подтипы
                                                BLOB</link>.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>subtype_name</replaceable></entry>
                                    <entry>
                                        <para>Мнемоника подтипа BLOB. См. <link
                                                linkend="types-binary-blob-subtype">Подтипы
                                                BLOB</link>.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>seqlen</replaceable></entry>
                                    <entry>
                                        <para>Размер сегмента, не может превышать 65535. </para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Оператор CREATE PACKAGE BODY создаёт новое тело пакета. Тело пакета может быть
                    создано только после того как будет создан заголовок пакета. Если заголовка
                    пакета с именем <replaceable>package_name</replaceable> не существует, то будет
                    выдана соответствующая ошибка. </para>
                <para>Все процедуры и функции, объявленные в заголовке пакета, должны быть
                    реализованы в теле пакета. Кроме того, должны быть реализованы и все процедуры и
                    функции, объявленные в теле пакета. Процедуры и функции, определенные в теле
                    пакета, но не объявленные в заголовке пакета, не видны вне тела пакета.</para>
                <para>Имена процедур и функций, объявленные в теле пакета, должны быть уникальны
                    среди имён процедур и функций, объявленных в заголовке и теле пакета.</para>
                <note>
                    <para>Желательно чтобы имена хранимых процедур и функций пакета не пересекались
                        с именами хранимых процедур и функций из глобального пространства имен, хотя
                        это и допустимо. Дело в том, что в настоящее время вы не сможете вызвать
                        функцию/процедуру из глобального пространства имён внутри пакета, если в
                        пакете объявлена одноименная функция/процедура. В этом случае всегда будет
                        вызвана процедура/функция пакета. </para>
                </note>
                <formalpara>
                    <title>Правила:</title>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para>В теле пакеты должны быть реализованы все подпрограммы, стой
                                    же сигнатурой, что и объявленные в заголовке и в начале тела
                                    пакета.</para>
                            </listitem>
                            <listitem>
                                <para>Значения по умолчанию для параметров процедур не могут быть
                                    переопределены (которые указываются в
                                        <replaceable>&lt;package_item&gt;</replaceable>). Это
                                    означает, что они могут быть в
                                        <replaceable>&lt;package_body_item&gt;</replaceable> только
                                    для частных процедур, которые не были объявлены.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </formalpara>
                <note>
                    <para>UDF деклараций (DECLARE внешняя функция) в настоящее время не
                        поддерживается внутри пакетов.</para>
                </note>
                <section xml:id="ddl-package-body-create-who">
                    <title>Кто может создать тело пакета?</title>

                    <para>Выполнить оператор <database>CREATE PACKAGE BODY</database> могут:
                            <itemizedlist spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец пакета; </para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>ALTER ANY
                                        PACKAGE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>
                <section xml:id="ddl-package-body-create-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Создание тела пакета </title>
                        <para><programlisting language="sql">
CREATE PACKAGE BODY APP_VAR
AS
BEGIN
  -- Возвращает дату начала периода
  FUNCTION GET_DATEBEGIN() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEBEGIN');
  END
  -- Возвращает дату окончания периода
  FUNCTION GET_DATEEND() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEEND');
  END
  -- Устанавливает диапазон дат рабочего периода
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE)
  AS
  BEGIN
    RDB$SET_CONTEXT('USER_SESSION', 'DATEBEGIN', ADATEBEGIN);
    RDB$SET_CONTEXT('USER_SESSION', 'DATEEND', ADATEEND);
  END
END    
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-body-alter">ALTER PACKAGE BODY</link>, <link
                                linkend="ddl-package-body-drop">DROP PACKAGE BODY</link>, <link
                                linkend="ddl-package-create">CREATE PACKAGE</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-package-body-alter">
                <info>
                    <title>ALTER PACKAGE BODY</title>
                    <keywordset>
                        <keyword>ALTER PACKAGE BODY</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>ALTER PACKAGE BODY</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Изменение тела пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
ALTER PACKAGE BODY <replaceable>package_name</replaceable>  
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
  [<replaceable>&lt;package_body_item&gt;</replaceable> ...]                                                        
END

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [<replaceable>&lt;function_options&gt;</replaceable>]   
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)] 
  [<replaceable>&lt;procedure_options&gt;</replaceable>]                          

<replaceable>&lt;package_body_item&gt;</replaceable> ::=
    <replaceable>&lt;function_impl&gt;</replaceable> 
  | <replaceable>&lt;procedure_impl&gt;</replaceable>

<replaceable>&lt;function_impl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]
  <replaceable>&lt;routine body&gt;</replaceable>  
      
<replaceable>&lt;procedure_impl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                         
  <replaceable>&lt;routine body&gt;</replaceable>                               
                        </programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>Подробнее см.</title>

                    <para>
                        <link linkend="ddl-package-body-create">CREATE PACKAGE BODY</link>. </para>
                </formalpara>

                <para>Оператор ALTER PACKAGE BODY изменяет тело пакета. Позволяется изменять
                    количество и состав процедур и функций тела пакета.</para>
                <para>Все процедуры и функции, объявленные в заголовке пакета, должны быть
                    реализованы в теле пакета. Кроме того, должны быть реализованы и все процедуры и
                    функции, объявленные в теле пакета.</para>
                <para>Имена процедур и функций, объявленные в теле пакета, должны быть уникальны
                    среди имён процедур и функций, объявленных в заголовке и теле пакета.</para>
                <note>
                    <para>Желательно чтобы имена хранимых процедур и функций пакета не пересекались
                        с именами хранимых процедур и функций из глобального пространства имен, хотя
                        это и допустимо. Дело в том, что в настоящее время вы не сможете вызвать
                        функцию/процедуру из глобального пространства имён внутри пакета, если в
                        пакете объявлена одноименная функция/процедура. В этом случае всегда будет
                        вызвана процедура/функция пакета. </para>
                </note>
                <formalpara>
                    <title>Правила:</title>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para>В теле пакеты должны быть реализованы все подпрограммы, стой
                                    же сигнатурой, что и объявленные в заголовке и в начале тела
                                    пакета.</para>
                            </listitem>
                            <listitem>
                                <para>Значения по умолчанию для параметров процедур не могут быть
                                    переопределены (которые указываются в
                                        <replaceable>&lt;package_item&gt;</replaceable>). Это
                                    означает, что они могут быть в
                                        <replaceable>&lt;package_body_item&gt;</replaceable> только
                                    для частных процедур, которые не были объявлены.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </formalpara>
                <section xml:id="ddl-package-body-alter-who">
                    <title>Кто может изменить тело пакета?</title>

                    <para>Выполнить оператор <database>ALTER PACKAGE BODY</database> могут:
                            <itemizedlist spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец пакета; </para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>ALTER ANY
                                        PACKAGE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>
                <section xml:id="ddl-package-body-alter-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Изменение тела пакета</title>
                        <para><programlisting language="sql">
ALTER PACKAGE BODY APP_VAR
AS
BEGIN
  -- Возвращает дату начала периода
  FUNCTION GET_DATEBEGIN() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEBEGIN');
  END
  -- Возвращает дату окончания периода
  FUNCTION GET_DATEEND() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEEND');
  END
  -- Устанавливает диапазон дат рабочего периода
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE)
  AS
  BEGIN
    RDB$SET_CONTEXT('USER_SESSION', 'DATEBEGIN', ADATEBEGIN);
    RDB$SET_CONTEXT('USER_SESSION', 'DATEEND', ADATEEND);
  END
END    
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-body-create">CREATE PACKAGE BODY</link>,
                                <link linkend="ddl-package-body-drop">DROP PACKAGE BODY</link>,
                                <link linkend="ddl-package-alter">ALTER PACKAGE</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-package-body-drop">
                <info>
                    <title>DROP PACKAGE BODY</title>
                    <keywordset>
                        <keyword>DROP PACKAGE BODY</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>DROP PACKAGE BODY</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Удаление тела пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
DROP PACKAGE BODY <replaceable>package_name</replaceable>                            
                        </programlisting>
                    </para>
                </formalpara>
                <para>
                    <table frame="all">
                        <title>Параметры оператора DROP PACKAGE BODY</title>
                        <?dbfo keep-together='auto'?>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>package_name</replaceable></entry>
                                    <entry>Имя пакета.</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Оператор DROP PACKAGE BODY удаляет тело пакета.</para>
                <section xml:id="ddl-package-body-drop-who">
                    <title>Кто может удалить тело пакета?</title>

                    <para>Выполнить оператор <database>DROP PACKAGE BODY</database> могут:
                            <itemizedlist spacing="compact">
                            <listitem>
                                <para><link linkend="security-administrators"
                                    >Администраторы</link></para>
                            </listitem>
                            <listitem>
                                <para>Владелец пакета; </para>
                            </listitem>
                            <listitem>
                                <para>Пользователи с привилегией <database>ALTER ANY
                                        PACKAGE</database>. </para>
                            </listitem>
                        </itemizedlist>
                    </para>

                </section>
                <section xml:id="ddl-package-body-drop-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Удаление тела пакета</title>
                        <para><programlisting language="sql">
DROP PACKAGE BODY APP_VAR;  
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-body-create">CREATE PACKAGE BODY</link>,
                                <link linkend="ddl-package-body-alter">ALTER PACKAGE BODY</link>,
                                <link linkend="ddl-package-drop">DROP PACKAGE</link>. </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="ddl-package-body-recreate">
                <info>
                    <title>RECREATE PACKAGE BODY</title>
                    <keywordset>
                        <keyword>RECREATE PACKAGE BODY</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>RECREATE PACKAGE BODY</primary></indexterm>
                <formalpara>
                    <title>Назначение:</title>

                    <para>Создание нового и пересоздание существующего тела пакета.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
RECREATE PACKAGE BODY <replaceable>package_name</replaceable>  
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
  [<replaceable>&lt;package_body_item&gt;</replaceable> ...]                                                        
END

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [<replaceable>&lt;function_options&gt;</replaceable>]   
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)] 
  [<replaceable>&lt;procedure_options&gt;</replaceable>]                          

<replaceable>&lt;package_body_item&gt;</replaceable> ::=
    <replaceable>&lt;function_impl&gt;</replaceable> 
  | <replaceable>&lt;procedure_impl&gt;</replaceable>

<replaceable>&lt;function_impl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]
  <replaceable>&lt;routine body&gt;</replaceable>  
      
<replaceable>&lt;procedure_impl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                          
  <replaceable>&lt;routine body&gt;</replaceable>                               
                        </programlisting>
                    </para>
                </formalpara>
                <formalpara>
                    <title>Подробнее см.</title>

                    <para>
                        <link linkend="ddl-package-body-create">CREATE PACKAGE BODY</link>. </para>
                </formalpara>

                <para>Оператор RECREATE PACKAGE BODY создаёт новое или пересоздаёт существующее тело
                    пакета. Если тело пакета с таким именем уже существует, то оператор попытается
                    удалить его и создать новое тело пакета. После пересоздания тела пакета
                    привилегии на выполнение подпрограмм пакета и привилегии самого пакета
                    сохраняются. </para>
                <section xml:id="ddl-package-body-recreate-examples">
                    <title>Примеры</title>
                    <example>
                        <title>Пересоздание тела пакета</title>
                        <para><programlisting language="sql">
RECREATE PACKAGE BODY APP_VAR
AS
BEGIN
  -- Возвращает дату начала периода
  FUNCTION GET_DATEBEGIN() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEBEGIN');
  END
  -- Возвращает дату окончания периода
  FUNCTION GET_DATEEND() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEEND');
  END
  -- Устанавливает диапазон дат рабочего периода
  PROCEDURE SET_DATERANGE(ADATEBEGIN DATE, ADATEEND DATE)
  AS
  BEGIN
    RDB$SET_CONTEXT('USER_SESSION', 'DATEBEGIN', ADATEBEGIN);
    RDB$SET_CONTEXT('USER_SESSION', 'DATEEND', ADATEEND);
  END
END    
                </programlisting></para>
                    </example>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-package-body-create">CREATE PACKAGE BODY</link>,
                                <link linkend="ddl-package-body-drop">DROP PACKAGE BODY</link>,
                                <link linkend="ddl-package-alter">ALTER PACKAGE</link>. </para>
                    </formalpara>
                </section>
            </section>
        </section>
    </section>
    <section xml:id="ddl-extrnalfunction">
        <info>
            <title>EXTERNAL FUNCTION</title>
            <keywordset>
                <keyword>EXTERNAL FUNCTION</keyword>
            </keywordset>
        </info>
        <para>Внешние функции, также известные как функции определяемые пользователем (User Defined
            Function) — это программы, написанные на любом языке программирования, и хранящиеся в
            динамических библиотеках. После того как функция объявлена в базе данных, она становится
            в динамических и процедурных операторах, как будто они реализованы внутри языка
            SQL.</para>
        <para>Внешние функции существенно расширяют возможности SQL по обработке данных. Для того
            чтобы функции были доступны в базе данных, их необходимо объявить с помощью оператора
            DECLARE EXTERNAL FUNCTON. </para>
        <para>После объявления функции, содержащая её библиотека будет загружаться при первом
            обращении к любой из функций, включённой в библиотеку.</para>
        <note>
            <para>Внешние функции, объявленные как DECLARE EXTERNAL FUNCTION, являются
                унаследованными (Legacy) из предыдущих версий Firebird. Их возможности существенно
                уступают возможностям нового типа внешних функций UDR (User Defined Routine). Такие
                функции объявляются как CREATE FUNCTION ... EXTERNAL NAME. Подробнее см. <link
                    linkend="ddl-function-create">CREATE FUNCTION</link>.</para>
        </note>
        <section xml:id="ddl-extrnalfunction-declare">
            <info>
                <title>DECLARE EXTERNAL FUNCTION</title>
                <keywordset>
                    <keyword>DECLARE EXTERNAL FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DECLARE EXTERNAL FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Объявление в базе данных функции определённой пользователем (UDF).</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DECLARE EXTERNAL FUNCTION <replaceable>funcname</replaceable>
[<replaceable>&lt;arg_type_decl&gt;</replaceable> [, <replaceable>&lt;arg_type_decl&gt;</replaceable> ...]]
RETURNS { 
  <replaceable>sqltype</replaceable> [BY {DESCRIPTOR | VALUE}] | 
  CSTRING(<replaceable>length</replaceable>) | 
  PARAMETER <replaceable>param_num</replaceable> }
[FREE_IT]
ENTRY_POINT '<replaceable>entry_point</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>';

<replaceable>&lt;arg_type_decl&gt;</replaceable> ::= 
  <replaceable>sqltype</replaceable> [{BY DESCRIPTOR} | NULL] | 
  CSTRING(<replaceable>length</replaceable>) [NULL]   
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DECLARE EXTERNAL FUNCTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>funcname</replaceable></entry>
                                <entry>
                                    <para>Имя внешней функции. Может содержать до 63
                                        символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>entry_point</replaceable></entry>
                                <entry>
                                    <para>Имя экспортируемой функции (точка входа). </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>library_name</replaceable></entry>
                                <entry>
                                    <para>Имя модуля, в котором расположена функция.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>sqltype</replaceable></entry>
                                <entry>
                                    <para>Тип данных SQL. Не может быть массивом или элементом
                                        массива. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>length</replaceable></entry>
                                <entry>
                                    <para>Максимальная длина нуль терминальной строки. Указывается в
                                        байтах. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>param_num</replaceable></entry>
                                <entry>
                                    <para>Номер входного параметра, который будет возвращён
                                        функцией.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DECLARE EXTERNAL FUNCTION делает доступным функцию, определенную
                пользователем (UDF), в базе данных. Внешние функции должны быть объявлены в каждой
                базе данных, которая собирается их использовать. Не нужно объявлять UDF, если вы
                никогда не будете её использовать.</para>
            <para>Имя внешней функции должно быть уникальным среди всех имён функций. Оно может
                отличаться от имени функции указанной в аргументе ENTRY_POINT. </para>
            <para>Входные параметры функции перечисляются через запятую сразу после имени функции.
                Для каждого параметра указывается SQL тип данных. Массивы не могут использоваться в
                качестве параметров функций. Помимо SQL типов можно указать тип CSTRING. В этом
                случае параметр является нуль терминальной строкой с максимальной длиной
                    <replaceable>length</replaceable> байт.</para>
            <para>По умолчанию входные параметры передаются по ссылке. При передаче NULL значения по
                ссылке оно преобразовывается в эквивалент нуля, например, число 0 или пустую строку.
                Если после указанного параметра указано ключевое слово NULL, то при передаче
                значение NULL оно попадёт в функцию в виде нулевого указателя (null).</para>
            <note>
                <para>Обратите внимание на то, что объявление функции с ключевым словом NULL не
                    гарантирует вам, что эта функция правильно обработает входной параметр со
                    значением NULL. Любая функция должна быть написана или переписана таким образом,
                    чтобы правильно обрабатывать значения NULL. Всегда смотрите и используйте
                    объявления функции, предоставленные её разработчиком. </para>
            </note>
            <indexterm>
                <primary>DECLARE EXTERNAL FUNCTION</primary>
                <secondary>BY DESCRIPTOR</secondary>
            </indexterm>
            <para>Если указано предложение BY DESCRIPTOR, то входной параметр передаётся по
                дескриптору. Передача параметра по дескриптору облегчает обработку значений NULL.
                Отметим, что это объявление работает только в том случае, если внешняя функция
                поддерживает его. Простое добавление <quote>BY DESCRIPTOR</quote> к существующей
                декларации не заставит его работать. Всегда используйте объявление блока,
                обеспеченное функционалом внешней функции. </para>
            <warning>
                <para>При передаче параметра функции по дескриптору передаваемое значение не
                    приводится к задекларированному типу данных. </para>
            </warning>
            <indexterm>
                <primary>DECLARE EXTERNAL FUNCTION</primary>
                <secondary>RETURNS</secondary>
            </indexterm>
            <para>Обязательное предложение RETURNS описывает выходной параметр возвращаемый
                функцией. Функция всегда возвращает только один параметр. Выходной параметр может
                быть любым SQL типом (кроме массива и элемента массива) или нуль терминальной
                строкой (CSTRING). Выходной параметр может быть передан по ссылке, по дескриптору
                или по значению. По умолчанию выходной параметр передаётся по ссылке. Если указано
                предложение BY DESCRIPTOR, то выходной параметр передаётся по дескриптору. Если
                указано предложение BY VALUE, то выходной параметр передаётся по значению.</para>
            <indexterm>
                <primary>DECLARE EXTERNAL FUNCTION</primary>
                <secondary>PARAMETER</secondary>
            </indexterm>
            <para>Ключевое слово PARAMETER указывает, что функция возвращает значение из параметра с
                номером <replaceable>param_num</replaceable>. Такая необходимость возникает, если
                необходимо возвращать значение типа BLOB.</para>
            <para>Ключевое слово FREE_IT означает, что память, выделенная для хранения возвращаемого
                значения, будет освобождена после завершения выполнения функции. Применяется только
                в том случае, если эта память в UDF выделялась динамически. В такой UDF память
                должна выделяться при помощи функции <emphasis role="itallic"
                    >ib_util_malloc</emphasis> из модуля <emphasis role="itallic"
                >ib_util</emphasis>. Это необходимо для совместимости функций выделения и
                освобождения памяти используемого в коде Firebird и коде UDF.</para>
            <indexterm>
                <primary>DECLARE EXTERNAL FUNCTION</primary>
                <secondary>ENTRY_POINT</secondary>
            </indexterm>
            <para>Предложение ENTRY_POINT указывает имя точки входа (имя экспортируемой функции) в
                модуле.</para>
            <indexterm>
                <primary>DECLARE EXTERNAL FUNCTION</primary>
                <secondary>MODULE_NAME</secondary>
            </indexterm>
            <para>Предложение MODULE_NAME задаёт имя модуля, в котором находится экспортируемая
                функция. В ссылке на модуль может отсутствовать полный путь и расширение файла. Это
                позволяет легче переносить базу данных между различными платформами. По умолчанию
                динамические библиотеки пользовательских функций должны располагаться в папке UDF
                корневого каталога сервера. Параметр <parameter>UDFAccess</parameter> в файле
                    <filename>firebird.conf</filename> позволяет изменить ограничения доступа к
                библиотекам внешних функций.</para>
            <section xml:id="ddl-extrnalfunction-declare-who">
                <title>Кто может объявить внешнюю функцию?</title>

                <para>Выполнить оператор <database>DECLARE EXTERNAL FUNCTION</database> могут:
                        <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE FUNCTION</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, объявивший внешнюю функцию, становится её владельцем.</para>
            </section>
            <section xml:id="ddl-extrnalfunction-declare-examples">
                <title>Примеры</title>
                <example>
                    <title>Объявление внешней функции с передачей входных и выходных параметров по
                        ссылке</title>
                    <para><programlisting language="sql">
DECLARE EXTERNAL FUNCTION addDay
TIMESTAMP, INT
RETURNS TIMESTAMP
ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';       
                </programlisting></para>
                </example>
                <example>
                    <title>Объявление внешней функции с передачей входных и выходных параметров по
                        дескриптору</title>
                    <para><programlisting language="sql">
DECLARE EXTERNAL FUNCTION invl
INT BY DESCRIPTOR, INT BY DESCRIPTOR
RETURNS INT BY DESCRIPTOR
ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';      
                </programlisting></para>
                </example>
                <example>
                    <title>Объявление внешней функции с передачей входных параметров по ссылке,
                        выходных по значению</title>
                    <para><programlisting language="sql">
DECLARE EXTERNAL FUNCTION isLeapYear
TIMESTAMP 
RETURNS INT BY VALUE
ENTRY_POINT 'isLeapYear' MODULE_NAME 'fbudf';     
                </programlisting></para>
                </example>
                <example>
                    <title>Объявление внешней функции с передачей входных и выходных параметров по
                        дескриптору. В качестве выходного параметра используется второй параметр
                        функции.</title>
                    <para><programlisting language="sql">
DECLARE EXTERNAL FUNCTION i64Truncate
NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
RETURNS PARAMETER 2
ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';     
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-extrnalfunction-alter">ALTER EXTERNAL FUNCTION</link>,
                            <link linkend="ddl-extrnalfunction-drop">DROP EXTERNAL FUNCTION</link>,
                            <link linkend="ddl-function-create">CREATE FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-extrnalfunction-alter">
            <info>
                <title>ALTER EXTERNAL FUNCTION</title>
                <keywordset>
                    <keyword>ALTER EXTERNAL FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER EXTERNAL FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение точки входа и/или имени модуля для функции определённой
                    пользователем (UDF).</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
ALTER EXTERNAL FUNCTION <replaceable>funcname</replaceable>
[ENTRY_POINT '<replaceable>new_entry_point</replaceable>'] 
[MODULE_NAME '<replaceable>new_library_name</replaceable>']; 
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER EXTERNAL FUNCTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>funcname</replaceable></entry>
                                <entry>
                                    <para>Имя внешней функции.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>new_entry_point</replaceable></entry>
                                <entry>
                                    <para>Новое имя экспортируемой функции (точки входа).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>new_library_name</replaceable></entry>
                                <entry>
                                    <para>Новое имя модуля, в котором расположена функция.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор ALTER EXTERNAL FUNCTION изменяет точку вход и/или имя модуля для функции
                определённой пользователем (UDF). При этом существующие зависимости сохраняются. </para>
            <para>Предложение ENTRY_POINT позволяет указать новую точку входа (имя экспортируемой
                функции). </para>
            <para>Предложение MODULE_NAME позволяет указать новое имя модуля, в котором расположена
                экспортируемая функция.</para>
            <section xml:id="ddl-extrnalfunction-alter-who">
                <title>Кто может изменить внешнюю функцию?</title>

                <para>Выполнить оператор <database>ALTER EXTERNAL FUNCTION</database> могут:
                        <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец внешней функции; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY
                                FUNCTION</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-extrnalfunction-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Изменение точки входа для внешней функции</title>
                    <para><programlisting language="sql">
ALTER EXTERNAL FUNCTION invl ENTRY_POINT 'intNvl';       
                </programlisting></para>
                </example>
                <example>
                    <title>Изменение имени модуля для внешней функции</title>
                    <para><programlisting language="sql">
ALTER EXTERNAL FUNCTION invl MODULE_NAME 'fbudf2';    
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-extrnalfunction-declare">DECLARE EXTERNAL
                        FUNCTION</link>, <link linkend="ddl-extrnalfunction-drop">DROP EXTERNAL
                            FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-extrnalfunction-drop">
            <info>
                <title>DROP EXTERNAL FUNCTION</title>
                <keywordset>
                    <keyword>DROP EXTERNAL FUNCTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP EXTERNAL FUNCTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление объявления функции определённой пользователем (UDF) из базы
                    данных.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DROP EXTERNAL FUNCTION <replaceable>funcname</replaceable>; 
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP EXTERNAL FUNCTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>funcname</replaceable></entry>
                                <entry>
                                    <para>Имя внешней функции.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DROP EXTERNAL FUNCTION удаляет объявление функции определённой
                пользователем из базы данных. Если есть зависимости от внешней функции, то удаления
                не произойдёт и будет выдана соответствующая ошибка.</para>
            <section xml:id="ddl-extrnalfunction-drop-who">
                <title>Кто может удалить внешнюю функцию?</title>

                <para>Выполнить оператор <database>DROP EXTERNAL FUNCTION</database> могут:
                        <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец внешней функции; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY FUNCTION</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-extrnalfunction-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление внешней функции</title>
                    <para><programlisting language="sql">
DROP EXTERNAL FUNCTION addDay;     
                </programlisting></para>
                </example>
                <formalpara>
                    <info>
                        <title>См. также:</title>
                    </info>
                    <para>
                        <link linkend="ddl-extrnalfunction-declare">DECLARE EXTERNAL
                        FUNCTION</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-filter">
        <info>
            <title>FILTER</title>
            <keywordset>
                <keyword>FILTER</keyword>
            </keywordset>
        </info>
        <para>BLOB фильтр — объект базы данных, являющийся, по сути, специальным видом внешних
            функций с единственным назначением: получение объекта BLOB одного формата и
            преобразования его в объект BLOB другого формата. Форматы объектов BLOB задаются с
            помощью подтипов BLOB. </para>
        <para>Внешние функции для преобразования BLOB типов хранятся в динамических библиотеках и
            загружаются по необходимости.</para>
        <para>Подробнее о подтипах BLOB см. в разделе <link linkend="types-binary">Бинарные типы
                данных</link>.</para>
        <section xml:id="ddl-filter-declare">
            <info>
                <title>DECLARE FILTER</title>
                <keywordset>
                    <keyword>DECLARE FILTER</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DECLARE FILTER</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Объявление в базе данных BLOB фильтра.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DECLARE FILTER <replaceable>filtername</replaceable>
INPUT_TYPE <replaceable>&lt;sub_type&gt;</replaceable> OUTPUT_TYPE <replaceable>&lt;sub_type&gt;</replaceable>
ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>';

<replaceable>&lt;sub_type&gt;</replaceable> ::= <replaceable>number</replaceable> | <replaceable>&lt;mnemonic&gt;</replaceable>

<replaceable>&lt;mnemonic&gt;</replaceable> ::= binary | text | blr | acl | ranges | summary |
               format | transaction_description |
               external_file_description | <replaceable>user_defined</replaceable>
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DECLARE FILTER</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>filtername</replaceable></entry>
                                <entry>
                                    <para>Имя фильтра. Может содержать до 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>sub_type</replaceable></entry>
                                <entry>
                                    <para>Подтип BLOB. См. <link linkend="types-binary-blob-subtype"
                                            >Подтипы BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>number</replaceable></entry>
                                <entry>
                                    <para>Номер подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>mnemonic</replaceable></entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB. См. <link
                                            linkend="types-binary-blob-subtype">Подтипы
                                        BLOB</link>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>function_name</replaceable></entry>
                                <entry>
                                    <para>Имя экспортируемой функции (точка входа). </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>library_name</replaceable></entry>
                                <entry>
                                    <para>Имя модуля, в котором расположен фильтр. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>user_defined</replaceable></entry>
                                <entry>
                                    <para>Определяемая пользователем мнемоника подтипа BLOB.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DECLARE FILTER делает доступным BLOB фильтр в базе данных. Имя BLOB
                фильтра должно быть уникальным среди имён BLOB фильтров. </para>
            <section xml:id="ddl-filter-declare-subtypes">
                <title>Задание подтипов</title>
                <para>Подтип может быть задан в виде номера подтипа или мнемоники подтипа.
                    Пользовательские подтипы должны быть представлены отрицательными числами (от -1
                    до -32768). Не допускается создание двух и более фильтров BLOB с одинаковыми
                    комбинациями входных и выходных типов. Объявление фильтра с уже существующими
                    комбинациями входных и выходных типов BLOB приведёт к ошибке.</para>
                <para>Предложение INPUT_TYPE идентифицирует тип преобразуемого объекта (подтип
                    BLOB).</para>
                <para>Предложение OUTPUT_TYPE идентифицирует тип создаваемого объекта. </para>
                <note>
                    <para>Если вы хотите определить мнемоники для собственных подтипов BLOB, вы
                        можете добавить их в системную таблицу RDB$TYPES, как показано ниже. После
                        подтверждения транзакции мнемоники могут быть использованы для декларации
                        при создании новых фильтров. </para>
                    <para><programlisting language="sql">
INSERT INTO RDB$TYPES (RDB$FIELD_NAME, RDB$TYPE, RDB$TYPE_NAME)
VALUES ('RDB$FIELD_SUB_TYPE', -33, 'MIDI');
                </programlisting></para>
                    <para>Значение поля rdb$field_name всегда должно быть 'RDB$FIELD_SUB_TYPE'. Если
                        вы определяете мнемоники в верхнем регистре, то можете использовать их без
                        учёта регистра и без кавычек при объявлении фильтра. </para>
                </note>
            </section>
            <section xml:id="ddl-filter-declare-params">
                <title>Параметры DECLARE FILTER</title>
                <para>Предложение ENTRY_POINT указывает имя точки входа (имя экспортируемой функции)
                    в модуле. </para>
                <para>Предложение MODULE_NAME задаёт имя модуля, в котором находится экспортируемая
                    функция. По умолчанию модули должны располагаться в папке UDF корневого каталога
                    сервера. Параметр <parameter>UDFAccess</parameter> в файле
                        <filename>firebird.conf</filename> позволяет изменить ограничения доступа к
                    библиотекам фильтров. </para>
            </section>
            <section xml:id="ddl-filter-declare-who">
                <title>Кто может создать BLOB фильтр?</title>

                <para>Выполнить оператор <database>DECLARE FILTER</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE FILTER</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший BLOB фильтр, становится его владельцем.</para>
            </section>
            <section xml:id="ddl-filter-declare-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание BLOB фильтра с использованием номеров подтипов</title>
                    <para><programlisting language="sql">
DECLARE FILTER DESC_FILTER
INPUT_TYPE 1
OUTPUT_TYPE -4
ENTRY_POINT 'desc_filter'
MODULE_NAME 'FILTERLIB';     
                </programlisting></para>
                </example>
                <example>
                    <title>Создание BLOB фильтра с использованием мнемоник подтипов</title>
                    <para><programlisting language="sql">
DECLARE FILTER FUNNEL
INPUT_TYPE blr OUTPUT_TYPE text
ENTRY_POINT 'blr2asc' MODULE_NAME 'myfilterlib';   
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-filter-drop">DROP FILTER</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-filter-drop">
            <info>
                <title>DROP FILTER</title>
                <keywordset>
                    <keyword>DROP FILTER</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP FILTER</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление объявления BLOB фильтра.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DROP FILTER <replaceable>filtername</replaceable>;
                       </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP FILTER</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>filtername</replaceable></entry>
                                <entry>
                                    <para>Имя BLOB фильтра.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DROP FILTER удаляет объявление BLOB фильтра из базы данных. Удаление BLOB
                фильтра из базы данных делает его не доступным из базы данных, при этом динамическая
                библиотека, в которой расположена функция преобразования, остаётся не
                тронутой.</para>
            <section xml:id="ddl-filter-drop-who">
                <title>Кто может удалить BLOB фильтр?</title>

                <para>Выполнить оператор <database>DROP FILTER</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец BLOB фильтра; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY FILTER</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-filter-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление BLOB фильтра</title>
                    <para><programlisting language="sql">
DROP FILTER DESC_FILTER;       
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-filter-declare">DECLARE FILTER</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-sequence">
        <info>
            <title>SEQUENCE (GENERATOR)</title>
            <keywordset>
                <keyword>SEQUENCE</keyword>
                <keyword>GENERATOR</keyword>
            </keywordset>
        </info>
        <para>Последовательность (sequence) или генератор (generator) — объект базы данных,
            предназначенный для получения уникального числового значения. Термин последовательность
            является SQL совместимым. Ранее в Interbase и Firebird последовательности называли
            генераторами.</para>
        <para>Независимо от диалекта базы данных последовательности (или генераторы) всегда хранятся
            как 64-битные целые значения. </para>
        <caution>
            <para>Если клиент использует 1 диалект, то сервер передаёт ему значения
                последовательности, усечённые до 32-битного значения. Если значение
                последовательности передаются в 32-разрядное поле или переменную, то до тех пор,
                пока текущее значение последовательности не вышло за границы для 32-битного числа,
                ошибок не будет. В момент выхода значения последовательности за этот диапазон база
                данных 3-го диалекта выдаст сообщение об ошибке, а база данных 1-го диалекта будет
                молча обрезать значения (что также может привести к ошибке — например, если поле,
                заполняемое генератором, является первичным или уникальным). </para>
        </caution>
        <para>В данном разделе описываются вопросы создания, модификации (установка значения
            последовательности) и удаления последовательностей.</para>

        <section xml:id="ddl-sequence-create">
            <info>
                <title>CREATE SEQUENCE</title>
                <keywordset>
                    <keyword>CREATE SEQUENCE</keyword>
                    <keyword>CREATE GENERATOR</keyword>
                    <keyword>INCREMENT</keyword>
                    <keyword>START WITH</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CREATE SEQUENCE</primary></indexterm>
            <indexterm><primary>CREATE GENERATOR</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой последовательности (генератора).</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
CREATE {SEQUENCE | GENERATOR} <replaceable>seq_name</replaceable>
[START WITH <replaceable>value</replaceable>] [INCREMENT [BY] <replaceable>increment</replaceable>];
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE SEQUENCE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>seq_name</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора). Может содержать до 63
                                        символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>value</replaceable></entry>
                                <entry>
                                    <para>Начальное значение последовательности (генератора).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>increment</replaceable></entry>
                                <entry>
                                    <para>Шаг приращения. 4 байтное целое число.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор CREATE SEQUENCE создаёт новую последовательность. Слова SEQUENCE и
                GENERATOR являются синонимами. Вы можете использовать любое из них, но рекомендуется
                использовать SEQUENCE. </para>
            <para>В момент создания последовательности ей устанавливается значение, указанное в
                необязательном предложении START WITH. Если предложение STARTING WITH отсутствует,
                то последовательности устанавливается значение равное 0. </para>
            <para>Необязательное предложение INCREMENT [BY] позволяет задать шаг приращения для
                оператора NEXT VALUES FOR. По умолчанию шаг приращения равен единице. Приращение не
                может быть установлено в ноль для пользовательских последовательностей. Значение
                последовательности изменяется также при обращении к функции GEN_ID, где в качестве
                параметра указывается имя последовательности и значение приращения, которое может
                быть отлично от указанного в предложении INCREMENT BY. </para>
            <section xml:id="ddl-sequence-create-who">
                <title>Кто может создать последовательность?</title>

                <para>Выполнить оператор <database>CREATE SEQUENCE</database> (<database>CREATE
                        GENERATOR</database>) могут: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE SEQUENCE</database>
                                    (<database>CREATE GENERATOR</database>). </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший последовательность, становится её владельцем.</para>
            </section>
            <section xml:id="ddl-sequence-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание последовательности</title>
                    <para>Создание последовательности EMP_NO_GEN с начальным значением 0 и шагом
                        приращения равным единице.
                        <programlisting language="sql">
CREATE SEQUENCE EMP_NO_GEN;       
                </programlisting></para>
                </example>
                <example>
                    <title>Создание последовательности</title>
                    <para>Создание последовательности EMP_NO_GEN с начальным значением 5 и шагом
                        приращения равным единице.
                        <programlisting language="sql">
CREATE SEQUENCE EMP_NO_GEN START WITH 5;      
                </programlisting></para>
                </example>
                <example>
                    <title>Создание последовательности</title>
                    <para>Создание последовательности EMP_NO_GEN с начальным значением 0 и шагом
                        приращения равным 10.
                        <programlisting language="sql">
CREATE SEQUENCE EMP_NO_GEN INCREMENT BY 10;      
                </programlisting></para>
                </example>
                <example>
                    <title>Создание последовательности</title>
                    <para>Создание последовательности EMP_NO_GEN с начальным значением 5 и шагом
                        приращения равным 10.
                        <programlisting language="sql">
CREATE SEQUENCE EMP_NO_GEN START WITH 5 INCREMENT BY 10;      
                </programlisting></para>
                </example>
                <formalpara>
                    <info>
                        <title>См. также:</title>
                    </info>
                    <para>
                        <link linkend="ddl-sequence-alter">ALTER SEQUENCE</link>, <link
                            linkend="ddl-sequence-setgen">SET GENERATOR</link>, <link
                            linkend="ddl-sequence-drop">DROP SEQUENCE</link>, <link
                            linkend="common-expr-nextvalue">NEXT VALUE FOR</link>, <link
                            linkend="ddl-sequence-drop">GEN_ID</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-sequence-alter">
            <info>
                <title>ALTER SEQUENCE</title>
                <keywordset>
                    <keyword>ALTER SEQUENCE</keyword>
                    <keyword>ALTER GENERATOR</keyword>
                    <keyword>RESTART</keyword>
                    <keyword>INCREMENT</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER SEQUENCE</primary></indexterm>
            <indexterm><primary>ALTER GENERATOR</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение последовательности (генератора).</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
ALTER {SEQUENCE | GENERATOR} <replaceable>seq_name</replaceable> 
[RESTART [WITH <replaceable>new_val</replaceable>]] 
[INCREMENT [BY] <replaceable>increment</replaceable>];
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER SEQUENCE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>seq_name</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>new_val</replaceable></entry>
                                <entry>
                                    <para>Новое значение последовательности (генератора). 64 битное
                                        целое в диапазоне от -2<superscript>63</superscript> ..
                                            2<superscript>63</superscript> + 1 </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>increment</replaceable></entry>
                                <entry>
                                    <para>Шаг приращения.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор ALTER SEQUENCE устанавливает значение последовательности или генератора в
                заданное значение и/или изменяет значение приращения.</para>
            <para>Предложение RESTART WITH позволяет установить значение последовательности.
                Предложение RESTART может быть использовано самостоятельно (без WITH) для
                перезапуска значения последовательности с того значения с которого был начат старт
                генерации значений или предыдущий рестарт.</para>
            <warning>
                <para>Неосторожное использование оператора ALTER SEQUENCE (изменение значения
                    последовательности или генератора) может привести к нарушению логической
                    целостности данных. </para>
            </warning>
            <para>Предложение INCREMENT [BY] позволяет изменить шаг приращения последовательности
                для оператора NEXT VALUES FOR.</para>
            <note>
                <para>Изменение значения приращения — это возможность, которая вступает в силу для
                    каждого запроса, который запускается после фиксаций изменения. Процедуры,
                    которые вызваны впервые после изменения приращения, будут использовать новое
                    значение, если они будут содержать операторы NEXT VALUE FOR. Процедуры, которые
                    уже работают, не будут затронуты, потому что они кэшируются. Процедуры,
                    использующие NEXT VALUE FOR, не должны быть перекомпилированы, чтобы видеть
                    новое приращение, но если они уже работают или загружены, то никакого эффекта не
                    будет. Конечно процедуры, использующие gen_id(gen, expression), не затронут при
                    изменении приращения. </para>
            </note>
            <section xml:id="ddl-sequence-alter-who">
                <title>Кто может изменить последовательность?</title>

                <para>Выполнить оператор <database>ALTER SEQUENCE</database> (<database>ALTER
                        GENERATOR</database>) могут: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец последовательности (генератора); </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY SEQUENCE</database>
                                    (<database>ALTER ANY GENERATOR</database>). </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-sequence-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Изменение последовательности</title>
                    <para>Установка для последовательности EMP_NO_GEN значения 145.
                        <programlisting language="sql">
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;      
                </programlisting></para>
                </example>
                <example>
                    <title>Изменение последовательности</title>
                    <para>Сброс значения последовательности в то, которое было установлено при
                        создании последовательности (или при предыдущей установке значения).
                        <programlisting language="sql">
ALTER SEQUENCE EMP_NO_GEN RESTART;    
                </programlisting></para>
                </example>
                <example>
                    <title>Изменение последовательности</title>
                    <para>Изменение значения приращения последовательности EMP_NO_GEN.
                        <programlisting language="sql">
ALTER SEQUENCE EMP_NO_GEN INCREMENT BY 10;  
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-sequence-setgen">SET GENERATOR</link>, <link
                            linkend="ddl-sequence-create">CREATE SEQUENCE</link>, <link
                            linkend="ddl-sequence-drop">DROP SEQUENCE</link>, <link
                            linkend="common-expr-nextvalue">NEXT VALUE FOR</link>, <link
                            linkend="ddl-sequence-drop">GEN_ID</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-sequence-createoralter">
            <info>
                <title>CREATE OR ALTER SEQUENCE</title>
                <keywordset>
                    <keyword>CREATE OR ALTER SEQUENCE</keyword>
                    <keyword>CREATE OR ALTER GENERATOR</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE OR ALTER SEQUENCE</primary></indexterm>
            <indexterm><primary>CREATE OR ALTER GENERATOR</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание новой или изменение существующей последовательности
                    (генератора).</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
CREATE OR ALTER {SEQUENCE | GENERATOR} <replaceable>seq_name</replaceable> 
[{START WITH <replaceable>value</replaceable> | RESTART}] 
[INCREMENT [BY] <replaceable>increment</replaceable>];
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора CREATE OR ALTER SEQUENCE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>seq_name</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора). Может содержать до 63
                                        символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>value</replaceable></entry>
                                <entry>
                                    <para>Начальное значение последовательности (генератора).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>increment</replaceable></entry>
                                <entry>
                                    <para>Шаг приращения. 4 байтное целое число.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Если последовательности не существует, то она будет создана. Уже существующая
                последовательность будет изменена, при этом существующие зависимости
                последовательности будут сохранены. </para>
            <para>
                <important>
                    <para>Оператор CREATE OR ALTER SEQUENCE требует, чтобы хотя бы одно из
                        необязательных предложений было указано.</para>
                </important>
            </para>
            <section xml:id="ddl-sequence-createoralter-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание новой или изменение существующей последовательности </title>
                    <para>
                        <programlisting language="sql">
CREATE OR ALTER SEQUENCE EMP_NO_GEN 
START WITH 10
INCREMENT BY 1;
                </programlisting></para>
                </example>
                <formalpara>
                    <info>
                        <title>См. также:</title>
                    </info>
                    <para>
                        <link linkend="ddl-sequence-create">CREATE SEQUENCE</link>, <link
                            linkend="ddl-sequence-alter">ALTER SEQUENCE</link>, <link
                            linkend="ddl-sequence-setgen">SET GENERATOR</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-sequence-drop">
            <info>
                <title>DROP SEQUENCE</title>
                <keywordset>
                    <keyword>DROP SEQUENCE</keyword>
                    <keyword>DROP GENERATOR</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP SEQUENCE</primary></indexterm>
            <indexterm><primary>DROP GENERATOR</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление последовательности (генератора).</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DROP {SEQUENCE | GENERATOR} <replaceable>seq_name</replaceable>;
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP SEQUENCE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>seq_name</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DROP SEQUENCE удаляет существующую последовательность (генератор). Слова
                SEQUENCE и GENERATOR являются синонимами. Вы можете использовать любое из них, но
                рекомендуется использовать SEQUENCE. При наличии зависимостей для существующей
                последовательности (генератора) удаления не будет выполнено. </para>
            <section xml:id="ddl-sequence-drop-who">
                <title>Кто может удалить генератор?</title>

                <para>Выполнить оператор <database>DROP SEQUENCE</database> (<database>DROP
                        GENERATOR</database>) могут: <itemizedlist spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец последовательности (генератора); </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY SEQUENCE</database>
                                    (<database>DROP ANY GENERATOR</database>). </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-sequence-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление последовательности </title>
                    <para>
                        <programlisting language="sql">
DROP SEQUENCE EMP_NO_GEN;
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-sequence-create">CREATE SEQUENCE</link>, <link
                            linkend="ddl-sequence-alter">ALTER SEQUENCE</link>, <link
                            linkend="ddl-sequence-recreate">RECREATE SEQUENCE</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-sequence-recreate">
            <info>
                <title>RECREATE SEQUENCE</title>
                <keywordset>
                    <keyword>RECREATE SEQUENCE</keyword>
                    <keyword>RECREATE GENERATOR</keyword>
                </keywordset>
            </info>
            <indexterm><primary>RECREATE SEQUENCE</primary></indexterm>
            <indexterm><primary>RECREATE GENERATOR</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание или пересоздание последовательности (генератора).</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
RECREATE {SEQUENCE | GENERATOR} <replaceable>seq_name</replaceable>
[START WITH <replaceable>value</replaceable>] [INCREMENT [BY] <replaceable>increment</replaceable>];
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора RECREATE SEQUENCE</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>seq_name</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора). Может содержать до 63
                                        символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>value</replaceable></entry>
                                <entry>
                                    <para>Начальное значение последовательности (генератора).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>increment</replaceable></entry>
                                <entry>
                                    <para>Шаг приращения. 4 байтное целое число.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор RECREATE SEQUENCE создаёт или пересоздаёт последовательность (генератор).
                Если последовательность с таким именем уже существует, то оператор RECREATE SEQUENCE
                попытается удалить её и создать новую последовательность. При наличии зависимостей
                для существующей последовательности оператор RECREATE SEQUENCE не выполнится.</para>
            <section xml:id="ddl-sequence-recreate-examples">
                <title>Примеры</title>
                <example>
                    <title>Пересоздание последовательности </title>
                    <para>
                        <programlisting language="sql">
RECREATE SEQUENCE EMP_NO_GEN 
START WITH 10
INCREMENT BY 1;
                </programlisting></para>
                </example>
            </section>
        </section>
        <section xml:id="ddl-sequence-setgen">
            <info>
                <title>SET GENERATOR</title>
                <keywordset>
                    <keyword>SET GENERATOR</keyword>
                </keywordset>
            </info>
            <indexterm><primary>SET GENERATOR</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Устанавливает значение последовательности или генератора в заданное значение.
                </para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
SET GENERATOR <replaceable>seq_name</replaceable> TO <replaceable>new_val</replaceable>;
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора SET GENERATOR</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>seq_name</replaceable></entry>
                                <entry>
                                    <para>Имя последовательности (генератора).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>new_val</replaceable></entry>
                                <entry>
                                    <para>Новое значение последовательности (генератора). 64 битное
                                        целое в диапазоне от -2<superscript>63</superscript> ..
                                            2<superscript>63</superscript> + 1 </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор SET GENERATOR устанавливает значение последовательности или генератора в
                заданное значение. </para>
            <note>
                <para>Оператор SET GENERATOR считается устаревшим и оставлен ради обратной
                    совместимости. В настоящее время вместо него рекомендуется использовать
                    стандарт-совместимый оператор ALTER SEQUENCE. </para>
                <para>Неосторожное использование оператора SET GENERATOR (изменение значения
                    последовательности или генератора) может привести к потере логической
                    целостности данных. </para>
            </note>
            <section xml:id="ddl-sequence-setgen-who">
                <title>Кто может изменить значение генератора?</title>

                <para>Выполнить оператор <database>SET GENERATOR</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец последовательности (генератора); </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY SEQUENCE</database>
                                    (<database>ALTER ANY GENERATOR</database>). </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
            <section xml:id="ddl-sequence-setgen-examples">
                <title>Примеры</title>

                <example>
                    <title>Установка значения для последовательности</title>
                    <para>
                        <programlisting language="sql">
SET GENERATOR EMP_NO_GEN TO 145;
                </programlisting></para>
                </example>
                <note>
                    <para>То же самое можно сделать, используя оператор <link
                            linkend="ddl-sequence-alter">ALTER SEQUENCE</link>
                        <programlisting language="sql">
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
                </programlisting>
                    </para>
                </note>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-sequence-alter">ALTER SEQUENCE</link>, <link
                            linkend="common-expr-nextvalue">NEXT VALUE FOR</link>, <link
                            linkend="ddl-sequence-drop">GEN_ID</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-exception">
        <info>
            <title>EXCEPTION</title>
            <keywordset>
                <keyword>EXCEPTION</keyword>
            </keywordset>
        </info>
        <para>Пользовательское исключение (exception) — объект базы данных, описывающий сообщение об
            ошибке. Исключение можно вызывать и обрабатывать в PSQL коде (см. <link
                linkend="psql-operators-exception">EXCEPTION</link>, <link
                linkend="psql-operators-when">WHEN … DO</link>).</para>
        <para>В данном разделе описываются операторы создания, модификации и удаления исключений. </para>
        <section xml:id="ddl-exception-create">
            <info>
                <title>CREATE EXCEPTION</title>
                <keywordset>
                    <keyword>CREATE EXCEPTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE EXCEPTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание пользовательского исключения для использования в PSQL модулях.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
CREATE EXCEPTION <replaceable>exception_name</replaceable> '<replaceable>&lt;message&gt;</replaceable>';

<replaceable>&lt;message&gt;</replaceable> ::= {<replaceable>txt</replaceable> | @<replaceable>n</replaceable>} <replaceable>&lt;message&gt;</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table xml:id="ddl-tbl-createexcep" frame="all">
                    <title>Параметры оператора CREATE EXCEPTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="colParam" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="colDes" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>exception_name</replaceable></entry>
                                <entry>
                                    <para>Имя исключения. Максимальная длина 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>message</replaceable></entry>
                                <entry>
                                    <para>Сообщение об ошибке. Максимальная длина ограничена 1021
                                        символом.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>txt</replaceable></entry>
                                <entry>
                                    <para>Текст.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>т</replaceable></entry>
                                <entry>
                                    <para>Номер слота для параметра. Нумерация начинается с 1.
                                        Максимальный номер слота равен 9.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор CREATE EXCEPTION создаёт новое пользовательское исключение для
                использования в PSQL модулях. Исключение должно отсутствовать в базе данных, иначе
                будет выдана соответствующая ошибка.</para>
            <para>Имя исключения является стандартным идентификатором. В диалекте 3 оно может быть
                заключено в двойные кавычки, что делает его чувствительным к регистру. Подробности
                см. <link linkend="langstruct-ids">Идентификаторы</link>.</para>
            <para>Сообщение исключения сохраняется в наборе символов NONE, т.е. любых символов из
                однобайтовых наборов символов. Текст сообщения может быть переопределён в PSQL коде
                во время возбуждения исключения.</para>
            <para>Сообщение об ошибке может содержать слоты для параметров, которые заполняются при
                возбуждении исключения. </para>
            <warning>
                <title>Внимание!</title>
                <para>Если в тексте сообщения, встретится номер слота параметра больше 9, то второй
                    и последующий символ будут восприняты как литералы. Например, @10 будет
                    воспринято как @1, после которого следует литерал 0. </para>
            </warning>
            <note>
                <para>Пользовательские исключения хранятся в таблице <link
                        linkend="systables-exceptions">RDB$EXCEPTION</link>.</para>
            </note>
            <section xml:id="ddl-exception-create-who">
                <title>Кто может создать исключение?</title>

                <para>Выполнить оператор <database>CREATE EXCEPTION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE EXCEPTION</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший исключение, становится его владельцем.</para>
            </section>
            <section xml:id="ddl-exception-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание пользовательского исключения</title>

                    <para><programlisting language="sql"> 
CREATE EXCEPTION E_LARGE_VALUE 'Значение превышает предельно допустимое';
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание параметризованного исключения</title>

                    <para><programlisting language="sql"> 
CREATE EXCEPTION E_INVALID_VALUE 
'Неверное значение @1 для поля @2';
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-exception-alter">ALTER EXCEPTION</link>, <link
                            linkend="ddl-exception-createoralter">CREATE OR ALTER EXCEPTION</link>,
                            <link linkend="ddl-exception-drop">DROP EXCEPTION</link>, <link
                            linkend="ddl-exception-recreate">RECREATE EXCEPTION</link>, <link
                            linkend="psql-operators-exception">EXCEPTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-exception-alter">
            <info>
                <title>ALTER EXCEPTION</title>
                <keywordset>
                    <keyword>ALTER EXCEPTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER EXCEPTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Изменение текста сообщения пользовательского исключения.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
ALTER EXCEPTION <replaceable>exception_name</replaceable> '<replaceable>&lt;message&gt;</replaceable>';

<replaceable>&lt;message&gt;</replaceable> ::= {<replaceable>txt</replaceable> | @<replaceable>n</replaceable>} <replaceable>&lt;message&gt;</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table xml:id="ddl-tbl-alterexcep" frame="all">
                    <title>Параметры оператора ALTER EXCEPTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="colParam" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="colDes" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>exception_name</replaceable></entry>
                                <entry>
                                    <para>Имя исключения.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>message</replaceable></entry>
                                <entry>
                                    <para>Сообщение об ошибке. Максимальная длина ограничена 1021
                                        символом.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>txt</replaceable></entry>
                                <entry>
                                    <para>Текст.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>т</replaceable></entry>
                                <entry>
                                    <para>Номер слота для параметра. Нумерация начинается с 1.
                                        Максимальный номер слота равен 9.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор ALTER EXCEPTION изменяет текст сообщения пользовательского исключения. </para>
            <section xml:id="ddl-exception-alter-who">
                <title>Кто может изменить исключение?</title>

                <para>Выполнить оператор <database>ALTER EXCEPTION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец исключения; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>ALTER ANY
                                    EXCEPTION</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-exception-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Изменение текста сообщения пользовательского исключения</title>

                    <para><programlisting language="sql"> 
ALTER EXCEPTION E_LARGE_VALUE 'Значение превышает максимально допустимое';
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-exception-create">CREATE EXCEPTION</link>, <link
                            linkend="ddl-exception-createoralter">CREATE OR ALTER EXCEPTION</link>,
                            <link linkend="ddl-exception-recreate">RECREATE EXCEPTION</link>.
                    </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-exception-createoralter">
            <info>
                <title>CREATE OR ALTER EXCEPTION</title>
                <keywordset>
                    <keyword>CREATE OR ALTER EXCEPTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE OR ALTER EXCEPTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание нового или изменение существующего исключения.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
CREATE OR ALTER EXCEPTION <replaceable>exception_name</replaceable> '<replaceable>&lt;message&gt;</replaceable>';

<replaceable>&lt;message&gt;</replaceable> ::= {<replaceable>txt</replaceable> | @<replaceable>n</replaceable>} <replaceable>&lt;message&gt;</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table xml:id="ddl-tbl-createoralterexcep" frame="all">
                    <title>Параметры оператора CREATE OR ALTER EXCEPTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="colParam" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="colDes" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>exception_name</replaceable></entry>
                                <entry>
                                    <para>Имя исключения. Максимальная длина 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>message</replaceable></entry>
                                <entry>
                                    <para>Сообщение об ошибке. Максимальная длина ограничена 1021
                                        символом.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>txt</replaceable></entry>
                                <entry>
                                    <para>Текст.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>т</replaceable></entry>
                                <entry>
                                    <para>Номер слота для параметра. Нумерация начинается с 1.
                                        Максимальный номер слота равен 9.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Если исключения не существует, то оно будет создано. Уже существующее исключение
                будет изменено, при этом существующие зависимости исключения будут сохранены. </para>
            <section xml:id="ddl-exception-createoralter-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание или изменение пользовательского исключения</title>

                    <para><programlisting language="sql"> 
CREATE OR ALTER EXCEPTION E_LARGE_VALUE 
'Значение превышает максимально допустимое';
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-exception-create">CREATE EXCEPTION</link>, <link
                            linkend="ddl-exception-alter">ALTER EXCEPTION</link>, <link
                            linkend="ddl-exception-recreate">RECREATE EXCEPTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-exception-drop">
            <info>
                <title>DROP EXCEPTION</title>
                <keywordset>
                    <keyword>DROP EXCEPTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP EXCEPTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление пользовательского исключения.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DROP EXCEPTION <replaceable>exception_name</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP EXCEPTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>exception_name</replaceable></entry>
                                <entry>
                                    <para>Имя исключения.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DROP EXCEPTION удаляет пользовательское исключение. При наличии
                зависимостей для существующего исключения удаления не будет выполнено. </para>
            <section xml:id="ddl-exception-drop-who">
                <title>Кто может удалить исключение?</title>

                <para>Выполнить оператор <database>DROP EXCEPTION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец исключения; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY
                                EXCEPTION</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-exception-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление пользовательского исключения</title>

                    <para><programlisting language="sql"> 
DROP EXCEPTION E_LARGE_VALUE;
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-exception-create">CREATE EXCEPTION</link>, <link
                            linkend="ddl-exception-recreate">RECREATE EXCEPTION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-exception-recreate">
            <info>
                <title>RECREATE EXCEPTION</title>
                <keywordset>
                    <keyword>RECREATE EXCEPTION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>RECREATE EXCEPTION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Создание или пересоздание пользовательского исключения.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
RECREATE EXCEPTION <replaceable>exception_name</replaceable> '<replaceable>&lt;message&gt;</replaceable>';

<replaceable>&lt;message&gt;</replaceable> ::= {<replaceable>txt</replaceable> | @<replaceable>n</replaceable>} <replaceable>&lt;message&gt;</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table xml:id="ddl-tbl-recreateexcep" frame="all">
                    <title>Параметры оператора RECREATE EXCEPTION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="colParam" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="colDes" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row valign="middle">
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>exception_name</replaceable></entry>
                                <entry>
                                    <para>Имя исключения. Максимальная длина 63 символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>message</replaceable></entry>
                                <entry>
                                    <para>Сообщение об ошибке. Максимальная длина ограничена 1021
                                        символом.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>txt</replaceable></entry>
                                <entry>
                                    <para>Текст.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>т</replaceable></entry>
                                <entry>
                                    <para>Номер слота для параметра. Нумерация начинается с 1.
                                        Максимальный номер слота равен 9.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор RECREATE EXCEPTION создаёт или пересоздаёт пользовательское исключение.
                Если исключение с таким именем уже существует, то оператор RECREATE EXCEPTION
                попытается удалить его и создать новое исключение. При наличии зависимостей для
                существующего исключения оператор RECREATE EXCEPTION не выполнится. </para>
            <section xml:id="ddl-exception-recreate-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание или пересоздание пользовательского исключения</title>

                    <para><programlisting language="sql"> 
RECREATE EXCEPTION E_LARGE_VALUE 
'Значение превышает максимально допустимое';
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-exception-create">CREATE EXCEPTION</link>, <link
                            linkend="ddl-exception-alter">ALTER EXCEPTION</link>, <link
                            linkend="ddl-exception-createoralter">CREATE OR ALTER EXCEPTION</link>.
                    </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-collation">
        <info>
            <title>COLLATION</title>
            <keywordset>
                <keyword>COLLATION</keyword>
            </keywordset>
        </info>
        <para>В SQL текстовые строки принадлежат к сортируемым объектам. Это означает, что они
            подчиняются своим внутренним правилам упорядочения, например, алфавитному порядку. К
            таким текстовым строкам можно применять операции сравнения (например, <quote>меньше
                чем</quote> или <quote>больше чем</quote>), при этом значения выражения должны
            вычисляться согласно определённой последовательности сортировки. Например, выражение
            'a'&lt;'b' означает, что 'a' предшествует 'b' в последовательности сортировки. Под
            выражением 'c'&gt;'b' имеется в виду, что в последовательности сортировки 'с' определено
            после 'b'. Текстовые строки, включающие больше одного символа, сортируются путём
            последовательного сравнения символов: сначала сравниваются первые символы двух строк,
            затем вторые символы и так далее, до тех пор, пока не будет найдено различие между двумя
            строками. Такое различие управляет порядком сортировки. </para>
        <para>Под сравнением (сортировкой) (COLLATION) принято понимать такой объект схемы, который
            определяет упорядочивающую последовательность (или последовательность
            сортировки).</para>
        <section xml:id="ddl-collation-create">
            <info>
                <title>CREATE COLLATION</title>
                <keywordset>
                    <keyword>CREATE COLLATION</keyword>
                    <keyword>NO PAD</keyword>
                    <keyword>PAD SPACE</keyword>
                    <keyword>CASE SENSITIVE</keyword>
                    <keyword>CASE INSENSITIVE</keyword>
                    <keyword>ACCENT SENSITIVE</keyword>
                    <keyword>ACCENT INSENSITIVE</keyword>
                </keywordset>
            </info>
            <indexterm><primary>CREATE COLLATION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Добавление новой сортировки (сравнения) для набора символов поддерживаемого в
                    базе данных.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
CREATE COLLATION <replaceable>collname</replaceable>
FOR <replaceable>charset</replaceable>
[FROM <replaceable>basecoll</replaceable> | FROM EXTERNAL ('<replaceable>extname</replaceable>')]
[NO PAD | PAD SPACE]
[CASE [IN]SENSITIVE]
[ACCENT [IN]SENSITIVE]
['<replaceable>&lt;specific-attributes&gt;</replaceable>'];

<replaceable>&lt;specific-attributes&gt;</replaceable> ::= <replaceable>&lt;attribute&gt;</replaceable> [; <replaceable>&lt;attribute&gt;</replaceable> ...]

<replaceable>&lt;attribute&gt;</replaceable> ::= <replaceable>attrname</replaceable>=<replaceable>attrvalue</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора CREATE COLLATION</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>collname</replaceable></entry>
                                <entry>
                                    <para>Имя сортировки (сравнения). Максимальная длина 63
                                        символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Набор символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>basecoll</replaceable></entry>
                                <entry>
                                    <para>Базовая сортировка (сравнение).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>extname</replaceable></entry>
                                <entry>
                                    <para>Имя сортировки из конфигурационного файла. Чувствительно к
                                        регистру.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор CREATE COLLATION ничего не <quote>создаёт</quote>, его целью является
                сделать сортировку известной для базы данных. Сортировка уже должна присутствовать в
                системе, как правило в файле библиотеки, и должна быть зарегистрирована в файле
                    <filename>fbintl.conf</filename> подкаталога <filename>intl</filename> корневой
                директории Firebird. </para>
            <para>Необязательное предложение FROM указывает сортировку, на основе которой будет
                создана новая сортировка. Такая сортировка должна уже присутствовать в базе данных.
                Если указано ключевое слово EXTERNAL, то будет осуществлён поиск сортировки из файла
                    <filename>$fbroot/intl/fbintl.conf</filename>, при этом
                    <replaceable>extname</replaceable> должно в точности соответствовать имени в
                конфигурационном файле (чувствительно к регистру).</para>
            <para>Если предложение FROM отсутвует, то Firebird ищет в конфигурационном файле
                    <filename>fbintl.conf</filename> подкаталога <filename>intl</filename> корневой
                директории сервера сортировку с именем, указанным сразу после CREATE COLLATION.
                Другими словами, отсутствие предложения FROM <replaceable>basecoll</replaceable>
                эквивалентно заданию FROM EXTERNAL ('<replaceable>collname</replaceable>').</para>

            <para>При создании сортировки можно указать учитываются ли конечные пробелы при
                сравнении. Если указана опция NO PAD, то конечные пробелы при сравнении учитываются.
                Если указана опция PAD SPACE, то конечные пробелы при сравнении не
                учитываются.</para>
            <para>Необязательное предложение CASE позволяет указать будет ли сравнение чувствительно
                к регистру. </para>
            <para>Необязательное предложение ACCENT позволяет указать будет ли сравнение
                чувствительно к акцентированным буквам (например <quote>е</quote> и
                <quote>ё</quote>).</para>

            <section xml:id="ddl-collation-specattr">
                <title>Специфичные атрибуты</title>
                <para>В операторе CREATE COLLATION можно также указать специфичные атрибуты для
                    сортировки. Ниже в таблице приведён список доступных специфичных атрибутов. Не
                    все атрибуты применимы ко всем сортировкам. Если атрибут не применим к
                    сортировке, но указан при её создании, то это не вызовет ошибки. </para>
                <important>
                    <para>Имена специфичных атрибутов чувствительны к регистру. </para>
                </important>
                <para><quote>1 bpc</quote> в таблице указывает на то, что атрибут действителен для
                    сортировок наборов символов, использующих 1 байт на символ (так называемый узкий
                    набор символов), а <quote>UNI</quote> — для юникодных сортировок.</para>
                <para>
                    <table frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Список доступных специфичных атрибутов COLLATION</title>
                        <tgroup cols="4">
                            <colspec colname="c1" colnum="1" colwidth="2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="1.2*" align="left"/>
                            <colspec colname="c3" colnum="3" colwidth="1.2*" align="left"/>
                            <colspec colname="c4" colnum="4" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Имя</entry>
                                    <entry align="center">Значение</entry>
                                    <entry align="center">Валидность</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>DISABLE-COMPRESSIONS</entry>
                                    <entry> 0, 1 </entry>
                                    <entry> 1 bpc </entry>
                                    <entry>Отключает сжатия (иначе сокращения). Сжатия заставляют
                                        определённые символьные последовательности быть
                                        сортированными как атомарные модули, например, испанские c +
                                        h как единственный символ ch. </entry>
                                </row>
                                <row>
                                    <entry>DISABLE-EXPANSIONS</entry>
                                    <entry> 0, 1</entry>
                                    <entry> 1 bpc </entry>
                                    <entry>Отключение расширений. Расширения позволяют рассматривать
                                        определённые символы (например, лигатуры или гласные
                                        умляуты) как последовательности символов и соответственно
                                        сортировать. </entry>
                                </row>
                                <row>
                                    <entry>ICU-VERSION</entry>
                                    <entry>
                                        <replaceable>default</replaceable> или
                                            <replaceable>M.m</replaceable>
                                    </entry>
                                    <entry>UNI</entry>
                                    <entry>Задаёт версию библиотеки ICU для использования.
                                        Допустимые значения определены в соответствующих элементах
                                        &lt;intl_module&gt; в файле
                                            <filename>intl/fbintl.conf</filename>. Формат: либо
                                        строка <quote>default</quote> или основной и дополнительный
                                        номер версии, как <quote>3.0</quote> (оба без кавычек).
                                    </entry>
                                </row>
                                <row>
                                    <entry>LOCALE</entry>
                                    <entry>
                                        <replaceable>xx_YY</replaceable>
                                    </entry>
                                    <entry>UNI</entry>
                                    <entry>Задаёт параметры сортировки языкового стандарта.
                                        Требуется полная версия библиотеки ICU. Формат строки:
                                            <quote>du_NL</quote> (без кавычек). </entry>
                                </row>
                                <row>
                                    <entry>MULTI-LEVEL</entry>
                                    <entry>0, 1</entry>
                                    <entry>1 bpc</entry>
                                    <entry>Использование нескольких уровней сортировки.</entry>
                                </row>
                                <row>
                                    <entry>NUMERIC-SORT</entry>
                                    <entry>0, 1</entry>
                                    <entry>UNI</entry>
                                    <entry>Обрабатывает непрерывные группы десятичных цифр в строке
                                        как атомарные модули и сортирует их в числовой
                                        последовательности (известна как естественная сортировка).
                                    </entry>
                                </row>
                                <row>
                                    <entry>SPECIALS-FIRST</entry>
                                    <entry>0, 1</entry>
                                    <entry>1 bpc</entry>
                                    <entry>Сортирует специальные символы (пробелы и т.д.) до
                                        буквенно-цифровых символов. </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
                <tip>
                    <para>Если вы хотите добавить в базу данных новый набор символов с его
                        умалчиваемой сортировкой, то зарегистрируйте и выполните хранимую процедуру
                            <emphasis>sp_register_character_name(name,
                            max_bytes_per_character)</emphasis> из подкаталога
                            <filename>misc/intl.sql</filename> установки Firebird. Для нормальной
                        работы с набором символов, он должен присутствовать в вашей операционной
                        системе, и зарегистрирован в файле <filename>fbintl.conf</filename>
                        поддиректории <filename>intl</filename>. </para>
                </tip>
            </section>
            <section xml:id="ddl-collation-create-who">
                <title>Кто может создать сортировку?</title>

                <para>Выполнить оператор <database>CREATE COLLATION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>CREATE COLLATION</database>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>

                <para>Пользователь, создавший сортировку, становится её владельцем.</para>
            </section>
            <section xml:id="ddl-collation-create-examples">
                <title>Примеры</title>
                <example>
                    <title>Создание сортировки с использованием имени, найденном в файле
                            <filename>fbintl.conf</filename> (регистро-чувствительно).</title>

                    <para><programlisting language="sql"> 
CREATE COLLATION ISO8859_1_UNICODE FOR ISO8859_1; 
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание сортировки с использованием специального (заданного
                        пользователем) названия (<quote>external</quote> имя должно в точности
                        соответствовать имени в файле <filename>fbintl.conf</filename>).</title>

                    <para><programlisting language="sql"> 
CREATE COLLATION LAT_UNI
FOR ISO8859_1
FROM EXTERNAL ('ISO8859_1_UNICODE');
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание регистронезависимой сортировки на основе уже присутствующей в
                        базе данных.</title>

                    <para><programlisting language="sql"> 
CREATE COLLATION ES_ES_NOPAD_CI
FOR ISO8859_1
FROM ES_ES
NO PAD
CASE INSENSITIVE;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание регистронезависимой сортировки на основе уже присутствующей в
                        базе данных со специфичными атрибутами.</title>

                    <para><programlisting language="sql"> 
CREATE COLLATION ES_ES_CI_COMPR
FOR ISO8859_1
FROM ES_ES
CASE INSENSITIVE
'DISABLE-COMPRESSIONS=0';
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Создание регистронезависимой сортировки по значению чисел (так называемой
                        натуральной сортировки).</title>

                    <para><programlisting language="sql"> 
CREATE COLLATION nums_coll FOR UTF8 
FROM UNICODE 
CASE INSENSITIVE 'NUMERIC-SORT=1';

CREATE DOMAIN dm_nums AS varchar(20) 
CHARACTER SET UTF8 COLLATE nums_coll; -- original (manufacturer) numbers

CREATE TABLE wares(id int primary key, articul dm_nums ...);
                </programlisting>
                    </para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-collation-drop">DROP COLLATION</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="ddl-collation-drop">
            <info>
                <title>DROP COLLATION</title>
                <keywordset>
                    <keyword>DROP COLLATION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>DROP COLLATION</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Удаление существующей сортировки.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DROP COLLATION <replaceable>collname</replaceable>;
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора DROP COLLATION</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>collname</replaceable></entry>
                                <entry>
                                    <para>Имя сортировки.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DROP COLLATION удаляет указанную сортировку. Сортировка должна
                присутствовать в базе данных, иначе будет выдана соответствующая ошибка. </para>
            <tip>
                <para>Если вы хотите удалить в базе данных набор символов со всеми его сортировками,
                    то зарегистрируйте и выполните хранимую процедуру <emphasis role="italic"
                        >sp_unregister_character_set(name)</emphasis> из подкаталога
                        <filename>misc/intl.sql</filename> установки Firebird. </para>
            </tip>
            <section xml:id="ddl-collation-drop-who">
                <title>Кто может удалить сортировку?</title>

                <para>Выполнить оператор <database>DROP COLLATION</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец сортировки; </para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией <database>DROP ANY
                                COLLATION</database>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-collation-drop-examples">
                <title>Примеры</title>
                <example>
                    <title>Удаление сортировки </title>
                    <para>
                        <programlisting language="sql">
DROP COLLATION ES_ES_NOPAD_CI;
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-collation-create">CREATE COLLATION</link>. </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="ddl-charset">
        <info>
            <title>CHARACTER SET</title>
            <keywordset>
                <keyword>CHARACTER SET</keyword>
            </keywordset>
        </info>

        <section xml:id="ddl-charset-alter">
            <info>
                <title>ALTER CHARACTER SET</title>
                <keywordset>
                    <keyword>ALTER CHARACTER SET</keyword>
                    <keyword>SET DEFAULT COLLATION</keyword>
                </keywordset>
            </info>
            <indexterm><primary>ALTER CHARACTER SET</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Установка сортировки по умолчанию для набора символов.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
ALTER CHARACTER SET <replaceable>charset</replaceable> 
SET DEFAULT COLLATION <replaceable>collation</replaceable>;
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора ALTER CHARACTER SET</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Набор символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Сортировка.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор ALTER CHARACTER SET изменяет сортировку по умолчанию для указанного
                набора символов. Это повлияет на использование набора символов в будущем, кроме
                случаев, когда явно переопределена сортировка COLLATE. Сортировка существующих
                доменов, столбцов и переменных PSQL при этом не будет изменена. </para>
            <note>
                <para>Если сортировка по умолчанию была изменена для набора символов базы данных
                    (тот, что был указан при создании базы данных), то также изменяется и сортировка
                    по умолчанию для базы данных. </para>
                <para>Если сортировка по умолчанию была изменена для набора символов, который был
                    указан при подключении, строковые константы будут интерпретироваться в
                    соответствии с новыми параметрами сортировки (если набор символов и/или
                    сортировка не переопределяются). </para>
            </note>
            <section xml:id="ddl-charset-alter-examples">
                <title>Примеры</title>
                <example>
                    <title>Установка сортировки UNICODE_CI_AI по умолчанию для кодировки
                        UTF8</title>
                    <para>
                        <programlisting language="sql">
ALTER CHARACTER SET UTF8 SET DEFAULT COLLATION UNICODE_CI_AI;
                </programlisting></para>
                </example>
            </section>
        </section>
    </section>

    <section xml:id="ddl-comment">
        <title>COMMENTS</title>
        <para>Объекты базы данных и сама база данных могут содержать примечания. Это удобное
            средство документирования во время разработки базы данных и её поддержки.</para>
        <section xml:id="ddl-commenton">
            <info>
                <title>COMMENT ON</title>
                <keywordset>
                    <keyword>COMMENT ON</keyword>
                </keywordset>
            </info>
            <indexterm><primary>COMMENT ON</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Документирование метаданных.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, ESQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>  
COMMENT ON <replaceable>&lt;object&gt;</replaceable> IS {'<replaceable>sometext</replaceable>' | NULL}
<replaceable>&lt;object&gt;</replaceable> ::= 
    DATABASE 
  | <replaceable>&lt;basic-type&gt;</replaceable> <replaceable>objectname</replaceable> 
  | COLUMN <replaceable>relationname</replaceable>.<replaceable>fieldname</replaceable> 
  | [PROCEDURE | FUNCTION] PARAMETER
    [<replaceable>package_name</replaceable>.] <replaceable>routinename</replaceable>.<replaceable>paramname</replaceable>
  | {PROCEDURE | [EXTERNAL] FUNCTION} 
    [<replaceable>package_name</replaceable>.]<replaceable>routinename</replaceable>

<replaceable>&lt;basic-type&gt;</replaceable> ::= 
    CHARACTER SET 
  | COLLATION 
  | DOMAIN 
  | EXCEPTION 
  | FILTER 
  | GENERATOR 
  | INDEX 
  | PACKAGE 
  | USER 
  | ROLE 
  | SEQUENCE 
  | TABLE 
  | TRIGGER 
  | VIEW               
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <title>Параметры оператора COMMENT ON</title>
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>sometext</replaceable></entry>
                                <entry>
                                    <para>Текст комментария.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>basic-type</replaceable></entry>
                                <entry>
                                    <para>Тип объекта метаданных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>objectname</replaceable></entry>
                                <entry>
                                    <para>Имя объекта метаданных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>relationname</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы или представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>filedname</replaceable></entry>
                                <entry>
                                    <para>Имя поля таблицы или представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>routinename</replaceable></entry>
                                <entry>
                                    <para>Имя хранимой процедуры или функции.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>paramname</replaceable></entry>
                                <entry>
                                    <para>Имя параметра хранимой процедуры или функции.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>package_name</replaceable></entry>
                                <entry>
                                    <para>Имя пакета.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор COMMENT ON добавляет комментарии для объектов базы данных (метаданных).
                Комментарии при этом сохраняются в текстовые поля RDB$DESCRIPTION типа BLOB
                соответствующей системной таблицы (из этих полей клиентское приложение может
                просмотреть комментарии). </para>
            <note>
                <para>Если вы вводите пустой комментарий (''), то он будет сохранен в базе данных
                    как NULL. </para>
            </note>
            <section xml:id="ddl-comment-who">
                <title>Кто может добавить комментарий?</title>

                <para>Выполнить оператор <database>COMMENT ON</database> могут: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para><link linkend="security-administrators"
                                >Администраторы</link></para>
                        </listitem>
                        <listitem>
                            <para>Владелец объекта, для которого добавляется комментарий;</para>
                        </listitem>
                        <listitem>
                            <para>Пользователи с привилегией ALTER ANY
                                    <replaceable>object_type</replaceable>. </para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>
            <section xml:id="ddl-commenton-examples">
                <title>Примеры</title>
                <example>
                    <title>Добавление комментария для текущей базы данных.</title>

                    <para><programlisting language="sql"> 
COMMENT ON DATABASE IS 'Это тестовая (''my.fdb'') БД';     
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Добавление комментария для таблицы.</title>

                    <para><programlisting language="sql"> 
COMMENT ON TABLE METALS IS 'Справочник металлов';    
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Добавление комментария для поля таблицы.</title>

                    <para><programlisting language="sql"> 
COMMENT ON COLUMN METALS.ISALLOY 
IS '0 = чистый металл, 1 = сплав';  
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Добавление комментария для параметра процедуры.</title>

                    <para><programlisting language="sql"> 
COMMENT ON PARAMETER ADD_EMP_PROJ.EMP_NO 
IS 'Код сотрудника';   
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Добавление комментария для пакета, его процедур и функций, и их
                        параметров.</title>

                    <para><programlisting language="sql"> 
COMMENT ON PACKAGE APP_VAR IS 'Переменные приложения';

COMMENT ON FUNCTION APP_VAR.GET_DATEBEGIN 
IS 'Возвращает дату начала периода';

COMMENT ON PROCEDURE APP_VAR.SET_DATERANGE 
IS 'Установка диапазона дат';

COMMENT ON 
PROCEDURE PARAMETER APP_VAR.SET_DATERANGE.ADATEBEGIN 
IS 'Дата начала';  
                </programlisting>
                    </para>
                </example>
            </section>
        </section>
    </section>
</chapter>
