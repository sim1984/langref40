[[fblangref-commons]]
= Общие элементы языка

В этой главе рассматриваются элементы, которые являются общими для всех реализаций языка SQL -- выражения, которые используются для извлечения и работают на утверждениях о данных, и предикатов, которые проверяют истинность этих утверждений.

[[fblangref-commons-expressions]]
== Выражения

Выражения SQL представляют формальные методы для вычисления, преобразования и сравнения значений.
Выражения SQL могут включать в себя столбцы таблиц, переменные, константы, литералы, различные операторы и предикаты, а так же другие выражения.
Полный список допустимых символов (tokens) в выражениях описан ниже.



.Описание элементов языка
Имя столбца::
Идентификаторы столбцов из указанных таблиц, используемые в
вычислениях, или сравнениях, или в качестве условия поиска. Столбец
типа массив не может быть элементом выражения, если только он не
проверяется на `IS [NOT] NULL`.

Элементы массива::
В выражении может содержаться ссылка на элемент массива, т.е. `<array_name>[__s__]`, где _``s``_ -- индекс элемента в массиве.

Арифметические операторы::
Символы `+`, `-`, `*`, `/` используемые для вычисления значений.

Оператор конкатенации::
Оператор `||` ("`две вертикальные линии`") используется для соединения символьных строк.

Логические операторы::
Зарезервированные слова `NOT`, `AND` и `OR` используются при
комбинировании простых условий поиска для создания сложных
утверждений.

Операторы сравнения::
Символы `=`, `<>`, `!=`, `~=`, `^=`, `<`, `++<=++`, `>`, `>=`, `!<`, `~<`, `^<`, `!>`, `~>` и `^>`

Предикаты сравнения::
`LIKE`, `STARTING WITH`, `CONTAINING`, `SIMILAR TO`, `BETWEEN`, `IS [NOT]
NULL`, `IS [NOT] {TRUE | FALSE | UNKNOWN}`, и `IS [NOT] DISTINCT FROM`

Предикаты существования::
Предикаты, используемые для проверки существования значений в
наборе. Предикат IN может быть использован как с наборами констант,
так и со скалярными подзапросами. Предикаты EXISTS, SINGULAR, ALL
ANY, SOME могут быть использованы только с подзапросами.

Константы и литералы::
Числа, заключённые в апострофы строковые литералы, логические
значения `TRUE`, `FALSE` и `UNKNOWN`, псевдозначение `NULL`.

Литералы дат и времени::
Выражения, подобные строковым литералам, заключённые в
апострофах, которые могут быть интерпретированы как значения даты,
времени или даты-времени. Литералами дат могут быть строки из
символов и чисел, такие как ``TIMESTAMP '25.12.2016
15:30:35'``, которые могут быть преобразованы в дату, время
или дату с временем.

Мнемоники дат и времени::
Строковый литерал с описанием желаемого значения даты и/или
времени, которое можно привести к типу даты и/или времени. Для
примера ``'NOW'``, ``'TODAY'``.

Контекстные переменные::
Встроенные <<fblangref-contextvars,контекстные переменные>>.

Локальные переменные::
Локальные переменные, входные или выходные параметры PSQL модулей
(хранимых процедур, триггеров, анонимных блоков PSQL).

Позиционные параметры::
В DSQL в качестве параметров запроса могут быть использованы
только позиционные параметры. Позиционные параметры представляют
собой знаки вопроса (?) внутри DSQL оператора. Доступ к таким
параметрам осуществляется по его номеру (позиции в запросе
относительно предыдущего позиционного параметра) поэтому они
называются позиционными. Обычно компоненты доступа позволяют
работать с именованными параметрами, которые они сами
преобразовывают в позиционные.

Подзапросы::
Оператор SELECT заключённый в круглые скобки, который возвращает
одно единственное (скалярное) значение или множество значений (при
использовании в предикатах существования).

Идентификаторы функций::
Идентификаторы встроенных или внешних функций в функциональных
выражениях.

Приведения типа::
Выражение явного преобразования одного типа данных в другой с использованием `CAST` как
`CAST(<value> AS <datatype>)`.

Условные выражения::
Выражение `CASE` и встроенные функции `COALESCE`, `NULLIF`.

Круглые скобки::
Пара скобок ( ... ) используются для группировки выражений.
Операции внутри скобок выполняются перед операциями вне скобок. При
использовании вложенных скобок, сначала вычисляются значения самых
внутренних выражений, а затем вычисления перемещаются наверх по
уровням вложенности.

Предложение `COLLATE`::
Предложение применяется к типам CHAR и VARCHAR, чтобы в указанной
кодировке установить параметры сортировки, используемые при
сравнении.

`NEXT VALUE FOR __sequence__`::
Конструкция `NEXT VALUE FOR` позволяет получить следующее значение
последовательности, то же самое делает встроенная функция `GEN_ID()`.

Выражение `AT`::
Выражение для изменения часового пояса даты и времени.


[[fblangref-commons-constants]]
=== Литералы (константы)

Литерал или константа -- это значение, подставляемое непосредственно в SQL оператор, которое не получено из выражения, параметра, ссылки на столбец или переменной. 

[[fblangref-commons-string-constant]]
==== Строковые литералы (константы)

Строковый литерал это последовательность символов, заключенных между парой апострофов ("`одинарных кавычек`"). Максимальная длина строковой константы составляет 65535 байт; максимальная количество символов будет определяться количеством байт, используемых для кодирования каждого символа.

[NOTE]
====

* Двойные кавычки _не должны_ (допускаются 1 диалектом) использоваться для квотирования строк. В SQL они предусмотрены для других целей.
* Если литерал апострофа требуется в строковой константе, то он может быть "`экранирован`" другим предшествующим апострофом. Например, 
+
[source]
----
'Mother O''Reilly's home-made hooch'
----
* Необходимо быть осторожным с длиной строки, если значение должно быть записано в столбец типа `VARCHAR`. Максимальная длина строки для типа `VARCHAR` составляет 32765 байт (32767 для типа `CHAR`). Если значение должно быть записано в столбец типа `BLOB`, то максимальная длина строкового литерала составляет 65535 байт.

Предполагается, что набор символов строковой константы совпадает с набором символов столбца предназначенного для её сохранения. 
====

[[fblangref-commons-hexstrings]]
===== Строковые константы в шестнадцатеричной нотации

Начиная с Firebird 2.5 строковые константы могут быть записаны в шестнадцатеричной нотации, так называемые "`двоичные строки`".
Каждая пара шестнадцатеричных цифр определяет один байт в строке.
Строки введённые таким образом будут иметь кодировку `OCTETS` по умолчанию,
но <<fblangref-commons-introducer-syntax,вводный синтаксис (introducer syntax)>> может быть использован для принудительной интерпретации строки в другом наборе символов.

.Синтаксис:
[listing,subs=+quotes]
----
{x|X}'<hexstring>'

<hexstring> ::= an even number of <hexdigit>
                                
<hexdigit> ::= 0..9 | A..F | a..f
----

.Примеры:
[example]
====
[source,sql]
----

SELECT x'4E657276656E' FROM rdb$database
-- returns 4E657276656E, a 6-byte 'binary' string

SELECT _ascii x'4E657276656E' FROM rdb$database
-- returns 'Nerven' (same string, now interpreted as ASCII text)

SELECT _iso8859_1 x'53E46765' FROM rdb$database
-- returns 'Säge' (4 chars, 4 bytes)

SELECT _utf8 x'53C3A46765' FROM rdb$database
-- returns 'Säge' (4 chars, 5 bytes)
----
====

[NOTE]
====
Как будут отображены двоичные строки зависит от интерфейса клиента.
Например, утилита [app]``isql`` использует заглавные буквы A-F, в то время как [app]``FlameRobin`` буквы в нижнем регистре.
Другие могут использовать другие правила конвертирования, например отображать пробелы между парами байт: '4E 65 72 76 65 6E'. 

Шестнадцатеричная нотация позволяет вставить любой байт (включая 00) в любой позиции в строке. 
====

[[fblangref-commons-qstrings]]
===== Альтернативы для апострофов в строковых литералах

Вместо двойного (экранированного) апострофа вы можете использовать другой символ или пару символов.

Ключевое слово `q` или `Q` предшествующее строке в кавычках сообщает парсеру, что некоторые левые и правые пары одинаковых символов являются разделителями для встроенного строкового литерала.

.Синтаксис:
[listing,subs=+quotes]
----
<alternate string literal> ::=
  { q | Q } <quote> <alternate start char> 
  [ { <char> }... ] 
  <alternate end char> <quote>
----

.Правила использования
[NOTE]
====
Когда [replaceable]``<alternate start char>`` является одним из символов '(', '{', '[' или '<', то [replaceable]``<alternate
                            end char>`` должен быть использован в паре с соответствующим "партнёром", а именно ')', '}', ']' или '>'. В других случаях [replaceable]``<alternate end char>`` совпадает с [replaceable]``<alternate start char>``. 

Внутри строки, т.е. [replaceable]``<char>`` элементах, одиночные (не экранированные) кавычки могут быть использованы.
Каждая кавычка будет частью результирующей строки. 
====

.Использование альтернативных апострофов в строковых литералах
[example]
====
[source]
----

-- result: abc{def}ghi
SELECT Q'{abc{def}ghi}' FROM rdb$database; 

-- result: That's a string
SELECT Q'!That's a string!' FROM rdb$database;
----
====


.Динамическая сборка запроса использующего строковые литералы.
[example]
====
[source,sql]
----

EXECUTE BLOCK
RETURNS (
  RDB$TRIGGER_NAME CHAR(64)
)
AS
  DECLARE VARIABLE S VARCHAR(8191);
BEGIN
  S = 'SELECT RDB$TRIGGER_NAME FROM RDB$TRIGGERS WHERE RDB$RELATION_NAME IN ';
  S = S || Q'! ('SALES_ORDER', 'SALES_ORDER_LINE')!';
  FOR
    EXECUTE STATEMENT :S
    INTO :RDB$TRIGGER_NAME
  DO
    SUSPEND;
END
----
====

[[fblangref-commons-introducer-syntax]]
===== Вводный синтаксис для строковых литералов

При необходимости, строковому литералу может предшествовать имя набор символов, который начинается с префикса подчеркивания "`_`".
Это известно как вводный синтаксис (Introducer syntax). Его цель заключается в информировании Firebird о том, как интерпретировать и хранить входящую строку.

.Вводный синтаксис для строковых литералов
[example]
====
[source,sql]
----

-- обратите внимание на префикс '_'
INSERT INTO People
VALUES (_ISO8859_1 'Hans-Jörg Schäfer');
----
====

[[fblangref-commons-number-constant]]
==== Числовые константы

Числовая константа -- это любое правильное число в одной из поддерживаемых нотаций: 

* В SQL, для чисел в стандартной десятичной записи, десятичная точка всегда представлена символом точки и тысячи не разделены. Включение запятых, пробелов, и т.д. вызовет ошибки.
* Экспоненциальная запись, например число 0.0000234 может быть записано как `2.34e-5`.
* Шестнадцатеричная запись (см. ниже) чисел поддерживается начиная с Firebird 2.5.

Далее показаны форматы числовых литералов и их типы.
Где `<d>` - десятичная цифра, `<h>` - шестнадцатеричная цифра.



.Формат числовых констант
[cols="3m,2", frame="all", options="header", stripes="none"]
|===
| Формат
| Тип

|`<d>[<d> ...]`
|`INTEGER` или ``BIGINT``.

|`0{x{vbar}X} <h><h>[<h><h> ...]`
|`INTEGER` для 1-8 `<h><h>` пар или `BIGINT` для 9-16 пар.

|`<d>[<d> ...].[<d> ...]`
|`NUMERIC(18, __n__)` где _n_ зависит от количества цифр после десятичной точки.

|`<d>[<d> ...][. [<d> ...]] E <d>[<d> ...]`
|`DOUBLE PRECISION`.
|===

[[fblangref-commons-hexnumbers]]
===== Шестнадцатеричная нотация чисел

Начиная с Firebird 2.5 целочисленные значения могут быть записаны в шестнадцатеричной системе счисления.
Числа состоящие из 1-8 шестнадцатеричных цифр будут интерпретированы как `INTEGER`, состоящие из 9-16 цифр -- как `BIGINT`.

.Синтаксис:
[listing,subs=+quotes]
----
{x|X}<hexdigits>

<hexdigits> ::= 1-16 of <hexdigit>
                                
<hexdigit> ::= 0..9 | A..F | a..f
----

.Шестнадцатиричные константы
[example]
====
[source,sql]
----

SELECT 0x6FAA0D3 FROM rdb$database -- returns 117088467
SELECT 0x4F9 FROM rdb$database -- returns 1273
SELECT 0x6E44F9A8 FROM rdb$database -- returns 1850014120
SELECT 0x9E44F9A8 FROM rdb$database -- returns -1639646808 (an INTEGER)
SELECT 0x09E44F9A8 FROM rdb$database -- returns 2655320488 (a BIGINT)
SELECT 0x28ED678A4C987 FROM rdb$database -- returns 720001751632263
SELECT 0xFFFFFFFFFFFFFFFF FROM rdb$database -- returns -1
----
====

[[fblangref-commons-hexranges]]
===== Диапазон значений шестнадцатеричных чисел


* Шестнадцатеричные числа в диапазоне 0 .. 7FFF FFFF являются положительными `INTEGER` числа со значениями 0 .. 2147483647. Для того чтобы интерпретировать константу как `BIGINT` число, необходимо дописать необходимо количества нулей слева. Это изменит тип, но не значение.
* Числа в диапазоне 8000 0000 .. FFFF FFFF требуют особого внимания: 
+
--
** При записи восемью шестнадцатеричный числами, такие как `0x9E44F9A8`, интерпретируется как 32-битное целое. Поскольку крайний левый (знаковый) бит установлен, то такие числа будут находиться в отрицательном диапазоне -2147483648 .. -1.
** Числа предварённые одним или несколькими нулями, такие как `0x09E44F9A8`, будут интерпретированы как 64-разрядный BIGINT в диапазоне значений 0000 0000 8000 0000 .. 0000 0000 FFFF FFFF. В этом случае знаковый бит не установлен, поэтому они отображаются в положительном диапазоне 2147483648 .. 4294967295 десятичных чисел.
--
+
Таким образом, только в этом диапазоне числа, предварённые совершенно незначимым нулём, имеют кардинально разные значения.
Это необходимо знать.
* Шестнадцатеричные числа в диапазоне 1 0000 0000 .. 7FFF FFFF FFFF FFFF являются положительными `BIGINT` числами.
* Шестнадцатеричные числа в диапазоне 8000 0000 0000 0000 .. FFFF FFFF FFFF FFFF являются отрицательными `BIGINT` числами.
* Числа с типом `SMALLINT` не могут быть записаны в шестнадцатеричном виде, строго говоря, так как даже `0x1` оценивается как `INTEGER`. Тем не менее, если вы записываете положительное целое число в пределах 16-разрядного диапазона от 0x0000 (десятичный ноль) до `0x7FFF` (десятичное 32767), то оно будет преобразовано в `SMALLINT` прозрачно.
+
Вы можете записать отрицательное `SMALLINT` число в шестнадцатеричном виде используя 4-байтное шестнадцатеричное число в диапазоне от `0xFFFF8000` (десятичное -32768) до `0xFFFFFFFF` (десятичное -1).


[[fblangref-commons-boolean-literal]]
==== Логические литералы

Логический литерал может быть одним из следующих значений: `TRUE`, `FALSE` или `UNKNOWN`.

[[fblangref-commons-sqloperators]]
=== Операторы SQL

SQL операторы включают в себя операторы для сравнения, вычисления, оценки и конкатенации значений.

[[fblangref-commons-operpreced]]
==== Приоритет операторов

Приоритет определяет порядок, в котором операторы и получаемые с помощью них значения вычисляются в выражении. 

Все операторы разбиты на 4 типа.
Каждый тип оператора имеет свой приоритет.
Чем выше приоритет типа оператора, тем раньше он будет вычислен.
Внутри одного типа операторы имеют собственный приоритет, который также определяет порядок их вычисления в выражении.
Операторы с одинаковым приоритетом вычисляются слева направо.
Для изменения порядка вычислений операции могут быть сгруппированы с помощью круглых скобок.

[[fblangref-dtyp-tbl-operpreced]]
.Приоритеты типов операторов
[cols="<1,<1,<3", options="header",stripes="none"]
|===
^| Тип оператора
^| Приоритет
^| Пояснение

|Конкатенация
|1
|Строки объединяются до выполнения любых других операций. 

|Арифметический
|2
|Арифметические операции выполняются после конкатенации
                                        строк, но перед выполнением операторов сравнения и
                                        логических операций.

|Сравнение
|3
|Операции сравнения вычисляются после конкатенации строк и
                                        выполнения арифметических операций, но до логических
                                        операций.

|Логический
|4
|Логические операторы выполняются после всех других типов
                                        операторов.
|===

[[fblangref-commons-concat]]
==== Оператор конкатенации

Оператор конкатенации `||` соединяет две символьные строки и создаёт одну строку.
Символьные стоки могут быть константами или значениями, полученными из столбцов или других выражений. 

.Оператор конкатенации
[example]
====
[source,sql]
----
SELECT LAST_NAME || ', ' || FIRST_NAME AS FULL_NAME
FROM EMPLOYEE
----
====

[[fblangref-commons-arith]]
==== Арифметические операторы

[[fblangref-dtyp-tbl-arithpreced]]
.Приоритет арифметических операторов
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Оператор
^| Назначение
^| Приоритет

|`{plus}signed_number`
|Унарный плюс
|1

|`-signed_number`
|Унарный минус
|1

|`{asterisk}`
|Умножение
|2

|`/`
|Деление
|2

|`{plus}`
|Сложение
|3

|`-`
|Вычитание
|3
|===

.Арифметические операторы
[example]
====
[source,sql]
----
 
UPDATE T
SET A = 4 + 1/(B-C)*D
----
====

[[fblangref-commons-compar]]
==== Операторы сравнения

[[fblangref-dtyp-tbl-comparpreced]]
.Операторы сравнения
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Оператор
^| Назначение
^| Приоритет

|`IS`
|Проверяет, что выражение в левой части является псевдо
значением `NULL` или соответствует логическому значению в
правой части.
|1

|`=`
|Равно, идентично
|2

|`<>`, `!=`, `~=`, `^=`
|Не равно
|2

|`>`
|Больше
|2

|`<`
|Меньше
|2

|`>=`
|Больше или равно
|2

|`++<=++`
|Меньше или равно
|2

|`!>`, `~>`, `^>`
|Не больше
|2

|`!<`, `~<`, `^<`
|Не меньше
|2
|===

В эту же группу входят предикаты сравнения <<fblangref-commons-isnotdistinct,IS DISTINCT FROM>>, <<fblangref-commons-predbetween,BETWEEN>>, <<fblangref-commons-in,IN>>, <<fblangref-commons-predlike,LIKE>>, <<fblangref-commons-predcontaining,CONTAINING>>, <<fblangref-commons-predstartwith,SIMILAR TO>> и другие.

.Использование оператора сравнения
[example]
====
[source,sql]
----
 
IF (SALARY > 1400) THEN   
...
----
====

.См. также:
<<fblangref-commons-othercomppreds,Другие предикаты сравнения>>.

[[fblangref-commons-logical]]
==== Логические операторы

[[fblangref-dtyp-tbl-logical]]
.Приоритет логических операторов
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Оператор
^| Назначение
^| Приоритет

|`NOT`
|Отрицание условия поиска.
|1

|`AND`
|Объединяет два предиката и более, каждый из которых
должен быть истинным, чтобы истинным был и весь
предикат.
|2

|`OR`
|Объединяет два предиката и более, из которых должен быть
истинным хотя бы один предикат, чтобы истинным был и весь
предикат.
|3
|===

.Использование логических операторов
[example]
====
[source,sql]
----
 
IF (A > B OR (A > C AND A > D) AND NOT (C = D)) THEN
...
----
====

[[fblangref-commons-at]]
=== `AT`

.Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
<expr> AT {TIME ZONE <time zone string> | LOCAL}                       
                        
<time zone string> ::=
    '<time zone>'                            
                            
<time zone> ::=
    <time zone region> |
    [+/-] <hour displacement> [: <minute displacement>]
----

Преобразует время или временную метку в указанный часовой пояс.
Если используется ключевое слово `LOCAL`, то преобразование происходит в часовой пояс сессии.


.Использование функции `AT`
[example]
====
[source,sql]
----

select time '12:00 GMT' at time zone '-03'
  from rdb$database;

select current_timestamp at time zone 'America/Sao_Paulo'
  from rdb$database;

select timestamp '2018-01-01 12:00 GMT' at local
  from rdb$database;
----
====

[[fblangref-commons-nxtvlufor]]
=== `NEXT VALUE FOR`

Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
NEXT VALUE FOR _sequence-name_
----

Возвращает следующее значение в последовательности (`SEQUENCE`). `SEQUENCE` является SQL совместимым термином генератора в InterBase и Firebird.
Оператор `NEXT VALUE FOR` полностью эквивалентен функции `GEN_ID (_sequence-name_, 1)` и является рекомендуемым синтаксисом.

[NOTE]
====
`NEXT VALUE FOR` не поддерживает значение приращения, отличное от того, что было указано при создании последовательности в предложении `INCREMENT [BY]`. Если требуется другое значение шага, то используйте старую функцию `GEN_ID`.
====

.Использование `NEXT VALUE FOR`
[example]
====
[source,sql]
----
 
NEW.CUST_ID = NEXT VALUE FOR CUSTSEQ;
----
====

.См. также:
<<fblangref-ddl-sequence,SEQUENCE (GENERATOR)>>, <<fblangref-scalarfuncs-gen-id,GEN_ID>>.

[[fblangref-commons-conditional]]
=== Условные выражения

Условное выражение -- это выражение, которое возвращает различные значения в зависимости от истинности некоторого условия или условий.
В данном разделе описано лишь одно условное выражение `CASE`.
Остальные условные выражения являются производными встроенными функциями и описаны в разделе <<fblangref-functions-conditional,Условные функции>>.

[[fblangref-commons-conditional-case]]
==== CASE

.Доступно в
DSQL, ESQL.

Оператор CASE возвращает только одно значение из нескольких возможных.
Есть два синтаксических варианта: 


* Простой `CASE`, сравнимый с Pascal [term]`case` или C [term]`switch`;
* Поисковый `CASE`, который работает как серия операторов "```if ... else if ... else if```".


[[fblangref-commons-conditional-case-simple]]
===== Простой CASE

.Синтаксис
[listing,subs=+quotes]
----
CASE <test-expr>
  WHEN <expr> THEN <result>
  [WHEN <expr> THEN <result> ...]
  [ELSE <defaultresult>]
END
----

При использовании этого варианта _test-expr_ сравнивается с первым _expr_,
затем вторым _expr_ и так далее,
до тех пор, пока не будет найдено совпадение, и тогда возвращается соответствующий результат.
Если совпадений не найдено, то возвращается _defaultresult_ из ветви `ELSE`.
Если нет совпадений, и ветвь `ELSE` отсутствует, то возвращается значение `NULL`.

Совпадение эквивалентно оператору "```=```", то есть
если _test-expr_ имеет значение `NULL`, то он не соответствует ни одному из _expr_, даже тем, которые имеют значение `NULL`.

Результаты необязательно должны быть литеральными значениями, они также могут быть именами полей, переменными, сложными выражениями или `NULL`.


.Использование простого CASE
[example]
====
[source,sql]
----
 
SELECT
  NAME,
  AGE,
  CASE UPPER(SEX)
    WHEN 'M' THEN 'Male'
    WHEN 'F' THEN 'Female'
    ELSE 'Unknown'
  END AS SEXNAME,
  RELIGION
FROM PEOPLE
----
====

Сокращённый вид простого оператора CASE используется в функции <<fblangref-scalarfuncs-decode,DECODE>>.

[[fblangref-commons-conditional-case-srched]]
===== Поисковый CASE

.Синтаксис
[listing,subs=+quotes]
----
CASE
  WHEN <bool_expr> THEN <result>
  [WHEN <bool_expr> THEN <result> …]
  [ELSE <defaultresult>]
END
----

Здесь [replaceable]``<bool_expr>`` выражение, которое даёт тройной логический результат: `TRUE`, `FALSE` или `NULL`.
Первое выражение, возвращающее `TRUE`, определяет результат.
Если нет выражений, возвращающих `TRUE`, то в качестве результата берётся [replaceable]``defaultresult`` из ветви `ELSE`.
Если нет выражений, возвращающих `TRUE`, и ветвь `ELSE` отсутствует, результатом будет `NULL`.

Как и в простом операторе `CASE`, результаты не обязаны быть литеральными значениями: они могут быть полями или именами переменных, сложными выражениями, или `NULL`.

.Использование поискового CASE
[example]
====
[source,sql]
----
 
CANVOTE = CASE
  WHEN AGE >= 18 THEN 'Yes'
  WHEN AGE < 18 THEN 'No'
  ELSE 'Unsure'
END;
----
====

[[fblangref-commons-null-in-expr]]
=== `NULL` в выражениях

`NULL` не является значением -- это состояние, указывающее, что значение элемента неизвестно или не существует.
Это не ноль, не пустота, не "`пустая строка`", и оно не ведёт себя как какое-то из этих значений.

При использовании `NULL` в числовых, строковых выражениях или в выражениях, содержащих дату/время, в результате вы всегда получите `NULL`.
При использовании `NULL` в логических (булевых) выражениях результат будет зависеть от типа операции и других вовлечённых значений.
При сравнении значения с `NULL` результат будет неопределённым (`UNKNOWN`).

[IMPORTANT]
====
Неопределённый логический результат `UNKNOWN` тоже представлен псевдо-значением `NULL`.
====

[[fblangref-commons-returningnull]]
==== Выражения возвращающие `NULL`

Выражения в этом списке всегда возвратят `NULL`:

[source,sql]
----
1 + 2 + 3 + NULL
'Home ' || 'sweet ' || NULL
MyField = NULL
MyField <> NULL
NULL = NULL
not (NULL)
----

Если вам трудно понять, почему, вспомните, что `NULL` -- значит "`неизвестно`".

[[fblangref-commons-nullinlogical]]
==== `NULL` в логических выражениях

Мы уже рассмотрели, что `not (NULL)` даёт в результате `NULL`.
Для операторов `AND` и `OR` взаимодействие несколько сложнее:

[listing,subs=+replacements]
----
NULL or false -> NULL
NULL or true -> true
NULL or NULL -> NULL
NULL and false -> false
NULL and true -> NULL
NULL and NULL -> NULL
----

.`NULL` в логических выражениях
[example]
====
[source,sql]
----

(1 = NULL) or (1 <> 1)    -- returns NULL
(1 = NULL) or FALSE       -- returns NULL
(1 = NULL) or (1 = 1)     -- returns TRUE
(1 = NULL) or TRUE        -- returns TRUE
(1 = NULL) or (1 = NULL)  -- returns NULL
(1 = NULL) or UNKNOWN     -- returns NULL
(1 = NULL) and (1 <> 1)   -- returns FALSE
(1 = NULL) and FALSE      -- returns FALSE
(1 = NULL) and (1 = 1)    -- returns NULL
(1 = NULL) and TRUE       -- returns NULL
(1 = NULL) and (1 = NULL) -- returns NULL
(1 = NULL) and UNKNOWN    -- returns NULL
----
====

[[fblangref-commons-subqueries]]
== Подзапросы

Подзапрос -- это специальный вид выражения, которое фактически является запросом, встроенным в другой запрос.
Подзапросы пишутся как обычные `SELECT` запросы, но должны быть заключены в круглые скобки.
Выражения подзапроса используется следующими способами: 

* Для задания выходного столбца в списке выбора `SELECT`;
* Для получения значений или условий для предикатов поиска (предложения `WHERE`, `HAVING`);
* Для создания набора данных, из которого включающий запрос может выбирать, как будто это обычная таблица или представление.
Подобные подзапросы появляются в предложении `FROM` (производные таблицы) или в общем табличном выражении (CTE).


[[fblangref-commons-correlatedsq]]
=== Коррелированные подзапросы

Подзапрос может быть коррелированным (соотнесённым). Запрос называется коррелированным, когда подзапрос и основной запрос взаимозависимы.
Это означает, что для обработки каждой записи подзапроса, должна быть получена также запись из основного запроса, т.е.
подзапросс всецело зависит от основного запроса.

.Коррелированный подзапрос
[example]
====
[source,sql]
----
 
SELECT *
FROM Customers C
WHERE EXISTS
      (SELECT *
       FROM Orders O
       WHERE C.cnum = O.cnum
         AND O.adate = DATE '10.03.1990');
----
====

При использовании подзапросов для получения значений выходного столбца в списке выбора `SELECT`, подзапрос должен возвращать скалярный результат.

[[fblangref-commons-scalarsq]]
=== Подзапросы возвращающие скалярный результат

__Подзапросы__, используемые в предикатах поиска, кроме предикатов существования и количественных предикатов, должны возвращать скалярный результат, то есть не более чем один столбец из одной отобранной строки или одно агрегированное значение, в противном случае, произойдёт ошибка времени выполнения ("`Multiple rows in a singleton select...`").

[NOTE]
====
Несмотря на то, что Firebird сообщает о подлинной ошибке, сообщение может немного вводить в заблуждение.
"`singleton SELECT`" -- это запрос, который не должен возвращать более одной строки.
Однако "`singleton`" и "`scalar`" не являются синонимами: не все одноэлементные SELECTS должны быть скалярными; а выборка по одному столбцу может возвращать несколько строк для предикатов существования и количественных предикатов.
====

.Подзапрос в качестве выходного столбца в списке выбора
[example]
====
[source,sql]
----
  
SELECT
    e.first_name,
    e.last_name,
    (SELECT
         sh.new_salary
     FROM
         salary_history sh
     WHERE
         sh.emp_no = e.emp_no
     ORDER BY sh.change_date DESC ROWS 1) AS last_salary
FROM
    employee e
----
====

.Подзапрос в предложении WHERE для получения значения максимальной зарплаты сотрудника и фильтрации по нему
[example]
====
[source,sql]
----
  
SELECT
    e.first_name,
    e.last_name,
    e.salary
FROM
    employee e
WHERE
    e.salary = (SELECT
                    MAX(ie.salary)
                FROM
                    employee ie)
----
====

[[fblangref-commons-predicates]]
== Предикаты

Предикат -- это простое выражение, утверждающее некоторый факт, назовем его `P`.
Если `P` разрешается как TRUE, он успешен.
Если он принимает значение FALSE или NULL (UNKNOWN), он терпит неудачу.
Однако здесь кроется ловушка: предположим, что предикат `P` возвращает FALSE.
В этом случае `NOT (P)` вернет TRUE.
С другой стороны, если `P` возвращает NULL (неизвестно), то `NOT (P)` также возвращает NULL.

В SQL предикаты проверяют в ограничении `CHECK`, предложении `WHERE`, выражении `CASE`, условии соединения во фразе ON для предложений JOIN, а также в предложении `HAVING`.
В PSQL операторы управления потоком выполнения проверяют предикаты в предложениях `IF`, `WHILE` и `WHEN`. Поскольку начиная с Firebird 3.0 введена поддержка логического типа, то предикат может встречаться в любом правильном выражении.

[[fblangref-commons-condition]]
=== Утверждения

Проверяемые условия не всегда являются простыми предикатами.
Они могут быть группой предикатов, каждый из которых при вычислении делает вклад в вычислении общей истинности.
Такие сложные условия называются утверждениями.
Утверждения могут состоять из одного или нескольких предикатов, связанных логическими операторами `AND`, `OR` и `NOT`. Для группировки предикатов и управления порядком вычислений можно использовать скобки.

Каждый из предикатов может содержать вложенные предикаты.
Результат вычисления истинности утверждения получается в результате вычисления всех предикатов по направлению от внутренних к внешним.
Каждый "`уровень`" вычисляется в порядке приоритета до тех пор, пока не будет получено значение истинности окончательного утверждения.

[[fblangref-commons-comppreds]]
=== Предикаты сравнения

Предикат сравнения представляет собой два выражения, соединяемых оператором сравнения.
Имеется шесть традиционных операторов сравнения: 

[listing]
----
=, >, <, >=, <=, <>
----

(Полный список операторов сравнения см. <<fblangref-commons-compar,Операторы сравнения>>).

Если в одной из частей (левой или правой) предиката сравнения встречается NULL, то значение предиката будет неопределённым (UNKNOWN). 

.Предикаты сравнения
[example]
====
Получить информацию о компьютерах, имеющих частоту процессора не менее 500 МГц и цену ниже $800

[source,sql]
----
  
SELECT * 
FROM Pc 
WHERE speed >= 500 AND price < 800;
----

Получить информацию обо всех принтерах, которые являются матричными и стоят меньше $300

[source,sql]
----
  
SELECT * 
FROM Printer 
WHERE type = 'matrix' AND price < 300;
----

Следующий запрос не вернёт ни одной записи, поскольку сравнение происходит с псевдо-значением `NULL`, даже если существуют принтеры с неуказанным типом.

[source,sql]
----
  
SELECT * 
FROM Printer 
WHERE type = NULL AND price < 300;
----
====

.Замечание о сравнении строк
[NOTE]
====
При сравнении на равенство полей типов `CHAR` и `VARCHAR` завершающий пробелы игнорируются во всех случаях.
====

[[fblangref-commons-othercomppreds]]
=== Другие предикаты сравнения

Другие предикаты сравнения состоят из ключевых слов.

[[fblangref-commons-predbetween]]
==== `BETWEEN`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> [NOT] BETWEEN <value_1> AND <value_2>
----

Предикат `BETWEEN` проверяет, попадает (или не попадает при использовании NOT) ли значение во включающий диапазон значений.

Операнды для предиката `BETWEEN` -- это два аргумента совместимых типов.
В отличие от некоторых других СУБД в Firebird предикат `BETWEEN` не является симметричным.
Меньшее значение должно быть первым аргументом, иначе предикат `BETWEEN` всегда будет ложным.
Поиск является включающим.
Таким образом, предикат `BETWEEN` можно переписать следующим образом:

[listing,subs=+quotes]
----
<value> >= <value_1> AND <value> <= <value_2>
----

При использовании предиката `BETWEEN` в поисковых условиях DML запросов, оптимизатор Firebird может использовать индекс по искомому столбцу, если таковой доступен.

.Использование предиката `BETWEEN`
[example]
====
[source,sql]
----
  
SELECT *
FROM EMPLOYEE
WHERE HIRE_DATE BETWEEN date '01.01.1992' AND CURRENT_DATE
----
====

[[fblangref-commons-predlike]]
==== `LIKE`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
<match value> [NOT] LIKE <pattern>
  [ESCAPE <escape character>]

<match value> ::= _выражение символьного типа_
<pattern> ::= _шаблон поиска_
<escape character> ::= _символ экранирования_
----


Предикат `LIKE` сравнивает выражение символьного типа с шаблоном, определённым во втором выражении.
Чувствительность к регистру или диакритическим знакам при сравнении определяется используемым параметром сортировки (`COLLATION`).

При использовании оператора `LIKE` во внимание принимаются все символы строки-шаблона.
Это касается так же начальных и конечных пробелов.
Если операция сравнения в запросе должна вернуть все строки, содержащие строки LIKE 'абв ' (с символом пробела на конце), то строка, содержащая 'абв' (без пробела), не будет возвращена.

[[fblangref-commons-wildcards]]
===== Трафаретные символы

В шаблоне, разрешается использование двух трафаретных символов: 

* символ процента (`%`) заменяет последовательность любых символов (число символов в последовательности может быть от 0 и более) в проверяемом значении;
* символ подчёркивания (`++_++`), который можно применять вместо любого единичного символа в проверяемом значении.

Если проверяемое значение соответствует образцу с учётом трафаретных символов, то предикат истинен.

[[fblangref-commons-escapechar]]
===== Использование управляющего символа в предложении `ESCAPE`

Если искомая строка содержит трафаретный символ, то следует задать управляющий символ в предложении `ESCAPE`.
Этот управляющий символ должен использоваться в образце перед трафаретным символом, сообщая о том, что последний следует трактовать как обычный символ.

===== Примеры использования предиката `LIKE`

.Поиск строк начинающихся с заданной подстроки с использованеим предиката LIKE
[example]
====

Поиск номеров отделов, названия которых начинаются со слова "`Software`"

[source,sql]
----
  
SELECT DEPT_NO
FROM DEPT
WHERE DEPT_NAME LIKE 'Software%';
----

В данном запросе может быть использован индекс, если он построен на поле DEPT_NAME.
====

.Оптимизация LIKE
[NOTE]
====
В общем случае предикат `LIKE` не использует индекс.
Однако если предикат принимает вид `LIKE 'string%'`, то он будет преобразован в предикат `STARTING WITH`, который будет использовать индекс.
Если вам необходимо выполнить поиск с начала строки, то вместо предиката `LIKE` рекомендуется использовать предикат <<fblangref-commons-predstartwith,STARTING WITH>>.
====

.Использование трафаретного символа "`_`" в предикате LIKE
[example]
====
Поиск сотрудников, имена которых состоят из 5 букв, начинающихся с букв "`Sm`" и заканчивающихся на "`th`".
В данном случае предикат будет истинен для имен "`Smith`" и "`Smyth`". 


[source,sql]
----
SELECT
    first_name
FROM
    employee
WHERE first_name LIKE 'Sm_th'
----
====

.Поиск внутри строки с использованем предиката LIKE
[example]
====
Поиск всех заказчиков, в адресе которых содержится строка "`Ростов`".


[source,sql]
----
  
SELECT *
FROM CUSTOMER
WHERE ADDRESS LIKE '%Ростов%'
----
====

[TIP]
====
Если вам необходимо выполнить поиск внутри строки, то вместо предиката `LIKE` рекомендуется использовать предикат <<fblangref-commons-predcontaining,CONTAINING>>.
====

.Использование управляющего символа в предложении ESCAPE с предикатом LIKE
[example]
====
Поиск таблиц, содержащих в имени знак подчёркивания.
В данном случае в качестве управляющего символа задан символ "`#`".

[source,sql]
----
  
SELECT
  RDB$RELATION_NAME
FROM RDB$RELATIONS
WHERE RDB$RELATION_NAME LIKE '%#_%' ESCAPE '#'
----
====

.См. также:
<<fblangref-commons-predstartwith,STARTING WITH>>, <<fblangref-commons-predcontaining,CONTAINING>>, <<fblangref-commons-predsimilarto,SIMILAR TO>>.

[[fblangref-commons-predstartwith]]
==== `STARTING WITH`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> [NOT] STARTING WITH <start-value>
----

Предикат `STARTING WITH` ищет строку, которая начинается с символов в его аргументе _start-value_.
Чувствительность к регистру и ударению в `STARTING WITH` зависит от сортировки (`COLLATION`) первого аргумента _value_.

При использовании предиката `STARTING WITH` в поисковых условиях DML запросов, оптимизатор Firebird может использовать индекс по искомому столбцу, если он определён.

.Использование предиката `STARTING WITH`
[example]
====
Поиск сотрудников, фамилия которых начинается с "`Jo`".


[source,sql]
----
  
SELECT LAST_NAME, FIRST_NAME
FROM EMPLOYEE
WHERE LAST_NAME STARTING WITH 'Jo'
----
====

.См. также:
<<fblangref-commons-predlike,LIKE>>.

[[fblangref-commons-predcontaining]]
==== `CONTAINING`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> [NOT] CONTAINING <substring>
----

Оператор `CONTAINING` ищет строку или тип, подобный строке, отыскивая последовательность символов, которая соответствует его аргументу.
Он может быть использован для алфавитно-цифрового (подобного строковому) поиска в числах и датах.
Поиск CONTAINING не чувствителен к регистру.
Тем не менее, если используется сортировка чувствительная к акцентам, то поиск будет чувствителен к акцентам.

При использовании оператора `CONTAINING` во внимание принимаются все символы строки.
Это касается так же начальных и конечных пробелов.
Если операция сравнения в запросе должна вернуть все строки, содержащие строки `CONTAINING 'абв '` (с символом пробела на конце), то строка, содержащая `'абв'` (без пробела), не будет возвращена.

При использовании предиката `CONTAINING` в поисковых условиях DML запросов, оптимизатор Firebird не может использовать индекс по искомому столбцу.

.Поиск подстроки с использованием предиката `CONTAINING`
[example]
====
Поиск проектов в именах, которых присутствует подстрока "`Map`":


[source,sql]
----
  
SELECT *
FROM PROJECT
WHERE PROJ_NAME CONTAINING 'map';
----

В данном случае будет возвращены две строки с именами "`AutoMap`" и "`MapBrowser port`". 
====

.Поиск внутри даты с ипользованием предиката CONTAINING
[example]
====
Поиск записей об изменении зарплат с датой содержащей число 84 (в данном случае изменения, которые произошли в 1984 году):

[source,sql]
----
  
SELECT *
FROM SALARY_HISTORY
WHERE CHANGE_DATE CONTAINING 84;
----
====

.См. также:
<<fblangref-commons-predlike,LIKE>>.

[[fblangref-commons-predsimilarto]]
==== `SIMILAR TO`

.Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
_string-expression_ [NOT] SIMILAR TO <pattern> [ESCAPE <escape-char>]

<pattern> ::= _регулярное выражение SQL_
<escape-char> ::= _символ экранирования_
----


Оператор `SIMILAR TO` проверяет соответствие строки с шаблоном регулярного выражения SQL.
В отличие от некоторых других языков для успешного выполнения шаблон должен соответствовать всей строке -- соответствие подстроки недостаточно.
Если один из операндов имеет значение `NULL`, то и результат будет `NULL`.
В противном случае результат является `TRUE` или `FALSE`.

[[fblangref-commons-syntaxregex]]
===== Синтаксис регулярных выражений SQL

Следующий синтаксис определяет формат регулярного выражения SQL.
Это полное и корректное его определение.
Он является весьма формальным и довольно длинным и, вероятно, озадачивает тех, кто не имеет опыта работы с регулярными выражениями.
Не стесняйтесь пропустить его и начать читать следующий раздел, <<fblangref-commons-buildregex,Создание регулярных выражений>>, использующий подход от простого к сложному.

[listing,subs=+quotes]
----
<regular expression> ::= <regular term> ['|' <regular term> ...]

<regular term> ::= <regular factor> ...

<regular factor> ::= <regular primary> [<quantifier>]

<quantifier> ::= ? | * | + | '{' <m> [,[<n>]] '}'

<m>, <n> ::= _целые положительные числа, если присутвуют оба числа, то <m> <= <n>_

<regular primary> ::=
    <character> | <character class> | %
  | (<regular expression>)

<character> ::= <escaped character> | <non-escaped character>

<escaped character> ::=
  <escape-char> <special character> | <escape-char> <escape-char>

<special character> ::= __любой из символов **[]()|^-+*%\_?{}**__

<non-escaped character> ::=
  __любой символ за исключением <special character>__
  __и не эквивалентный <escape-char> (если задан)__

<character class> ::=
    '_' | '[' <member> ... ']' | '[^' <non-member> ... ']'
  | '[' <member> ... '^' <non-member> ... ']'

<member>, <non-member> ::= <character> | <range> | <predefined class>

<range> ::= <character>-<character>

<predefined class> ::= '[:' <predefined class name> ':]'

<predefined class name> ::=
  ALPHA | UPPER | LOWER | DIGIT | ALNUM | SPACE | WHITESPACE
----

[[fblangref-commons-buildregex]]
===== Создание регулярных выражений 

В этом разделе представлены элементы и правила построения регулярных выражений SQL.

[[fblangref-commons-regexchar]]
====== Символы

В регулярных выражениях большинство символов представляет сами себя, за исключением специальных символов (special character):

[listing]
----
[ ] ( ) | ^ - + * % _ ? { }
----

$$...$$ и управляющих символов (escaped character), если они заданы.

Регулярному выражению, не содержащему специальных или управляющих символов, соответствует только полностью идентичные строки (в зависимости от используемой сортировки). То есть это функционирует точно так же, как оператор "```=```":


[source,sql]
----

'Apple' SIMILAR TO 'Apple' -- TRUE
'Apples' SIMILAR TO 'Apple' -- FALSE
'Apple' SIMILAR TO 'Apples' -- FALSE
'APPLE' SIMILAR TO 'Apple' -- в зависимости от сортировки
----

[[fblangref-commons-regexwildcards]]
====== Шаблоны

Известным SQL шаблонам '```++_++```' и '```%```' соответствует любой единственный символ и строка любой длины, соответственно:


[source,sql]
----

'Birne' SIMILAR TO 'B_rne' -- TRUE
'Birne' SIMILAR TO 'B_ne' -- FALSE
'Birne' SIMILAR TO 'B%ne' -- TRUE
'Birne' SIMILAR TO 'Bir%ne%' -- TRUE
'Birne' SIMILAR TO 'Birr%ne' -- FALSE
----

Обратите внимание, что шаблон '```%```' также соответствует пустой строке.

[[fblangref-commons-regexcharclass]]
====== Классы символов

Набор символов, заключённый в квадратные скобки определяют класс символов.
Символ в строке соответствует классу в шаблоне, если символ является элементом класса:


[source,sql]
----

'Citroen' SIMILAR TO 'Cit[arju]oen' -- TRUE
'Citroen' SIMILAR TO 'Ci[tr]oen' -- FALSE
'Citroen' SIMILAR TO 'Ci[tr][tr]oen' -- TRUE
----

Как видно из второй строки классу только соответствует единственный символ, а не их последовательность.

Два символа, соединённые дефисом, в определении класса определяют диапазон.
Диапазон для активного сопоставления включает в себя эти два конечных символа и все символы, находящиеся между ними.
Диапазоны могут быть помещены в любом месте в определении класса без специальных разделителей, чтобы сохранить в классе и другие символы.


[source,sql]
----

'Datte' SIMILAR TO 'Dat[q-u]e' -- TRUE
'Datte' SIMILAR TO 'Dat[abq-uy]e' -- TRUE
'Datte' SIMILAR TO 'Dat[bcg-km-pwz]e' -- FALSE
----

[float]
[[fblangref-commons-regexpredclass]]
====== Предопределённые классы символов

Следующие предопределенные классы символов также могут использоваться в определении класса:



`[:ALPHA:]`::
Латинские буквы a...z и A...Z.
Этот класс также включает символы с диакритическими знаками при нечувствительных к акцентам сортировках.

`[:DIGIT:]`::
Десятичные цифры 0...9.

`[:ALNUM:]`::
Объединение [:ALPHA:] и [:DIGIT:].

`[:UPPER:]`::
Прописные (в верхнем регистре) латинские буквы A...Z.
Также включает в себя символы в нижнем регистре при нечувствительных к регистру сортировках и символы с диакритическими знаками при нечувствительных к акцентам сортировках.

`[:LOWER:]`::
Строчные (в нижнем регистре) латинские буквы a...z.
Также включает в себя символы в верхнем регистре при нечувствительных к регистру сортировках и символы с диакритическими знаками при нечувствительных к акцентам сортировках.

`[:SPACE:]`::
Символ пробела (ASCII 32).

`[:WHITESPACE:]`::
Горизонтальная табуляция (ASCII 9), перевод строки (ASCII 10), вертикальная табуляция (ASCII 11), разрыв страницы (ASCII 12), возврат каретки (ASCII 13) и пробел (ASCII 32).

Включение в оператор `SIMILAR TO` предопределённого класса имеет тот же эффект, как и включение всех его элементов.
Использование предопределённых классов допускается только в пределах определения класса.
Если вам нужно сопоставление только с предопределённым классом и ничего больше, то поместите дополнительную пару скобок вокруг него.


[source,sql]
----

'Erdbeere' SIMILAR TO 'Erd[[:ALNUM:]]eere' -- TRUE
'Erdbeere' SIMILAR TO 'Erd[[:DIGIT:]]eere' -- FALSE
'Erdbeere' SIMILAR TO 'Erd[a[:SPACE:]b]eere' -- TRUE
'Erdbeere' SIMILAR TO '[[:ALPHA:]]' -- FALSE
'E' SIMILAR TO '[[:ALPHA:]]' -- TRUE
----

Если определение класса запускается со знаком вставки (^), то все, что следует за ним, исключается из класса.
Все остальные символы проверяются.


[source,sql]
----

'Framboise' SIMILAR TO 'Fra[^ck-p]boise' -- FALSE
'Framboise' SIMILAR TO 'Fr[^a][^a]boise' -- FALSE
'Framboise' SIMILAR TO 'Fra[^[:DIGIT:]]boise' -- TRUE
----

Если знак вставки (^) находится не в начале последовательности, то класс включает в себя все символы до него и исключает символы после него.


[source,sql]
----

'Grapefruit' SIMILAR TO 'Grap[a-m^f-i]fruit' -- TRUE
'Grapefruit' SIMILAR TO 'Grap[abc^xyz]fruit' -- FALSE
'Grapefruit' SIMILAR TO 'Grap[abc^de]fruit' -- FALSE
'Grapefruit' SIMILAR TO 'Grap[abe^de]fruit' -- FALSE
'3' SIMILAR TO '[[:DIGIT:]^4-8]' -- TRUE
'6' SIMILAR TO '[[:DIGIT:]^4-8]' -- FALSE
----

Наконец, уже упомянутый подстановочный знак '```++_++```' является собственным классом символов, соответствуя любому единственному символу.

[[fblangref-commons-regexquantifiers]]
====== Кванторы

Вопросительный знак ('```?```') сразу после символа или класса указывает на то, что для соответствия предыдущий элемент должен встретиться 0 или 1 раз:

[source,sql]
----

'Hallon' SIMILAR TO 'Hal?on' -- FALSE
'Hallon' SIMILAR TO 'Hal?lon' -- TRUE
'Hallon' SIMILAR TO 'Halll?on' -- TRUE
'Hallon' SIMILAR TO 'Hallll?on' -- FALSE
'Hallon' SIMILAR TO 'Halx?lon' -- TRUE
'Hallon' SIMILAR TO 'H[a-c]?llon[x-z]?' -- TRUE
----

Звёздочка ('```{asterisk}```') сразу после символа или класса указывает на то, что для соответствия предыдущий элемент должен встретиться 0 или более раз:

[source,sql]
----

'Icaque' SIMILAR TO 'Ica*que' -- TRUE
'Icaque' SIMILAR TO 'Icar*que' -- TRUE
'Icaque' SIMILAR TO 'I[a-c]*que' -- TRUE
'Icaque' SIMILAR TO '_*' -- TRUE
'Icaque' SIMILAR TO '[[:ALPHA:]]*' -- TRUE
'Icaque' SIMILAR TO 'Ica[xyz]*e' -- FALSE
----

Знак плюс ('```{plus}```') сразу после символа или класса указывает на то, что для соответствия предыдущий элемент должен встретиться 1 или более раз:

[source,sql]
----

'Jujube' SIMILAR TO 'Ju_+' -- TRUE
'Jujube' SIMILAR TO 'Ju+jube' -- TRUE
'Jujube' SIMILAR TO 'Jujuber+' -- FALSE
'Jujube' SIMILAR TO 'J[jux]+be' -- TRUE
'Jujube' SIMILAR TO 'J[[:DIGIT:]]+ujube' -- FALSE
----

Если символ или класс сопровождаются числом, заключённым в фигурные скобки ('```{```'  и '```}```'), то для соответствия необходимо повторение элемента точно это число раз:

[source,sql]
----

'Kiwi' SIMILAR TO 'Ki{2}wi' -- FALSE
'Kiwi' SIMILAR TO 'K[ipw]{2}i' -- TRUE
'Kiwi' SIMILAR TO 'K[ipw]{2}' -- FALSE
'Kiwi' SIMILAR TO 'K[ipw]{3}' -- TRUE
----

Если число сопровождается запятой ('```,```'), то для соответствия необходимо повторение элемента как минимум это число раз:

[source,sql]
----

'Limone' SIMILAR TO 'Li{2,}mone' -- FALSE
'Limone' SIMILAR TO 'Li{1,}mone' -- TRUE
'Limone' SIMILAR TOto 'Li[nezom]{2,}' -- TRUE
----

Если фигурные скобки содержат два числа ([replaceable]``m`` и [replaceable]``n``), разделённые запятой, и второе число больше первого, то для соответствия элемент должен быть повторен, как минимум, [replaceable]``m`` раз и не больше [replaceable]``n`` раз:

[source,sql]
----

'Mandarijn' SIMILAR TO 'M[a-p]{2,5}rijn' -- TRUE
'Mandarijn' SIMILAR TO 'M[a-p]{2,3}rijn' -- FALSE
'Mandarijn' SIMILAR TO 'M[a-p]{2,3}arijn' -- TRUE
----

Кванторы '```?```', '```{asterisk}```' и '```{plus}```' являются сокращением для `{0,1}`, `{0,}` и `{1,}`, соответственно.

[[fblangref-commons-regexoring]]
====== Термин ИЛИ

В условиях регулярных выражений можно использовать оператор ИЛИ '```|```'. Соответствие произошло, если строка параметра соответствует, по крайней мере, одному из условий:

[source,sql]
----

'Nektarin' SIMILAR TO 'Nek|tarin' -- FALSE
'Nektarin' SIMILAR TO 'Nektarin|Persika' -- TRUE
'Nektarin' SIMILAR TO 'M_+|N_+|P_+' -- TRUE
----

[[fblangref-commons-regexsubexpr]]
====== Подвыражения

Одна или более частей регулярного выражения могут быть сгруппированы в подвыражения (также называемые подмасками). Для этого их нужно заключить в круглые скобки ('```(```' и '```)```'):

[source,sql]
----

'Orange' SIMILAR TO 'O(ra|ri|ro)nge' -- TRUE
'Orange' SIMILAR TO 'O(r[a-e])+nge' -- TRUE
'Orange' SIMILAR TO 'O(ra){2,4}nge' -- FALSE
'Orange' SIMILAR TO 'O(r(an|in)g|rong)?e' -- TRUE
----

[[fblangref-commons-regexescap]]
====== Экранирование специальных символов

Для исключения из процесса сопоставления специальных символов (которые часто встречаются в регулярных выражениях) их надо экранировать.
Специальных символов экранирования по умолчанию нет -- их при необходимости определяет пользователь:

[source]
----

'Peer (Poire)' SIMILAR TO 'P[^ ]+ \(P[^ ]+\)' ESCAPE '\' -- TRUE
'Pera [Pear]' SIMILAR TO 'P[^ ]+ #[P[^ ]+#]' ESCAPE '#' -- TRUE
'Paron-Appledryck' SIMILAR TO 'P%$-A%' ESCAPE '$' -- TRUE
'Parondryck' SIMILAR TO 'P%--A%' ESCAPE '-' -- FALSE
----

[[fblangref-commons-isnotdistinct]]
==== `IS DISTINCT FROM`

.Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
<operand1> IS [NOT] DISTINCT FROM <operand2>
----

Два операнда считают _DISTINCT_ (различными), если они имеют различные значения, или если одно из них -- `NULL`, а другое нет.
Они считаются _NOT DISTINCT_ (равными), если имеют одинаковые значения или оба имеют значение `NULL`.

`IS [NOT] DISTINCT FROM` всегда возвращает `TRUE` или `FALSE` и никогда `UNKNOWN` (NULL) (неизвестное значение). Операторы '```=```' и '```<>```', наоборот, вернут `UNKNOWN` (NULL), если один или оба операнда имеют значение NULL.


.Результаты выполнения различных операторов сравнения
[cols="3,^.^2m,^.^2m,^.^2m,^.^2m"]
|===
.2+h|  Характеристики операнда
4+h|  Результаты различных операторов

^.^m| =
| IS NOT DISTINCT FROM
|  <> 
| IS DISTINCT FROM

| Одинаковые значения 
| TRUE 
| TRUE 
| FALSE 
| FALSE 

| Различные значения 
| FALSE 
| FALSE 
| TRUE 
| TRUE 

| Оба `NULL`
| UNKNOWN 
| TRUE 
| UNKNOWN 
| FALSE 

| Одно `NULL`
| UNKNOWN 
| FALSE 
| UNKNOWN 
| TRUE 
|===

.Использование предиката `IS [NOT] DISTINCT FROM`
[example]
====
[source,sql]
----

SELECT ID, NAME, TEACHER
FROM COURSES
WHERE START_DAY IS NOT DISTINCT FROM END_DAY

IF (NEW.JOB IS DISTINCT FROM OLD.JOB) THEN
  POST_EVENT 'JOB_CHANGED';
----
====

.См. также:
<<fblangref-commons-isnotboolean>>, <<fblangref-commons-isnotnull>>.

[[fblangref-commons-isnotboolean]]
==== Логический `IS [NOT]`

.Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> IS [NOT] {TRUE | FALSE | UNKNOWN}
----

Оператор `IS` проверяет, что выражение в левой части соответствует логическому значению в правой части.
Выражение в левой части должно быть логического типа, иначе будет выдана ошибка.

Для логического типа данных предикат `IS [NOT] UNKNOWN` эквивалентен `IS [NOT] NULL`.

.Замечание:
[NOTE]
====
В правой части предиката могут быть использованы только литералы `TRUE`, `FALSE`, `UNKNOWN`, но не выражения.
====

.Использование оператора IS с логическим типом данных
[example]
====
[source,sql]
----

-- Проверка FALSE значения 
SELECT * FROM TBOOL WHERE BVAL IS FALSE
----
----

ID           BVAL 
============ ======= 
2            <false>
----
[source,sql]
----
                        
-- Проверка UNKNOWN значения 
SELECT * FROM TBOOL WHERE BVAL IS UNKNOWN
----
----
                        
ID           BVAL 
============ ======= 
3            <null>
----
====

[[fblangref-commons-isnotnull]]
==== `IS [NOT] NULL`

.Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> IS [NOT] NULL
----

Поскольку `NULL` не является значением, эти операторы не являются операторами сравнения.
Оператор `IS [NOT] NULL` проверяет, что выражение слева имеет значение (__IS NOT NULL__) или не имеет значения (__IS NULL__) 

.Использование предиката IS [NOT] NULL
[example]
====
Поиск записей о продажах, для которых не установлена дата отгрузки:

[source,sql]
----
SELECT *
FROM SALES
WHERE SHIP_DATE IS NULL;
----
====

[[fblangref-commons-existential]]
=== Предикаты существования

В эту группу предикатов включены предикаты, которые используют подзапросы и передают значения для всех видов утверждений в условиях поиска.
Предикаты существования называются так потому, что они различными способами проверяют существование или отсутствие результатов подзапросов.

[[fblangref-commons-exists]]
==== `EXISTS`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
[NOT] EXISTS (<select_stmt>)
----

Предикат `EXISTS` использует подзапрос в качестве аргумента.
Если результат подзапроса будет содержать хотя бы одну запись, то предикат оценивается как истинный (TRUE), в противном случае предикат оценивается как ложный (FALSE). 

Результат подзапроса может содержать несколько столбцов, поскольку значения не проверяются, а просто фиксируется факт наличия строк результата.
Данный предикат может принимать только два значения: истина (TRUE) и ложь (FALSE).

Предикат `NOT EXISTS` возвращает `FALSE`, если результат подзапроса будет содержать хотя бы одну запись, в противном случае предикат вернёт `TRUE`.

.Предикат `EXISTS`
[example]
====
Найти тех сотрудников, у которых есть проекты.

[source,sql]
----
  
SELECT *
FROM employee
WHERE EXISTS (SELECT *
              FROM
                employee_project ep
              WHERE
                ep.emp_no = employee.emp_no)
----
====

.Предикат NOT EXISTS
[example]
====
Найти тех сотрудников, у которых нет проектов.

[source,sql]
----
  
SELECT *
FROM employee
WHERE NOT EXISTS (SELECT *
                  FROM
                    employee_project ep
                  WHERE
                    ep.emp_no = employee.emp_no)
----
====

[[fblangref-commons-in]]
==== `IN`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> [NOT] IN (<select_stmt> | <value_list>)

<value_list> ::= <value_1> [, <value_2> ...]
----

Предикат `IN` проверяет, присутствует ли значение выражения слева в указанном справа наборе значений.
Набор значений не может превышать 1500 элементов.
Предикат `IN` может быть переписан в следующей эквивалентной форме:

[listing,subs=+quotes]
----
(<value> = <value_1> [OR <value> = <value_2> ...])
----

При использовании предиката `IN` в поисковых условиях DML запросов, оптимизатор Firebird может использовать индекс по искомому столбцу, если он определён.

Во второй форме предикат `IN` проверяет, присутствует (или отсутствует, при использовании `NOT IN`) ли значение выражения слева в результате выполнения подзапроса справа.
Результат подзапроса может содержать только один столбец, иначе будет выдана ошибка
"`count of column list and variable list do not match`".

Запросы с использованием предиката `IN` с подзапросом, можно переписать на аналогичный запрос с использованием предиката `EXISTS`.
Например, следующий запрос:

[source,sql]
----

SELECT
  model, speed, hd
FROM PC
WHERE
  model IN (SELECT model
            FROM product
            WHERE maker = 'A');
----

Можно переписать на аналогичный запрос с использованием предиката `EXISTS`:

[source,sql]
----

SELECT
  model, speed, hd
FROM PC
WHERE
  EXISTS (SELECT *
          FROM product
          WHERE maker = 'A'
            AND product.model = PC.model);
----

Однако, запрос с использованием `NOT IN` не всегда даст тот же результат, что запрос `NOT EXISTS`.
Причина заключается в том, что предикат `EXISTS` всегда возвращает `TRUE` или `FALSE`, тогда как предикат `IN` может вернуть `NULL` в следующих случаях:

[loweralpha]
. Когда проверяемое значение равно `NULL` и список в `IN` не пуст.
. Когда проверяемое значение не имеет совпадений в списке `IN` и одно из значений является `NULL`.

В этих двух случаях предикат `IN` вернёт `NULL`, в то время как соответствующий предикат `EXISTS` вернёт `FALSE`.
В поисковых условиях или операторе `IF` оба результата обозначают "`провал`" и обрабатываются одинаково.

Однако на тех же данных `NOT IN` вернёт `NULL`, в то время как `EXISTS` вернёт `TRUE`, что приведёт к противоположному результату.

Это можно продемонстрировать следующим примером.

Предположим у вас есть такой запрос:

[source,sql]
----

-- Ищем людей, которые не родились в тот же день, что
-- известные жители Нью-Йорка
SELECT P1.name AS NAME
FROM Personnel P1 
WHERE P1.birthday NOT IN (SELECT C1.birthday
                          FROM Celebrities C1 
                          WHERE С1.birthcity = 'New York');
----

Можно предположить, что аналогичный результат даст запрос с использованием предиката `NOT EXISTS`:

[source,sql]
----

-- Ищем людей, которые не родились в тот же день, что
-- известные жители Нью-Йорка
SELECT P1.name AS NAME
FROM Personnel P1
WHERE NOT EXISTS (SELECT *
                  FROM Celebrities C1
                  WHERE C1.birthcity = 'New York'
                    AND C1.birthday = P1.birthday);
----

Допустим, что в Нью-Йорке всего один известный житель, и его дата рождения неизвестна.
При использовании предиката `EXISTS` подзапрос внутри него не выдаст результатов, так как при сравнении дат рождения с `NULL` результатом будет `UNKNOWN`.
Это приведёт к тому, что результат предиката `NOT EXISTS` будет истинен для каждой строки основного запроса.
В то время как результатом предиката `NOT IN` будет `UNKNOWN` и ни одна строка не будет выведена.


.Предикат IN
[example]
====
Найти сотрудников с именами "`Pete`", "`Ann`" и "`Roger`":


[source,sql]
----
  
SELECT *
FROM EMPLOYEE
WHERE FIRST_NAME IN ('Pete', 'Ann', 'Roger');
----
====

.Поисковый предикат IN
[example]
====
Найти все компьютеры, для которых существуют модели с производителем начинающимися на букву "`A`":

[source,sql]
----
  
SELECT
  model, speed, hd
FROM PC
WHERE
  model IN (SELECT model
            FROM product
            WHERE maker STARTING WITH 'A');
----
====

.См. также:
<<fblangref-commons-exists,EXISTS>>.

[[fblangref-commons-singular]]
==== `SINGULAR`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
[NOT] SINGULAR (<select_stmt>)
----

Предикат `SINGULAR` использует подзапрос в качестве аргумента и оценивает его как истинный, если подзапрос возвращает одну и только одну строку результата, в противном случае предикат оценивается как ложный.
Результат подзапроса может содержать несколько столбцов, поскольку значения не проверяются.
Данный предикат может принимать только два значения: истина (TRUE) и ложь (FALSE). 

.Предикат SINGULAR
[example]
====
Найти тех сотрудников, у которых есть только один проект.

[source,sql]
----
  
SELECT *
FROM employee
WHERE SINGULAR (SELECT *
                FROM
                  employee_project ep
                WHERE
                  ep.emp_no = employee.emp_no)
----
====

[[fblangref-commons-quantifiedsq]]
=== Количественные предикаты подзапросов

Квантором называется логический оператор, задающий количество объектов, для которых данное утверждение истинно.
Это логическое количество, а не числовое; оно связывает утверждение с полным множеством возможных объектов.
Такие предикаты основаны на формальных логических квантификаторах общности и существования, которые распознаются формальной логикой.

В выражениях подзапросов количественные предикаты позволяют сравнивать отдельные значения с результатами подзапросов; их общая форма:

[listing,subs=+quotes]
----
<value expression> <comparison operator> <quantifier> <subquery>
----

[[fblangref-commons-quant_all]]
==== `ALL`

.Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> <op> ALL (<select_stmt>)
----

При использовании квантора `ALL`, предикат является истинным, если каждое значение выбранное подзапросом удовлетворяет условию в предикате внешнего запроса.
Если подзапрос не возвращает ни одной строки, то предикат автоматически считается верным. 

.Квантор ALL
[example]
====
Вывести только тех заказчиков, чьи оценки выше, чем у каждого заказчика в Париже.

[source,sql]
----
  
SELECT * 
FROM Customers 
WHERE rating > ALL 
      (SELECT rating 
       FROM Customers 
       WHERE city = 'Paris')
----
====

[IMPORTANT]
====
Если подзапрос возвращает пустое множество, то предикат будет истинен для каждого левостороннего значения, независимо от оператора.
Это может показаться странным и противоречивым, потому что в этом случае каждое левостороннее значение рассматривается как одновременно больше, меньше, равное и неравное любому значению из правого потока.

Тем не менее это нормально согласуется с формальной логикой: если множество пусто, то предикат верен 0 раз, т.е.
для каждой строки в множестве.
====

[[fblangref-commons-quant-anysome]]
==== `ANY` и `SOME`

.Доступно в
DSQL, PSQL.

.Синтаксис
[listing,subs=+quotes]
----
<value> <op> {ANY | SOME} (<select_stmt>)
----

Эти два квантора идентичны по поведению.
Очевидно, оба представлены в стандарте SQL для взаимозаменяемого использования с целью улучшения читаемости операторов.
При использовании квантора `ANY` или `SOME`, предикат является истинным, если любое из значений выбранное подзапросом удовлетворяет условию в предикате внешнего запроса.
Если подзапрос не возвращает ни одной строки, то предикат автоматически считается ложным. 

.Квантор ANY
[example]
====
Вывести только тех заказчиков, чьи оценки выше, чем у какого-либо заказчика в Риме.

[source,sql]
----
  
SELECT * 
FROM Customers 
WHERE rating > ANY 
      (SELECT rating 
       FROM Customers 
       WHERE city = 'Rome')
----
====
