[[fblangref-datatypes]]
= Типы данных

((Типы данных)) используются в случае:

* определения столбца в таблице базы данных в операторе CREATE TABLE или для его изменения с использованием ALTER TABLE;
* при объявлении и редактировании домена оператором CREATE DOMAIN/ALTER DOMAIN; 
* при объявлении локальных переменных в хранимых процедурах, функциях, PSQL-блоках и триггерах, при указании аргументов хранимых процедур и функций; 
* при описании внешних функций (UDF – функций, определённых пользователем) для указания аргументов и возвращаемых значений; 
* при явном преобразовании типов данных в качестве аргумента для функции CAST.


[[fblangref-dtyp-tbl-dtypinfo]]
.Обзор типов данных
[cols="<1,<1,<1,<2", options="header",stripes="none"]
|===
^| Наименование
^| Размер
^| Точность и ограничения
^^| Описание

|`BIGINT`
|64 бита
|от -2^63^ до (2^63^ - 1)
|64 битное целое. Тип данных доступен только в 3 диалекте.

|`BINARY(_n_)`
|n байт
|от 1 до 32 767 байт
|Бинарный тип данных фиксированной длины. Является псевдонимом типа `CHAR(_n_) CHARACTER SET OCTETS`.

|`BLOB`
|Переменный
|Размер сегмента `BLOB` ограничивается 64К. Максимальный размер
поля `BLOB` 32 Гб. Для размера страницы 4096 максимальный размер BLOB
поля несколько ниже 2 Гб.
|Тип данных с динамически изменяемым размером для хранения больших данных, таких как графика, тексты,
оцифрованные звуки. Для сегментированных BLOB базовой структурной единицей является сегмент.
Подтип `BLOB` описывает содержимое.

|`BOOLEAN`
|8 бит
|false, true, unknown
|Логический тип данных.

|`CHAR(__n__)`, `CHARACTER(__n__)`
|_n_ символов.
Размер в байтах зависит от кодировки и количества байт на символ.
|от 1 до 32,767 байт
|Символьный тип данных фиксированной длины. При извлечении данных, строка дополняется пробелами справа
до указанной длины. Если количество символов _n_ не указано, то по умолчанию принимается 1.

|`DATE`
|32 бита
|от 01.01.0001 до 31.12.9999
|`ISC_DATE`.
Только дата без временной части.

|`DECIMAL (__precision__, __scale__)`
|16, 32, 64 или 128 бит в зависимости от точности
|_precision_ = от 1 до 38, указывает, по меньшей мере, количество цифр для хранения;
_scale_ = от 0 до 38, задаёт количество знаков после десятичной точки.
|Число с десятичной точкой, которое после десятичной точки имеет _scale_ разрядов.
_scale_ должно быть меньше или равно _precision_.
Пример: `DECIMAL(10,3)` содержит число точно в следующем формате: `ppppppp.sss`.

|`DECFLOAT(__precision__)`
|64 или 128 бит в зависимости от точности
|_precision_ = 16 или 34, количество значащих цифр (точность)
|SQL:2016 совместимый тип данных точно хранящий десятичные числа с плавающей запятой, основанный на стандарте IEEE 754-2008.

|`DOUBLE PRECISION`
|64 бита
|от 2.225 * 10^-308^ до 1.797 * 10^308^
|IEEE двойной точности, 15 цифр, размер зависит от платформы.

|`FLOAT`
|32 бита
|от 1.175 * 10^-38^ до 3.402 * 10^38^
|IEEE одинарной точности, 7 цифр

|`FLOAT(__precision__)`
|32 или 64 бита в зависимости от точности
|_precision_ — точность в двоичных числах, может находиться в диапазоне от 1 до 53.
|Если _precision_ от 1 до 32 — 32-битное одинарной точности (синоним типа FLOAT).
Если _precision_ от 33 до 53 — 64-битное двойной точности (синоним типа DOUBLE PRECISION).

|`INTEGER`, `INT`
|32 бита
|от -2147483648 до 2147483647
|Знаковое целое

|`INT128`
|128 бит
|от -2^127 до 2^128-1
|128-битное целое.

|`NUMERIC (__precision__, __scale__)`
|16, 32, 64 или 128 бит в зависимости от точности
|_precision_ = от 1 до 38, указывает, по меньшей мере, количество цифр для хранения;
_scale_ = от 0 до 38, задаёт количество знаков после десятичной точки.
|Число с десятичной точкой, которое после десятичной точки имеет _scale_ разрядов.
_scale_ должно быть меньше или равно _precision_.
Пример: `NUMERIC(10,3)` содержит число точно в следующем формате: `ppppppp.sss`.

|`REAL`
|32 бита
|от 1.175 * 10^-38^ до 3.402 * 10^38^
|Является синонимом типа FLOAT.

|`SMALLINT`
|16 бита
|от -32,768 до 32,767
|Короткое знаковое целое.

|`TIME [WITHOUT TIME ZONE]`
|32 бита
|0:00 to 23:59:59.9999
|`ISC_TIME`.
Время дня без информации о часовом поясе

|`TIME WITH TIME ZONE`
|6 байт
|0:00 to 23:59:59.9999
|Время дня с информацией о часовом поясе

|`TIMESTAMP [WITHOUT TIME ZONE]`
|64 бита (2 X 32 бита)
|от 01.01.0001 до 31.12.9999
|Дата включающая время без информации о часовом поясе

|`TIMESTAMP WITH TIME ZONE`
|10 байт
|от 01.01.0001 до 31.12.9999
|Дата включающая время с информацией о часовом поясе

|`VARBINARY(__n__)`, `BINARY VARYING(__n__)`
|_n_ байт.
|от 1 до 32,765 байт
|Бинарный тип данных переменной длины. Является псевдонимом типа `VARCHAR(__n__) CHARACTER SET OCTETS`.

|`VARCHAR(__n__)`, `CHAR VARYING(__n__)`, `CHARACTER VARYING(__n__)`
|_n_ символов.
Размер в байтах зависит от кодировки и количества байт на символ.
|от 1 до 32,765 байт
|Размер символов в байтах с учётом их кодировки не может быть больше 32765.
Для этого типа данных, в отличие от CHAR (где по умолчанию предполагается количество символов 1), количество символов _n_ обязательно должно быть указано.
|===

[NOTE]
====
Следует иметь в виду, что временной ряд из дат прошлых веков рассматривается без учёта реальных исторических фактов и так, как будто бы во всем этом диапазоне ВСЕГДА действовал только Григорианский календарь. 
====

[[fblangref-datatypes-inttypes]]
== Целочисленные типы данных

Для целых чисел используют целочисленные типы данных SMALLINT, INTEGER, BIGINT (в 3 диалекте) и INT128.
Firebird не поддерживает беззнаковый целочисленный тип данных. 

[[fblangref-datatypes-smallint]]
=== `SMALLINT`

(((Типы данных, SMALLINT)))
Тип данных `SMALLINT` представляет собой 16-битное целое.
Он применяется в случае, когда не требуется широкий диапазон возможных значений для хранения данных.

Числа типа `SMALLINT` находятся в диапазоне от -2^15^ до 2^15^ - 1, или от -32768 до 32767.

.Использование `SMALLINT`
[example]
====
[source, sql]
----
CREATE DOMAIN DFLAG AS SMALLINT DEFAULT 0 NOT NULL
  CHECK (VALUE=-1 OR VALUE=0 OR VALUE=1);

CREATE DOMAIN RGB_VALUE AS SMALLINT;
----
====

[[fblangref-datatypes-int]]
=== `INTEGER`

(((Типы данных, INTEGER)))
Тип данных `INTEGER` представляет собой 32-битное целое. Сокращённый вариант записи типа данных `INT`.

Числа типа `INTEGER` находятся в диапазоне от -2^31^ до 2^31^ - 1, или от -2,147,483,648 до 2,147,483,647.


.Использование `INTEGER`
[example]
====
[source, sql]
----
CREATE TABLE CUSTOMER (
  CUST_NO INTEGER NOT NULL,
  CUSTOMER VARCHAR(25) NOT NULL,
  CONTACT_FIRST VARCHAR(15),
  CONTACT_LAST VARCHAR(20),
  ...
  PRIMARY KEY (CUST_NO)
);
----
====

[[fblangref-datatypes-bigint]]
=== `BIGINT`

(((Типы данных, BIGINT)))
`BIGINT` — это SQL:99-совместимый 64 битный целочисленный тип данных. Он доступен только в 3-м диалекте.
При использовании клиентом диалекта 1, передаваемое сервером значение генератора усекается до 32-х битного целого (`INTEGER`).
При подключении в 3-м диалекте значение генератора имеет тип `BIGINT`.

Числа типа `BIGINT` находятся в диапазоне от -2^63^ до 2^63^ - 1, или от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.

.Использование `BIGINT`
[example]
====
[source, sql]
----
CREATE TABLE WHOLELOTTARECORDS (
  ID BIGINT NOT NULL PRIMARY KEY,
  DESCRIPTION VARCHAR(32)
);
----
====

[[fblangref-datatypes-int128]]
=== `INT128`

(((Типы данных, INT128)))
`INT128` — не стандартный 128 битный целочисленный тип данных.

Числа типа `INT128` находятся в диапазоне от -2^127^ до 2^127^ - 1.

.Использование `INT128`
[example]
====
[source, sql]
----
CREATE PROCEDURE PROC1 (PAR1 INT128)
AS
BEGIN
  -- текст процедуры
END
----
====

[[fblangref-datatypes-integer-hex]]
=== Шестнадцатеричный формат для целых чисел

Начиная с Firebird 2.5, константы трех целочисленных типов можно указать в шестнадцатеричном формате с помощью 9-16 шестнадцатеричных цифр для `BIGINT` или 1 до 8 цифр для `INTEGER`. Запись `SMALLINT` в шестнадцатеричном представлении не поддерживается в явном виде, но Firebird будет прозрачно преобразовывать шестнадцатеричное число в `SMALLINT`, если это необходимо, при условии что оно попадает в допустимый диапазон положительных и отрицательных значений для `SMALLINT`.

Использование и диапазоны значений чисел шестнадцатеричной нотации более подробно описаны в ходе обсуждения числовых констант в главе под названием Общие элементы языка.

.Использование целых чисел заданных шестнадцатеричном виде
[example]
====
[source, sql]
----
INSERT INTO MYBIGINTS VALUES (
  -236453287458723,
  328832607832,
  22,
  -56786237632476,
  0X6F55A09D42, -- 478177959234
  0X7FFFFFFFFFFFFFFF, -- 9223372036854775807
  0XFFFFFFFFFFFFFFFF, -- -1
  0X80000000, -- -2147483648, т.е. INTEGER
  0X080000000, -- 2147483648, т.е. BIGINT
  0XFFFFFFFF, -- -1, т.е. INTEGER
  0X0FFFFFFFF -- 4294967295, т.е. BIGINT
);
----
====

Шестнадцатеричный `INTEGER` автоматически приводится к типу `BIGINT` перед вставкой в
таблицу. Однако это происходит после установки численного значения, так 0x80000000 (8 цифр)
и 0x080000000 (9 цифр) будут сохранены в разных форматах. Значение 0x80000000 (8 цифр)
будет сохранено в формате `INTEGER`, а 0x080000000 (9 цифр) как `BIGINT`.

[[fblangref-datatypes-floattypes]]
== Типы данных с плавающей точкой

Типы данных с плавающей точкой хранятся в двоичном формате IEEE 754, который включает в
себя знак, показатель степени и мантиссу. Firebird имеет две формы типов с плавающей точкой:

* приблизительные числовые типы (или двоичные типы с плавающей точкой);
* десятичные типы с плавающей точкой.


[[fblangref-datatypes-floattypes-approximate]]
=== Приблизительные числовые типы

Приблизительные числовые типы плавающей запятой, поддерживаемые Firebird представлены типами 32-битной одинарной
точностью и 64-битной двойной точности. Эти типы доступны со следующими именами стандартных типов SQL:

* `REAL` — 32-битный одинарной точности (синоним типа `FLOAT`);
* `FLOAT` — 32-битный одинарной точности;
* `DOUBLE PRECISION` — 64-битный двойной точности;
* `FLOAT(_p_)`, где _p_ — точность в двоичных числах
** 1 \<= _p_ \<= 32 — 32-битное одинарной точности (синоним типа `FLOAT`)
** 33 \<= _p_ \<= 53 — 64-битное двойной точности (синоним типа `DOUBLE PRECISION`)

Кроме того, в Firebird имеются нестандартные имена типов:

* `LONG FLOAT` — 64-двойной точности (синоним типа `DOUBLE PRECISION`);
* `LONG FLOAT(_p_)`, где _p_ — точность в двоичных числах. 1 \<= _p_ \<= 53 — 64-битное двойной точности (синоним типа `DOUBLE PRECISION`)

Точность этого типов `FLOAT` и `DOUBLE PRECISION` является динамической, что соответствует физическому формату хранения,
который составляет 4 байта для типа `FLOAT` и 8 байт для типа `DOUBLE PRECISION`.

Учитывая особенности хранения чисел с плавающей точкой, этот тип данных не рекомендуется использовать для хранения денежных данных. По тем же причинам не рекомендуется использовать столбцы с данными такого типа в качестве ключей и применять к ним ограничения уникальности.

При проверке данных столбцов с типами данных с плавающей точкой рекомендуется вместо точного равенства использовать выражения проверки вхождения в диапазон, например `BETWEEN`.

При использовании таких типов данных в выражениях рекомендуется крайне внимательно и серьёзно подойти к вопросу округления результатов расчётов.

[[fblangref-datatypes-float]]
==== `FLOAT`

(((Типы данных, FLOAT)))
`FLOAT` — тип данных для хранения чисел с плавающей точкой.

.Синтаксис
[listing,subs=+quotes]
----
FLOAT [(_bin_prec_)]
----

[[fblangref-datatypes-floattbl]]
.Параметры типа `FLOAT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|bin_prec
|Точность в двоичных цифрах, по умолчанию рано 24

1 - 24: 32-битное одинарной точности (FLOAT без указания точности)
25 - 53: 64-битное двойной точности (синоним типа DOUBLE PRECISION)
|===

Тип данных `FLOAT` по умолчанию представляет собой 32-битный тип с плавающей запятой одинарной точности
с приблизительной точностью 7 десятичных знаков после десятичной точки (24 двоичных знака).
Числа типа `FLOAT` находятся в диапазоне от 1.175 x 10^-38^ до 3.402 x 10^38^.


[[fblangref-datatypes-float-precision]]
===== FLOAT с указанием точности

У типа FLOAT может быть указана точность в двоичных числах

Указанная точность _bin_prec_ влияет на способ хранения числа.

* 1 ++<=++ _bin_prec_ ++<=++ 24: 32-битное одинарной точности (синоним типа FLOAT без указания точности)
* 25 \<= _bin_prec_ \<= 53: 64-битное двойной точности (синоним типа DOUBLE PRECISION)

[NOTE]
====
В Firebird 3.0 и более ранних версиях поддерживался синтаксис `FLOAT(_dec_prec_)`, где _dec_prec_ — приблизительная точность в десятичных знаках.
Если 0 ++<=++ _dec_prec_ ++<=++ 7, то тип отображался на 32-битный одинарной точности. Если _dec_prec_ > 7, то отображался на 64-битный двойной точности.
Это нестандартное поведение. Данный синтаксис не был документирован ранее.
====

[[fblangref-datatypes-real]]
==== `REAL`

(((Типы данных, REAL)))
Тип `REAL` является синонимом типа `FLOAT`.

[[fblangref-datatypes-double]]
==== `DOUBLE PRECISION`

(((Типы данных, DOUBLE PRECISION)))
`DOUBLE PRECISION` — 64-битный тип данных для хранения чисел с плавающей точкой. Он обладает приблизительной точностью 15 цифр после запятой.
Числа типа `DOUBLE PRECISION` находятся в диапазоне от 2.225 x 10^-308^ до 1.797 x 10^308^.

[[fblangref-datatypes-long-float]]
==== `LONG FLOAT`
(((Типы данных, LONG FLOAT)))

.Синтаксис:
[listing,subs=+quotes]
----
LONG FLOAT[(_bin_prec_)]
<precision> ::= 1..53
----

Тип `LONG FLOAT` является синонимом типа `DOUBLE PRECISION` или `FLOAT(__bin_prec__)`, где 25 ++<=++ _bin_prec_ ++<=++ 53.

У типа `LONG FLOAT` может быть указана точность в двоичных числах.
Указанная точность 1 ++<=++ _bin_prec_ ++<=++ 53 не влияет на способ хранения -- число всегда храниться как 64-битное двойной точности.

[NOTE]
====
В Firebird 3.0 и более ранних версиях поддерживался синтаксис
`LONG FLOAT(_dec_prec_)`, где _dec_prec_ -- приблизительная точность в десятичных знаках.
Независимо от указанной точности число всегда хранится как 64-битное двойной точности.
Данный синтаксис не был документирован ранее.
====

[WARNING]
====
Эти нестандартные имена типов устарели и могут быть удалены в будущей версии.
====

[[fblangref-datatypes-dec]]
=== Десятичные типы с плавающей точкой

Начиная с Firebird 4.0 поддерживаются типы десятичных чисел с плавающей запятой.

[[fblangref-datatypes-decfloat]]
==== `DECFLOAT`

(((Типы данных, DECFLOAT)))
`DECFLOAT` является числовым типом из стандарта SQL:2016, который точно хранит
числа с плавающей запятой. В отличие от `DECFLOAT` типы `FLOAT` или `DOUBLE PRECISION`
обеспечивают двоичное приближение предполагаемой точности.

Firebird в соответствии со стандартом IEEE 754-1985 (IEEE 754-2008) реализует типы
`DECIMAL64` (`DECFLOAT(16)`) и `DECIMAL128` (`DECFLOAT(34)`).

Все промежуточные вычисления осуществляются с использованием 34-значными
значениями.

.16-значное и 34-значное
****
"`16`" и "`34`" относятся к максимальной точности десятичных цифр.

См. https://ru.wikipedia.org/wiki/IEEE_754-2008#Основные_и_взаимозаменяемые_форматы[https://ru.wikipedia.org/wiki/IEEE_754-2008#Основные_и_взаимозаменяемые_форматы^] для получения подробного описания.
****


.Синтаксис
[listing,subs=+quotes]
----
DECFLOAT[(_precision_)]

_precision_ ::= 16 | 34
----

.Диапазон значений `DECFLOAT`
[cols="<2,<1,<1,<1,<1,<1", options="header",stripes="none"]
|===
|Тип
|Максимальная точность
|Минимальная экспонента
|Максимальная экспонента
|Наименьшее значение
|Наибольшее значение

|`DECFLOAT(16)`
|16
|-383
|+384
|1E-398
|9.9..9E+384

|`DECFLOAT(34)`
|34
|-6143
|+6144
|1E-6176
|9.9..9E+6144
|===

Обратите внимание, что хотя наименьший показатель степени для `DECFLOAT (16)` равен -383, наименьшее значение имеет показатель степени -398, что на 15 цифр меньше.
И аналогично для `DECFLOAT (34)`, наименьший показатель степени равен -6143, но наименьшее значение имеет показатель степени -6176, что на 33 цифры меньше.
Причина заключается в том, что точность была "`принесена в жертву`", чтобы можно было хранить меньшее значение.

Это результат того, как хранится значение: как десятичное значение из 16 или 34 цифр и показатель степени.
Например, `1.234567890123456e-383` фактически сохраняется как коэффициент `1234567890123456` и показатель степени `-398`,
а `1E-398` сохраняется как коэффициент `1`, показатель степени `-398`.

Тип `DECFLOAT` следует использовать если вам необходимы вычисления и хранение чисел с большой точностью.


.Использование типа `DECFLOAT` при определении таблицы
[example]
====
[source,sql]
----
CREATE TABLE StockPrice (
  id    INT NOT NULL PRIMARY KEY,
  stock DECFLOAT(16),
  ...
);
----
====

.Использование типа `DECFLOAT` в PSQL
[example]
====
[source,sql]
----
DECLARE VARIABLE v DECFLOAT(34);
----
====

[[fblangref-datatypes-decfloat-ctrl]]
===== Поведение операций с `DECFLOAT`

Поведение операций с `DECFLOAT`, в частности округление и поведение при ошибках, можно настроить с помощью
оператора управления <<fblangref-management-setdecfloat, `SET DECFLOAT`>>.

[[fblangref-datatypes-decfloat-literals]]
===== Длина литералов `DECFLOAT`

Значение типа `DECFLOAT` можно задать числовым литералом в научной нотации, только если
мантисса состоит из 20 или более цифр, или абсолютный показатель степени больше 308. В противном случае такие литералы
интерпретируются как `DOUBLE PRECISION`. Точные числовые литералы с 40 или более цифрами -- фактически 39 цифр, если они больше максимального значения INT128  также обрабатываются как `DECFLOAT (34)`.

В качестве альтернативы можно использовать строковый литерал и явно привести к желаемому типу `DECFLOAT`.

Длина литералов типа `DECFLOAT` ограничена 1024 символами.
Для более длинных значений вам придётся использовать научную нотацию.
Например, значение `0.0<1020 zeroes>11` не может быть записано как литерал, вместо него вы можете использовать аналогичную научную нотацию: `1.1E-1022`.
Аналогично `10<1022 zeroes>0` может быть записано как `1.0E1024`.

Литералы, содержащие более 34 значащих цифр, округляются с использованием режима округления `DECFLOAT` установленного для сеанса.

[[fblangref-datatypes-decfloat-funcs]]
===== `DECFLOAT` и функции

[float]
===== Использование обычных функций

Ряд стандартных скалярных функций можно использовать с выражениями и значениями типа `DECFLOAT`.
Это относится к следующим математическим функциям:

[cols="5*m", frame="none", grid="none", stripes="none"]
|===
| ABS
| CEILING
| EXP
| FLOOR
| LN
| LOG
| LOG10
| POWER
| SIGN
| SQRT
|===

Агрегатные функции `SUM`, `AVG`, `MIN` и `MAX` тоже работают с типом `DECFLOAT`.
Все статистические агрегатные функции (такие как `STDDEV` или `CORR`, но не ограничено ими) могут работать с данными типа `DECFLOAT`.

[float]
===== Специальные функции для `DECFLOAT`

Firebird поддерживает 4 функции, которые созданы специально для поддержки типа `DECFLOAT`:

<<fblangref-scalarfuncs-comparedecfloat,`COMPARE_DECFLOAT`>>:: сравнивает два значения `DECFLOAT` как равные, разные или неупорядоченные
<<fblangref-scalarfuncs-normalize_decfloat,`NORMALIZE_DECFLOAT`>>:: принимает единственный аргумент `DECFLOAT` и возвращает его в простейшей форме
<<fblangref-scalarfuncs-quantize,`QUANTIZE`>>:: принимает два аргумента `DECFLOAT` и возвращает первый аргумент, масштабированный с использованием второго значения в качестве образца
<<fblangref-scalarfuncs-totalorder,`TOTALORDER`>>:: выполняет точное сравнение двух значений `DECFLOAT`


[[fblangref-datatypes-decfloat-comparation]]
===== Семантика сравнения

Замыкающие нули в значениях десятичных чисел с плавающей запятой сохраняются.
Например, 1.0 и 1.00 -- это два различных представления.
Это порождает различные семантики сравнения для типа данных `DECFLOAT`, как показано ниже.

[float]
====== Сравнение числовых значений

Замыкающие нули игнорируются в сравнениях.
Например, 1.0 равно 1.00.
По умолчанию такой тип сравнения используется для индексирования, сортировки, разбивки таблицы, оценки предикатов и других функций -- короче говоря, везде, где сравнение выполняется неявно или в предикатах.


.Сравнение числовых значений
[example]
====
[source,sql]
----
create table stockPrice (stock DECFLOAT(16));

insert into stockPrice 
values (4.2); 

insert into stockPrice 
values (4.2000); 

insert into stockPrice 
values (4.6125); 

insert into stockPrice 
values (4.20);

commit;

select * from stockPrice where stock = 4.2;
-- Возвращает три значения 4.2, 4.2000, 4.20

select * from stockPrice where stock > 4.20;
-- Возвращает одно значение 4.6125

select * from stockPrice order by stock;
-- Возвращает все значения, 4.2, 4.2000, 4.20, 4.6125. 
-- Первые три значения возвращаются в неопределенном порядке.
----
====

[float]
====== Сравнение TotalOrder

Замыкающие нули учитываются при сравнении.
Например, 1.0 > 1.00.
Каждое значение `DECFLOAT` имеет порядок в семантике сравнения TotalOrder.

Согласно семантике TotalOrder, порядок различных значений определяется так, как показано в следующем примере:

----
-nan < -snan < -inf < -0.1 < -0.10 < -0 < 0 < 0.10 < 0.1 < inf < snan < nan
----

[IMPORTANT]
====
Обратите внимание на то, что отрицательный нуль меньше положительного нуля при сравнении TotalOrder
====

Запросить сравнение TotalOrder в предикатах можно при помощи встроенной функции <<fblangref-scalarfuncs-totalorder,TOTALORDER()>>.

.Сравнение TotalOrder
[example]
====
Для курсов акций может быть важным знать точность данных.
Например, если курсы обычно указываются с точностью в пять знаков после запятой, а курс равен $4.2, тогда неясно, равна цена $4.2000, $4.2999 или чему-то, лежащему между этими двумя значениями.

[source,sql]
----
create table stockPrice (stock DECFLOAT(16));

insert into stockPrice 
values (4.2); 

insert into stockPrice 
values (4.2000); 

insert into stockPrice 
values (4.6125); 

insert into stockPrice 
values (4.20);

commit;

select * from stockPrice where TOTALORDER(stock, 4.2000) = 0;
-- Возвращает только значение 4.2000 

select * from stockPrice where TOTALORDER(stock, 4.20) = 1;
-- Возвращает два значения 4.2 и 4.6125, которое больше 4.20
----
====

Порядок, в котором возвращаются арифметически одинаковые значения, имеющие различное количество замыкающих нулей, не определен.
Следовательно, `ORDER BY` по столбцу `DECFLOAT` со значениями 1.0 и 1.00 возвращает два значения в произвольном порядке.
Аналогично, `DISTINCT` возвращает либо 1.0, либо 1.00.


[[fblangref-datatypes-decfloat-bind]]
===== Поддержка в клиентских приложениях

Библиотека fbclient версии 4.0 имеет нативную поддержку типа `DECFLOAT`.
Однако более старые версии клиентской библиотеки ничего не знают о типе `DECFLOAT`.
Для того чтобы старые приложения умели работать с типом `DECFLOAT` вы можете настроить отображение значений `DECFLOAT` на другие доступные типы данных c помощью оператора <<fblangref-management-set-bind,`SET BIND`>>.

.Примеры:
[source,sql]
----
SET BIND OF DECFLOAT TO LEGACY;
-- значения столбцов типа DECFLOAT будут преобразованы в тип DOUBLE PRECISION

-- другой вариант
SET BIND OF DECFLOAT TO DOUBLE PRECISION;

SET BIND OF DECFLOAT(16) TO CHAR;
-- значения столбцов типа DECFLOAT(16) будут преобразованы в тип CHAR(23)

SET BIND OF DECFLOAT(34) TO CHAR;
-- значения столбцов типа DECFLOAT(34) будут преобразованы в тип CHAR(42)

SET BIND OF DECFLOAT TO NUMERIC(18, 4);
-- значения столбцов типа DECFLOAT будут преобразованы в тип NUMERIC(18, 4)

SET BIND OF DECFLOAT TO NATIVE;
-- возвращает значения столбцов типа DECFLOAT в нативном типе
----

Различные привязки полезны, если вы планируете использовать значения `DECFLOAT` со старым клиентом, не поддерживающим собственный формат.
Можно выбирать между строками (идеальная точность, но плохая поддержка для дальнейшей обработки), значения с плавающей запятой (идеальная поддержка для дальнейшей обработки, но с плохой точностью) или масштабированные целые числа (хорошая поддержка дальнейшей обработки и требуемая точность, но диапазон значений очень ограничен). Когда используется инструмент, подобный универсальному GUI-клиенту, выбор привязки к CHAR подходит в большинстве случаев.


[[fblangref-datatypes-fixedtypes]]
== Типы данных с фиксированной точкой

Данные типы данных позволяют применять их для хранения денежных значений и обеспечивают предсказуемость операций умножения и деления. 

Firebird предлагает два типа данных с фиксированной точкой: `NUMERIC` и `DECIMAL`.
В соответствии со стандартом оба типа ограничивают хранимое число объявленным масштабом (количеством чисел после запятой).
При этом подход к тому, как ограничивается точность для типов разный: для столбцов `NUMERIC` точность является такой, "`как
объявлено`", в то время, как `DECIMAL` столбцы могут получать числа, чья точность, по меньшей мере, равна тому, что было объявлено.

Например, `NUMERIC(4, 2)` описывает число, состоящее в общей сложности из четырёх цифр, включая 2 цифры после запятой; итого 2 цифры до запятой, 2 после.
При записи в столбец с этим типом данных значений 3.1415 в столбце `NUMERIC(4, 2)` будет сохранено значение 3,14.

Для данных с фиксированной точкой общим является форма декларации, например NUMERIC(p, s). Здесь важно понять, что в этой записи `s` -- это масштаб, а не интуитивно предсказываемое "`количество знаков после запятой`".
Для "`визуализации`" механизма хранения данных запомните для себя процедуру:

* При сохранении в базу данных число умножается на 10 (10^s^), превращаясь в целое;
* При чтении данных происходит обратное преобразование числа. 

Способ физического хранения данных в СУБД зависит от нескольких факторов: декларируемой точности, диалекта базы данных, типа объявления.

[[fblangref-dtyp-tbl-realnums]]
.Способ физического хранения чисел с фиксированной точкой
[cols="<2,<3,<3,<3", options="header",stripes="none"]
|===
| Точность
| Тип данных
| Диалект 1
| Диалект 3

|1 - 4
|NUMERIC
|SMALLINT
|SMALLINT

|1 - 4
|DECIMAL
|INTEGER
|INTEGER

|5 - 9
|NUMERIC и DECIMAL
|INTEGER
|INTEGER

|10 - 18
|NUMERIC и DECIMAL
|DOUBLE PRECISION
|BIGINT

|19 - 38
|NUMERIC и DECIMAL
|INT128
|INT128
|===

[[fblangref-datatypes-numeric]]
=== `NUMERIC`
(((Типы данных, NUMERIC)))

.Формат объявления данных
[listing,subs=+quotes]
----
  NUMERIC
| NUMERIC(_precision_)
| NUMERIC(_precision_, _scale_)
----

[[fblangref-datatypes-numerictbl]]
.Параметры типа `NUMERIC`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^^| Описание

|precision
|Точность. Может быть в диапазоне от 1 до 38.
По умолчанию 9.

|scale
|Масштаб. Может быть в диапазоне от 0 до _precision_.
По умолчанию 0.
|===

В зависимости от точности _precision_ и масштаба _scale_ СУБД хранит данные по-разному.

Приведём примеры того, как СУБД хранит данные в зависимости от формы их объявления:

[listing,subs=+quotes]
----
NUMERIC(4)    stored as   SMALLINT (exact data)
NUMERIC(4,2)              SMALLINT (data * 10^2^)
NUMERIC(10,4) (Dialect 1) DOUBLE PRECISION
              (Dialect 3) BIGINT (data * 10^4^)
NUMERIC(38, 6)            INT128 (data * 10^6^)
----

[CAUTION]
====
Всегда надо помнить, что формат хранения данных зависит от точности.
Например, вы задали тип столбца `NUMERIC(2, 2)`, предполагая, что диапазон значений в нем будет -0.99...0.99.
Однако в действительности диапазон значений в столбце будет -327.68..327.67, что объясняется хранением типа данных NUMERIC(2, 2) в формате SMALLINT.
Фактически типы данных NUMERIC(4, 2), NUMERIC(3, 2) и NUMERIC(2, 2) являются одинаковыми.

Таким образом, для реального хранения данных в столбце с типом данных NUMERIC(2, 2) в диапазоне -0.99...0.99 для него надо создавать ограничение.
====

[[fblangref-datatypes-decimal]]
=== `DECIMAL`
(((Типы данных, DECIMAL)))

.Формат объявления данных
[listing,subs=+quotes]
----
  DECIMAL
| DECIMAL(_precision_)
| DECIMAL(_precision_, _scale_)
----

[[fblangref-datatypes-decimaltbl]]
.Параметры типа `DECIMAL`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^^| Описание

|precision
|Точность. Может быть в диапазоне от 1 до 38.
По умолчанию 9.

|scale
|Масштаб. Может быть в диапазоне от 0 до _precision_.
По умолчанию 0.
|===

Формат хранения данных в базе во многом аналогичен `NUMERIC`, хотя существуют некоторые особенности, которые проще всего пояснить на примере.

Приведём примеры того, как СУБД хранит данные в зависимости от формы их объявления:

[listing,subs=+quotes]
----
DECIMAL(4)    stored as   INTEGER (exact data)
DECIMAL(4,2)              INTEGER (data * 10^2^)
DECIMAL(10,4) (Dialect 1) DOUBLE PRECISION
              (Dialect 3) BIGINT (data * 10^4^)
DECIMAL(38, 6)            INT128 (data * 10^6^)
----

[[fblangref-datatypes-arithmetic-precision]]
=== Точность арифметических операций

Функции `MIN`, `MAX`, `SUM`, `AVG` работают со всеми точными числовыми типами.
`SUM` и `AVG` являются точными, если обрабатываемая запись имеет точный числовой тип, а масштабированная сумма соответствует 64 или 128 битам: в противном случае возникает исключение переполнения.
`SUM` и `AVG` никогда не вычисляются с использованием арифметики с плавающей запятой, если тип данных столбца не является приблизительным числом.

Функции `MIN` и `MAX` для точного числового столбца возвращают точный числовой результат, имеющий ту же точность и масштаб, что и столбец.
`SUM` и `AVG` для точного числового типа возвращает результат типа `NUMERIC ({18 | 38}, S)` или `DECIMAL ({18 | 38}, S)`, где S - масштаб столбца.
Стандарт SQL определяет масштаб результата в таких случаях, в то время как точность SUM или AVG для столбцов с фиксированной точкой определяется реализацией: мы определяем его как 18 или 38 (если точность аргумента 18 или 38).

Если два операнда OP1 и OP2 являются точными числами с масштабами S1 и S2 соответственно, то `OP1 + OP2` и `OP1 - OP2` являются точными числами с точностью 18 или 38 (если один из аргументов с точностью 38) и масштабом равному наибольшему из значений S1 и S2, тогда как для `OP1 * OP2` и `OP1 / OP2` являются точными числами с точностью 18 или 38 (если точность аргументов 18 или 38) и шкалой `S1 + S2`.
Масштабы этих операций, кроме разделения, определяются стандартом SQL.
Точность всех этих операций и масштаб при делении стандартом не регламентируются, а определяются реализацией: Firebird определяет точность как 18 или 38 (если точность аргументов 18 или 38), а масштаб деления как `S1 + S2`, такой же, что определён стандартом в для умножения.

Всякий раз, когда выполняется арифметические операции с точными числовыми типами, в случае потери точности будет сообщено об ошибке переполнения, а не возвращено неправильное значение. Например, если столбец `DECIMAL (18,4)` содержит наиболее отрицательное значение этого типа, -922337203685477.5808, попытка разделить этот столбец на -1 будет сообщать об ошибке переполнения, поскольку истинный результат превышает наибольшее положительное значение, которое может быть представлено в типе, а именно 922337203685477.5807.

Если один операнд является точным числом, а другой приблизительным числом, то результатом любого из четырех диадических операторов будет типа `DOUBLE PRECISION`.
(В стандарте говорится, что результат является приблизительным числом с точностью, по крайней мере, такой же как точность приблизительного числового операнда: Firebird удовлетворяет этому требованию, всегда используя `DOUBLE PRECISION`, поскольку этот тип является максимальным приблизительным числовым типом, который предоставлен в Firebird.)

[[fblangref-datatypes-datetime]]
== Типы данных для работы с датой и временем

В СУБД Firebird для работы с данными, содержащими дату и время, используются типы данных `DATE`, `TIME` и `TIMESTAMP`.
В 3-м диалекте присутствуют все три вышеназванных типа данных, а в 1-м для операций с датой и временем доступен только тип данных DATE, который не тождественен типу данных `DATE` 3-го диалекта, а является типом данных `TIMESTAMP` из 3-го диалекта.

[NOTE]
====
В диалекте 1 тип `DATE` может быть объявлен как `TIMESTAMP`.
Такое объявление является рекомендуемым для новых баз данных в 1-м диалекте. 
====

.Доли секунды
В типах `TIMESTAMP` и `TIME` Firebird хранит секунды с точностью до десятитысячных долей.
Если вам необходима более низкая гранулярность, то точность может быть указана явно в виде тысячных, сотых или десятых долей секунды в базах данных в 3 диалекте и ODS 11 и выше.

.Несколько полезных сведений о точности секунд
[NOTE]
====
Временная часть типов `TIME` или `TIMESTAMP` представляет собой 4-байтный целое (WORD) вмещающее значение времени с долями секунды, и хранящаяся как количество десятитысячных долей секунды прошедших с полуночи.
Фактическая точность значений полученных из time(stamp) функций и переменных будет следующей: 

* CURRENT_TIME -- по умолчанию имеет точность до секунды, точность до миллисекунд может быть указана следующим образом `CURRENT_TIME (0 | 1 | 2 | 3)`
* CURRENT_TIMESTAMP -- по умолчанию имеет точность до миллисекунды, точность от секунд до миллисекунд может быть указана следующим образом
`CURRENT_TIMESTAMP (0 | 1 | 2 | 3)`
* LOCALTIME -- по умолчанию имеет точность до секунды, точность до миллисекунд может быть указана следующим образом 
`LOCALTIME (0 | 1 | 2 | 3)`
* LOCALTIMESTAMP -- по умолчанию имеет точность до миллисекунды, точность от секунд до миллисекунд может быть указана следующим образом 
`LOCALTIMESTAMP (0 | 1 | 2 | 3)`
* Литерал `'NOW'` имеет точность до миллисекунд;
* Функции `DATEADD` и `DATEDIFF` поддерживают точность до десятых долей миллисекунд.
* Функция `EXTRACT` возвращает значения с точностью до десятых долей миллисекунды для аргументов `SECOND` и `MILLISECOND`;
====

[aside]
.Хранение типов с часовыми поясами
****
Типы данных с поддержкой часовых поясов сохраняются в виде значений в формате UTC (смещение 0) с использованием структуры `TIME` или `TIMESTAMP`
{plus} два дополнительных байта для информации о часовом поясе (либо смещение в минутах, либо идентификатор именованного часового пояса).

Хранение в формате UTC позволяет Firebird индексировать и сравнивать два значения в разных часовых поясах.

При хранении в UTC есть некоторые предостережения:

- Когда вы используете именованные зоны и правила часовых поясов для этой зоны меняются, время в формате UTC остается прежним, но местное время в названной зоне может измениться.
- Для типа данных `TIME WITH TIME ZONE` при вычислении смещения часового пояса для именованной зоны для получения местного времени в зоне применяются правила, действующие на 1 января 2020 года, чтобы гарантировать стабильное значение.
Это может привести к неожиданным или сбивающим с толку результатам.
****

[[fblangref-datatypes-date]]
=== `DATE`

(((Типы данных, DATE)))
В 3-м диалекте тип данных `DATE`, как это и следует предположить из названия, хранит только одну дату без времени.
В 1-м диалекте тип `DATE` эквивалентен типу `TIMESTAMP` и хранит дату вместе со временем.

Допустимый диапазон хранения от 01.01.0001 н.э. до 31.12.9999 н.э.

[TIP]
====
В случае необходимости сохранять в 1 диалекте только значения даты, без времени, при записи в таблицу добавляйте время к значению даты в виде
литерала `'00:00:00.0000'`.
====

.Пример использования `DATE`
====
[source,sql]
----
CRETE TABLE DataLog(
  id BIGINT NOT NULL,
  bydate DATE
);
----

[source,sql]
----
...
AS
  DECLARE BYDATE DATE; 
BEGIN  
...
----
====

См. также
<<fblangref-scalarfuncs-extract,EXTRACT>>,
<<fblangref-contextvars-current-date,CURRENT_DATE>>,
<<fblangref-datatypes-convert-literalformats,Литералы дат>>.

[[fblangref-datatypes-time]]
=== `TIME`
(((Типы данных, TIME))) (((Типы данных, TIME, WITH TIME ZONE))) (((Типы данных, TIME, WITHOUT TIME ZONE)))

.Синтаксис
[listing,subs=+quotes]
----
TIME [{WITH | WITHOUT} TIME ZONE]

EXTENDED TIME WITH TIME ZONE
----

Этот тип данных доступен только в 3-м диалекте.
Позволяет хранить время дня в диапазоне от 00:00:00.0000 до 23:59:59.9999.
По умолчанию тип `TIME` не содержит информацию о часовом поясе.
Для того чтобы тип `TIME` включал информацию о часовом поясе необходимо использовать его с модификатором `WITH TIME ZONE`.

[IMPORTANT]
====
`EXTENDED TIME WITH TIME ZONE` предназначен для использования только при общении с клиентами, он решает проблему представления правильного времени на клиентах, у которых отсутствует библиотека ICU.
Нельзя использовать расширенные типы данных в таблицах, процедурах и т.д.
Единственный способ использовать эти типы данных -- это приведение типов данных, включая инструкцию `SET BIND` (дополнительную информацию смотри в <<fblangref-management-set-bind,SET BIND OF>>).
====

.Пример использования `TIME`
====
[source,sql]
----
CRETE TABLE DataLog(
  id BIGINT NOT NULL,
  bytime TIME WITH TIME ZONE
);
----


[source,sql]
----
...
AS
  DECLARE BYTIME TIME; -- без часового пояса
  DECLARE BYTIME2 TIME WITHOUT TIME ZONE; -- без часового пояса  
  DECLARE BYTIME3 TIME WITH TIME ZONE; -- с информацией о часовом поясе   
BEGIN  
...
----
====

См. также
<<fblangref-scalarfuncs-extract,EXTRACT>>,
<<fblangref-commons-at,AT>>,
<<fblangref-contextvars-localtime,LOCALTIME>>,
<<fblangref-contextvars-current-time,CURRENT_TIME>>,
<<fblangref-datatypes-convert-literalformats>>.

[[fblangref-datatypes-timestamp]]
=== `TIMESTAMP`
(((Типы данных, TIMESTAMP))) (((Типы данных, TIMESTAMP, WITH TIME ZONE))) (((Типы данных, TIMESTAMP, WITHOUT TIME ZONE)))

.Синтаксис
[listing,subs=+quotes]
----
TIMESTAMP [{WITH | WITHOUT} TIME ZONE]

EXTENDED TIMESTAMP WITH TIME ZONE
----

Этот тип данных хранит временную метку (дату вместе со временем) в диапазоне от 01.01.0001 00:00:00.0000 до 31.12.9999 23:59:59.9999.
По умолчанию тип `TIMESTAMP` не содержит информацию о часовом поясе.
Для того чтобы тип `TIMESTAMP` включал информацию о часовом поясе необходимо использовать его с модификатором `WITH TIME ZONE`.

[IMPORTANT]
====
`EXTENDED TIMESTAMP WITH TIME ZONE` предназначен для использования только при общении с клиентами, он решает проблему представления правильного времени на клиентах, у которых отсутствует библиотека ICU.
Нельзя использовать расширенные типы данных в таблицах, процедурах и т.д.
Единственный способ использовать эти типы данных -- это приведение типов данных, включая инструкцию `SET BIND` (дополнительную информацию смотри в <<fblangref-management-set-bind,SET BIND OF>>).
====

.Пример использования TIME
====
[source,sql]
----
CRETE TABLE DataLog(
  id BIGINT NOT NULL,
  bydate TIMESTAMP WITH TIME ZONE
);
----

[source,sql]
----
...
AS
  DECLARE BYDATE TIMESTAMP; -- без часового пояса
  DECLARE BYDATE2 TIMESTAMP WITHOUT TIME ZONE; -- без часового пояса  
  DECLARE BYDATE3 TIMESTAMP WITH TIME ZONE; -- с информацией о часовом поясе   
BEGIN  
...
----
====

См. также
<<fblangref-scalarfuncs-extract,EXTRACT>>,
<<fblangref-commons-at,AT>>,
<<fblangref-contextvars-localtimestamp,LOCALTIMESTAMP>>,
<<fblangref-contextvars-current-timestamp,CURRENT_TIMESTAMP>>,
<<fblangref-datatypes-convert-literalformats>>.


[[fblangref-datatypes-session-tz]]
=== Часовой пояс сеанса

Часовой пояс сеанса как следует из названия может быть разным для каждого соединения с базой данных.
Он может быть установлен с помощью DPB `isc_dpb_session_time_zone`, а если нет, то он будет считан из параметра `DefaultTimeZone` конфигурации [path]_firebird.conf_.
Если параметр DefaultTimeZone не установлен, то часовой пояс сеанса будет тем же, что используется операционной системой в которой запущен процесс Firebird.

Часовой пояс сеанса может быть изменён с помощью оператора <<fblangref-management-settimezone,`SET TIME ZONE`>>
или сброшен в исходное значение с помощью `SET TIME ZONE LOCAL`.


[[fblangref-datatypes-get-timezone]]
==== Получение часового пояса сеанса

Получить текущий часовой пояс сеанса можно с использованием функции `RDB$GET_CONTEXT` с аргументами 'SYSTEM' для пространства имён и 'SESSION_TIMEZONE' в качестве имени переменной.

.Получение часового пояса сеанса
[example]
====
[source,sql]
----
set time zone '-02:00';
select rdb$get_context('SYSTEM', 'SESSION_TIMEZONE') from rdb$database;
-- returns -02:00

set time zone 'America/Sao_Paulo';
select rdb$get_context('SYSTEM', 'SESSION_TIMEZONE') from rdb$database;
-- returns America/Sao_Paulo
----
====

[[fblangref-datatypes-tz-format]]
=== Формат часового пояса

Часовой пояс может быть задан строкой с регионом часового пояса (например, America/Sao_Paulo), или в виде
смещения "`часов:минут`" относительно GMT (например, -03:00).
Список региональных часовых поясов и их идентификаторов можно посмотреть в таблице <<fblangref-systables-timezones,RDB$TIME_ZONES>>.
Правила преобразования региональных часовых поясов в смещение в минутах можно получить с помощью процедуры <<fblangref-datatypes-timezone-zone-util-transitions,RDB$TIME_ZONE_UTIL.TRANSITIONS>>.

`{TIME | TIMESTAMP} WITH TIMEZONE` считается равным другому `{TIME | TIMESTAMP} WITH TIMEZONE`, если их преобразование
в UTC равно, например `time '10:00 -02' = time '09:00 -03'`, поскольку оба времени эквивалентны `time '12:00 GMT'`.
Это также справедливо в контексте ограничения UNIQUE и для сортировки.

[[fblangref-datatypes-timezone_time_rb_semantics]]
==== Региональная семантика TIME WITH TIME ZONE

По определению региональные часовые пояса зависят от момента (дата и время -- или timestamp), чтобы узнать его смещение UTC относительно GMT.
Но Firebird также поддерживает региональные часовые пояса в значениях `TIME WITH TIME ZONE`.

При построении значения `TIME WITH TIME ZONE` из литерала или его преобразования, значение UTC должно быть вычислено и не может быть изменено, поэтому текущая дата может не использоваться.
В этом случае используется фиксированная дата `2020-01-01`.
Таким образом, при сравнении `TIME WITH TIME ZONE` с различными часовыми поясами сравнение выполняется аналогично тому, как они представляют собой значения `TIMESTAMP WITH TIME ZONE` на заданную дату.

Однако при преобразовании между типами `TIMESTAMP` в `TIME WITH TIME ZONE` эта фиксированная дата не используется,
в противном случае могут наблюдаться некоторые странные преобразования, когда текущая дата имеет другое смещение (из-за изменений летнего времени), чем в `2020-01-01`.
В этом случае при преобразовании `TIME WITH TIME ZONE` в `TIMESTAMP WITH TIME ZONE` сохраняется часть времени (если это возможно).
Например, если текущая дата `2020-05-03`, эффективное смещение в часовом поясе America/Los_Angeles равно -420, а его эффективное смещение
в `2020-01-01` равно -480, но `cast(time '10:00:00 America/Los_Angeles' as timestamp with time zone)` даст в результате `2020-05-03 10:00:00.0000 America/Los_Angeles` вместо корректировки временной части.

Но в дату, когда начинается летнее время, пропущен час, например, для часового пояса America/Los_Angeles в `2021-03-14` нет времени с `02:00:00` до `02:59:59`.
В этом случае преобразование выполняется как построение литерала, и час корректируется до следующего допустимого значения.
Например, в `2021-03-14` `cast(time '02:10:00 America/Los_Angeles' as timestamp with time zone)` даст результат `2021-03-14 03:10:00.0000 America/Los_Angeles`.



[[fblangref-datatypes-datetime-literals]]
=== Литералы даты и времени

Для записи литералов даты и времени в Firebird используются сокращенные "C-style" выражения.
Строковое представление даты и времени должно быть в одном из разрешённых форматов.

.Синтаксис
[listing,subs=+quotes]
----
<date_literal> ::= DATE <date>                        
                        
<time_literal> ::= TIME <time>
                        
<timestamp_literal> ::= TIMESTAMP <timestamp>                        

<date> ::= 
  [YYYY<p>]MM<p>DD |
  MM<p>DD[<p>YYYY] |
  DD<p>MM[<p>YYYY] |
  MM<p>DD[<p>YY] |
  DD<p>MM[<p>YY] 


<time> := HH[:mm[:SS[.NNNN]]] [<time zone>]

<timestamp> ::= <date> <time>
                    
<time zone> ::=
    <time zone region> |
    [+/-] <hour displacement> [: <minute displacement>]                    

<p> ::= whitespace | . | : | , | - | /
----


.Описание формата даты и времени
[cols="<1,<3", options="header",stripes="none"]
|===
^| Аргумент
^| Описание

|datetime
|Строковое представление даты-времени.

|date
|Строковое представление даты.

|time
|Строковое представление времени.

|YYYY
|Год из четырёх цифр.

|YY
|Последние две цифры года (00-99).

|MM
|Месяц.
Может содержать 1 или 2 цифры (1-12 или 01-12). В качестве месяца допустимо также указывать трёх буквенное сокращение или полное наименование месяца на английском языке, регистр не имеет значение.

|DD
|День.
Может содержать 1 или 2 цифры (1-31 или 01-31).

|HH
|Час.
Может содержать 1 или 2 цифры (0-23 или 00-23).

|mm
|Минуты.
Может содержать 1 или 2 цифры (0-59 или 00-59).

|SS
|Секунды.
Может содержать 1 или 2 цифры (0-59 или 00-59).

|NNNN
|Десятитысячные доли секунды.
Может содержать от 1 до 4 цифр (0-9999).

|p
|Разделитель, любой из разрешённых символов, лидирующие и завершающие пробелы игнорируются.

|time zone region
|Один из часовых поясов связанных с регионом.

|hour displacement
|Смещение времени для часов относительно GMT.

|minute displacement
|Смещение времени для минут относительно GMT.
|===

Правила: 

* В формате Год-Месяц-День, год обязательно должен содержать 4 цифры;
* Для дат в формате с завершающим годом, если в качестве разделителя дат используется точка ".", то дата интерпретируется в форме День-Месяц-Год, для остальных разделителей она интерпретируется в форме Месяц-День-Год;
* Если год не указан, то в качестве года берётся текущий год;
* Если указаны только две цифры года, то для получения столетия Firebird использует алгоритм скользящего окна. Задача заключается в интерпретации двух символьного значения года как ближайшего к текущему году в интервале предшествующих и последующих 50 лет;
* Если в строковом представлении времени присутствует часовой пояс или смещение времени, то тип литерала будет WITH TIME ZONE, в противном случае WITHOUT TIME ZONE;
* Если не указан один из элементов времени, то оно принимается равным 0.


[TIP]
====
Настоятельно рекомендуем в литералах дат использовать только формы с полным указанием года в виде 4 цифр во избежание путаницы. 
====

.Примеры литералов дат и времени
[example]
====
[source,sql]
----
SELECT
  date '04.12.2014' AS d1, -- DD.MM.YYYY
  date '12-04-2014' AS d2, -- MM-DD-YYYY
  date '12/04/2014' AS d3, -- MM/DD/YYYY
  date '04.12.14'  AS d4,   -- DD.MM.YY
  -- DD.MM в качестве года берётся текущий
  date '04.12' AS d5,
  -- MM/DD в качестве года берётся текущий      
  date '12/4' AS d6,
  date '2014/12/04'  AS d7, -- YYYY/MM/DD
  date '2014.12.04'  AS d8, -- YYYY.MM.DD
  date '2014-12-04'  AS d9, -- YYYY-MM-DD
  time '11:37' AS t1, -- HH:mm
  time '11:37:12' AS t2, -- HH:mm:ss
  time '11:31:12.1234' AS t3, -- HH:mm:ss.nnnn
  -- HH:mm:ss.nnnn +hh
  time '11:31:12.1234 +03' AS t4,
  -- HH:mm:ss.nnnn +hh:mm
  time '11:31:12.1234 +03:30' AS t5,
  -- HH:mm:ss.nnnn tz
  time '11:31:12.1234 Europe/Moscow' AS t5,
  -- HH:mm tz
  time '11:31 Europe/Moscow' AS t6,
  -- DD.MM.YYYY HH:mm
  timestamp '04.12.2014 11:37' AS dt1,
  -- MM/DD/YYYY HH:mm:ss
  timestamp '12/04/2014 11:37:12' AS dt2,
  -- DD.MM.YYYY HH:mm:ss.nnnn 
  timestamp '04.12.2014 11:31:12.1234' AS dt3,
  -- YYYY-MM-DD HH:mm:ss.nnnn +hh:mm
  timestamp '2014-12-04 11:31:12.1234 +03:00' AS dt4,
  -- DD.MM.YYYY HH:mm:ss.nnnn tz
  timestamp '04.12.2014 11:31:12.1234 Europe/Moscow' AS dt5
FROM rdb$database
----
====

[NOTE]
====
Обратите внимание, что эти сокращённые выражения вычисляются сразу же во время синтаксического анализа (подготовки запроса или компиляции процедуры, функции или триггера). До Firebird 4.0 сокращённые выражения позволялись также для специальных строковых литералов 'NOW', 'TODAY', 'TOMORROW', 'YESTERDAY'. Использование таких выражений в компилируемом PSQL приводило к тому, что значение "замораживалось" на момент компиляции, и возвращалось не актуальное значение.
Поэтому в Firebird 4.0 сокращённые выражения для таких строковых литералов запрещены, однако вы можете использовать их при приведении типа оператором CAST.
====

.См. также:
<<fblangref-datatypes-convert-literalformats>>.

[[fblangref-datatypes-datetimeops]]
=== Операции, использующие значения даты и времени

Благодаря способу хранения даты и времени с этими типами возможны арифметические операции вычитания из более поздней даты (времени) более раннюю.
Дата представлена количеством дней с "нулевой даты" – 17 ноября 1858 г.
Время представлено количеством секунд (с учётом десятитысячных долей), прошедших с полуночи.

[[fblangref-dtyp-tbl-dateops]]
.Арифметические операции для типов данных даты и времени
[cols="1,1,1,1", frame="all", options="header"]
|===
| Операнд 1
| Оператор
| Операнд 2
| Результат

|`DATE`
|`{plus}`
|`TIME`
|`TIMESTAMP`

|`DATE`
|`{plus}`
|`TIME WITH TIME ZONE`
|`TIMESTAMP WITH TIME ZONE`

|`DATE`
|`{plus}`
|Числовое значение `n`
|`DATE`, увеличенная на `n` целых дней (дробная часть игнорируется).

|`TIME`
|`{plus}`
|`DATE`
|`TIMESTAMP`

|`TIME WITH TIME ZONE`
|`{plus}`
|`DATE`
|`TIMESTAMP WITH TIME ZONE`

|`TIME`
|`{plus}`
|Числовое значение `n`
|`TIME`, увеличенное на `n` секунд (дробная часть учитывается).

|`TIME WITH TIME ZONE`
|`{plus}`
|Числовое значение `n`
|`TIME WITH TIME ZONE`, увеличенное на `n` секунд (дробная часть учитывается).

|`TIMESTAMP`
|`{plus}`
|Числовое значение `n`
|`TIMESTAMP`, где дата будет увеличиваться на количество дней и на часть дня, представленную числом _n_ - поэтому "```+ 2.75```" сдвинет дату вперед на 2 дня и 18 часов.

|`TIMESTAMP WITH TIME ZONE`
|`{plus}`
|Числовое значение `n`
|`TIMESTAMP WITH TIME ZONE`, где дата будет увеличиваться на количество дней и на часть дня, представленную числом _n_ - поэтому "```+ 2.75```" сдвинет дату вперед на 2 дня и 18 часов.

|`DATE`
|`-`
|`DATE`
|Количество дней в интервале как `DECIMAL (9, 0)`.

|`DATE`
|`-`
|Числовое значение `n`
|`DATE`, уменьшенная на `n` целых дней (дробная часть игнорируется).

|`TIME`
|`-`
|`TIME`
|Количество секунд в интервале как `DECIMAL (9, 4)`.

|`TIME`
|`-`
|`n`
|`TIME`, уменьшенное на `n` секунд (дробная часть учитывается).

|`TIME`
|`-`
|`TIME WITH TIME ZONE`
|Значение без часового пояса преобразуется в `WITH TIME ZONE` в часовом поясе текущего сеанса.
Возвращается количество секунд в интервале между UTC значениями как `DECIMAL(9, 4)`.
То же правило действует при изменении порядка операндов.

|`TIME WITH TIME ZONE`
|`-`
|`TIME WITH TIME ZONE`
|Возвращается количество секунд в интервале между UTC значениями как `DECIMAL(9, 4)`.

|`TIMESTAMP`
|`-`
|`TIMESTAMP`
|Количество дней и части дня в интервале как `DECIMAL (18, 9)`.

|`TIMESTAMP`
|`-`
|`TIMESTAMP WITH TIME ZONE`
|Значение без часового пояса преобразуется в `WITH TIME ZONE` в часовом поясе текущего сеанса.
Количество дней и части дня в интервале между UTC значениями как `DECIMAL (18, 9)`.
То же правило действует при изменении порядка операндов.

|`TIMESTAMP`
|`-`
|`n`
|`TIMESTAMP`, где дата будет уменьшена на количество дней, и часть дня, представленную числом _n_ - поэтому "```- 2.25```" сдвинет дату назад на 2 дня и 6 часов.

|`TIMESTAMP WITH TIME ZONE`
|`-`
|`n`
|`TIMESTAMP WITH TIME ZONE`, где дата будет уменьшена на количество дней, и часть дня, представленную числом _n_ - поэтому "```- 2.25```" сдвинет дату назад на 2 дня и 6 часов.
|===

Одно значение даты/времени может быть вычтено из другого если: 

* Оба значения имеют один и тот же тип даты/времени;
* Первый операнд является более поздним, чем второй.


[NOTE]
====
В диалекте 1 тип `DATE` рассматривается как `TIMESTAMP`.
====

.См. также:
<<fblangref-scalarfuncs-dateadd>>, <<fblangref-scalarfuncs-datediff>>.

[[fblangref-datatypes-tz-extras]]
=== Дополнительные функции для поддержки часовых поясов

Firebird 4 предоставляет ряд функций для получения информации о часовых поясах.

[[fblangref-datatypes-time-zones-tbl]]
==== Виртуальная таблица `RDB$TIME_ZONES`

Виртуальная таблица со списком часовых поясов, поддерживаемых Firebird.

См. также <<fblangref-systables-timezones,`RDB$TIME_ZONES`>> в приложении "`Системные таблицы`".

[[fblangref-datatypes-time-zone-util-pkg]]
==== Пакет `RDB$TIME_ZONE_UTIL`

Данный пакет содержит процедуры и функции для работы с часовыми поясами.

[[fblangref-datatypes-time-zone-util-version]]
===== Функция `RDB$TIME_ZONE_UTIL.DATABASE_VERSION()`

Функция `RDB$TIME_ZONE_UTIL.DATABASE_VERSION` возвращает версию базы данных часовых поясов (из библиотеки icu).

.Тип возвращаемого результата
`VARCHAR(10) CHARACTER SET ASCII`


.Использование функции RDB$TIME_ZONE_UTIL.DATABASE_VERSION
[example]
====
[source,sql]
----
SELECT rdb$time_zone_util.database_version()
FROM rdb$database;
----

[listing]
----
DATABASE_VERSION
================
2021a
----
====

[[fblangref-datatypes-timezone-zone-util-transitions]]
===== Процедура `RDB$TIME_ZONE_UTIL.TRANSITIONS()`

Процедура `RDB$TIME_ZONE_UTIL.TRANSITIONS` возвращает набор правил для часового пояса между начальной и конечной временной меткой.


.Входные параметры процедуры `RDB$TIME_ZONE_UTIL.TRANSITIONS`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|RDB$TIME_ZONE_NAME
|`CHAR(63)`
|Наименование часового пояса

|RDB$FROM_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Начало интервала дат

|RDB$TO_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Окончание интервала дат
|===

.Выходные параметры процедуры `RDB$TIME_ZONE_UTIL.TRANSITIONS`
[cols="<4m,<3m,<5", frame="all", options="header",stripes="none"]
|===
^| Параметр
^| Тип
^| Описание

|RDB$START_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Дата начала действия правила

|RDB$END_TIMESTAMP
|`TIMESTAMP WITH TIME ZONE`
|Дата окончания действия правила

|RDB$ZONE_OFFSET
|`SMALLINT`
|Смещение времени в минутах для заданного часового пояса

|RDB$DST_OFFSET
|`SMALLINT`
|Летнее смещение времени в минутах для заданного часового пояса

|RDB$EFFECTIVE_OFFSET
|`SMALLINT`
|Эффективное смещение, вычисляется как `RDB$ZONE_OFFSET + RDB$DST_OFFSET`
|===


.Использование процедуры `RDB$TIME_ZONE_UTIL.TRANSITIONS`
====
[source,sql]
----
SELECT
  RDB$START_TIMESTAMP,
  RDB$END_TIMESTAMP,
  RDB$ZONE_OFFSET AS ZONE_OFF,
  RDB$DST_OFFSET AS DST_OFF,
  RDB$EFFECTIVE_OFFSET AS OFF
FROM rdb$time_zone_util.transitions(
    'America/Sao_Paulo',
    timestamp '2017-01-01',
    timestamp '2019-01-01');
----

[listing]
----
         RDB$START_TIMESTAMP            RDB$END_TIMESTAMP ZONE_OFF DST_OFF  OFF
============================ ============================ ======== ======= ====
2016-10-16 03:00:00.0000 GMT 2017-02-19 01:59:59.9999 GMT     -180      60 -120
2017-02-19 02:00:00.0000 GMT 2017-10-15 02:59:59.9999 GMT     -180       0 -180
2017-10-15 03:00:00.0000 GMT 2018-02-18 01:59:59.9999 GMT     -180      60 -120
2018-02-18 02:00:00.0000 GMT 2018-10-21 02:59:59.9999 GMT     -180       0 -180
2018-10-21 03:00:00.0000 GMT 2019-02-17 01:59:59.9999 GMT     -180      60 -120
----
====

[[fblangref-datatypes-tz-dbupdate]]
=== Обновление базы данных часовых поясов

Часовые пояса меняются часто: конечно, когда это происходит, желательно как можно скорее обновить базу данных часовых поясов.

Firebird хранит значения `WITH TIME ZONE`, переведенные во время UTC. Предположим, что значение создано с помощью одной базы данных часового пояса, и более позднее обновление этой базы данных изменяет информацию в диапазоне нашего сохраненного значения. Когда это значение будет прочитано, оно будет возвращено как отличное от значения, которое было сохранено изначально.

Firebird использует https://www.iana.org/time-zones[IANA базу данных часовых поясов] через библиотеку ICU. Библиотека ICU, представленная в комплекте Firebird (Windows) или установленная в операционной системе POSIX, иногда может иметь устаревшую базу данных часовых поясов.

Обновленную базу данных можно найти на https://github.com/FirebirdSQL/firebird/tree/master/extern/icu/tzdata[этой странице в FirebirdSQL GitHub].
Имя файла `le.zip` обозначает прямой порядок байтов и является необходимым файлом для большинства компьютерных архитектур (совместимых с Intel/AMD x86 или x64), в то время как `be.zip` обозначает архитектуры с прямым порядком байтов и необходим в основном для компьютерных архитектур RISC.
Содержимое zip-файла должно быть извлечено в подкаталог `/tzdata` установки Firebird, перезаписывая существующие файлы `*.res`.

[NOTE]
====
`/tzdata` -- это каталог по умолчанию, в котором Firebird ищет базу данных часовых поясов.
Его можно переопределить с помощью переменной среды `ICU_TIMEZONE_FILES_DIR`.
====

[[fblangref-datatypes-chartypes]]
== Символьные типы данных

В СУБД Firebird для работы с символьными данными есть типы фиксированной длины `CHAR` и переменной длины `VARCHAR`.
Максимальный размер текстовых данных, хранящийся в этих типах данных, составляет 32767 байт для `CHAR` и 32765 байт для `VARCHAR`.
Максимальное количество символов, которое поместится в этот объём, зависит от используемого набора символов `CHARACTER SET`.
Последовательность сортировки, задаваемая предложением `COLLATE`, не влияет на этот максимум, хотя может повлиять на максимальный размер любого индекса, который включает столбец.

В случае отсутствия явного указания набора символов при описании текстового объекта базы данных будет использоваться набор символов по умолчанию, заданный при создании базы данных.
При отсутствии явного указания набора символов, а также отсутствия набора символов по умолчанию для базы данных, поле получает набор символов `CHARACTER SET NONE`.


[[fblangref-datatypes-chartypes-unicode]]
=== Unicode

В настоящее время все современные средства разработки поддерживают Unicode.
При возникновении необходимости использования восточноевропейских текстов в строковых полях базы данных или для более экзотических алфавитов, рекомендуется работать с набором символов UTF8.
При этом следует иметь в виду, что на один символ в данном наборе приходится до 4 байт.
Следовательно, максимальное количество символов в символьных полях составит 32765/4 = 8191.

[NOTE]
====
При этом следует обратить внимание, что фактически значение параметра "`bytes per character`" зависит от диапазона, к которому принадлежит символ: английские буквы занимают 1 байт, русские буквы -- 2 байта, остальные символы -- могут занимать до 4-х байт.
====

Набор символов UTF8 поддерживает последнюю версию стандарта Unicode, до 4 байт на символ, поэтому для интернациональных баз рекомендуется использовать именно эту реализацию поддержки Unicode в Firebird. 

[[fblangref-datatypes-chartypes-client]]
=== Набор символов клиента

При работе со строками важно помнить о наборе символов клиентского соединения.
В случае различия набора символов, при выдаче результата для строковых столбцов происходит автоматическая перекодировка как при передаче данных с клиента на сервер, так и в обратном направлении с сервера на клиента.
То есть, совершенно нормальной является ситуация, когда база создана в кодировке `WIN1251`, а в настройках клиента в параметрах соединения стоит `KOI8R` или `UTF8`.

[[fblangref-datatypes-chartypes-special]]
=== Специальные наборы символов

.Набор символов `NONE`
Набор символов `NONE` относится к специальным наборам символов.
Его можно охарактеризовать тем, что каждый байт является частью строки, но в системе хранится без указаний, к какому фактическому набору символов они относятся.
Разбираться с такими данными должно клиентское приложение, на него возлагается ответственность в правильной трактовке символов из таких полей. 

.Набор символов `OCTETS`
Также к специальным наборам символов относится `OCTETS`.
В этом случае данные рассматриваются как байты, которые могут в принципе не интерпретироваться как символы.
`OCTETS` позволяет хранить бинарные данные и/или результаты работы некоторых функций Firebird.
Правильное отображение данных пользователю, хранящихся в полях с `CHARACTER SET OCTETS`, также становится заботой клиентской стороны.
При работе с подобными данными следует также помнить, что СУБД не контролирует их содержимое и возможно возникновение исключения при работе кода, когда идёт попытка отображения бинарных данных в желаемой кодировке. 

[[fblangref-datatypes-chartypes-collation]]
=== Последовательность сортировки

Каждый набор символов имеет последовательность сортировки (сопоставления) по умолчанию (`COLLATE`), которая определяет порядок сопоставления. Обычно он обеспечивает упорядочивание на основе числового кода символов и базовое сопоставление символов верхнего и нижнего регистра. Если для строк требуется какое-то поведение, которое не обеспечивается последовательностью сортировки по умолчанию, и для этого набора символов поддерживается подходящее альтернативная сортировка, то в определении столбца можно указать предложение `COLLATE _collation_`.

Предложение `COLLATE _collation_` может применяться в других контекстах помимо определения столбца. Для операций сравнения больше/меньше его можно добавить в предложение `WHERE` оператора `SELECT`. Если вывод необходимо отсортировать в специальной алфавитной последовательности или без учета регистра и существует соответствующее сопоставление, то предложение `COLLATE` может быть использовано в предложении `ORDER BY`, когда строки сортируются по символьному полю, и в предложении `GROUP BY` в случае групповых операций.


[[fblangref-datatypes-chartypes-caseinsenstv]]
==== Независимый от регистра поиск

Для независимого от регистра поиска можно воспользоваться функцией `UPPER`.

Для поиска без учета регистра вы можете воспользоваться функция `UPPER` для преобразования как аргумента поиска, так
и искомых строк в верхний регистр перед попыткой сопоставления.

[source,sql]
----
...
WHERE UPPER(name) = UPPER(:flt_name)
----

Для строк в наборе символов, для которых доступна сортировка без учета регистра, вы можете просто применить
сопоставление, чтобы напрямую сравнить аргумент поиска и искомые строки.
Например, при использовании набора символов `WIN1251` вы можете использовать для этой цели сортировку `PXW_CYRL` не чувствительную к регистру символов.

[source,sql]
----
...
WHERE FIRST_NAME COLLATE PXW_CYRL >= :FLT_NAME
...
ORDER BY NAME COLLATE PXW_CYRL
----

.См. также:
<<fblangref-commons-predcontaining,CONTAINING>>.

[[fblangref-datatypes-chartypes-utf8collations]]
==== Последовательности сортировки для UTF-8

Ниже приведена таблица возможных последовательностей сортировки для набора символов UTF8.

[[fblangref-dtyp-tbl-utfcollats]]
.Последовательности сортировки для UTF8
[cols="<1,<3", options="header",stripes="none"]
|===
| COLLATION
| Комментарии

|UCS_BASIC
|Сортировка работает в соответствии с положением символа в
таблице (бинарная).

|UNICODE
|Сортировка работает в соответствии с алгоритмом UCA
(Unicode Collation Algorithm) (алфавитная).

|UTF-8
|По умолчанию используется двоичное сопоставление,
идентичное UCS_BASIC, которое было добавлено для
совместимости с SQL стандартом.

|UNICODE_CI
|Сортировка без учета регистра символов. 

|UNICODE_CI_AI
|Сортировка без учета регистра и без учета диакритических
знаков в алфавитном порядке.
|===

Пример сортировки строк для набора символов UTF8 без учёта регистра символов и диакритических знаков.
[source,sql]
----
ORDER BY NAME COLLATE UNICODE_CI_AI
----

[[fblangref-datatypes-chartypes-charindxs]]
=== Индексирование символьных типов

При построении индекса по строковым полям необходимо учитывать ограничение на длину ключа индекса.
Максимальная используемая длина ключа индекса равна 1/4 размера страницы, то есть от 1024 (для страницы размером 4096) до 8192 байтов (для страницы размером 32768). Максимальная длина индексируемой строки на 9 байтов меньше, чем максимальная длина ключа.
В таблице приведены данные для максимальной длины индексируемой строки (в символах) в зависимости от размера страницы и набора символов, её можно вычислить по следующей формуле:

[source,sql]
----
max_char_length = FLOOR((page_size / 4 – 9) / N),
----

где `N` -- число байтов на представление символа.

[[fblangref-dtyp-tbl-charindxsz]]
.Длина индексируемой строки и набор символов
[cols=">1,>1,>1,>1,>1,>1",stripes="none"]
|===
.2+^h| Размер страницы
5+^h| Максимальная длина
индексируемой строки для набора символов, байт/символ

^h|1
^h|2
^h|3
^h|4
^h|6

|4096
|1015
|507
|338
|253
|169

|8192
|2039
|1019
|679
|509
|339

|16384
|4087
|2043
|1362
|1021
|681

|32768
|8183
|4091
|2727
|2045
|1363
|===

[NOTE]
====
В кодировках, нечувствительных к регистру ("_CI"), один символ в _индексе_ будет занимать не 4, а 6 байт, поэтому максимальная длина ключа для страницы, например для страницы 4096 байт составит 169 символов.
====

Последовательность сортировки (COLLATE) тоже может повлиять на максимальную длину индексируемой строки.
Полный список доступных наборов символов и нестандартных порядков сортировки доступен в приложении
<<fblangref-appx-charsets,Наборы символов и порядки сортировки>>.

.См. также
<<fblangref-ddl-database-create,`CREATE DATABASE`>>, <<fblangref-datatypes-chartypes-collation,Порядок сортировки>>, <<fblangref-dml-select,`SELECT`>>, <<fblangref-dml-select-where,`WHERE`>>, <<fblangref-dml-select-groupby,`GROUP BY`>>, <<fblangref-dml-select-orderby,`ORDER BY`>>

[[fblangref-datatypes-binary]]
=== `BINARY`

(((Типы данных, BINARY)))
`BINARY` является типом данных с фиксированной длиной для хранения бинарных данных.
Если переданное количество байт меньше объявленной длины, то значение будет дополнено нулями.
В случае если не указана длина, то считается, что она равна единице.

.Синтаксис
[listing,subs=+quotes]
----
BINARY [(<length>)]
----

[NOTE]
====
Этот тип является псевдонимом типа `CHAR [(<length>)] CHARACTER SET OCTETS` и обратно совместим с ним.
====

[TIP]
====
Данный тип хорошо подходит для хранения уникального идентификатора полученного с помощью функции <<fblangref-scalarfuncs-gen-uuid>>.
====

.См. также:
<<fblangref-datatypes-chartypes-char,CHAR>>, <<fblangref-datatypes-chartypes-special,CHARACTER SET OCTETS>>.

[[fblangref-datatypes-chartypes-char]]
=== `CHAR`

(((Типы данных, CHAR))) (((Типы данных, CHARACTER)))
`CHAR` является типом данных фиксированной длины.
Если введённое количество символом меньше объявленной длины, то поле дополнится концевыми пробелами.
В общем случае символ заполнитель может и не являться пробелом, он зависит от набора символов, так например, для набора символов `OCTETS` -- это ноль.

Полное название типа данных `CHARACTER`, но при работе нет необходимости использовать полные наименования; инструменты по работе с базой прекрасно понимают и короткие имена символьных типов данных.

.Синтаксис
[listing,subs=+quotes]
----
{CHAR | CHARACTER} [(length)] 
  [CHARACTER SET <charset>] [COLLATE <collate>]
----

В случае если не указана длина, то считается, что она равна единице. 

Данный тип символьных данных можно использовать для хранения в справочниках кодов, длина которых стандартна и определённой "`ширины`".
Примером такого может служить почтовый индекс в России – 6 символов.


[[fblangref-datatypes-varbinary]]
=== `VARBINARY`

(((Типы данных, VARBINARY)))
`VARBINARY` является типом для хранения бинарных данных переменной длины.
Реальный размер хранимой структуры равен фактическому размеру данных плюс 2 байта, в которых задана длина поля.

Полное название `BINARY VARYING`.

.Синтаксис
[listing,subs=+quotes]
----
{VARBINARY  | BINARY VARYING} (<length>)
----

[NOTE]
====
Этот тип является псевдонимом типа `VARCHAR (<length>) CHARACTER SET OCTETS` и обратно совместим с ним.
====


.Использование типов BINARY и VARBINARY в PSQL
[example]
====
[source,sql]
----

DECLARE VARIABLE VAR1 VARBINARY(10);
----
====

.Использование типов BINARY и VARBINARY при определении таблицы
[example]
====
[source,sql]
----
CREATE TABLE INFO (
  GUID BINARY(16),
  ENCRYPT_KEY VARBINARY(100),
  ICON BINARY VARYING(32000));
----
====

.См. также:
<<fblangref-datatypes-chartypes-varchar,VARCHAR>>, <<fblangref-datatypes-chartypes-special,CHARACTER SET OCTETS>>.


[[fblangref-datatypes-chartypes-varchar]]
=== `VARCHAR`

(((Типы данных, VARCHAR))) (((Типы данных, CHAR VARYING))) (((Типы данных, CHARACTER VARYING)))
`VARCHAR` является базовым строковым типом для хранения текстов переменной длины, поэтому реальный размер хранимой структуры равен фактическому размеру данных плюс 2 байта, в которых задана длина поля.

Все символы, которые передаются с клиентского приложения в базу данных, считаются как значимые, включая начальные и конечные пробельные символы.

Полное название `CHARACTER VARYING`.
Имеется и сокращённый вариант записи `CHAR VARYING`.

.Синтаксис
[listing,subs=+quotes]
----
 {VARCHAR | {CHAR | CHARACTER} VARYING} (length) 
  [CHARACTER SET <charset>] [COLLATE <collate>]
----

[[fblangref-datatypes-chartypes-nchar]]
=== `NCHAR`

(((Типы данных, NCHAR))) (((Типы данных, NATIONAL CHAR))) (((Типы данных, NATIONAL CHARACTER)))
Представляет собой символьный тип данных фиксированной длины с предопределённым набором символов ISO8859_1.

.Синтаксис
[listing,subs=+quotes]
----
{NCHAR | NATIONAL {CHAR | CHARACTER}} [(length)]
----

Синонимом является написание `NATIONAL CHAR`.

Аналогичный тип данных доступен для строкового типа переменной длины: `NATIONAL CHARACTER VARYING`.


[[fblangref-datatypes-booleantypes]]
== Логический тип данных

В Firebird 3.0 был введён полноценный логический тип данных.

[[fblangref-datatypes-boolean]]
=== `BOOLEAN`

(((Типы данных, BOOLEAN)))
SQL-2008 совместимый тип данных `BOOLEAN` (8 бит) включает различные значения истинности `TRUE` и `FALSE`.
Если не установлено ограничение `NOT NULL`, то тип данных `BOOLEAN` поддерживает также значение истинности `UNKNOWN` как `NULL` значение.
Спецификация не делает различия между значением NULL этого типа и значением истинности UNKNOWN, которое является результатом SQL предиката, поискового условия или выражения логического типа.
Эти значения взаимозаменяемы и обозначают одно и то же. 

Как и в других языках программирования, значения типа `BOOLEAN` могут быть проверены в неявных значениях истинности.
Например, `field1 OR field2` или `NOT field1` являются допустимыми выражениями.

[[fblangref-datatypes-boolean-is]]
==== Оператор `IS`

Предикаты могут использовать оператор <<fblangref-commons-isnotboolean,Логический `IS [NOT]`>> для сопоставления.
Например, `field1 IS FALSE`, или `field1 IS NOT TRUE`.

[NOTE]
====
* Операторы эквивалентности ("```=```", "```!=```", "```<>```" и др.) допустимы во всех сравнениях.
====

[[fblangref-datatypes-boolean-examples]]
==== Примеры `BOOLEAN`

.INSERT и SELECT
[source,sql]
----
CREATE TABLE TBOOL (ID INT, BVAL BOOLEAN); 
COMMIT; 

INSERT INTO TBOOL VALUES (1, TRUE); 
INSERT INTO TBOOL VALUES (2, 2 = 4); 
INSERT INTO TBOOL VALUES (3, NULL = 1); 
COMMIT; 

SELECT * FROM TBOOL
----
----
ID           BVAL 
============ ======= 
1            <true> 
2            <false>
3            <null>
----

.Проверка `TRUE` значения
[source,sql]
----
SELECT * FROM TBOOL WHERE BVAL
----
----
ID           BVAL 
============ ======= 
1            <true>
----

.Проверка `FALSE` значения
[source,sql]
----
SELECT * FROM TBOOL WHERE BVAL IS FALSE
----
----
   
ID           BVAL 
============ ======= 
2            <false>
----

.Проверка `UNKNOWN` значения
[source,sql]
----
SELECT * FROM TBOOL WHERE BVAL IS UNKNOWN
----
----
  
ID           BVAL 
============ ======= 
3            <null>
----

.Логические выражения в SELECT списке
[source,sql]
----
SELECT ID, BVAL, BVAL AND ID < 2 
FROM TBOOL
----
----
  
ID           BVAL 
============ ======= ======= 
1            <true> <true> 
2            <false> <false> 
3            <null> <false>
----

.PSQL объявления с начальным значением
[source,sql]
----
DECLARE VARIABLE VAR1 BOOLEAN = TRUE;
----

.Сравнения с UNKNOWN
[source,sql]
----
-- Допустимый синтаксис, но как и сравнение 
-- с NULL, никогда не вернёт ни одной записи 
SELECT * FROM TBOOL WHERE BVAL = UNKNOWN 
SELECT * FROM TBOOL WHERE BVAL <> UNKNOWN
----

[[fblangref-datatypes-boolean-othertypes]]
==== Использование Boolean с другими типами данных

Хотя `BOOLEAN` по своей сути не может быть преобразован в какой-либо другой тип данных, начиная с версии 3.0.1 строки `'true'` и `'false'` (без учета регистра) будут неявно приводиться к `BOOLEAN` в выражениях значений, например

[source]
----
if (true > 'false') then ...
----

`'false'` преобразуется в `BOOLEAN`.
Любая попытка использовать логические операторы `AND`, `NOT`, `OR` и `IS` потерпят неудачу.
Например, `NOT 'False'` приведёт к ошибке.

A `BOOLEAN` может быть явно преобразован в строку и из нее с помощью `CAST`.
Значение `UNKNOWN` не доступен при преобразовании к строке.

.Другие замечания
[NOTE]
====
* Тип данных `BOOLEAN` представлен в API типом `FB_BOOLEAN` и константами `FB_TRUE` и `FB_FALSE`.
* Значение `TRUE` больше чем значение `FALSE`.
====

[[fblangref-datatypes-bnrytypes]]
== Бинарные типы данных

[[fblangref-datatypes-blob]]
=== `BLOB`

(((Типы данных, BLOB)))
BLOB (Binary Large Objects, большие двоичные объекты) представляют собой сложные структуры, предназначенные для хранения текстовых и двоичных данных неопределённой длины, зачастую очень большого объёма.

.Синтаксис
[listing,subs=+quotes]
----
BLOB [SUB_TYPE <subtype>]
  [SEGMENT SIZE <seg_length>]
  [CHARACTER SET <charset>]   
  [COLLATE <collation name>]
----

.Сокращённый синтаксис:
[listing,subs=+quotes]
----
BLOB (<seg_length>)
BLOB (<seg_length>, <subtype>)
BLOB (, <subtype>)
----

.Размер сегмента:
Указание размера сегмента BLOB является некоторым атавизмом, оно идёт с тех времён, когда приложения для работы с данными BLOB писались на C (Embedded SQL) при помощи GPRE.
В настоящий момент размер сегмента при работе с данными BLOB определяется клиентской частью, причём размер сегмента может превышать размер страницы данных. 

[[fblangref-datatypes-blob-subtype]]
==== Подтипы BLOB

Подтип BLOB отражает природу данных, записанную в столбце.
Firebird предоставляет два предопределённых подтипа для сохранения пользовательских данных: 

Подтип 0 (BINARY)::
Если подтип не указан, то данные считаются не типизированными и значение подтипа принимается равным 0.
Псевдоним подтипа 0 -- `BINARY`.
Этот подтип указывает, что данные имеют форму бинарного файла или потока (изображение, звук, видео, файлы текстового процессора, PDF и т.д.).

Подтип 1 (TEXT)::
Подтип 1 имеет псевдоним `TEXT`, который может быть использован вместо указания номера подтипа.
Например, `BLOB SUBTYPE TEXT`.
Это специализированный подтип, который используется для хранения текстовых данных большого объёма.
Для текстового подтипа `BLOB` может быть указан набор символов и порядок сортировки `COLLATE`, аналогично символьному полю.

.Пользовательские подтипы
Кроме того, существует возможность добавления пользовательских подтипов данных, для них зарезервирован интервал от -1 до -32768.
Пользовательские подтипы с положительными числами не поддерживаются, поскольку Firebird использует числа больше 2 для внутренних подтипов метаданных.

[[fblangref-datatypes-blob-specifics]]
==== Особенности BLOB

.Размер
Максимальный размер поля BLOB ограничен 4Гб и не зависит от варианта сервера, 32 битный или 64 битный (во внутренних структурах, связанных с BLOB присутствуют 4-х байтные счётчики). Для размера страницы 4096 максимальный размер BLOB поля несколько ниже 2 Гб. 

.Операторы и выражения
Текстовые BLOB любой длины и с любым набором символов (включая multi-byte) могут быть использованы практически с любыми встроенными функциями и операторами.

Полностью поддерживаются следующие операторы:

[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|=
|(присвоение)
|=, <>, <, \<=, >, >=
|(сравнение)
|`{vbar}{vbar}`
|(конкатенация)
|`BETWEEN`,
|`IS [NOT] DISTINCT FROM`,
|`IN`,
|`ANY` {vbar} `SOME`,
|`ALL`
|{nbsp}
|===

Частично поддерживаются следующие операторы:

* возникает ошибка, в случае если второй аргумент больше или равен 32 Кб
+
[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|`STARTING [WITH]`,
|`LIKE`,
|`CONTAINING`
|{nbsp}
|===

* Предложения агрегирования работают не с содержимым самого поля, а с идентификатором BLOB ID. Помимо этого, есть некоторые странности:
+
[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|`SELECT DISTINCT`
|ошибочно выдаёт несколько значений NULL, если они присутствуют
|`ORDER BY`
|--
|`GROUP BY`
|объединяет одинаковые строки, если они находятся рядом, но не делает этого, если они располагаются вдали друг от друга
|===



.Хранение BLOB

* По умолчанию, для каждого `BLOB` создаётся обычная запись, хранящаяся на какой-то выделенной для этого странице данных (data page). Если весь BLOB на эту страницу поместится, его называют `BLOB` уровня 0. Номер этой специальной записи хранится в записи таблицы и занимает 8 байт.
* Если `BLOB` не помещается на одну страницу данных (data page), то его содержимое размещается на отдельных страницах, целиком выделенных для него (blob page), а в записи о `BLOB` помещают номера этих страниц. Это `BLOB` уровня 1.
* Если массив номеров страниц с данными `BLOB` не помещается на страницу данных (data page), то его (массив) размещают на отдельных страницах (blob page), а в запись о `BLOB` помещают уже номера этих страниц. Это `BLOB` уровня 2.
* Уровни выше 2 не поддерживаются. 

.См. также:
<<fblangref-ddl-filter,FILTER>>, <<fblangref-ddl-filter-declare,DECLARE FILTER>>.

[[fblangref-datatypes-array]]
=== Массивы

Поддержка массивов в СУБД Firebird является расширением традиционной реляционной модели.
Поддержка в СУБД такого инструмента позволяет проще решать некоторые задачи по обработке однотипных данных.
Массивы в Firebird реализованы на базе полей типа BLOB.
Массивы могут быть одномерными и многомерными. 

[example]
====
[source,sql]
----
  
CREATE TABLE SAMPLE_ARR (
  ID INTEGER NOT NULL PRIMARY KEY,
  ARR_INT INTEGER [4]);
----
====

Так будет создана таблица с полем типа массива из четырёх целых.
Индексы данного массива от 1 до 4. 

[[fblangref-datatypes-array-bounds]]
==== Указание явных границ для измерений

По умолчанию размеры начинаются с 1.
Для определения верхней и нижней границы значений индекса следует воспользоваться следующим синтаксисом: 

[listing]
----
[<lower>:<upper>]
----

[[fblangref-datatypes-array-adddim]]
==== Добавление дополнительных измерений

Добавление новой размерности в синтаксисе идёт через запятую.
Пример создания таблицы с массивом размерности два, в котором нижняя граница значений начинается с нуля:

[source,sql]
----
CREATE TABLE SAMPLE_ARR2 (
  ID INTEGER NOT NULL PRIMARY KEY,
  ARR_INT INTEGER [0:3, 0:3]);
----

==== Использование массивов

СУБД не предоставляет большого набора инструментов для работы с содержимым массивов.
База данных [path]_employee.fdb_, которая находится в дистрибутиве Firebird, содержит пример хранимой процедуры, показывающей возможности работы с массивами.
Ниже приведён её текст:

[source,sql]
----
  
CREATE OR ALTER PROCEDURE SHOW_LANGS (
  CODE VARCHAR(5),
  GRADE SMALLINT,
  CTY VARCHAR(15))
RETURNS (
  LANGUAGES VARCHAR(15))
AS
  DECLARE VARIABLE I INTEGER;
BEGIN
  I = 1;
  WHILE (I <= 5) DO
  BEGIN
    SELECT LANGUAGE_REQ[:I]
    FROM JOB
    WHERE (JOB_CODE = :CODE)
      AND (JOB_GRADE = :GRADE)
      AND (JOB_COUNTRY = :CTY)
      AND (LANGUAGE_REQ IS NOT NULL))
    INTO :LANGUAGES;
    
    IF (:LANGUAGES = '') THEN
      /* PRINTS 'NULL' INSTEAD OF BLANKS */
      LANGUAGES = 'NULL';
    I = I +1;
    SUSPEND;
  END
END
----

Если приведённых выше возможностей достаточно для ваших задач, то вы вполне можете применять массивы для своих проектов.
В настоящее время совершенствования механизмов обработки массивов средствами СУБД не производится. 

[[fblangref-datatypes-special]]
== Специальные типы данных

[[fblangref-datatypes-special-sqlnull]]
=== Тип данных `SQL_NULL`

Данный тип данных содержит не данные, а только состояние: `NULL` или `NOT NULL`.
Также, этот тип данных не может быть использован при объявлении полей таблицы, переменных PSQL, использован в описании параметров.
Этот тип данных добавлен для улучшения поддержки нетипизированных параметров в предикате `IS NULL`.
Такая проблема возникает при использовании "`отключаемых фильтров`" при написании запросов следующего типа:

[source,sql]
----
WHERE col1 = :param1 OR :param1 IS NULL
----

после обработки, на уровне API запрос будет выглядеть как 
[source,sql]
----
WHERE col1 = ? OR ? IS NULL
----

В данном случае получается ситуация, когда разработчик при написании SQL запрос рассматривает [replaceable]``:param1`` как одну переменную, которую использует два раза, а на уровне API запрос содержит два отдельных и независимых параметра.
Вдобавок к этому, сервер не может определить тип второго параметра, поскольку он идёт в паре с `IS NULL`.

Именно для решения проблемы "`? IS NULL`" и был добавлен этот специальный тип данных SQL_NULL. 

После введения данного специального типа данных при передаче запроса и его параметров на сервер будет работать такая схема: приложение передаёт параметризованные запросы на сервер в виде "`?`".
Это делает невозможным слияние пары "`одинаковых`" параметров в один.
Так, например, для двух фильтров (двух именованных параметров) необходимо передать четыре позиционных параметра (далее предполагается, что читатель имеет некоторое знакомство с Firebird API):

[source,sql]
----
SELECT
  SH.SIZE, SH.COLOUR, SH.PRICE
FROM SHIRTS SH
WHERE (SH.SIZE = ? OR ? IS NULL)
  AND (SH.COLOUR = ? OR ? IS NULL)
----

После выполнения `isc_dsql_describe_bind()` sqltype 2-го и 4-го параметров устанавливается в SQL_NULL.
Как уже говорилось выше, сервер Firebird не имеет никакой информации об их связи с 1-м и 3-м параметрами -- это полностью прерогатива программиста.
Как только значения для 1-го и 3-го параметров были установлены (или заданы как NULL) и запрос подготовлен, каждая пара XSQLVARs должна быть заполнена следующим образом: 

Пользователь задал параметры::
* Первый параметр (сравнение значений): установка `{asterisk}sqldata` в переданное значение и `{asterisk}sqlind` в `0` (для `NOT NULL`);
* Второй параметр (проверка на NULL): установка `{asterisk}sqldata` в `null` (указатель null, а не SQL `NULL`) и `{asterisk}sqlind` в 0 (для `NOT NULL`).


Пользователь оставил поле пустым::
* Оба параметра (проверка на NULL): установка `{asterisk}sqldata` в `null` (указатель null, а не SQL `NULL`) и `{asterisk}sqlind` в -1 (индикация `NULL`).

Другими словами: значение параметра сравнения всегда устанавливается как обычно.
`SQL_NULL` параметр устанавливается также, за исключением случая, когда `sqldata` передаётся как  `null`.

[[fblangref-datatypes-convert]]
== Преобразование типов данных

При написании выражения или при задании, например, условий сравнения, нужно стараться использовать совместимые типы данных.
В случае необходимости использования смешанных данных различных типов, желательно первоначально выполнить преобразования типов, а уже потом выполнять операции. 

При рассмотрении вопроса преобразования типов в Firebird большое внимание стоит уделить тому, в каком диалекте база данных. 

[[fblangref-datatypes-convert-explicit]]
=== Явное преобразование типов данных

В тех случаях, когда требуется выполнить явное преобразование одного типа в другой, используют функцию `CAST`.

.Синтаксис
[listing,subs=+quotes]
----
CAST (<expression> | NULL AS <data_type>)

<data_type> ::= 
    <datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN _relname_._colname_

<datatype> ::= 
    <scalar_datatype> | <blob_datatype> | <array_datatype>                    
                    
<scalar_datatype> ::=  См. <<fblangref-datatypes-syntax-scalar,Синтаксис скалярных типов данных>>

<blob_datatype> ::= См. <<fblangref-datatypes-syntax-blob,Синтаксис типа данных BLOB>>

<array_datatype> ::= См. <<fblangref-datatypes-syntax-array,Синтаксис массивов>>
----

[[fblangref-datatypes-convert-domain]]
==== Преобразование к домену

При преобразовании к домену учитываются объявленные для него ограничения, например, `NOT NULL` или описанные в `CHECK` и если `<expression>` не пройдёт проверку, то преобразование не удастся.
В случае если дополнительно указывается `TYPE OF` (преобразование к базовому типу), при преобразовании игнорируются любые ограничения домена.
При использовании `TYPE OF` с типом `[VAR]CHAR` набор символов и сортировка сохраняются.

[[fblangref-datatypes-convert-typeof]]
==== Преобразование к типу столбца

При преобразовании к типу столбца допускается использовать указание столбца таблицы или представления.
Используется только сам тип столбца; в случае строковых типов это также включает набор символов, но не сортировку.
Ограничения и значения по умолчанию исходного столбца не применяются. 


[example]
====
[source,sql]
----
  
CREATE TABLE TTT (
  S VARCHAR (40)
  CHARACTER SET UTF8 COLLATE UNICODE_CI_AI);
COMMIT;

/* У меня много друзей (шведский)*/
SELECT
  CAST ('Jag har manga vanner' AS TYPE OF COLUMN TTT.S)
FROM RDB$DATABASE;
----
====

[[fblangref-datatypes-convert-conversions]]
==== Допустимые преобразования для функции `CAST`

[[fblangref-dtyp-tbl-conversions]]
.Допустимые преобразования для функции CAST
[cols="<1,<3", options="header",stripes="none"]
|===
| Из типа
| В тип

|Числовые типы
|Числовые типы, `[VAR]CHAR`, `BLOB`

|`[VAR]CHAR`, `BLOB`
|`[VAR]CHAR`, `BLOB`, `BOOLEAN`, Числовые типы, `DATE`, `TIME`, `TIMESTAMP`

|`DATE`, `TIME`
|`[VAR]CHAR`, `BLOB`, `TIMESTAMP`

|`TIMESTAMP`
|`[VAR]CHAR`, `BLOB`, `TIME`, `DATE`

|`BOOLEAN`
|`[VAR]CHAR`, `BLOB`
|===

Для преобразования строковых типов данных в тип BOOLEAN необходимо чтобы строковый аргумент был одним из предопределённых литералов логического типа (`'true'` или `'false'`).

[IMPORTANT]
====
При преобразовании типов следует помнить о возможной частичной потери данных, например, при преобразовании типа данных `TIMESTAMP` в `DATE`.
====

[[fblangref-datatypes-convert-literalformats]]
==== Преобразование строк в дату и время

Для преобразования строковых типов данных в типы `DATE`, `TIME` или `TIMESTAMP` необходимо чтобы строковый аргумент был либо одним из предопределённых литералов даты и времени, либо строковое представление даты в одном из разрешённых форматов.

[listing,subs=+quotes]
----
<date_literal> ::= 
  [YYYY<p>]MM<p>DD |
  MM<p>DD[<p>YYYY] |
  DD<p>MM[<p>YYYY] |
  MM<p>DD[<p>YY] |
  DD<p>MM[<p>YY] 


<time_literal> := HH[:mm[:SS[.NNNN]]]

<datetime_literal> ::= <date_literal> <time_literal>
                    
<time zone> ::=
    <time zone region> |
    [+/-] <hour displacement> [: <minute displacement>]                    

<p> ::= whitespace | . | , | - | /
----


.Описание формата даты и времени
[cols="<1,<3", options="header",stripes="none"]
|===
^| Аргумент
^| Описание

|datetime_literal
|Литерал даты-времени.

|date_literal
|Литерал даты.

|time_literal
|Литерал времени.

|YYYY
|Год из четырёх цифр.

|YY
|Последние две цифры года (00-99).

|MM
|Месяц.
Может содержать 1 или 2 цифры (1-12 или 01-12). В качестве месяца допустимо также указывать трёх буквенное сокращение или полное наименование месяца на английском языке, регистр не имеет значение.

|DD
|День.
Может содержать 1 или 2 цифры (1-31 или 01-31).

|HH
|Час.
Может содержать 1 или 2 цифры (0-23 или 00-23).

|mm
|Минуты.
Может содержать 1 или 2 цифры (0-59 или 00-59).

|SS
|Секунды.
Может содержать 1 или 2 цифры (0-59 или 00-59).

|NNNN
|Десятитысячные доли секунды.
Может содержать от 1 до 4 цифр (0-9999).

|p
|Разделитель, любой из разрешённых символов, лидирующие и завершающие пробелы игнорируются

|time zone region
|Один из часовых поясов связанных с регионом

|hour displacement
|Смещение времени для часов относительно GMT

|minute displacement
|Смещение времени для минут относительно GMT
|===


.Литералы с предопределёнными значениями даты и времени
[cols="1,1,1,1", options="header"]
|===
| Литерал
| Значение
| Тип данных для диалекта 1
| Тип данных для диалекта 3

|``'NOW'``
|Текущая дата и время
|TIMESTAMP
|TIMESTAMP

|``'TODAY'``
|Текущая дата
|TIMESTAMP (c нулевым временем)
|DATE (только дата)

|``'TOMORROW'``
|Завтрашняя дата
|TIMESTAMP (c нулевым временем)
|DATE (только дата)

|``'YESTERDAY'``
|Вчерашняя дата
|TIMESTAMP (c нулевым временем)
|DATE (только дата)
|===

Правила: 

* В формате Год-Месяц-День, год обязательно должен содержать 4 цифры;
* Для дат в формате с завершающим годом, если в качестве разделителя дат используется точка "`$$.$$`", то дата интерпретируется в форме День-Месяц-Год, для остальных разделителей она интерпретируется в форме Месяц-День-Год;
* Если год не указан, то в качестве года берётся текущий год;
* Если указаны только две цифры года, то для получения столетия Firebird использует алгоритм скользящего окна. Задача заключается в интерпретации двухсимвольного значения года как ближайшего к текущему году в интервале предшествующих и последующих 50 лет;
* Если не указан один из элементов времени, то оно принимается равным 0.

При использовании преобразования строковых литералов в тип даты/времени с помощью функции CAST() вычисление значения всегда происходит в момент выполнения.

При преобразовании строковых литералов с предопределёнными значениями даты и времени в тип TIMESTAMP точность составляет 3 знака после запятой (миллисекунды).

[TIP]
====
Настоятельно рекомендуем в литералах дат использовать только формы с полным указанием года в виде 4 цифр во избежание путаницы. 
====

.Преобразование строк в дату и время:
[example]
====
[source,sql]
----

SELECT
  CAST('04.12.2014' AS DATE) AS d1, -- DD.MM.YYYY
  CAST('12-04-2014' AS DATE) AS d2, -- MM-DD-YYYY
  CAST('12/04/2014' AS DATE) AS d3, -- MM/DD/YYYY
  CAST('04.12.14' AS DATE) AS d4,   -- DD.MM.YY
  -- DD.MM в качестве года берётся текущий
  CAST('04.12' AS DATE) AS d5,
  -- MM/DD в качестве года берётся текущий      
  CAST('12/4' AS DATE) AS d6,
  CAST('2014/12/04' AS DATE) AS d7, -- YYYY/MM/DD
  CAST('2014.12.04' AS DATE) AS d8, -- YYYY.MM.DD
  CAST('2014-12-04' AS DATE) AS d9, -- YYYY-MM-DD
  CAST('11:37' AS TIME) AS t1, -- HH:mm
  CAST('11:37:12' AS TIME) AS t2, -- HH:mm:ss
  CAST('11:31:12.1234' AS TIME) AS t3, -- HH:mm:ss.nnnn
  -- HH:mm:ss.nnnn +hh
  CAST('11:31:12.1234 +03' AS TIME WITH TIME ZONE) AS t4,
  -- HH:mm:ss.nnnn +hh:mm
  CAST('11:31:12.1234 +03:30' AS TIME WITH TIME ZONE) AS t5,
  -- HH:mm:ss.nnnn tz
  CAST('11:31:12.1234 Europe/Moscow' AS TIME WITH TIME ZONE) AS t5,
  -- HH:mm tz
  CAST('11:31 Europe/Moscow' AS TIME WITH TIME ZONE) AS t6,
  -- DD.MM.YYYY HH:mm
  CAST('04.12.2014 11:37' AS TIMESTAMP) AS dt1,
  -- MM/DD/YYYY HH:mm:ss
  CAST('12/04/2014 11:37:12' AS TIMESTAMP) AS dt2,
  -- DD.MM.YYYY HH:mm:ss.nnnn 
  CAST('04.12.2014 11:31:12.1234' AS TIMESTAMP) AS dt3,
  -- YYYY-MM-DD HH:mm:ss.nnnn +hh:mm
  CAST('2014-12-04 11:31:12.1234 +03:00' AS TIMESTAMP WITH TIME ZONE) AS dt4,
  -- DD.MM.YYYY HH:mm:ss.nnnn tz
  CAST('04.12.2014 11:31:12.1234 Europe/Moscow' AS TIMESTAMP WITH TIME ZONE) AS dt5,
  CAST('now' AS DATE) AS d_now,
  CAST('now' AS TIMESTAMP) AS ts_now,
  CAST('now' AS TIMESTAMP WITH TIME ZONE) AS ts_now_tz,
  CAST('today' AS DATE) AS d_today,
  CAST('today' AS TIMESTAMP) AS ts_today,
  CAST('today' AS TIMESTAMP WITH TIME ZONE) AS ts_today_tz,
  CAST('tomorrow' AS DATE) AS d_tomorrow,
  CAST('tomorrow' AS TIMESTAMP) AS ts_tomorrow,
  CAST('tomorrow' AS TIMESTAMP WITH TIME ZONE) AS ts_tomorrow_tz,
  CAST('yesterday' AS DATE) AS d_yesterday,
  CAST('yesterday' AS TIMESTAMP) AS ts_yesterday,
  CAST('yesterday' AS TIMESTAMP WITH TIME ZONE) AS ts_yesterday_tz
FROM rdb$database
----
====

[NOTE]
====
Поскольку `CAST('NOW' AS TIMESTAMP)` всегда возвращает актуальные значения даты и времени, то она может использоваться для измерения временных интервалов и скорости выполнения кода в процедурах, триггерах и блоках кода PSQL.
====

.Использование `CAST('NOW' AS TIMESTAMP)` измерения длительности выполнения кода
[example]
====
[source,sql]
----

EXECUTE BLOCK
RETURNS (ms BIGINT)
AS
DECLARE VARIABLE t1 TIME;
DECLARE VARIABLE n BIGINT;
BEGIN
  t1 = CAST('now' AS TIMESTAMP);
  /* Долгая операция  */
  SELECT COUNT(*) FROM rdb$types, rdb$types, rdb$types INTO n;
  /*======*/
  ms = DATEDIFF(MILLISECOND FROM t1 TO CAST('now' AS TIMESTAMP));
  SUSPEND;
END
----
====

.См. также:
<<fblangref-datatypes-chartypes-special,Литералы даты и времени>>, <<fblangref-scalarfuncs-cast>>.

[[fblangref-datatypes-convert-implicit]]
=== Неявное преобразование типов данных

В 3-м диалекте невозможно неявное преобразование данных, здесь требуется указывать функцию `CAST` для явной трансляции одного типа в другой.
Однако это не относится к операции конкатенации, при которой все другие типы данных будут неявно преобразованы к символьному. 

При использовании 1-го диалекта во многих выражениях выполняется неявное преобразование одних типов в другой без применения функции `CAST`.
Например, в выражении отбора в диалекте 1 можно записать:

[source,sql]
----
WHERE DOC_DATE < '31.08.2014'
----

и преобразование строки в дату произойдёт неявно. 

В 1-м диалекте можно смешивать целые данные и числовые строки, строки неявно преобразуются в целое, если это будет возможно, например:

[source,sql]
----
2 + '1'
----

корректно выполнится.

В 3-м диалекте подобное выражение вызовет ошибку, в нем потребуется запись следующего вида:

[source,sql]
----
2 + CAST('1' AS SMALLINT)
----

[[fblangref-datatypes-convert-implicit-concat]]
==== Неявное преобразование типов при конкатенации

При конкатенации множества элементов разных типов, все не строковые данные будут неявно преобразованы к строке, если это возможно.

.Неявное преобразование типов при конкатенации
[example]
====
[source,sql]
----
 
SELECT 30||' days hath September, April, June and November' CONCAT$
FROM RDB$DATABASE
----
[listing]
----
CONCAT$
------------------------------------------------
30 days hath September, April, June and November
----
====

[[fblangref-datatypes-domain]]
== Пользовательские типы данных -- домены

Домены в СУБД Firebird реализуют широко известный по многим языкам программирования инструмент "`типы данных, определённые пользователем`".
Когда несколько таблиц в базе данных содержат поля с характеристиками одинаковыми или практически одинаковыми, то есть целесообразность сделать домен, в котором описать набор свойств поля и использовать такой набор свойств, описанный один раз, в нескольких объектах базы данных.
Домены могут использоваться помимо описания полей таблиц и представлений (VIEW) и при объявлении входных и выходных параметров, а также при объявлении переменных в коде PSQL. 

[[fblangref-datatypes-domainattribs]]
=== Атрибуты домена

Определение домена содержит обязательные и необязательные атрибуты.
К обязательному атрибуту относится тип данных.
К необязательным относятся: 

* значение по умолчанию;
* возможности использования NULL для домена;
* ограничения CHECK для данных домена;
* набор символов (для символьных типов данных и BLOB полей); 
* порядок сортировки (для символьных типов данных).


.Создание домена
[example]
====
[source,sql]
----
CREATE DOMAIN BOOL3 AS SMALLINT
			CHECK (VALUE IS NULL OR VALUE IN (0, 1));
----
====

.См. также:
<<fblangref-datatypes-convert-explicit,Явное преобразование типов данных>>, где описаны отличия работы механизма преобразования данных при указании доменов для опций `TYPE OF` и `TYPE OF COLUMN`.

[[fblangref-datatypes_domain-domainoverride]]
=== Переопределение свойств доменов

При описании таблиц базы данных некоторые свойства столбцов, базирующихся на доменах, могут быть переопределены.
Возможности переопределения атрибутов столбцов на базе доменов приведены в таблице.

[[fblangref-dtyp-tbl-domoverride]]
.Возможности переопределения атрибутов столбцов на базе доменов
[cols="1,1,1", frame="all", options="header"]
|===
| Атрибут
| Переопределяется?
| Примечания

|тип данных
|нет
|

|значение по умолчанию
|да
|

|текстовый набор символов
|да
|также может использоваться, чтобы восстановить для столбца
значения по умолчанию для базы данных

|текстовый порядок сортировки
|да
|

|условия проверки `CHECK`
|нет
|для добавления в проверку новых условий, можно использовать в
операторах `CREATE` и `ALTER` на уровне таблицы соответствующие
предложения `CHECK`.

|`NOT NULL`
|нет
|во многих случаях лучше оставить при описании домена
возможность значения `NULL`, а контроль его допустимости
осуществлять в описании полей на уровне таблицы.
|===

[[fblangref-datatypes-domaincreate]]
=== Создание доменов

Создание домена производится оператором CREATE DOMAIN.

.Краткий синтаксис:
[listing,subs=+quotes]
----
CREATE DOMAIN _name_ [AS] <type>
[DEFAULT {<literal> | NULL | <context_var>}]
[NOT NULL] [CHECK (<condition>)]
[COLLATE _collation_];
----

.См. также:
<<fblangref-ddl-domain-create,CREATE DOMAIN>>.

[[fblangref-datatypes-domainalter]]
=== Изменение доменов

Для редактирования свойств домена используют оператор `ALTER DOMAIN` языка определения данных (DDL).


.При редактировании домена можно:* переименовать домен;
* изменить тип данных;
* удалить текущее значение по умолчанию;
* установить новое значение по умолчанию;
* установить ограничение `NOT NULL`;
* удалить ограничение `NOT NULL`;
* удалить текущее ограничение `CHECK`;
* добавить новое ограничение `CHECK`.

.Краткий синтаксис:
[listing,subs=+quotes]
----
ALTER DOMAIN _name_
  [{TO _new_name_}]
  [{SET DEFAULT {<literal> | NULL | <context_var>} |
    DROP DEFAULT}]
  [{SET | DROP} NOT NULL]
  [{ADD [CONSTRAINT] CHECK (<dom_condition>) | 
    DROP CONSTRAINT}]
  [{TYPE <datatype>}];
----

.Изменение значения по умолчанию для домена
[example]
====
[source,sql]
----
ALTER DOMAIN STORE_GRP SET DEFAULT -1;
----
====

При изменении доменов следует учитывать и его зависимости: имеются ли столбцы таблиц; находятся ли в коде PSQL объявления переменных, входных и/или выходных параметров с типом этого домена.
При поспешном редактировании без внимательной проверки можно сделать данный код неработоспособным! 

[IMPORTANT]
====
При смене в домене типа данных не допустимы преобразования, которые могут привести к потере данных.
Также, например, при преобразовании `VARCHAR` в `INTEGER` проверьте, все ли данные, что используют данных домен, смогут пройти преобразование.
====

.См. также:
<<fblangref-ddl-domain-alter,ALTER DOMAIN>>.

[[fblangref-datatypes-domaindrop]]
=== Удаление доменов

Оператор DROP DOMAIN удаляет из базы данных домена при условии, что он не используется в каком либо из объектов базы данных. 

.Синтаксис:
[listing,subs=+quotes]
----
DROP DOMAIN _name_;
----

.Удаление домена
[example]
====
[source,sql]
----
  
DROP DOMAIN Test_Domain;
----
====

.См. также:
<<fblangref-ddl-domain-drop,DROP DOMAIN>>.

[[fblangref-datatypes-datatypes-syntax]]
== Синтаксис объявления типа данных

В этом разделе описывается синтаксис объявления типов данных.
Объявление типа данных чаще всего встречается в <<fblangref-ddl,операторах DDL>>, но также в <<fblangref-datatypes-convert-explicit,`CAST`>>
и <<fblangref-dml-execblock,`EXECUTE BLOCK`>>.

На приведенный ниже синтаксис есть ссылки из других частей этого руководства. 

[[fblangref-datatypes-syntax-scalar]]
=== Синтаксис скалярных типов данных

Скалярные типы данных -- это простые типы данных, которые содержат одно значение.
Синтаксис типов BLOB рассматривается отдельно в секции <<fblangref-datatypes-syntax-blob,Синтаксисе типов данных BLOB>>.

[[fblangref-datatypes-syntax-scalar-syntax]]
.Синтаксис:
[listing,subs=+quotes]
----
<domain_or_non_array_type> ::=
    <scalar_datatype>
  | <blob_datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN _rel_._col_
                        
<scalar_datatype> ::= 
    {SMALLINT | INT[EGER] | BIGINT | INT128}
  | BOOLEAN 
  | {FLOAT | REAL | DOUBLE PRECISION} 
  | [LONG] FLOAT [(_binary-precision_)]
  | DECFLOAT[({16 | 34})]
  | DATE
  | {TIME | TIMESTAMP} [{WITH | WITHOUT} TIME ZONE]
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {VARCHAR | {CHAR | CHARACTER} VARYING} (_length_)
    [CHARACTER SET _charset_]
  | {CHAR | CHARACTER} [(_length_)] [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} VARYING (_length_)
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [(_length_)]
----

[[fblangref-datatypes-tbl-scalar-syntax]]
.Параметры декларации скалярных типов
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|domain
|Имя домена (только не домены типа массив).

|rel
|Имя таблицы или представления.

|col
|Имя столбца таблицы или представления (только столбцы не типа массив).

|binary-precision
|Двоичная точность.
От 1 до 64 бит.

|precision
|Десятичная точность.
От 1 до 38 десятичных цифр.

|scale
|Масштаб или количество знаков после запятой.
От 0 до 38.
Оно должно быть меньше или равно точности.

|length
|Максимальная длина строки в символах.

|charset
|Набор символов.

|domain_or_non_array_type
|Типы, не являющиеся массивами, которые можно использовать в коде PSQL и операторе CAST.
|===

[[fblangref-datatypes-syntax-scalar-domns]]
==== Использование доменов в объявлениях

Имя домена может быть указано как тип параметра PSQL или локальной переменной.
Параметр или переменная наследует все атрибуты домена.
Если для параметра или переменной указано значение по умолчанию, оно переопределяет значение по умолчанию, указанное в определении домена. 

Если предложение `TYPE OF` добавлено перед именем домена, то используется только тип данных домена: любые другие атрибуты домена -- ограничение `NOT NULL`, ограничение `CHECK`, значение по умолчанию -- не проверяются и не используются.
Однако, если домен имеет текстовый тип, всегда используются его набор символов и последовательность сортировки.

[[fblangref-ddl-func-paramscoltype]]
==== Использование TYPE OF COLUMN в объявлениях

Входные и выходные параметры или локальные переменные также могут быть объявлены с использованием типа данных столбцов в существующих таблицах и представлениях.
Для этого используется предложение `TYPE OF COLUMN`, в котором в качестве аргумента указывается `_rel_._col_`.

Когда используется `TYPE OF COLUMN`, параметр или переменная наследует только тип данных и -- для строковых типов -- набор символов и последовательность сортировки.
Ограничения и значение столбца по умолчанию игнорируются. 

[[fblangref-datatypes-syntax-blob]]
=== Синтаксис типов данных BLOB

Типы данных `BLOB` содержат данные в двоичном, символьном или пользовательском формате неопределенного размера.
Для получения дополнительной информации см. <<fblangref-datatypes-blob,BLOB>>.

[[fblangref-datatypes-syntax-blob-syntax]]
.Синтаксис типа BLOB
[listing,subs=+quotes]
----
<blob_datatype> ::=
    BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_]
  | BLOB [(_seglen_ [, _subtype_num_])]
----


[[fblangref-datatypes-tbl-blob-syntax]]
.Параметры декларации типа BLOB
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^^| Описание

|charset
|Набор символов (игнорируется для всех подтипов кроме 1 (TEXT)).

|subtype_num
|Номер подтипа BLOB.

|subtype_name
|Мнемоническое имя подтипа BLOB; это может быть TEXT, BINARY или одно из (других) стандартных или настраиваемых имен, определенных в `RDB$TYPES` для `RDB$FIELD_NAME = 'RDB$FIELD_SUB_TYPE'`.

|`seglen`
|Размер сегмента не может быть больше 65535, по умолчанию -- 80, если не указан.
Размер сегмента может быть может быть переопределён клиентом и в большинстве случаев не учитывается.
|===

[[fblangref-datatypes-syntax-array]]
=== Синтаксис массивов

Тип данных массив содержит несколько скалярных значений в одном или многомерном массиве.
Для получения дополнительной информации см. <<fblangref-datatypes-array,Тип массив>>.

[[fblangref-datatypes-syntax-array-syntax]]
.Синтаксис массивов
[listing,subs="+quotes,attributes"]
----
<array_datatype> ::= 
    {SMALLINT | INT[EGER] | BIGINT | INT128} <array_dim>
  | BOOLEAN <array_dim>
  | {FLOAT | REAL | DOUBLE PRECISION} <array_dim>
  | [LONG] FLOAT [_binary-precision_] <array_dim>
  | DECFLOAT[({16 | 34})] <array_dim>
  | DATE <array_dim>
  | {TIME | TIMESTAMP} [{WITH | WITHOUT} TIME ZONE] <array_dim>
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]  <array_dim>
  | {VARCHAR | {CHAR | CHARACTER} VARYING} (_length_)  <array_dim>
    [CHARACTER SET _charset_]
  | {CHAR | CHARACTER} [(_length_)]  <array_dim> [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} VARYING (_length_) <array_dim>
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [(_length_)] <array_dim>
                        
<array_dim> ::= '[' [_m_:{endsb}__n__ [,[_m_:{endsb}__n__ ...] ']'
----

[[fblangref-datatypes-tbl-array-syntax]]
.Параметры декларации массивов
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^^| Описание

|binary-precision
|Двоичная точность.
От 1 до 64 бит.

|precision
|Десятичная точность.
От 1 до 38 десятичных цифр.

|scale
|Масштаб или количество знаков после запятой.
От 0 до 38.
Оно должно быть меньше или равно точности.

|length
|Максимальная длина строки в символах.

|charset
|Набор символов.

|m, n
|Целые числа, определяющие диапазон индекса измерения массива.
|===
