[[_fblangref_aggfuncs]]
= Агрегатные функции
:doctype: book
:sectnums:
:toc: left
:icons: font
:experimental:
:sourcedir: .

Агрегатные функции выполняют вычисление на наборе значений и возвращают одиночное значение.
Агрегатные функции, за исключением COUNT, не учитывают значения NULL.
Агрегатные функции часто используются совместно с предложением GROUP BY.

Агрегатные функции могут быть использованы в качестве выражений только в следующих случаях: 

* Список выбора инструкции SELECT (вложенный или внешний запрос);
* Предложение HAVING.


[[_fblangref_aggfuncs_syntax]]
== Синтаксис агрегатных функций

Обобщённый синтаксис агрегатных функций выглядит следующим образом: 
[source]
----

<agg_function>([ALL | DISTINCT] <expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----

[[_fblangref_aggfuncs_filter]]
=== Предложение FILTER
(((FILTER)))

Предложение FILTER расширяет агрегатные функции дополнительным предложением WHERE.
Если используется предложение FILTER, то результат агрегата строится только из строк, которые также удовлетворяют условию в дополнительном предложении WHERE.

Как правило, предложение фильтра может быть реализовано с использованием выражения CASE внутри агрегатной функции: условие фильтра должно быть помещено в предложение WHEN, значение, которое должно быть агрегировано в предложение THEN.
Поскольку агрегатные функции обычно пропускают значения NULL, неявное предложение ELSE NULL достаточно, чтобы игнорировать не подходящие под условия фильтрации строки.
Следующие два выражения эквивалентны: 
[source]
----

SUM(<expression>) FILTER(WHERE <condition>)
----
и 
[source]
----

SUM(CASE WHEN <condition> THEN <expression> END)
----

Для COUNT(*) этот пример выглядит иначе, потому что выражение "`*`" не может быть использовано в предложении THEN.
Вместо этого обычно используется любое константное значение не равное NULL. 
[source]
----

COUNT(*) FILTER(WHERE <condition>)
----
и 
[source]
----

SUM(CASE WHEN <condition> THEN 1 END)
----

.Примеры:


.Использование предложения FILTER
[example]

[source,sql]
----

SELECT 
  invoice_year,
  SUM(revenue) FILTER (WHERE invoice_month = 1) AS jan_revenue,
  SUM(revenue) FILTER (WHERE invoice_month= 2) AS feb_revenue,
  ...
  SUM(revenue) FILTER (WHERE invoice_month = 12) AS dec_revenue 
FROM (
  SELECT
    EXTRACT(YEAR FROM invoices.invoice_date) AS invoice_year,
    EXTRACT(MONTH FROM invoices.invoice_date) AS invoice_month,
    invoices.revenue AS revenue
  FROM invoices
)
GROUP BY invoice_year
----

[[_fblangref_aggfuncs_over]]
=== Предложение OVER

Любая агрегатная функция может быть использована в качестве оконной.
Подробнее см. <<_fblangref_windowfuncs_aggfuncs,Оконные (аналитические) функции>>. 

[[_fblangref_aggfuncs_general]]
== Основные агрегатные функции

[[_fblangref_aggfuncs_avg]]
=== AVG
(((AVG)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

AVG([ALL | DISTINCT] <expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции AVG
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION, DECFLOAT или масштабируемое целое (INTEGER, BIGINT или INT128) в зависимости от типа аргумента функции [replaceable]``expr``.

Функция AVG возвращает среднее значение для группы.
Значения NULL пропускаются.

Параметр ALL применяет агрегатную функцию ко всем значениям.
ALL является параметром по умолчанию.
Параметр DISTINCT указывает на то, что функция AVG будет выполнена только для одного экземпляра каждого уникального значения, независимо от того, сколько раз встречается это значение.

В случае если выборка записей пустая или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции AVG
[example]

[source,sql]
----

SELECT 
  dept_no,
  AVG(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_dml_select,SELECT>>. 

[[_fblangref_aggfuncs_count]]
=== COUNT
(((COUNT)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

COUNT({[ALL | DISTINCT] <expr> | *}) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции COUNT
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
BIGINT.

Функция COUNT возвращает количество значений в группе, которые не являются NULL.

При указании DISTINCT из выборки устраняются дубликаты, ALL является значением по умолчанию для всех выборки значений не NULL.

Если вместо выражения [replaceable]``expr`` указана звёздочка (*), то будут подсчитаны все строки.
Функция COUNT(*) не принимает параметры и не может использоваться с ключевым словом DISTINCT.
Для функции COUNT(*) не нужен параметр [replaceable]``expr``, так как по определению она не использует сведения о каких-либо конкретных столбцах.
Функция COUNT(*) возвращает количество строк в указанной таблице, не отбрасывая дублированные строки.
Она подсчитывает каждую строку отдельно.
При этом учитываются и строки, содержащие значения NULL.

Для пустой выборки данных или если при выборке окажутся одни значения, содержащие NULL, функция возвратит значение равное 0.

.Примеры:


.Использование функции COUNT
[example]

[source,sql]
----

SELECT 
  dept_no,
  COUNT(*) AS cnt,
  COUNT(DISTINCT name) AS cnt_name
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_dml_select,SELECT>>. 

[[_fblangref_aggfuncs_list]]
=== LIST
(((LIST)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

LIST([ALL | DISTINCT] <expr> [, separator]) [FILTER (WHERE <condition>)] 
  [OVER ([<partition_exp>])]
----



.Параметры функции LIST
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает строковый тип данных или BLOB.
Поля типа дата / время и числовые преобразуются к строке.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``separator``
|

Разделитель.
Выражение строкового типа.
По умолчанию разделителем является запятая.
|===

.Тип возвращаемого результата:
BLOB.

Функция LIST возвращает строку, содержащую значения элементов выборки, которые не равны NULL.
При пустой выборке функция возвратит NULL.
Тип возвращаемого значения текстовый BLOB за исключением тех случаев, когда выражением являются BLOB других подтипов.

ALL является опцией по умолчанию.
При ней обрабатываются все значения в выборке, не содержащие NULL.
При указании DISTINCT из выборки устраняются дубликаты.

Значения выражения [replaceable]``expr`` и разделитель [replaceable]``separator`` поддерживают тип данных BLOB любого размера и набора символов.
Поля типа дата / время и числовые перед проведением операции конкатенации преобразуются в строки.

[NOTE]
====
Порядок конкатенации строк определяется порядком чтения записей из источников, который в общем случае не определён.
Для придания списку необходимого порядка вы можете предварительно упорядочить источник данных, например с помощью производной таблицы.
====

.Примеры:


.Использование функции LIST
[example]

[source,sql]
----

-- Получение списка, порядок не определён                    
SELECT LIST (display_name, '; ') 
FROM GR_WORK;          

-- Получение списка в алфавитном порядке
SELECT LIST (display_name, '; ') 
FROM (SELECT display_name 
      FROM GR_WORK 
      ORDER BY display_name);
----

.См. также:
<<_fblangref_dml_select,SELECT>>. 

[[_fblangref_aggfuncs_max]]
=== MAX
(((MAX)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

MAX([ALL | DISTINCT] <expr>) [FILTER (WHERE <condition>)] 
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции MAX
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
тот же что и аргумент функции [replaceable]``expr``.

Функция MAX возвращает максимальный элемент выборки, которые не равны NULL.
При пустой выборке, или при выборке из одних NULL функция возвратит NULL.
Если аргумент функции строка, то функция вернёт значение, которое окажется последним в сортировке при применении COLLATE.

[NOTE]
====
Параметр DISTINCT не имеет смысла при использовании функцией MAX и доступен только для совместимости со стандартом. 
====

.Примеры:


.Использование функции MAX
[example]

[source,sql]
----

SELECT 
  dept_no,
  MAX(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_dml_select,SELECT>>, <<_fblangref_aggfuncs_min,MIN>>. 

[[_fblangref_aggfuncs_min]]
=== MIN
(((MIN)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

MIN([ALL | DISTINCT] <expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции MIN
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
тот же что и аргумент функции [replaceable]``expr``.

Функция MIN возвращает минимальный элемент выборки, которые не равны NULL.
При пустой выборке, или при выборке из одних NULL функция возвратит NULL.
Если аргумент функции строка, то функция вернёт значение, которое окажется первым в сортировке при применении COLLATE.

[NOTE]
====
Параметр DISTINCT не имеет смысла при использовании функцией MIN и доступен только для совместимости со стандартом. 
====

.Примеры:


.Использование функции MIN
[example]

[source,sql]
----

SELECT 
  dept_no,
  MIN(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_dml_select,SELECT>>, <<_fblangref_aggfuncs_max,MAX>>. 

[[_fblangref_functions_agg_sum]]
=== SUM
(((SUM)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

SUM([ALL | DISTINCT] <expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции SUM
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION, DECFLOAT или масштабируемое целое (INTEGER, BIGINT или INT128) в зависимости от типа аргумента функции [replaceable]``expr``.
Обычно, если это возможно, выбирается тип с большей вместимостью, чем тип выражения [replaceable]``expr``.

Функция SUM возвращает сумму элементов выборки, которые не равны NULL.
При пустой выборке, или при выборке из одних NULL функция возвратит NULL.

ALL является опцией по умолчанию.
При ней обрабатываются все значения из выборки, не содержащие NULL.
При указании DISTINCT из выборки устраняются дубликаты, после осуществляется подсчёт.

.Примеры:


.Использование функции SUM
[example]

[source,sql]
----

SELECT 
  dept_no,
  SUM(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_dml_select,SELECT>>. 

[[_fblangref_aggfuncs_stats]]
== Статистические функции

Статистические функции являются агрегатными функциями.
Эти функции не учитывают значения NULL.
К аргументу статистической функции не применимы параметры ALL и DISTINCT.

Статистические функции часто используются совместно с предложением GROUP BY.
Любую из статистических функций можно использовать в качестве оконной.
Подробнее см. <<_fblangref_windowfuncs_aggfuncs,OVER>>.

[[_fblangref_aggfuncs_corr]]
=== CORR
(((CORR)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

CORR(<expr1>, <expr2>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции CORR
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr1``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``expr2``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция CORR возвращает коэффициент корреляции для пары выражений, возвращающих числовые значения.

Функция 
[source]
----
CORR(<expr1>, <expr2>)
----
эквивалентна 
[source]
----
COVAR_POP(<expr1>, <expr2>) / (STDDEV_POP(<expr2>) * STDDEV_POP(<expr1>))
----

В статистическом смысле, корреляция -- это степень связи между переменными.
Связь между переменными означает, что значение одной переменной можно в определённой степени предсказать по значению другой.
Коэффициент корреляции представляет степень корреляции в виде числа в диапазоне от -1 (высокая обратная корреляция) до 1 (высокая корреляция). Значение 0 соответствует отсутствию корреляции.

В случае если выборка записей пустая или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции CORR
[example]

[source,sql]
----

SELECT
    CORR(alength, aheight) AS c_corr
FROM measure
----

.См. также:
<<_fblangref_aggfuncs_covar_pop,COVAR_POP>>, <<_fblangref_aggfuncs_stddev_pop,STDDEV_POP>>. 

[[_fblangref_aggfuncs_covar_pop]]
=== COVAR_POP
(((COVAR_POP)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

COVAR_POP(<expr1>, <expr2>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции COVAR_POP
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr1``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``expr2``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция COVAR_POP возвращает ковариацию совокупности (population covariance) пар выражений с числовыми значениями.

Функция 
[source]
----
COVAR_POP(<expr1>, <expr2>)
----
эквивалентна 
[source]
----

(SUM(<expr1> * <expr2>) - SUM(<expr1>) * SUM(<expr2>) / COUNT(*)) 
  / COUNT(*)
----

В случае если выборка записей пустая или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции COVAR_POP
[example]

[source,sql]
----

SELECT
    COVAR_POP(alength, aheight) AS c_corr
FROM measure
----

.См. также:
<<_fblangref_aggfuncs_covar_samp,COVAR_SAMP>>, <<_fblangref_functions_agg_sum,SUM>>, <<_fblangref_aggfuncs_count,COUNT>>. 

[[_fblangref_aggfuncs_covar_samp]]
=== COVAR_SAMP
(((COVAR_SAMP)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

COVAR_SAMP(<expr1>, <expr2>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции COVAR_SAMP
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr1``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``expr2``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция COVAR_SAMP возвращает выборочную ковариацию (sample covariance) пары выражений с числовыми значениями.

Функция 
[source]
----
COVAR_SAMP(<expr1>, <expr2>)
----
эквивалентна 
[source]
----

(SUM(<expr1> * <expr2>) - SUM(<expr1>) * SUM(<expr2>) / COUNT(*)) 
  / (COUNT(*) - 1)
----

В случае если выборка записей пустая, содержит только 1 запись или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции COVAR_SAMP
[example]

[source,sql]
----

SELECT
    COVAR_SAMP(alength, aheight) AS c_corr
FROM measure
----

.См. также:
<<_fblangref_aggfuncs_covar_pop,COVAR_POP>>, <<_fblangref_functions_agg_sum,SUM>>, <<_fblangref_aggfuncs_count,COUNT>>. 

[[_fblangref_aggfuncs_stddev_pop]]
=== STDDEV_POP
(((STDDEV_POP)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

STDDEV_POP(<expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции STDDEV_POP
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION или NUMERIC в зависимости от типа [replaceable]``expr``.

Функция STDDEV_POP возвращает среднеквадратичное отклонение для группы.
Значения NULL пропускаются.

Функция 
[source]
----
STDDEV_POP(<expr>)
----
эквивалентна 
[source]
----
SQRT(VAR_POP(<expr>))
----

В случае если выборка записей пустая или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции STDDEV_POP
[example]

[source,sql]
----

SELECT 
  dept_no,
  STDDEV_POP(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_aggfuncs_stddev_pop,STDDEV_SAMP>>, <<_fblangref_aggfuncs_var_pop,VAR_POP>>. 

[[_fblangref_aggfuncs_stddev_samp]]
=== STDDEV_SAMP
(((STDDEV_SAMP)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

STDDEV_SAMP(<expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции STDDEV_SAMP
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION или NUMERIC в зависимости от типа [replaceable]``expr``.

Функция STDDEV_SAMP возвращает стандартное отклонение для группы.
Значения NULL пропускаются.

Функция 
[source]
----
STDDEV_SAMP(<expr>)
----
эквивалентна 
[source]
----
SQRT(VAR_SAMP(<expr>))
----

В случае если выборка записей пустая, содержит только 1 запись или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции STDDEV_SAMP
[example]

[source,sql]
----

SELECT 
  dept_no,
  STDDEV_SAMP(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_aggfuncs_stddev_pop,STDDEV_POP>>, <<_fblangref_aggfuncs_var_samp,VAR_SAMP>>. 

[[_fblangref_aggfuncs_var_pop]]
=== VAR_POP
(((VAR_POP)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

VAR_POP(<expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции VAR_POP
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION или NUMERIC в зависимости от типа [replaceable]``expr``.

Функция VAR_POP возвращает выборочную дисперсию для группы.
Значения NULL пропускаются.

Функция 
[source]
----
VAR_POP(<expr>)
----
эквивалентна 
[source]
----

(SUM(<expr> * <expr>) - SUM(<expr>) * SUM(<expr>) / COUNT(<expr>)) 
  / COUNT(<expr>)
----

В случае если выборка записей пустая или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции VAR_POP
[example]

[source,sql]
----

SELECT 
  dept_no,
  VAR_POP(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_aggfuncs_var_samp,VAR_SAMP>>, <<_fblangref_functions_agg_sum,SUM>>, <<_fblangref_aggfuncs_count,COUNT>>. 

[[_fblangref_aggfuncs_var_samp]]
=== VAR_SAMP
(((VAR_SAMP)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

VAR_SAMP(<expr>) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции VAR_SAMP
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``expr``
|

Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION или NUMERIC в зависимости от типа [replaceable]``expr``.

Функция VAR_SAMP возвращает несмещённую выборочную дисперсию для группы.
Значения NULL пропускаются.

Функция 
[source]
----
VAR_SAMP(<expr>)
----
эквивалентна 
[source]
----

(SUM(<expr> * <expr>) - SUM(<expr>) * SUM(<expr>) / COUNT(<expr>)) 
  / (COUNT(<expr>) - 1)
----

В случае если выборка записей пустая, содержит только 1 запись или содержит только значения NULL, результат будет содержать NULL.

.Примеры:


.Использование функции VAR_SAMP
[example]

[source,sql]
----

SELECT 
  dept_no,
  VAR_SAMP(salary)
FROM employee
GROUP BY dept_no
----

.См. также:
<<_fblangref_aggfuncs_var_pop,VAR_POP>>, <<_fblangref_functions_agg_sum,SUM>>, <<_fblangref_aggfuncs_count,COUNT>>. 

[[_fblangref_aggfuncs_regr]]
== Функции линейной регрессии

Функции линейной регрессии полезны для продолжения линии тренда.
Линия тренда – это, как правило, закономерность, которой придерживается набор значений.
Линия тренда полезна для прогнозирования будущих значений.
Этот означает, что тренд будет продолжаться и в будущем.
Для продолжения линии тренда необходимо знать угол наклона и точку пересечения с осью Y.
Набор линейных функций включает функции для вычисления этих значений.

В синтаксисе функций, [replaceable]``у`` интерпретируется в качестве переменной, зависящей от [replaceable]``х``.

Любую функции линейной регрессии из статистических функций можно использовать в качестве оконной.
Подробнее см. <<_fblangref_windowfuncs_aggfuncs,Оконные (аналитические) функции>>.

[[_fblangref_aggfuncs_regr_avgx]]
=== REGR_AVGX
(((REGR_AVGX)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_AVGX(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_AVGX
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция REGR_AVGX вычисляет среднее независимой переменной линии регрессии. 

Функция 
[source]
----
REGR_AVGX(y, x)
----
эквивалентна 
[source]
----

SUM(<X>) / REGR_COUNT(y, x)                       

<X> ::= CASE WHEN x IS NOT NULL AND y IS NOT NULL THEN x END
----

.См. также:
<<_fblangref_aggfuncs_regr_count,REGR_COUNT>>, <<_fblangref_aggfuncs_regr_avgy,REGR_AVGY>>. 

[[_fblangref_aggfuncs_regr_avgy]]
=== REGR_AVGY
(((REGR_AVGY)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_AVGY(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_AVGY
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция REGR_AVGY вычисляет среднее зависимой переменной линии регрессии. 

Функция 
[source]
----
REGR_AVGY(y, x)
----
эквивалентна 
[source]
----

SUM(<Y>) / REGR_COUNT(y, x)                       

<Y> ::= CASE WHEN x IS NOT NULL AND y IS NOT NULL THEN y END
----

.См. также:
<<_fblangref_aggfuncs_regr_count,REGR_COUNT>>, <<_fblangref_aggfuncs_regr_avgx,REGR_AVGX>>. 

[[_fblangref_aggfuncs_regr_count]]
=== REGR_COUNT
(((REGR_COUNT)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_COUNT(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_COUNT
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
BIGINT.

Функция REGR_COUNT возвращает количество не пустых пар, используемых для создания линии регрессии. 

Функция 
[source]
----
REGR_COUNT(y, x)
----
эквивалентна 
[source]
----

SUM(CASE WHEN x IS NOT NULL AND y IS NOT NULL THEN 1 END)
----

[[_fblangref_aggfuncs_regr_intercept]]
=== REGR_INTERCEPT
(((REGR_INTERCEPT)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_INTERCEPT(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_INTERCEPT
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция REGR_INTERCEPT вычисляет точку пересечения линии регрессии с осью  Y. 

Функция 
[source]
----
REGR_INTERCEPT(y, x)
----
эквивалентна 
[source]
----

REGR_AVGY(y, x) - REGR_SLOPE(y, x) * REGR_AVGX(y, x)
----

.Примеры:


.Прогнозирование объёмов продаж
====

[source,sql]
----

WITH RECURSIVE years(byyear) AS (
  SELECT 1991 FROM rdb$database UNION ALL
  SELECT byyear+1 FROM years WHERE byyear < 2020
),
s AS (
  SELECT EXTRACT(YEAR FROM order_date) AS byyear,
         SUM(total_value) AS total_value
  FROM sales GROUP BY 1
),
regr AS (
  SELECT REGR_INTERCEPT(total_value, byyear) as intercept,
         REGR_SLOPE(total_value, byyear) as slope
FROM s)
SELECT years.byyear AS byyear,
       intercept + (slope * years.byyear) AS total_value
FROM years CROSS JOIN regr
----


[listing]
....

BYYEAR     TOTAL_VALUE
----------------------------
 1991        118377,35
 1992        414557,62
 1993        710737,89
 1994       1006918,16
 1995       1303098,43
 1996       1599278,69
 1997       1895458,96
 1998       2191639,23
 1999       2487819,50
 2000       2783999,77
...
....
====

.См. также:
<<_fblangref_aggfuncs_regr_avgy,REGR_AVGY>>, <<_fblangref_aggfuncs_regr_avgx,REGR_AVGX>>, <<_fblangref_aggfuncs_regr_slope,REGR_SLOPE>>. 

[[_fblangref_aggfuncs_regr_r2]]
=== REGR_R2
(((REGR_R2)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_R2(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_R2
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция REGR_R2 вычисляет коэффициент детерминации, или R-квадрат, линии регрессии.

Функция 
[source]
----
REGR_R2(y, x)
----
эквивалентна 
[source]
----

POWER(CORR(y, x), 2)
----

.См. также:
<<_fblangref_aggfuncs_corr,CORR>>. 

[[_fblangref_aggfuncs_regr_slope]]
=== REGR_SLOPE
(((REGR_SLOPE)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_SLOPE(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_SLOPE
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Функция REGR_SLOPE вычисляет угол наклона линии регрессии. 

Функция 
[source]
----
REGR_SLOPE(y, x)
----
эквивалентна 
[source]
----

COVAR_POP(y, x) / VAR_POP(<X>) 
                        
<X> ::= CASE WHEN x IS NOT NULL AND y IS NOT NULL THEN x END
----

.См. также:
<<_fblangref_aggfuncs_covar_pop,COVAR_POP>>. 

[[_fblangref_aggfuncs_regr_sxx]]
=== REGR_SXX
(((REGR_SXX)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_SXX(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_SXX
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Диагностическая статистика, используемая для анализа регрессии.
Вычисляется следующим образом: 
[source]
----

REGR_COUNT(y, x) * VAR_POP(<X>)                  

<X> ::= CASE WHEN x IS NOT NULL AND y IS NOT NULL THEN x END
----

.См. также:
<<_fblangref_aggfuncs_regr_count,REGR_COUNT>>, <<_fblangref_aggfuncs_var_pop,VAR_POP>>. 

[[_fblangref_aggfuncs_regr_sxy]]
=== REGR_SXY
(((REGR_SXY)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_SXY(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_SXY
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Диагностическая статистика, используемая для анализа регрессии.
Вычисляется следующим образом: 
[source]
----

REGR_COUNT(y, x) * COVAR_POP(y, x)
----

.См. также:
<<_fblangref_aggfuncs_regr_count,REGR_COUNT>>, <<_fblangref_aggfuncs_covar_pop,COVAR_POP>>. 

[[_fblangref_aggfuncs_regr_syy]]
=== REGR_SYY
(((REGR_SYY)))

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

REGR_SYY(y, x) [FILTER (WHERE <condition>)]
  [OVER ([<partition_exp>] [<order_exp>])]
----



.Параметры функции REGR_SYY
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``y``
|

Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|[replaceable]``x``
|

Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата:
DOUBLE PRECISION.

Диагностическая статистика, используемая для анализа регрессии.
Вычисляется следующим образом: 
[source]
----

REGR_COUNT(y, x) * VAR_POP(<Y>)                  

<Y> ::= CASE WHEN x IS NOT NULL AND y IS NOT NULL THEN y END
----

.См. также:
<<_fblangref_aggfuncs_regr_count,REGR_COUNT>>, <<_fblangref_aggfuncs_var_pop,VAR_POP>>. 

ifdef::backend-docbook[]
[index]
== Index
// Generated automatically by the DocBook toolchain.
endif::backend-docbook[]