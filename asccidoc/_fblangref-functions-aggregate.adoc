[[fblangref-aggfuncs]]
= Агрегатные функции

Агрегатные функции выполняют вычисление на наборе значений и возвращают одиночное значение.
Агрегатные функции, за исключением COUNT, не учитывают значения NULL.
Агрегатные функции часто используются совместно с предложением GROUP BY.

Агрегатные функции могут быть использованы в качестве выражений только в следующих случаях: 

* Список выбора инструкции SELECT (вложенный или внешний запрос);
* Предложение HAVING.


.Синтаксис агрегатных функций
[listing,subs=+quotes]
----
<aggregate_function> ::=
  _aggragate_function_ ([ALL | DISTINCT] <expr>)
  [FILTER (WHERE <condition>)]
----

Агрегатные функции также могут использоваться как оконные с предложением `OVER ()`.
Подробнее смотри в <<fblangref-windowfuncs,Оконные (Аналитические) функции>>.

[[fblangref-aggfuncs-filter]]
== Предложение `FILTER`

Предложение `FILTER` расширяет агрегатные функции дополнительным предложением `WHERE`.
Если используется предложение `FILTER`, то результат агрегата строится только из строк, которые также удовлетворяют условию в дополнительном предложении `WHERE`.

Как правило, предложение фильтра может быть реализовано с использованием выражения `CASE` внутри агрегатной функции: условие фильтра должно быть помещено в предложение `WHEN`, значение, которое должно быть агрегировано в предложение `THEN`.
Поскольку агрегатные функции обычно пропускают значения `NULL`, неявное предложение `ELSE NULL` достаточно, чтобы игнорировать не подходящие под условия фильтрации строки.
Следующие два выражения эквивалентны:

[listing]
----
SUM(<expression>) FILTER(WHERE <condition>)
----

и

[listing]
----
SUM(CASE WHEN <condition> THEN <expression> END)
----

Для `COUNT({asterisk})` этот пример выглядит иначе, потому что выражение "`{asterisk}`" не может быть использовано в предложении `THEN`.
Вместо этого обычно используется любое константное значение не равное `NULL`.

[listing]
----
COUNT(*) FILTER(WHERE <condition>)
----

и

[listing]
----
SUM(CASE WHEN <condition> THEN 1 END)
----

[float]
===== Примеры `FILTER`

.Использование предложения FILTER
[example]
====
[source,sql]
----
SELECT 
  invoice_year,
  SUM(revenue) FILTER (WHERE invoice_month = 1) AS jan_revenue,
  SUM(revenue) FILTER (WHERE invoice_month= 2) AS feb_revenue,
  ...
  SUM(revenue) FILTER (WHERE invoice_month = 12) AS dec_revenue 
FROM (
  SELECT
    EXTRACT(YEAR FROM invoices.invoice_date) AS invoice_year,
    EXTRACT(MONTH FROM invoices.invoice_date) AS invoice_month,
    invoices.revenue AS revenue
  FROM invoices
)
GROUP BY invoice_year
----
====


[[fblangref-aggfuncs-general]]
== Основные агрегатные функции

[[fblangref-aggfuncs-avg]]
=== `AVG()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
AVG([ALL | DISTINCT] <expr>)
----

[[fblangref-aggfuncs-tbl-avg]]
.Параметры функции AVG
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`, `DECFLOAT` или масштабируемое целое (`INTEGER`, `BIGINT` или `INT128`) в зависимости от типа аргумента функции _expr_.

Функция `AVG` возвращает среднее значение для группы.
Значения `NULL` пропускаются.

* Параметр `ALL` (по умолчанию) применяет агрегатную функцию ко всем значениям.
* Параметр `DISTINCT` указывает на то, что функция `AVG` будет выполнена только для одного экземпляра каждого уникального значения, независимо от того, сколько раз встречается это значение.
* В случае если выборка записей пустая или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-avg-exmpl]]
==== Примеры `AVG`

.Использование функции AVG
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  AVG(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-dml-select,`SELECT`>>.

[[fblangref-aggfuncs-count]]
=== `COUNT()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
COUNT([ALL | DISTINCT] <expr> | *)
----

[[fblangref-aggfuncs-tbl-count]]
.Параметры функции COUNT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`BIGINT`

Функция `COUNT` возвращает количество значений в группе, которые не являются `NULL`.

* По умолчанию используется `ALL`: функция просто считает все значения в наборе, которые не равны `NULL`.
* Если указан `DISTINCT` дубликаты исключаются из подсчитываемого набора.
* Если вместо выражения _expr_ указано `COUNT ({asterisk})`, будут подсчитаны все записи.
** не может использоваться с ключевым словом `DISTINCT`
** дубликаты записей не исключаются
** при этом учитываются записи содержащие `NULL`
* Для пустой выборки данных или если при выборке окажутся одни значения, содержащие `NULL`, функция возвратит значение равное `0`.

[[fblangref-aggfuncs-count-exmpl]]
==== Примеры `COUNT`

.Использование функции COUNT
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  COUNT(*) AS cnt,
  COUNT(DISTINCT name) AS cnt_name
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-dml-select,`SELECT`>>.

[[fblangref-aggfuncs-list]]
=== `LIST()`

.Доступно в
DSQL

.Синтаксис
[listing,subs=+quotes]
----
LIST([ALL | DISTINCT] <expr> [, _separator_])
----

[[fblangref-aggfuncs-tbl-list]]
.Параметры функции LIST
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает строковый тип данных или `BLOB`.
Поля типа дата / время и числовые преобразуются к строке.
Агрегатные функции в качестве выражения не допускаются.

|separator
|Разделитель.
Выражение строкового типа.
По умолчанию разделителем является запятая.
|===

.Тип возвращаемого результата
`BLOB`

Функция `LIST` возвращает строку, состоящую из значений аргумента, отличных от `NULL` в группе,
разделенных запятой или заданным пользователем разделителем.
Если нет значений, отличных от `NULL` (включая случай, когда группа пуста), возвращается `NULL`.

* `ALL` (по умолчанию) приводит к обработке всех значений, отличных от `NULL`.
Если указано ключевое слово `DISTINCT`, то дубликаты удаляются, за исключением случаев, когда _expr_ является `BLOB`.
* Необязательный аргумент _separator_ может быть любым строковым выражением.
Это позволяет указать, например, ascii_char (13) в качестве разделителя.
* Аргументы _expr_ и _separator_ поддерживают `BLOB` любого размера и набора символов.
* Дата / время и числовые аргументы неявно преобразуются в строки перед объединением.
* Результатом функции является текстовый `BLOB`, кроме случаев, когда _expr_ является `BLOB` другого подтипа.
* Порядок значений в списке не определен -- порядок, в котором строки объединяются, определяется порядком чтения из исходного набора данных.
Для таблиц такой порядок обычно не определяется.
Если порядок важен, исходные данные можно предварительно отсортировать используя производную таблицы или аналогичное средство.

[[fblangref-aggfuncs-list-exmpl]]
==== Примеры `LIST`

.Использование функции LIST
[example]
====
Получение списка, порядок не определён.

[source,sql]
----
SELECT LIST (display_name, '; ') 
FROM GR_WORK;
----
====

.Использование функции LIST с заданным порядком
[example]
====
Получение списка в алфавитном порядке.

[source,sql]
----
SELECT LIST (display_name, '; ') 
FROM (SELECT display_name 
      FROM GR_WORK 
      ORDER BY display_name);
----
====

.См. также:
<<fblangref-dml-select,`SELECT`>>.

[[fblangref-aggfuncs-max]]
=== `MAX()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
MAX([ALL | DISTINCT] <expr>)
----

[[fblangref-aggfuncs-tbl-max]]
.Параметры функции MAX
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
тот же что и аргумент функции _expr_.

Функция `MAX` возвращает максимальный элемент выборки, которые не равны NULL.

* Если группа пуста или содержит только `NULL`, результатом будет `NULL`.
* Если входным аргументом является строка, то функция вернет значение, которое будет последним в сортировке с использованием соответствующего `COLLATE`.
* Эта функция полностью поддерживает текстовые `BLOB` любого размера и набора символов.

[NOTE]
====
Параметр `DISTINCT` не имеет смысла при использовании функцией `MAX` и доступен только для совместимости со стандартом.
====

[[fblangref-aggfuncs-max-exmpl]]
==== Примеры `MAX`

.Использование функции `MAX`
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  MAX(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-dml-select,`SELECT`>>, <<fblangref-aggfuncs-min>>.

[[fblangref-aggfuncs-min]]
=== `MIN()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
MIN([ALL | DISTINCT] <expr>)
----

[[fblangref-aggfuncs-tbl-min]]
.Параметры функции MIN
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
тот же что и аргумент функции _expr_

Функция `MIN` возвращает минимальный элемент выборки, которые не равны `NULL`.

* Если группа пуста или содержит только `NULL`, результатом будет `NULL`.
* Если входным аргументом является строка, то функция вернет значение, которое будет первым в сортировке с использованием соответствующего `COLLATE`.
* Эта функция полностью поддерживает текстовые `BLOB` любого размера и набора символов.

[NOTE]
====
Параметр `DISTINCT` не имеет смысла при использовании функцией `MIN` и доступен только для совместимости со стандартом.
====

[[fblangref-aggfuncs-min-exmpl]]
==== Примеры `MIN`

.Использование функции `MIN`
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  MIN(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-dml-select,`SELECT`>>, <<fblangref-aggfuncs-max>>.

[[fblangref-aggfuncs-sum]]
=== `SUM()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
SUM([ALL | DISTINCT] <expr>)
----

[[fblangref-aggfuncs-tbl-sum]]
.Параметры функции `SUM`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`, `DECFLOAT` или масштабируемое целое (`INTEGER`, `BIGINT` или `INT128`) в зависимости от типа аргумента функции _expr_.
Обычно, если это возможно, выбирается тип с большей вместимостью, чем тип выражения expr.

Функция `SUM` возвращает сумму элементов выборки, которые не равны `NULL`.

* `ALL` является опцией по умолчанию -- обрабатываются все значения из выборки, не содержащие `NULL`.
При указании `DISTINCT` из выборки устраняются дубликаты, после чего осуществляется суммирование.
* При пустой выборке, или при выборке из одних `NULL` функция возвратит `NULL`.

[[fblangref-aggfuncs-sum-exmpl]]
==== Примеры `SUM`

.Использование функции SUM
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  SUM(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-dml-select,`SELECT`>>.

[[fblangref-aggfuncs-stats]]
== Статистические функции

Статистические функции являются агрегатными функциями.
Эти функции не учитывают значения `NULL`.
К аргументу статистической функции не применимы параметры `ALL` и `DISTINCT`.

Статистические функции часто используются совместно с предложением `GROUP BY`.

[[fblangref-aggfuncs-corr]]
=== `CORR()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
CORR(<expr1>, <expr2>)
----

[[fblangref-aggfuncs-tbl-corr]]
.Параметры функции `CORR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr1, expr2
|Выражение возвращает числовой тип данных.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `CORR` возвращает коэффициент корреляции для пары выражений, возвращающих числовые значения.

Функция `CORR(<expr1>, <expr2>)` эквивалентна

[listing]
----
COVAR_POP(<expr1>, <expr2>) / (STDDEV_POP(<expr2>) * STDDEV_POP(<expr1>))
----

В статистическом смысле, корреляция -- это степень связи между переменными.
Связь между переменными означает, что значение одной переменной можно в определённой степени предсказать по значению другой.
Коэффициент корреляции представляет степень корреляции в виде числа в диапазоне от -1 (высокая обратная корреляция) до 1 (высокая корреляция). Значение 0 соответствует отсутствию корреляции.

В случае если выборка записей пустая или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-corr-exmpl]]
==== Примеры `CORR`

.Использование функции CORR
[example]
====
[source,sql]
----
SELECT
    CORR(alength, aheight) AS c_corr
FROM measure
----
====

.См. также:
<<fblangref-aggfuncs-covar-pop>>, <<fblangref-aggfuncs-stddev-pop>>.

[[fblangref-aggfuncs-covar-pop]]
=== `COVAR_POP()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
COVAR_POP(<expr1>, <expr2>)
----

[[fblangref-aggfuncs-tbl-covar-pop]]
.Параметры функции `COVAR_POP`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr1, expr2
|Выражение возвращает числовой тип данных.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `COVAR_POP` возвращает ковариацию совокупности (population covariance) пар выражений с числовыми значениями.

Функция `COVAR_POP(<expr1>, <expr2>)` эквивалентна

[listing]
----
(SUM(<expr1> * <expr2>) - SUM(<expr1>) * SUM(<expr2>) / COUNT(*)) 
  / COUNT(*)
----

В случае если выборка записей пустая или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-covar-pop-exmpl]]
==== Примеры `COVAR_POP`

.Использование функции `COVAR_POP`
[example]
====
[source,sql]
----
SELECT
    COVAR_POP(alength, aheight) AS c_corr
FROM measure
----
====

.См. также:
<<fblangref-aggfuncs-covar-samp>>, <<fblangref-aggfuncs-sum>>, <<fblangref-aggfuncs-count>>. 

[[fblangref-aggfuncs-covar-samp]]
=== `COVAR_SAMP()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
COVAR_SAMP(<expr1>, <expr2>)
----

[[fblangref-aggfuncs-tbl-covar-samp]]
.Параметры функции `COVAR_SAMP`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr1, expr2
|Выражение возвращает числовой тип данных.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `COVAR_SAMP` возвращает выборочную ковариацию (sample covariance) пары выражений с числовыми значениями.

Функция `COVAR_SAMP(<expr1>, <expr2>)` эквивалентна

[listing]
----
(SUM(<expr1> * <expr2>) - SUM(<expr1>) * SUM(<expr2>) / COUNT(*)) 
  / (COUNT(*) - 1)
----

В случае если выборка записей пустая, содержит только 1 запись или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-covar-samp-exmpl]]
==== Примеры `COVAR_SAMP`

.Использование функции `COVAR_SAMP`
[example]
====
[source,sql]
----
SELECT
    COVAR_SAMP(alength, aheight) AS c_corr
FROM measure
----
====

.См. также:
<<fblangref-aggfuncs-covar-pop>>, <<fblangref-aggfuncs-sum>>, <<fblangref-aggfuncs-count>>.

[[fblangref-aggfuncs-stddev-pop]]
=== `STDDEV_POP()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
STDDEV_POP(<expr>)
----

[[fblangref-aggfuncs-tbl-stddev-pop]]
.Параметры функции STDDEV_POP
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение возвращает числовой тип данных.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION` или `NUMERIC` в зависимости от типа _expr_.

Функция `STDDEV_POP` возвращает среднеквадратичное отклонение для группы.
Значения `NULL` пропускаются.

Функция `STDDEV_POP(<expr>)` эквивалентна

[listing]
----
SQRT(VAR_POP(<expr>))
----

В случае если выборка записей пустая или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-stddev-pop-exmpl]]
==== Примеры `STDDEV_POP`

.Использование функции `STDDEV_POP`
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  STDDEV_POP(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-aggfuncs-stddev-pop>>, <<fblangref-aggfuncs-var-pop>>.

[[fblangref-aggfuncs-stddev-samp]]
=== `STDDEV_SAMP()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
STDDEV_SAMP(<expr>)
----

[[fblangref-aggfuncs-tbl-stddev-samp]]
.Параметры функции STDDEV_SAMP
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение возвращает числовой тип данных.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION` или `NUMERIC` в зависимости от типа _expr_

Функция `STDDEV_SAMP` возвращает стандартное отклонение для группы.
Значения `NULL` пропускаются.

Функция `STDDEV_SAMP(<expr>)` эквивалентна

[listing]
----
SQRT(VAR_SAMP(<expr>))
----

В случае если выборка записей пустая, содержит только 1 запись или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-stddev-samp-exmpl]]
==== Примеры `STDDEV_SAMP` 

.Использование функции `STDDEV_SAMP`
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  STDDEV_SAMP(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-aggfuncs-stddev-pop>>, <<fblangref-aggfuncs-var-samp>>.

[[fblangref-aggfuncs-var-pop]]
=== `VAR_POP()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
VAR_POP(<expr>)
----

[[fblangref-aggfuncs-tbl-var-pop]]
.Параметры функции `VAR_POP`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение возвращает числовой тип данных.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION` или `NUMERIC` в зависимости от типа _expr_

Функция `VAR_POP` возвращает выборочную дисперсию для группы.
Значения `NULL` пропускаются.

Функция `VAR_POP(<expr>)` эквивалентна

[listing]
----
(SUM(<expr> * <expr>) - SUM(<expr>) * SUM(<expr>) / COUNT(<expr>)) 
  / COUNT(<expr>)
----

В случае если выборка записей пустая или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-var-pop-exmpl]]
==== Примеры `VAR_POP`

.Использование функции `VAR_POP`
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  VAR_POP(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-aggfuncs-var-samp>>, <<fblangref-aggfuncs-sum>>, <<fblangref-aggfuncs-count>>.

[[fblangref-aggfuncs-var-samp]]
=== `VAR_SAMP()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
VAR_SAMP(<expr>)
----

[[fblangref-aggfuncs-tbl-var-samp]]
.Параметры функции `VAR_SAMP`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr
|Выражение возвращает числовой тип данных.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION` или `NUMERIC` в зависимости от типа _expr_

Функция `VAR_SAMP` возвращает несмещённую выборочную дисперсию для группы.
Значения `NULL` пропускаются.

Функция `VAR_SAMP(<expr>)` эквивалентна

[listing]
----
(SUM(<expr> * <expr>) - SUM(<expr>) * SUM(<expr>) / COUNT(<expr>)) 
  / (COUNT(<expr>) - 1)
----

В случае если выборка записей пустая, содержит только 1 запись или содержит только значения `NULL`, результат будет содержать `NULL`.

[[fblangref-aggfuncs-var-samp-exmpl]]
==== Примеры `VAR_SAMP`

.Использование функции `VAR_SAMP`
[example]
====
[source,sql]
----
SELECT 
  dept_no,
  VAR_SAMP(salary)
FROM employee
GROUP BY dept_no
----
====

.См. также:
<<fblangref-aggfuncs-var-pop>>, <<fblangref-aggfuncs-sum>>, <<fblangref-aggfuncs-count>>.

[[fblangref-aggfuncs-regr]]
== Функции линейной регрессии

Функции линейной регрессии полезны для продолжения линии тренда.
Линия тренда -- это, как правило, закономерность, которой придерживается набор значений.
Линия тренда полезна для прогнозирования будущих значений.
Этот означает, что тренд будет продолжаться и в будущем.
Для продолжения линии тренда необходимо знать угол наклона и точку пересечения с осью Y.
Набор линейных функций включает функции для вычисления этих значений.

В синтаксисе функций, _у_ интерпретируется в качестве переменной, зависящей от _х_.


[[fblangref-aggfuncs-regr-avgx]]
=== `REGR_AVGX()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_AVGX ( <y>, <x> )
----

[[fblangref-aggfuncs-tbl-regr-avgx]]
.Параметры функции REGR_AVGX
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `REGR_AVGX` вычисляет среднее независимой переменной линии регрессии.

Функция `REGR_AVGX(<y>, <x>)` эквивалентна

[listing]
----
SUM(<exprX>) / REGR_COUNT(<y>, <x>)

<exprX> ::=
  CASE WHEN <x> IS NOT NULL AND <y> IS NOT NULL THEN <x> END
----

.См. также:
<<fblangref-aggfuncs-regr-count>>, <<fblangref-aggfuncs-regr-avgy>>.

[[fblangref-aggfuncs-regr-avgy]]
=== `REGR_AVGY()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_AVGY(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-avgy]]
.Параметры функции `REGR_AVGY`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `REGR_AVGY` вычисляет среднее зависимой переменной линии регрессии.

Функция `REGR_AVGY(<y>, <x>)` эквивалентна

[listing]
----
SUM(<exprY>) / REGR_COUNT(<y>, <x>)

<exprY> ::=
  CASE WHEN <x> IS NOT NULL AND <y> IS NOT NULL THEN <y> END
----

.См. также:
<<fblangref-aggfuncs-regr-count>>, <<fblangref-aggfuncs-regr-avgx>>.

[[fblangref-aggfuncs-regr-count]]
=== `REGR_COUNT()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_COUNT(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-count]]
.Параметры функции `REGR_COUNT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`BIGINT`

Функция `REGR_COUNT` возвращает количество не пустых пар, используемых для создания линии регрессии.

Функция `REGR_COUNT(<y>, <x>)` эквивалентна

[listing]
----
SUM(CASE WHEN <x> IS NOT NULL AND <y> IS NOT NULL THEN 1 END)
----

См. также:
<<fblangref-aggfuncs-sum>>

[[fblangref-aggfuncs-regr-intercept]]
=== `REGR_INTERCEPT()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_INTERCEPT(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-intercept]]
.Параметры функции `REGR_INTERCEPT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `REGR_INTERCEPT` вычисляет точку пересечения линии регрессии с осью Y.

Функция `REGR_INTERCEPT(<y>, <x>)` эквивалентна 

[listing]
----
REGR_AVGY(<y>, <x>) - REGR_SLOPE(<y>, <x>) * REGR_AVGX(<y>, <x>)
----

[[fblangref-aggfuncs-regr-intercept-exmpl]]
==== Примеры `REGR_INTERCEPT`

.Прогнозирование объёмов продаж
[example]
====
[source,sql]
----
WITH RECURSIVE years(byyear) AS (
  SELECT 1991 FROM rdb$database UNION ALL
  SELECT byyear+1 FROM years WHERE byyear < 2020
),
s AS (
  SELECT EXTRACT(YEAR FROM order_date) AS byyear,
         SUM(total_value) AS total_value
  FROM sales GROUP BY 1
),
regr AS (
  SELECT REGR_INTERCEPT(total_value, byyear) as intercept,
         REGR_SLOPE(total_value, byyear) as slope
FROM s)
SELECT years.byyear AS byyear,
       intercept + (slope * years.byyear) AS total_value
FROM years CROSS JOIN regr
----


[listing]
----
BYYEAR     TOTAL_VALUE
----------------------------
 1991        118377,35
 1992        414557,62
 1993        710737,89
 1994       1006918,16
 1995       1303098,43
 1996       1599278,69
 1997       1895458,96
 1998       2191639,23
 1999       2487819,50
 2000       2783999,77
...
----
====

.См. также:
<<fblangref-aggfuncs-regr-avgy>>, <<fblangref-aggfuncs-regr-avgx>>, <<fblangref-aggfuncs-regr-slope>>. 

[[fblangref-aggfuncs-regr-r2]]
=== `REGR_R2()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_R2(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-r2]]
.Параметры функции `REGR_R2`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `REGR_R2` вычисляет коэффициент детерминации, или R-квадрат, линии регрессии.

Функция `REGR_R2(<y>, <x>)` эквивалентна

[listing]
----
POWER(CORR(<y>, <x>), 2)
----

.См. также:
<<fblangref-aggfuncs-corr>>, <<fblangref-scalarfuncs-power>>

[[fblangref-aggfuncs-regr-slope]]
=== `REGR_SLOPE()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_SLOPE(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-slope]]
.Параметры функции `REGR_SLOPE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Функция `REGR_SLOPE` вычисляет угол наклона линии регрессии.

Функция `REGR_SLOPE(<y>, <x>)` эквивалентна

[listing]
----
COVAR_POP(<y>, <x>) / VAR_POP(<exprX>)
                        
<exprX> :==
  CASE WHEN <x> IS NOT NULL AND <y> IS NOT NULL THEN <x> END
----

.См. также:
<<fblangref-aggfuncs-covar-pop>>, <<fblangref-aggfuncs-var-pop>>.

[[fblangref-aggfuncs-regr-sxx]]
=== `REGR_SXX()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_SXX(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-sxx]]
.Параметры функции `REGR_SXX`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Диагностическая статистика, используемая для анализа регрессии.

Функция `REGR_SXX(<y>, <x>)` вычисляется следующим образом:

[listing]
----
REGR_COUNT(<y>, <x>) * VAR_POP(<exprX>)

<exprX> :==
  CASE WHEN <x> IS NOT NULL AND <y> IS NOT NULL THEN <x> END
----

.См. также:
<<fblangref-aggfuncs-regr-count>>, <<fblangref-aggfuncs-var-pop>>.

[[fblangref-aggfuncs-regr-sxy]]
=== `REGR_SXY()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_SXY(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-sxy]]
.Параметры функции `REGR_SXY`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Диагностическая статистика, используемая для анализа регрессии.

Функция `REGR_SXY(<y>, <x>)` вычисляется следующим образом:

[listing]
----
REGR_COUNT(<y>, <x>) * COVAR_POP(<y>, <x>)
----

.См. также:
<<fblangref-aggfuncs-regr-count>>, <<fblangref-aggfuncs-covar-pop>>.

[[fblangref-aggfuncs-regr_syy]]
=== `REGR_SYY()`

.Доступно в
DSQL

.Синтаксис
[listing]
----
REGR_SYY(<y>, <x>)
----

[[fblangref-aggfuncs-tbl-regr-syy]]
.Параметры функции `REGR_SYY`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Зависимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.

|x
|Независимая переменная линии регрессии.
Может содержать столбец таблицы, константу, переменную, выражение, неагрегатную функцию или UDF, которая возвращает числовой тип данных.
Агрегатные функции в качестве выражения не допускаются.
|===

.Тип возвращаемого результата
`DOUBLE PRECISION`

Диагностическая статистика, используемая для анализа регрессии.

Функция `REGR_SYY(<y>, <x>)` вычисляется следующим образом:

[listing]
----
REGR_COUNT(<y>, <x>) * VAR_POP(<exprY>)

<exprY> :==
  CASE WHEN <x> IS NOT NULL AND <y> IS NOT NULL THEN <y> END
----

.См. также:
<<fblangref-aggfuncs-regr-count>>, <<fblangref-aggfuncs-var-pop>>.

