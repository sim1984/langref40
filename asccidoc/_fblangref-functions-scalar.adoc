[[fblangref-functions]]
= Встроенные скалярные функции

[[fblangref-functions-workcontext]]
== Функции для работы с контекстными переменными

[[fblangref-scalarfuncs-get-context]]
=== `RDB$GET_CONTEXT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$GET_CONTEXT('<namespace>', '_varname_')
                            
<namespace> ::= SYSTEM | DDL_TRIGGER | USER_SESSION | USER_TRANSACTION
----

[[fblangref-funcs-tbl-rdbgetcontext]]
.Параметры функции `RDB$GET_CONTEXT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|namespace
|Пространство имён.

|varname
|Имя переменной.
Зависит от регистра.
Максимальная длина 80 байт.
|===

.Тип возвращаемого результата:
VARCHAR(255) CHARACTER SET NONE

Функция `RDB$GET_CONTEXT` возвращает значение контекстной переменной из одного из пространства имён.

В настоящий момент существуют следующие пространства имён: 

* `SYSTEM` -- предоставляет доступ к системным контекстным переменным. Эти переменные доступны только для чтения;
* `USER_SESSION` -- предоставляет доступ к пользовательским контекстным переменным, заданным через функцию `RDB$SET_CONTEXT`. Переменные существуют в течение подключения;
* `USER_TRANSACTION` -- предоставляет доступ к пользовательским контекстным переменным, заданным через функцию `RDB$SET_CONTEXT`. Переменные существуют в течение транзакции;
* `DDL_TRIGGER` -- предоставляет доступ к системным контекстным переменным, доступным только во время выполнения DDL триггера. Эти переменные доступны только для чтения.

Пространства имён `USER_SESSION` и `USER_TRANSACTION` -- изначально пусты и пользователь сам создаёт переменные и наполняет их при помощи функции `RDB$SET_CONTEXT`.

[NOTE]
====
Для предотвращения DoS атак, существует ограничение на 1000 переменных в одном "`пространстве имён`".
====

Если запрашиваемая функцией переменная существует в указанном пространстве имён, то будет возвращено её значение в виде строки `VARCHAR(255) CHARACTER SET NONE`.
При обращении к несуществующей переменной в пространстве `SYSTEM` возникает ошибка, если такое происходит с пространствами имён `USER_SESSION` или `USER_TRANSACTION` -- функция возвращает NULL.

[[fblangref-funcs-tbl-rdbgetcontext-system]]
==== Пространство имён `SYSTEM`

[[fblangref-funcs-tbl-systemnamespace]]
.Переменные пространства имён SYSTEM

`CLIENT_ADDRESS`::
Для TCPv4 – IP адрес, для XNET – локальный ID процесса. Для
остальных случаев `NULL`.

`CLIENT_HOST`::
Имя хоста сетевого протокола удаленного клиента. Значение
возвращается для всех поддерживаемых протоколов.

`CLIENT_PID`::
PID процесса на клиентском компьютере.

`CLIENT_PROCESS`::
Полный путь к клиентскому приложению, подключившемуся к базе
данных. Позволяет не использовать системную таблицу
`MON$ATTACHMENTS` (поле `MON$REMOTE_PROCESS`).

`CURRENT_ROLE`::
Глобальная переменная `CURRENT_ROLE`.

`CURRENT_USER`::
Глобальная переменная `CURRENT_USER`.

`DB_NAME`::
Каноническое имя текущей базы данных. Это либо имя псевдонима
(если соединение с помощью имён файлов запрещено `DatabaseAccess = NONE`) или,
в противном случае, полностью расширенное имя файла базы данных.

`DB_FILE_ID`::
Уникальный идентификатор текущей базы данных на уровне
файловой системы.

`DB_GUID`::
GUID базы данных.

`EFFECTIVE_USER`::
Эффективный пользователь в текущий момент. Указывает
пользователя с привилегиями которого в текущий момент времени
выполняется процедура, функция или триггер.

`ENGINE_VERSION`::
Версия сервера Firebird.

`EXT_CONN_POOL_SIZE`::
Размер пула внешних соединений.

`EXT_CONN_POOL_LIFETIME`::
Время жизни неактивных соединений в пуле внешних
соединений.

`EXT_CONN_POOL_IDLE_COUNT`::
Текущее количество неактивных соединений в пуле внешних
соединений.

`EXT_CONN_POOL_ACTIVE_COUNT`::
Текущее количество активных соединений в пуле внешних
соединений.

`GLOBAL_CN`::
Последнее значение текущего глобального счётчика Commit Number

`ISOLATION_LEVEL`::
Уровень изоляции текущей транзакции -- `CURRENT_TRANSACTION`.
Значения: `'READ_COMMITED'`, `'SNAPSHOT'` или `'CONSISTENCY'`.

`LOCK_TIMEOUT`::
Время ожидания транзакцией высвобождения ресурса при
блокировке, в секундах.

`NETWORK_PROTOCOL`::
Протокол, используемый для соединения с базой данных.
Возможные значения: `'TCPv4'`, `'TCPv6'`, `'WNET'`, `'XNET'`, `NULL`.

`READ_ONLY`::
Отображает, является ли транзакция, транзакцией только для
чтения. `'FALSE'` для Read-Write транзакций `'TRUE'` для Read Only.

`REPLICA_MODE`::
Режим репликации: пустая строка или `NULL` -- первичная база данных,
`'READ-ONLY'` -- реплика в режиме только чтение, `'READ-WRITE'` -- реплика в режиме чтение и запись.

`REPLICATION_SEQUENCE`::
Текущее значение последовательности репликации (номер
последнего сегмента, записанного в журнал репликации).

`SESSION_ID`::
Глобальная переменная `CURRENT_CONNECTION`.

SESSION_IDLE_TIMEOUT`::
Содержит текущее значение тайм-аут простоя соединения в
секундах, который был установлен на уровне соединения, или ноль,
если тайм-аут не был установлен.

`SESSION_TIMEZONE`::
Текущий часовой пояс, установленный в текущей сессии.

`SNAPSHOT_NUMBER`::
Номер моментального снимка базы данных: уровня транзакции
(для транзакции `SNAPSHOT` или `CONSISTENCY`) или уровня запроса
(для транзакции `READ COMMITTED READ CONSISTENCY`). NULL, если
моментальный снимок не существует.

`STATEMENT_TIMEOUT`::
Содержит текущее значение тайм-аута выполнения оператора в
миллисекундах, который был установлен на уровне подключения, или
ноль, если тайм-аут не был установлен.

`TRANSACTION_ID`::
Глобальная переменная `CURRENT_TRANSACTION`.

`WIRE_COMPRESSED`::
Используется ли сжатие сетевого трафика. Если используется
сжатие сетевого трафика возвращает `'TRUE'`, если не используется
-- `'FALSE'`. Для встроенных соединений -- возвращает `NULL`.

`WIRE_ENCRYPTED`::
Используется ли шифрование сетевого трафика. Если
используется шифрование сетевого трафика возвращает `'TRUE'`, если
не используется -- `'FALSE'`. Для встроенных соединений --
возвращает `NULL`.

`WIRE_CRYPT_PLUGIN`::
Если используется шифрование сетевого трафика, то возвращает
имя текущего плагина шифрования, в противном случае `NULL`.

[[fblangref-funcs-tbl-rdbgetcontext-ddl-trigger]]
==== Пространство имён `DDL_TRIGGER`

Использование пространства имён `DDL_TRIGGER` допустимо, только во время работы DDL триггера.
Его использование также допустимо в хранимых процедурах и функциях, вызванных триггерами DDL.

Контекст `DDL_TRIGGER` работает как стек.
Перед возбуждением DDL триггера, значения, относящиеся к выполняемой команде, помещаются в этот стек.
После завершения работы триггера значения выталкиваются.
Таким образом в случае каскадных DDL операторов, когда каждая пользовательская DDL команда возбуждает DDL триггер, и этот триггер запускает другие DDL команды, с помощью `EXECUTE STATEMENT`, значения переменных в пространстве имён `DDL_TRIGGER` будут соответствовать команде, которая вызвала последний DDL триггер в стеке вызовов.


.Переменные пространства имён `DDL_TRIGGER`

`EVENT_TYPE`:: тип события (`CREATE`, `ALTER`, `DROP`).

`OBJECT_TYPE`:: тип объекта (`TABLE`, `VIEW` и др.).

`DDL_EVENT`:: (`<ddl event item>`), где `<ddl_event_item>` это `EVENT_TYPE || ' ' || OBJECT_TYPE`

OBJECT_NAME:: имя объекта метаданных.

OLD_OBJECT_NAME:: имя объекта метаданных до переименования.

NEW_OBJECT_NAME:: имя объекта метаданных после переименования.

SQL_TEXT:: текст SQL запроса.


[NOTE]
====
Ещё раз обратите внимание на то, что пространства имён и имена переменных регистрочувствительны, должны быть не пустыми строками, и заключены в кавычки!
====

[[fblangref-funcs-tbl-rdbgetcontext-exmpl]]
==== Примеры

.Использование функции RDB$GET_CONTEXT
[example]
====
[source,sql]
----
NEW.USER_ADR = RDB$GET_CONTEXT ('SYSTEM', 'CLIENT_ADDRESS');
----
====

.См. также:
<<fblangref-scalarfuncs-set-context,RDB$SET_CONTEXT>>. 

[[fblangref-scalarfuncs-set-context]]
=== `RDB$SET_CONTEXT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$SET_CONTEXT('<namespace>', 'varname', {<value> | NULL})   
                            
<namespace> ::= USER_SESSION | USER_TRANSACTION
----

[[fblangref-funcs-tbl-rdbsetcontext]]
.Параметры функции `RDB$SET_CONTEXT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|namespace
|Пространство имён.

|varname
|Имя переменной.
Зависит от регистра.
Максимальная длина 80 байт.

|value
|Данные любого типа при условии, что их можно привести к типу VARCHAR(255) CHARACTER SET NONE.
|===

.Тип возвращаемого результата
`INTEGER`

Функция `RDB$SET_CONTEXT` создаёт, устанавливает значение или обнуляет переменную в одном из используемых пользователем пространстве имён: `USER_SESSION` или `USER_TRANSACTION`.

Функция возвращает 1, если переменная уже существовала до вызова и 0, если не существовала.
Для удаления переменной надо установить её значение в `NULL`.
Если данное пространство имён не существует, то функция вернёт ошибку.
Пространство имён и имя переменной зависят от регистра, должны быть не пустыми строками, и заключены в кавычки.

[NOTE]
====
* Пространство имён `SYSTEM` доступно только для чтения;
* Максимальное число переменных в рамках одного соединения (для пространства `USER_SESSION`) или одной транзакции (для пространства `USER_TRANSACTION`) равно 1000;
* Все переменные в пространстве имён `USER_TRANSACTION` сохраняются при `ROLLBACK RETAIN` или `ROLLBACK TO SAVEPOINT`, независимо от того, в какой точке во время выполнения транзакции они были установлены.
====

.Использование функции `RDB$SET_CONTEXT`
[example]
====
[source,sql]
----
SELECT RDB$SET_CONTEXT ('USER_SESSION', 'DEBUGL', 3)	
FROM RDB$DATABASE;

-- в PSQL доступен такой синтаксис
RDB$SET_CONTEXT('USER_SESSION', 'RECORDSFOUND', RECCOUNTER);

SELECT RDB$SET_CONTEXT ('USER_TRANSACTION', 'SAVEPOINTS', 'YES')
FROM RDB$DATABASE;
----
====

.Использование функций для работы с контекстными переменными
[example]
====
[source,sql]
----
SET TERM ^;
CREATE PROCEDURE set_context(User_ID VARCHAR(40), 
                             Trn_ID INT) AS
BEGIN
  RDB$SET_CONTEXT('USER_TRANSACTION', 'Trn_ID', Trn_ID);
  RDB$SET_CONTEXT('USER_TRANSACTION', 'User_ID', User_ID);
END^
SET TERM ;^

CREATE TABLE journal (
   jrn_id INTEGER NOT NULL PRIMARY KEY,
   jrn_lastuser VARCHAR(40),
   jrn_lastaddr VARCHAR(255),
   jrn_lasttran INTEGER
);

SET TERM ^;
CREATE TRIGGER UI_JOURNAL 
FOR JOURNAL BEFORE INSERT OR UPDATE
AS 
BEGIN
  new.jrn_lastuser = RDB$GET_CONTEXT('USER_TRANSACTION',
                                     'User_ID');
  new.jrn_lastaddr = RDB$GET_CONTEXT('SYSTEM',
                                     'CLIENT_ADDRESS');
  new.jrn_lasttran = RDB$GET_CONTEXT('USER_TRANSACTION',
                                         'Trn_ID');
END^
SET TERM ;^

EXECUTE PROCEDURE set_context('skidder', 1);

INSERT INTO journal(jrn_id) VALUES(0);

COMMIT;
----
====

.См. также:
<<fblangref-scalarfuncs-get-context,`RDB$GET_CONTEXT`>>.

[[fblangref-functions-security]]
== Функции подсистемы безопасности

[[fblangref-scalarfuncs-roleinuse]]
=== `RDB$ROLE_IN_USE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$ROLE_IN_USE (_role_name_)
----

.Параметры функции `RDB$ROLE_IN_USE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|role_name
|Имя роли использование которой проверяется
|===

.Тип возвращаемого результата
`BOOLEAN`

Функция `RDB$ROLE_IN_USE` возвращает используется ли роль текущим пользователем.

[NOTE]
====
Данная функция позволяет проверить использование любой роли: указанной явно (при входе в систему или изменённой с помощью оператора SET ROLE) и назначенной неявно (роли назначенные пользователю с использованием предложения DEFAULT).
====


.Использование функции `RDB$ROLE_IN_USE`
[example]
====
[source,sql]
----
-- Проверяем используется ли явно назначенная или 
-- неявно полученная роль MANAGER                                
IF (RDB$ROLE_IN_USE('MANAGER')) THEN
BEGIN
  ...
END
----
====

.Список ролей используемых текущим подключением
[example]
====
[source,sql]
----
SELECT * FROM RDB$ROLES WHERE RDB$ROLE_IN_USE(RDB$ROLE_NAME)
----
====

.См. также:
<<fblangref-security-grant-role,GRANT ROLE>>, <<fblangref-management-setrole,SET ROLE>>, <<fblangref-contextvars-current-role,CURRENT_ROLE>>.

[[fblangref-scalarfuncs-system-privelege]]
=== `RDB$SYSTEM_PRIVILEGE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$SYSTEM_PRIVILEGE (<privilege>)
----

.Параметры функции `RDB$SYSTEM_PRIVILEGE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|privilege
|Проверяемая системная привилегия
|===

.Тип возвращаемого результата
`BOOLEAN`

Функция `RDB$SYSTEM_PRIVILEGE` используется системная привилегия текущим соединением.
Список системных привилегий см.
в <<fblangref-security-roles-create,CREATE ROLE>>.

.Использование функции `RDB$SYSTEM_PRIVILEGE`
[example]
====
[source,sql]
----
SELECT RDB$SYSTEM_PRIVILEGE(USER_MANAGEMENT) FROM RDB$DATABASE;
----
====

.См. также:
<<fblangref-security-roles-create,CREATE ROLE>>. 

[[fblangref-functions-error]]
== Функции для обработки ошибок

[[fblangref-scalarfuncs-rdberror]]
=== `RDB$ERROR()`

.Доступно в
PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$ERROR (<context>)   
                            
<context> ::= GDSCODE | SQLCODE | SQLSTATE | EXCEPTION | MESSAGE
----

.Тип возвращаемого результата
Зависит от контекста

Возвращает значение контекста активного исключения.
Тип возвращаемого значения зависит от контекста.

[NOTE]
====
Функция `RDB$ERROR` всегда возвращает `NULL` вне блока обработки ошибок `WHEN ... DO`.
====

Доступные контексты в качестве аргумента функции `RDB$ERROR`:

`EXCEPTION`:: функция возвращает имя исключения, если активно исключение определённое пользователем, или `NULL` если активно одно из системных исключений.
Для контекста `EXCEPTION` тип возвращаемого значения: `VARCHAR(63) CHARACTER SET UTF8`.

`MESSAGE`:: функция возвращает интерпретированный текст активного исключения.
Для контекста `MESSAGE` тип возвращаемого значения: `VARCHAR(1024) CHARACTER SET UTF8`.

`GDSCODE`:: функция возвращает значение контекстной переменной `GDSCODE`.

`SQLCODE`:: функция возвращает значение контекстной переменной `SQLCODE`.

`SQLSTATE`:: функция возвращает значение контекстной переменной `SQLSTATE`.


.Использование функции `RDB$ERROR` для сохранения текста ошибки в журнал
[example]
====
[source,sql]
----
...
BEGIN
...
WHEN ANY DO
  EXECUTE PROCEDURE P_LOG_EXCEPTION(RDB$ERROR(MESSAGE));
END
...
----
====

.См. также:
<<fblangref-psql-statements-when,`WHEN ... DO`>>,
<<fblangref-psql-statements-exception,`EXCEPTION`>>,
<<fblangref-contextvars-gdscode,`GDSCODE`>>,
<<fblangref-contextvars-sqlcode,`SQLCODE`>>,
<<fblangref-contextvars-sqlstate,`SQLSTATE`>>.


[[fblangref-functions-math]]
== Математические функции

[[fblangref-scalarfuncs-abs]]
=== `ABS()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ABS (_number_)
----

.Параметры функции `ABS`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа
|===

.Тип возвращаемого результата:
тот же что и входной аргумент.

Функция `ABS` возвращает абсолютное значение (модуль) аргумента.

[[fblangref-scalarfuncs-acos]]
=== `ACOS()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ACOS (_number_)
----

.Параметры функции ACOS
[cols="<1,<3", options="header",stripes="none"]
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа в диапазоне [-1; 1].
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ACOS` возвращает арккосинус (в радианах) аргумента.

В случае если аргумент функции вне границы диапазона [-1, 1], то функция вернёт неопределённое значения `NaN`.

.См. также:
<<fblangref-scalarfuncs-cos>>.

[[fblangref-scalarfuncs-acosh]]
=== `ACOSH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ACOSH (_number_)
----

.Параметры функции `ACOSH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа в диапазоне [1; +∞].
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ACOSH` возвращает гиперболический арккосинус (в радианах) аргумента.

.См. также:
<<fblangref-scalarfuncs-cosh>>.

[[fblangref-scalarfuncs-asin]]
=== `ASIN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ASIN (_number_)
----

.Параметры функции `ASIN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа в диапазоне [-1; 1].
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ASIN` возвращает арксинус (в радианах) аргумента.

В случае если аргумент функции вне границы диапазона [-1, 1], то функция вернёт неопределённое значения `NaN`.

.См. также:
<<fblangref-scalarfuncs-sin>>.

[[fblangref-scalarfuncs-asinh]]
=== `ASINH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ASIN (_number_)
----

.Параметры функции `ASINH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ASINH` возвращает гиперболический арксинус (в радианах) аргумента.

.См. также:
<<fblangref-scalarfuncs-sinh>>.

[[fblangref-scalarfuncs-atan]]
=== `ATAN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ATAN (_number_)
----

.Параметры функции `ATAN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ATAN` возвращает арктангенс аргумента. 

Функция возвращает угол в радианах в диапазоне [-π/2; π/2].

.См. также:
<<fblangref-scalarfuncs-atan2>>, <<fblangref-scalarfuncs-tan>>. 

[[fblangref-scalarfuncs-atan2]]
=== `ATAN2()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ATAN2 (_y_, _x_)
----

.Параметры функции ATAN2
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|y
|Выражение числового типа.

|x
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ATAN2` возвращает угол как отношение синуса к косинусу, аргументы, у которых задаются этими двумя параметрами, а знаки синуса и косинуса соответствуют знакам параметров.
Это позволяет получать результаты по всей окружности, включая углы -π/2 и π/2.

Особенности использования: 

* Результат -- угол в диапазоне [-π, π] радиан;
* Если _х_ отрицательный, то при нулевом значении _y_ результат равен π, а при значении 0 равен -π;
* Если и _y_ и _x_ равны 0, то результат бессмыслен.

[NOTE]
====
* Полностью эквивалентное описание этой функции следующее: `ATAN2 (__y__, __x__)` является углом между положительной осью X и линией от начала координат до точки (_x_, _y_). Это также делает очевидным, что значение `ATAN2 (0, 0)` не определено;
* Если _x_ больше, чем 0, `ATAN2 (__y__, __x__)` совпадает с `ATAN (__y__/__x__)`;
* Если известны и синус, и косинус угла, то `ATAN2 (__sin__, __cos__)` возвращает угол.
====

.См. также:
<<fblangref-scalarfuncs-atan>>, <<fblangref-scalarfuncs-sin>>, <<fblangref-scalarfuncs-cos>>.

[[fblangref-scalarfuncs-atanh]]
=== `ATANH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ATANH (_number_)
----

.Параметры функции `ATANH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ATANH` возвращает гиперболический арктангенс (в радианах) аргумента.

.См. также:
<<fblangref-scalarfuncs-tanh>>.

[[fblangref-scalarfuncs-ceil]]
=== `CEIL()`, `CEILING()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
CEIL[ING] (_number_)
----

.Параметры функции CEIL[ING]
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`BIGINT`, `INT128`, `DECFLOAT` или `DOUBLE PRECISION` в зависимости от типа аргумента.

Функция `CEIL` возвращает наименьшее целое число, большее или равное аргументу.

.См. также:
<<fblangref-scalarfuncs-floor>>, <<fblangref-scalarfuncs-trunc>>.

[[fblangref-scalarfuncs-cos]]
=== `COS()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
COS (_angle_)
----

.Параметры функции `COS`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `COS` возвращает косинус угла.
Аргумент должен быть задан в радианах.

Любой `NOT NULL` результат находится в диапазоне [-1, 1].

.См. также:
<<fblangref-scalarfuncs-acos>>.

[[fblangref-scalarfuncs-cosh]]
=== `COSH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
COSH (_number_)
----

.Параметры функции `COSH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `COSH` возвращает гиперболический косинус аргумента.

Любой `NOT NULL` результат находится в диапазоне [1, +∞].

.См. также:
<<fblangref-scalarfuncs-acosh>>.

[[fblangref-scalarfuncs-cot]]
=== `COT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
COT (_angle_)
----

.Параметры функции `COT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `COT` возвращает котангенс угла.
Аргумент должен быть задан в радианах.

.См. также:
<<fblangref-scalarfuncs-tan>>.

[[fblangref-scalarfuncs-exp]]
=== `EXP()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
EXP (_number_)
----

.Параметры функции `EXP`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `EXP` возвращает значение натуральной экспоненты, _e_^`number`^

.См. также:
<<fblangref-scalarfuncs-ln>>.

[[fblangref-scalarfuncs-floor]]
=== `FLOOR()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
FLOOR (_number_)
----

.Параметры функции `FLOOR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`BIGINT`, `INT128`, `DECFLOAT` или `DOUBLE PRECISION` в зависимости от типа аргумента.

Функция `FLOOR` возвращает целое число, меньшее или равное аргументу.

.См. также:
<<fblangref-scalarfuncs-ceil>>, <<fblangref-scalarfuncs-trunc>>.

[[fblangref-scalarfuncs-ln]]
=== `LN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
LN (_number_)
----

.Параметры функции `LN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `LN` возвращает натуральный логарифм аргумента.

[NOTE]
====
В случае если передан отрицательный или нулевой аргумент функция вернёт ошибку. 
====

.См. также:
<<fblangref-scalarfuncs-exp>>.

[[fblangref-scalarfuncs-log]]
=== `LOG()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
LOG (_x_, _y_)
----

.Параметры функции `LOG`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|x
|Основание.
Выражение числового типа.

|y
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `LOG` возвращает логарифм _y_ (второй аргумент) по основанию _x_ (первый аргумент).

Особенности использования: 

* Если один из аргументов меньше или равен 0, то возникает ошибка;
* Если оба аргумента равны 1, то результатом функции будет `NaN` (Not-a-Number -- не число);
* Если _x_ = 1 и _y_ < 1, то результатом функции будет `-INF` (-∞);
* Если _x_ = 1 и _y_ > 1, то результатом функции будет `+INF` (+∞).


[[fblangref-scalarfuncs-log10]]
=== `LOG10()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
LOG10 (_number_)
----

.Параметры функции `LOG10`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `LOG10` возвращает десятичный логарифм аргумента.

[NOTE]
====
Если входной аргумент отрицательный или равен 0, возникает ошибка. 
====

[[fblangref-scalarfuncs-mod]]
=== `MOD()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
MOD (_a_, _b_)
----

.Параметры функции `MOD`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|a
|Выражение числового типа.

|b
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`INTEGER`, `BIGINT` или `INT128` в зависимости от типов аргументов.

Функция `MOD` возвращает остаток от целочисленного деления.

[NOTE]
====
Вещественные числа округляются до выполнения деления.
Например, результатом "```mod(7.5, 2.5)```" будет 2 ("```mod(8, 3)```"), а не 0.
====

[[fblangref-scalarfuncs-pi]]
=== `PI()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
PI ()
----

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `PI` возвращает число π.

[[fblangref-scalarfuncs-power]]
=== `POWER()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
POWER (_x_, _y_)
----

.Параметры функции `POWER`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|x
|Выражение числового типа.

|y
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `POWER` возвращает результат возведения числа _x_ в степень _y_ то есть (_x^y^_).

[NOTE]
====
Если _x_ меньше нуля, возникает ошибка.
====

[[fblangref-scalarfuncs-rand]]
=== `RAND()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
RAND ()
----

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `RAND` возвращает псевдослучайное число в интервале от 0 до 1.

[[fblangref-scalarfuncs-round]]
=== `ROUND()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ROUND (_number_ [, _scale_])
----

.Параметры функции `ROUND`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.

|scale
a|Масштаб -- целое число, определяющее число десятичных разрядов, к которым должен быть проведено округление, т.е.

* {nbsp}2 для округления к самому близкому кратному 0.01 числу
* {nbsp}1 для округления к самому близкому кратному 0.1 числу
* {nbsp}0 для округления к самому близкому целому числу
* -1 для округления к самому близкому кратному 10 числу
* -2 для округления к самому близкому кратному 100 числу

По умолчанию 0.
|===

.Тип возвращаемого результата
масштабируемое целое (`INTEGER`, `BIGINT` или `INT128`) или `DECFLOAT`, или `DOUBLE PRECISION` в зависимости от типа _number_.

Функция `ROUND` округляет число до ближайшего целого числа.
Если дробная часть равна 0.5, то округление до ближайшего большего целого числа для положительных чисел и до ближайшего меньшего для отрицательных чисел.
С дополнительным опциональным параметром _scale_ число может быть округлено до одной из степеней числа 10 (десятки, сотни, десятые части, сотые части и т.д.) вместо просто целого числа.

[NOTE]
====
Если используется параметр _scale_, то результат имеет такой же масштаб, как и первый параметр _number_.
====

[[fblangref-scalarfuncs-round-exmpl]]
==== Примеры `ROUND`

.Использование функции `ROUND`
[example]
====
[source,sql]
----
ROUND(123.654, 1) -- Результат: 123.700 (а не 123.7)
ROUND(8341.7, -3) -- Результат: 8000.0 (а не 8000)
ROUND(45.1212, 0) -- Результат: 45.0000 (а не 45)
ROUND(45.1212)    -- Результат: 45
----
====

.См. также:
<<fblangref-scalarfuncs-trunc>>.

[[fblangref-scalarfuncs-sign]]
=== `SIGN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SIGN (_number_)
----

.Параметры функции `SIGN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`SMALLINT`

Функция `SIGN` возвращает знак входного параметра.

* -1 -- число меньше нуля
* {nbsp}0 -- число равно нулю
* {nbsp}1 -- число больше нуля

[[fblangref-scalarfuncs-sin]]
=== `SIN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SIN (_angle_)
----

.Параметры функции `SIN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `SIN` возвращает синус угла.
Аргумент должен быть задан в радианах.

Любой `NOT NULL` результат находится в диапазоне [-1, 1].

.См. также:
<<fblangref-scalarfuncs-asin>>.

[[fblangref-scalarfuncs-sinh]]
=== `SINH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SINH (_number_)
----

.Параметры функции `SINH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `SINH` возвращает гиперболический синус аргумента.

.См. также:
<<fblangref-scalarfuncs-asinh>>.

[[fblangref-scalarfuncs-sqrt]]
=== `SQRT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SQRT (_number_)
----

.Параметры функции `SQRT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `SQRT` возвращает квадратный корень аргумента.

[[fblangref-scalarfuncs-tan]]
=== `TAN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
TAN (_angle_)
----

.Параметры функции `TAN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `TAN` возвращает тангенс угла.
Аргумент должен быть задан в радианах.

.См. также:
<<fblangref-scalarfuncs-atan>>, <<fblangref-scalarfuncs-atan2>>.

[[fblangref-scalarfuncs-tanh]]
=== `TANH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
TANH (_number_)
----

.Параметры функции `TANH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `TANH` возвращает гиперболический тангенс аргумента.

Любой `NOT NULL` результат находится в диапазоне [-1, 1].

.См. также:
<<fblangref-scalarfuncs-atanh>>.

[[fblangref-scalarfuncs-trunc]]
=== `TRUNC()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
TRUNC (_number_ [, _scale_])
----

.Параметры функции `TRUNC`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.

|scale
a|Масштаб -- целое число, определяющее число десятичных разрядов, к которым должен быть проведено усечение, т.е.

* {nbsp}2 для усечения к самому близкому кратному 0.01 числу
* {nbsp}1 для усечения к самому близкому кратному 0.1 числу
* {nbsp}0 для усечения к самому близкому целому числу
* -1 для усечения к самому близкому кратному 10 числу
* -2 для усечения к самому близкому кратному 100 числу

По умолчанию 0.
|===

.Тип возвращаемого результата
масштабируемое целое (`INTEGER`, `BIGINT` или `INT128`) или `DECFLOAT`, или `DOUBLE PRECISION` в зависимости от типа _number_.

Функция `TRUNC` усекает число до ближайшего целого числа.
С дополнительным опциональным параметром _scale_ число может быть усечено до одной из степеней числа 10 (десятки, сотни, десятые части, сотые части и т.д.) вместо просто целого числа.

[NOTE]
====
Если используется параметр _scale_, то результат имеет такой же масштаб, как и первый параметр _number_.
====

[IMPORTANT]
====
Функция всегда увеличивает отрицательные числа, поскольку она обрезает дробную часть. 
====

.Использование функции `TRUNC`
[example]
====
[source,sql]
----
TRUNC(789.2225, 2)  -- Результат: 789.2200 (а не 789.22)
TRUNC(345.4, -2) 	-- Результат: 300.0 (а не 300)
TRUNC(-163.41, 0)	-- Результат: -163.00 (а не -163)
TRUNC(-163.41)      -- Результат: -163
----
====

.См. также:
<<fblangref-scalarfuncs-round>>, <<fblangref-scalarfuncs-ceil>>, <<fblangref-scalarfuncs-floor>>.

[[fblangref-functions-string]]
== Функции для работы со строками

[[fblangref-scalarfuncs-ascii-char]]
=== `ASCII_CHAR()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ASCII_CHAR (_code_)
----

[[fblangref-funcs-tbl-asciichar]]
.Параметры функции `ASCII_CHAR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|code
|Целое число в диапазоне от 0 до 255.
|===

.Тип возвращаемого результата:
`CHAR(1) CHARACTER SET NONE`.

Функция ASCII_CHAR возвращает ASCII символ соответствующий номеру, переданному в качестве аргумента.

.См. также:
<<fblangref-scalarfuncs-ascii-val>>.

[[fblangref-scalarfuncs-ascii-val]]
=== `ASCII_VAL()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ASCII_VAL (_ch_)
----

.Параметры функции `ASCII_VAL`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|ch
|Строка типа данных [VAR]CHAR или текстовый BLOB максимального размера 32767 байт.
|===

.Тип возвращаемого результата:
`SMALLINT`

Функция `ASCII_VAL` возвращает ASCII код символа, переданного в качестве аргумента.

Особенности использования: 

* Если строка содержит более одного символа, то возвращается код первого символа строки;
* Если строка пустая, возвращается ноль;
* Если аргумент `NULL`, то возвращаемое значение также `NULL`.


.См. также:
<<fblangref-scalarfuncs-ascii-char>>.

[[fblangref-scalarfuncs-bit-length]]
=== `BIT_LENGTH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BIT_LENGTH (_string_)
----

.Параметры функции `BIT_LENGTH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Выражение строкового типа.
|===

.Тип возвращаемого результата:
`BIGINT`

Функция `BIT_LENGTH` возвращает длину входной строки в битах.
Для многобайтных наборов символов результат может быть в 8 раз больше, чем количество символов в "`формальном`" числе байт на символ, записанном в `RDB$CHARACTER_SETS`.

С параметрами типа CHAR эта функция берет во внимание всю формальную строковую длину (например, объявленная длина поля или переменной). Если вы хотите получить "`логическую`" длину в битах, не считая пробелов, то перед передачей аргумента в `BIT_LENGTH` надо выполнить над ним операцию RIGHT TRIM.

[[fblangref-scalarfuncs-bit-length-exmpl]]
==== Примеры `BIT_LENGTH`

.Использование функции `BIT_LENGTH`
[example]
====
[source,sql]
----
SELECT BIT_LENGTH ('Hello!') FROM RDB$DATABASE
-- возвращает 48

SELECT BIT_LENGTH (_ISO8859_1 'Grüß Di!')
FROM RDB$DATABASE
-- возвращает 64: каждый, и ü, и ß занимают один байт в ISO8859_1

SELECT BIT_LENGTH (
CAST (_ISO8859_1 'Grüß di!' AS VARCHAR (24)
CHARACTER SET UTF8))
FROM RDB$DATABASE
-- возвращает 80: каждый, и ü, и ß занимают по два байта в UTF8

SELECT BIT_LENGTH (
CAST (_ISO8859_1 'Grüß di!' AS CHAR (24)
CHARACTER SET UTF8))
FROM RDB$DATABASE
-- возвращает 208: размер всех 24 позиций CHAR и два из них 16-битные
----
====

.См. также:
<<fblangref-scalarfuncs-char-length>>, <<fblangref-scalarfuncs-octet-length>>.

[[fblangref-scalarfuncs-char-length]]
=== `CHAR_LENGTH()`, `CHARACTER_LENGTH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
  CHAR_LENGTH (_string_)
| CHARACTER_LENGTH (_string_)
----

.Параметры функции `CHAR_LENGTH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Выражение строкового типа.
|===

.Тип возвращаемого результата:
`BIGINT`

Функция `CHAR_LENGTH` возвращает длину (в символах) строки, переданной в качестве аргумента.

[NOTE]
====
С параметрами типа `CHAR` эта функция берет во внимание всю формальную строковую длину (например, объявленная длина поля или переменной). Если вы хотите получить "`логическую`" длину без учёта пробелов, то перед передачей аргумента в `CHAR[ACTER]_LENGTH` надо выполнить над ним операцию RIGHT TRIM.
====

.См. также:
<<fblangref-scalarfuncs-bit-length>>, <<fblangref-scalarfuncs-octet-length>>.

[[fblangref-scalarfuncs-hash]]
=== `HASH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
HASH (_str_ [USING <algorithm>])

<algorithm> ::= { CRC32 }
----

.Параметры функции `HASH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|str
|Выражение строкового типа.
|===

.Тип возвращаемого результата:
`BIGINT`

Функция `HASH` возвращает некриптографический хэш входной строки.
Эта функция полностью поддерживает текстовые `BLOB` любой длины и с любым набором символов.

Необязательное предложение `USING` определяет применяемый некриптографический алгоритм хеширования.
Когда предложение `USING` отсутствует, применяется устаревший алгоритм PJW; это идентично его поведению в предыдущих
версиях Firebird.

.Поддерживаемые алгоритмы:
_не указан_::
Если алгоритм не указан, то используется 64-битный вариант некриптографической
https://en.wikipedia.org/wiki/PJW_hash_function[хэш-функции PJW^] (также известной как ELF64).
Эта функция очень быстра и может использоваться для общих целей (хеш-таблицы и т.
д.), но имеет большое количество коллизий.
Для более надежного хеширования следует использовать другие хеш-функции, явно указанные в предложении USING, или криптографические хеши с помощью <<fblangref-scalarfuncs-crypthash>>.
+
Для этого алгоритма хеширования функция возвращает тип `BIGINT`.

`CRC32`::
Если в предложении `USING` указан алгоритм `CRC32`, то Firebird применяет алгоритм CRC32, используя полином 0x04C11DB7.
+
Для этого алгоритма функция `HASH` возвращает результат с типом `INTEGER`.

[[fblangref-scalarfuncs-hash-exmpl]]
==== Примеры `HASH`

.Вычисление хеша с алгоритмом PJW
[example]
====
[source,sql]
----
SELECT HASH(x) FROM MyTable;
-- результат типа BIGINT
----
====

.Вычисление хеша с алгоритмом CRC32
[example]
====
[source,sql]
----
SELECT HASH(x USING CRC32) FROM MyTable;
-- результат типа INTEGER
----
====

См. также:
<<fblangref-scalarfuncs-crypthash>>

[[fblangref-scalarfuncs-left]]
=== `LEFT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
LEFT (_string_, _length_)
----

.Параметры функции `LEFT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Выражение строкового типа.

|length
|Целое число.
Определяет количество возвращаемых символов.
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`.

Функция `LEFT` возвращает левую часть строки, количество возвращаемых символов определяется вторым параметром.

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если строковый аргумент `BLOB`, результатом будет BLOB, в противном случае результатом будет VARCHAR(N), при этом N – будет равно длине строкового параметра;
* Если числовой параметр превысит длину текста, результатом будет исходный текст.


[WARNING]
====
При использовании `BLOB` в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах `BLOB` могут наблюдаться потери производительности.
====

.Использование функции LEFT
[example]
====
[source,sql]
----
SELECT LEFT('ABC', 2) FROM rdb$database;
-- результат AB
----
====

.См. также:
<<fblangref-scalarfuncs-right>>, <<fblangref-scalarfuncs-substring>>.

[[fblangref-scalarfuncs-lower]]
=== `LOWER()`

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис
[listing,subs=+quotes]
----
LOWER (_string_)
----

.Параметры функции `LOWER`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Выражение строкового типа.
|===

.Тип возвращаемого результата:
`VAR[CHAR]` или `BLOB`

Функция `LOWER` возвращает входную строку в нижнем регистре.
Точный результат зависит от набора символов входной строки.
Например, для наборов символов NONE и ASCII только ASCII символы переводятся в нижний регистр; для OCTETS -- вся входная строка возвращается без изменений.

[[fblangref30-scalarfuncs-lower-exmpl]]
==== Примеры `LOWER`

.Использование функции `LOWER`
[example]
====
[source,sql]
----
----
select Sheriff
from Towns
where lower(Name) = 'cooper''s valley'
----
----
====

.См. также:
<<fblangref-scalarfuncs-upper>>.

[[fblangref-scalarfuncs-lpad]]
=== `LPAD()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
LPAD (_str_, _endlen_ [, _padstr_])
----

.Параметры функции LPAD
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|str
|Выражение строкового типа.

|endlen
|Длина выходной строки.

|padstr
|Строка, которой дополняется исходная строка до указанной длины.
По умолчанию является пробелом ("```' '```").
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`.

Функция `LPAD` дополняет слева входную строку пробелами или определённой пользователем строкой до заданной длины.

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если входная строка имеет тип `BLOB`, то результат также будет `BLOB`, в противном случае результат будет `VARCHAR(__endlen__)`.
* Если аргумент _padstr_ задан, но равен `''` (пустой строке), то дополнения строки не происходит! В случае если _endlen_ меньше длины входной строки, то в результате происходит её усечение до длины _endlen_, даже если параметр _padstr_ равен пустой строке.

[WARNING]
====
При использовании `BLOB` в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах `BLOB` могут наблюдаться потери производительности.
====

[[fblangref-scalarfuncs-lpad-exmpl]]
==== Примеры `LPAD`

.Использование функции `LPAD`
[example]
====
[source,sql]
----
LPAD ('Hello', 12)                -- возвращает '       Hello'
LPAD ('Hello', 12, '-')           -- возвращает '-------Hello'
LPAD ('Hello', 12, '')            -- возвращает 'Hello'
LPAD ('Hello', 12, 'abc')         -- возвращает 'abcabcaHello'
LPAD ('Hello', 12, 'abcdefghij')  -- возвращает 'abcdefgHello'
LPAD ('Hello', 2)                 -- возвращает 'He'
LPAD ('Hello', 2, '-')            -- возвращает 'He'
LPAD ('Hello', 2, '')             -- возвращает 'He'
----
====

.См. также:
<<fblangref-scalarfuncs-rpad>>.

[[fblangref-scalarfuncs-octet-length]]
=== `OCTET_LENGTH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
OCTET_LENGTH (_string_)
----

.Параметры функции `OCTET_LENGTH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Выражение строкового типа.
|===

.Тип возвращаемого результата:
`BIGINT`

Функция `OCTET_LENGTH` возвращает количество байт занимаемое строкой.

При работе с параметрами типа `CHAR` функция возвращает значение всей формальной строковой длины.
Для того чтобы узнать "`логическую`" длину строки в байтах, то перед передачей аргумента функции следует применить RIGHT TRIM.

[NOTE]
====
Следует помнить, что не во всех наборах символов количество байт занимаемых строкой равно количеству символов.
====

[[fblangref-scalarfuncs-octet-length-exmpl]]
==== Примеры `OCTET_LENGTH`

.Использование функции `OCTET_LENGTH`
[example]
====
[source,sql]
----

SELECT OCTET_LENGTH('Hello!') 
FROM rdb$database
-- возвратит 6

SELECT OCTET_LENGTH(_iso8859_1 'Grüß di!') 
FROM rdb$database
-- возвратит 8: ü и ß занимают не более 1 байта в ISO8859_1

SELECT 
  OCTET_LENGTH(CAST(_iso8859_1 'Grüß di!' AS VARCHAR(24) CHARACTER SET utf8))
FROM rdb$database
-- возвратит 10: ü и ß занимают 2 байта в UTF8

SELECT 
  OCTET_LENGTH(CAST(_iso8859_1 'Grüß di!' AS CHAR(24) CHARACTER SET utf8))
FROM rdb$database
-- возвратит 26: всего 24 CHAR позиции, и две из них занимают 2 байта
----
====

.См. также:
<<fblangref-scalarfuncs-bit-length>>, <<fblangref-scalarfuncs-char-length>>.

[[fblangref-scalarfuncs-overlay]]
=== `OVERLAY()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
OVERLAY (_string_ PLACING _replacement_ FROM _pos_ [FOR _length_])
----

.Параметры функции OVERLAY
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Строка, в которой происходит замена.

|replacement
|Строка, которой заменяется.

|pos
|Позиция, с которой происходит замена.

|length
|Количество символов, которые будут удалены из исходной строки.
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`

Функция OVERLAY предназначена для замены части строки другой строкой. 

По умолчанию число удаляемых из строки символов равняется длине заменяемой строки.
Дополнительный четвёртый параметр позволяет пользователю задать своё число символов, которые будут удалены.

Особенности использования: 

* Функция полностью поддерживает тестовые `BLOB` с любым набором символов и любой длины;
* Если входная строка имеет тип `BLOB`, то и результат будет иметь тип `BLOB`. В противном случае тип результата будет `VARCHAR(__n__)`, где _n_ является суммой длин параметров _string_ и _replacement_;
* Как и во всех строковых функциях SQL параметр _pos_ является определяющим;
* Если _pos_ больше длины строки, то _replacement_ помещается сразу после окончания строки;
* Если число символов от _pos_ до конца строки меньше, чем длина _replacement_ (или, чем параметр _length_, если он задан), то строка усекается до значения _pos_ и _replacement_ помещается после него;
* При нулевом параметре _length_ (FOR 0) _replacement_ просто вставляется в строку, начиная с позиции _pos_;
* Если любой из параметров имеет значение `NULL`, то и результат будет `NULL`;
* Если параметры _pos_ и _length_ не являются целым числом, то используется банковское округление (до чётного): 0.5 становится 0, 1.5 становится 2, 2.5 становится 2, 3.5 становится 4 и т.д.


[WARNING]
====
При использовании `BLOB` функции может потребоваться загрузить весь объект в память.
При больших размерах `BLOB` это может повлиять на производительность.
====

[[fblangref-scalarfuncs-overlay-exmpl]]
==== Примеры `OVERLAY`

.Использование функции `OVERLAY`
[example]
====
[source,sql]
----
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2) -- Результат: 'Ghelloe'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 5) -- Результат: 'GoodHello'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 8) -- Результат: 'GoodbyeHello'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 20) -- Результат: 'GoodbyeHello'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 0) -– Результат: 'GHellooodbye'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 3) -- Результат: 'GHellobye'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 6) -- Результат: 'GHello'	
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 9) -- Результат: 'Ghello'
OVERLAY ('Goodbye' PLACING '' FROM 4) -- Результат: 'Goodbye'
OVERLAY ('Goodbye' PLACING '' FROM 4 FOR 3) -- Результат: 'Gooe'
OVERLAY ('Goodbye' PLACING '' FROM 4 FOR 20) -- Результат: 'Goo'
OVERLAY ('' PLACING 'Hello' FROM 4) -- Результат: 'Hello'
OVERLAY ('' PLACING 'Hello' FROM 4 FOR 0) -- Результат: 'Hello'
OVERLAY ('' PLACING 'Hello' FROM 4 FOR 20) -- Результат: 'Hello'
----
====

.См. также:
<<fblangref-scalarfuncs-substring>>, <<fblangref-scalarfuncs-replace>>.

[[fblangref-scalarfuncs-position]]
=== `POSITION()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
  POSITION (_substr_ IN _string_)
| POSITION (_substr_, _string_ [, _startpos_])
----

.Параметры функции `POSITION`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|substr
|Подстрока, позиция которой ищется.

|string
|Строка, в которой ищется позиция.

|startpos
|Позиция, с которой начинается поиск подстроки.
|===

.Тип возвращаемого результата:
`INTEGER`

Функция `POSITION` возвращает позицию первого вхождения подстроки в строку.
Отсчёт начинается с 1.
Третий аргумент (опциональный) задаёт позицию в строке, с которой начинается поиск подстроки, тем самым игнорирую любые вхождения подстроки в строку до этой позиции.
Если совпадение не найдено, функция возвращает 0. 

Особенности использования: 

* Опциональный третий параметр поддерживается только вторым вариантом синтаксиса (синтаксис с запятой);
* Пустую строку, функция считает подстрокой любой строки. Поэтому при входном параметре _substr_, равном `''` (пустая строка), и при параметре _string_, отличном от `NULL`, результатом будет:
+
** 1, если параметр _startpos_ не задан;
** _startpos_, если _startpos_ не превышает длину параметра _string_;
** 0, если _startpos_ больше длины параметра _string_.

[[fblangref-scalarfuncs-position-exmpl]]
==== Примеры `POSITION`

.Использование функции `POSITION`
[example]
====
[source,sql]
----
POSITION ('be' IN 'To be or not to be')   -- Результат: 4
POSITION ('be', 'To be or not to be')     -- Результат: 4
POSITION ('be', 'To be or not to be', 4)  -- Результат: 4
POSITION ('be', 'To be or not to be', 8)  -- Результат: 17
POSITION ('be', 'To be or not to be', 18) -- Результат: 0
POSITION ('be' in 'Alas, poor Yorick!') -- Результат: 0
----
====

.См. также:
<<fblangref-scalarfuncs-substring>>.

[[fblangref-scalarfuncs-replace]]
=== `REPLACE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
REPLACE (_str_, _find_, _repl_)
----

.Параметры функции `REPLACE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|str
|Строка, в которой делается замена.

|find
|Строка, которая ищется.

|repl
|Строка, на которую происходит замена.
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`

Функция `REPLACE` заменяет в строке все вхождения одной строки на другую строку.

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если один из аргументов имеет тип `BLOB`, то результат будет иметь тип `BLOB`. В противном случае результат будет иметь тип `VARCHAR(__N__)`, где _N_ рассчитывается из длин _str_, _find_ и _repl_ таким образом, что даже максимальное количество замен не будет вызывать переполнения поля.
* Если параметр _find_ является пустой строкой, то возвращается _str_ без изменений;
* Если параметр _repl_ является пустой строкой, то все вхождения _find_ удаляются из строки _str_;
* Если любой из аргументов равен `NULL`, то результатом всегда будет `NULL`, даже если не было произведено ни одной замены.


[WARNING]
====
При использовании `BLOB` в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах `BLOB` могут наблюдаться потери производительности.
====

[[fblangref-scalarfuncs-replace-exmpl]]
==== Примеры `REPLACE`

.Использование функции `REPLACE`
[example]
====
[source,sql]
----
REPLACE ('Billy Wilder', 'il', 'oog')  -- возвращает 'Boogly Woogder'
REPLACE ('Billy Wilder', 'il', '')     -- возвращает 'Bly Wder'
REPLACE ('Billy Wilder', null, 'oog')  -- возвращает NULL
REPLACE ('Billy Wilder', 'il', null)   -- возвращает NULL
REPLACE ('Billy Wilder', 'xyz', null)  -- возвращает NULL (!)
REPLACE ('Billy Wilder', 'xyz', 'abc') -- возвращает 'Billy Wilder'
REPLACE ('Billy Wilder', '', 'abc')    -- возвращает 'Billy Wilder'
----
====

.См. также:
<<fblangref-scalarfuncs-overlay>>.

[[fblangref-scalarfuncs-reverse]]
=== `REVERSE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
REVERSE (_string_)
----

.Параметры функции REVERSE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Выражение строкового типа.
|===

.Тип возвращаемого результата:
`VARCHAR`

Функция `REVERSE` возвратит строку перевёрнутую "задом наперёд".

[[fblangref-scalarfuncs-reverse-exmpl]]
==== Примеры `REVERSE`

.Использование функции `REVERSE`
[example]
====
[source,sql]
----
REVERSE ('spoonful')             -- возвращает 'lufnoops'
REVERSE ('Was it a cat I saw?')  -- возвращает '?was I tac a ti saW'
----
====

[TIP]
====
Данная функция очень удобна, если вам предстоит обработать (сортировать или группировать) информацию, которая находится в конце строки.
Пример такой информации – доменные имена или имена адресов электронной почты. 

[source,sql]
----
CREATE INDEX ix_people_email ON people
COMPUTED BY (reverse(email));

SELECT * FROM people
WHERE REVERSE(email) STARTING WITH reverse('.br');
----
====

[[fblangref-scalarfuncs-right]]
=== `RIGHT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RIGHT (_string_, _length_)
----

.Параметры функции `RIGHT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|string
|Выражение строкового типа.

|length
|Целое число.
Определяет количество возвращаемых символов.
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`

Функция `RIGHT` возвращает конечную (правую) часть входной строки.
Длина возвращаемой подстроки определяется вторым параметром. 

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если строковый аргумент `BLOB`, результатом будет `BLOB`, в противном случае результатом будет `VARCHAR(__N__)`, при этом _N_ -- будет равно длине строкового параметра;
* Если числовой параметр превысит длину текста, результатом будет исходный текст.

[WARNING]
====
При использовании `BLOB` в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах `BLOB` могут наблюдаться потери производительности.
====

.Использование функции `RIGHT`
[example]
====
[source,sql]
----
SELECT RIGHT('ABC', 1) FROM rdb$database;
-- результат C
----
====

.См. также:
<<fblangref-scalarfuncs-left>>, <<fblangref-scalarfuncs-substring>>.

[[fblangref-scalarfuncs-rpad]]
=== `RPAD()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RPAD (_str_, _endlen_ [, _padstr_])
----

[[fblangref-funcs-tbl-rpad]]
.Параметры функции `RPAD`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|str
|Выражение строкового типа.

|endlen
|Длина выходной строки.

|padstr
|Строка, которой дополняется исходная строка до указанной длины.
По умолчанию является пробелом (`' '`).
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`

Функция `RPAD` дополняет справа входную строку пробелами или определённой пользователем строкой до заданной длины.

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если входная строка имеет тип `BLOB`, то результат также будет BLOB, в противном случае результат будет `VARCHAR(__endlen__)`.
* Если аргумент _padstr_ задан, но равен `''` (пустой строке), то дополнения строки не происходит! В случае если _endlen_ меньше длины входной строки, то в результате происходит её усечение до длины _endlen_, даже если параметр _padstr_ равен пустой строке.


[WARNING]
====
При использовании `BLOB` в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах `BLOB` могут наблюдаться потери производительности.
====

[[fblangref-scalarfuncs-rpad-exmpl]]
==== Примеры `RPAD`

.Использование функции `RPAD`
[example]
====
[source,sql]
----
RPAD ('Hello', 12)                -- возвращает 'Hello       '
RPAD ('Hello', 12, '-')           -- возвращает 'Hello-------'
RPAD ('Hello', 12, '')            -- возвращает 'Hello'
RPAD ('Hello', 12, 'abc')         -- возвращает 'Helloabcabca'
RPAD ('Hello', 12, 'abcdefghij')  -- возвращает 'Helloabcdefg'
RPAD ('Hello', 2)                 -- возвращает 'He'
RPAD ('Hello', 2, '-')            -- возвращает 'He'
RPAD ('Hello', 2, '')             -- возвращает 'He'
----
====

.См. также:
<<fblangref-scalarfuncs-lpad>>.

[[fblangref-scalarfuncs-substring]]
=== `SUBSTRING()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SUBSTRING (<substring-args>)
                        
<substring-args> ::=
    _str_ FROM _startpos_ [FOR _length_]
  | str SIMILAR <similar_pattern> ESCAPE <escape>                     
                            
<similar-pattern> ::=
  <similar-pattern-R1>
  <escape>"<similar pattern_R2><escape>"
  <similar pattern-R3>
----

.Параметры функции `SUBSTRING`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|str
|Выражение строкового типа.

|startpos
|Позиция, с которой начинается извлечение подстроки.
Целочисленное выражение.

|length
|Длина возвращаемой подстроки.
Целочисленное выражение.

|similar-pattern
|Шаблон регулярного выражения SQL, по которому ищется подстрока.

|escape
|Символ экранирования.
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`

Функция `SUBSTRING` возвращает подстроку из строки, начиная с заданной позиции до конца строки или до указанной длины, либо извлекает подстроку с использованием шаблона регулярного выражения SQL.

Если любой из входных параметров имеет значение `NULL`, то и результат тоже будет иметь значение `NULL`.

[WARNING]
====
При использовании `BLOB` в параметрах функции может потребоваться загрузить объект в память полностью.
При больших объёмах `BLOB` могут наблюдаться потери производительности.
====

[[fblangref-scalarfuncs-substring-pos]]
==== Позиционный `SUBSTRING`

В простой позиционной форме (с `FROM`) эта функция возвращает подстроку, начинающуюся с позиции символа _startpos_ (позиция первого сивола равна 1). Без аргумента `FOR` он возвращает все оставшиеся символы в строке.
С использованием FOR возвращается _length_ символов или остаток строки, в зависимости от того что короче.

Начиная с Firebird 4.0, _startpos_ может быть меньше 1.
Когда _startpos_ меньше 1, подстрока ведет себя так, как если бы строка имела дополнительные позиции `1 - __startpos__` перед
фактическим первым символом в позиции `1`.
Значение _length_ считается от этого воображаемого начала строки, поэтому результирующая строка может быть короче указанной _length_ или даже пустой.

Функция полностью поддерживает двоичные и текстовые BLOB любой длины и с любым набором символов.
Если параметр _str_ имеет тип `BLOB`, то и результат будет иметь тип `BLOB`.
Для любых других типов результатом будет тип `VARCHAR`.

Для входного параметра _str_, не являющегося `BLOB`, длина результата функции всегда будет равна длине строки _str_, независимо от значений параметров _startpos_ и _length_.


.Использование функции `SUBSTRING`
[example]
====
[source,sql]
----
select substring('abcdef' from 1 for 2) from rdb$database;
-- результат: 'ab'

select substring('abcdef' from 2) from rdb$database;
-- результат: 'bcdef'

select substring('abcdef' from 0 for 2) from rdb$database;
-- результат: 'a'
-- не 'ab', потому что в позиции 0 нет "ничего"

select substring('abcdef' from -5 for 2) from rdb$database;
-- результат: ''
-- длина заканчивается до фактического начала строки
----
====

==== `SUBSTRING` по регулярному выражению

Функция `SUBSTRING` с регулярным выражением (с `SIMILAR`) возвращает часть строки соответствующей шаблону регулярного выражения SQL.
Если соответствия не найдено, то возвращается `NULL`.

Шаблон `SIMILAR` формируется из трех шаблонов регулярных выражений SQL: R1, R2 и R3.
Полностью шаблон имеет форму `R1 || '__<escape>__"' || R2 || '__<escape>__"' || R3`, где _<escape>_ -- это escape-символ, определенный в предложении `ESCAPE`.
R2 -- это шаблон, который соответствует подстроке для извлечения и заключен в экранированные двойные кавычки (`__<escape>__"`, например, "```++#"++```" с escape-символом '```++#++```'). R1 соответствует префиксу строки, а R3 -- суффиксу строки.
И R1, и R3 необязательны (они могут быть пустыми), но шаблон должен соответствовать всей строке.
Другими словами, недостаточно указать шаблон, который находит только подстроку для извлечения. 

[TIP]
====
Экранированные двойные кавычки вокруг _R2_ можно сравнить с определением одной группы захвата в более распространенном синтаксисе регулярных выражений, таком как PCRE.
То есть полный шаблон эквивалентен `__R1__(__R2__)__R3__`, который должен соответствовать всей входной строке, а группа захвата -- это возвращаемая подстрока.

Возвращаемое значение соответствует части _R2_ регулярного выражения.
Для этого значения истинно выражение

[source]
----
str SIMILAR TO R1 || R2 || R3 ESCAPE <escape>
----
====

[NOTE]
====
Если любая часть шаблона из _R1_, _R2_ или _R3_ не является пустой строкой и не имеет формата регулярного выражения SQL, возникает исключение.
====

Полный формат регулярных выражений SQL описан в <<fblangref-commons-syntaxregex,Синтаксис регулярных выражений SQL>>.

.Использование функции `SUBSTRING` с регулярными выражениями
[example]
====
[source,sql]
----
SUBSTRING('abcabc' SIMILAR 'a#"bcab#"c' ESCAPE '#')  -- bcab
SUBSTRING('abcabc' SIMILAR 'a#"%#"c' ESCAPE '#')     -- bcab
SUBSTRING('abcabc' SIMILAR '_#"%#"_' ESCAPE '#')     -- bcab
SUBSTRING('abcabc' SIMILAR '#"(abc)*#"' ESCAPE '#')  -- abcabc
SUBSTRING('abcabc' SIMILAR '#"abc#"' ESCAPE '#')     -- <null>
----
====

.См. также:
<<fblangref-scalarfuncs-position>>, <<fblangref-scalarfuncs-left>>, <<fblangref-scalarfuncs-right>>,
<<fblangref-scalarfuncs-char-length>>, <<fblangref-commons-predsimilarto>>.

[[fblangref-scalarfuncs-trim]]
=== `TRIM()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
TRIM ([<adjust>] _str_)

<adjust> ::=  {[<where>] [_what_]} FROM

<where> ::=  BOTH | LEADING | TRAILING
----

.Параметры функции `TRIM`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|str
|Выражение строкового типа.

|where
|Из какого места необходимо удалить подстроку -- `BOTH` {vbar} `LEADING` {vbar} `TRAILING`.
По умолчанию `BOTH`.

|what
|Подстрока, которую надо удалить (неоднократно, если таких вхождений несколько) из входной строки _str_ в её начале и/или конце.
По умолчанию является пробелом (`' '`).
|===

.Тип возвращаемого результата:
`VARCHAR` или `BLOB`

Функция `TRIM` удаляет начальные и /или концевые пробелы (или текст согласно настройкам) из входной строки.


.Особенности использования
[NOTE]
====
* Если входной параметр _str_ имеет тип `BLOB`, то и результат будет иметь тип BLOB. В противном случае результат будет иметь тип `VARCHAR(__n__)`, где _n_ является длиной параметра _str_;
* Подстрока для удаления, если она, конечно, задана, не должна иметь длину больше, чем 32767 байта. Однако при повторениях подстроки в начале и/или конце входного параметра _str_ общее число удаляемых байтов может быть гораздо больше.
====

[WARNING]
====
При использовании `BLOB` в параметрах функции может потребоваться загрузить объект в память полностью.
При больших объёмах `BLOB` могут наблюдаться потери производительности.
====

[[fblangref-scalarfuncs-trim-exmpl]]
==== Примеры `TRIM`

.Использование функции `TRIM`
[example]
====
[source,sql]
----
SELECT TRIM (' Waste no space ')
FROM RDB$DATABASE -- Результат: 'Waste no space'

SELECT TRIM (LEADING FROM ' Waste no space ')
FROM RDB$DATABASE -- Результат: 'Waste no space '

SELECT TRIM (LEADING '.' FROM ' Waste no space ')
FROM RDB$DATABASE -- Результат: ' Waste no space '

SELECT TRIM (TRAILING '!' FROM 'Help!!!!')
FROM RDB$DATABASE -- Результат: 'Help'

SELECT TRIM ('la' FROM 'lalala I love you Ella')
FROM RDB$DATABASE -- Результат: ' I love you El'
----
====

.См. также:
<<fblangref-scalarfuncs-overlay>>, <<fblangref-scalarfuncs-replace>>.

[[fblangref-scalarfuncs-upper]]
=== `UPPER()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
UPPER (_str_)
----

.Параметры функции `UPPER`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|str
|Выражение строкового типа.
|===

.Тип возвращаемого результата:
`[VAR]CHAR` или `BLOB`

Функция `UPPER` возвращает входную строку в верхнем регистре.
Точный результат зависит от набора символов входной строки.
Например, для наборов символов NONE и ASCII только ASCII символы переводятся в верхний регистр; для OCTETS -- вся входная строка возвращается без изменений.

[[fblangref-scalarfuncs-upper-exmpl]]
==== Примеры `UPPER`

.Использование функции `UPPER`
[example]
====
[source,sql]
----
select upper(_iso8859_1 'Débâcle')
from rdb$database
-- returns 'DÉBÂCLE'

select upper(_iso8859_1 'Débâcle' collate fr_fr)
from rdb$database
-- returns 'DEBACLE', following French uppercasing rules
----
====

.См. также:
<<fblangref-scalarfuncs-lower>>.

[[fblangref-functions-datetime]]
== Функции для работы с датой и временем

[[fblangref-scalarfuncs-dateadd]]
=== `DATEADD()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
DATEADD (<args>)
                            
<args> ::= <amount> <unit> TO <datetime>
         | <unit>, <amount>, <datetime>
                            
<unit> ::= 
    YEAR | MONTH | WEEK | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
----

[[fblangref-funcs-tbl-dateadd]]
.Параметры функции `DATEADD`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|amount
|Выражение типа `SMALLINT`, `INTEGER`, `BIGINT` или `NUMERIC` (отрицательное вычитается).

|unit
|Составляющая даты/времени.

|datetime
|Выражение типа `DATE`, `TIME` или `TIMESTAMP`.
|===

.Тип возвращаемого результата
`DATE`, `TIME` или `TIMESTAMP`.

Функция `DATEADD` позволяет добавить заданное число лет, месяцев, недель, часов, минут, секунд, миллисекунд к заданному значению даты/времени.

[NOTE]
====
* С аргументом типа `TIMESTAMP` и `DATE` можно использовать любую составляющую даты/времени <unit>;
* Для типа данных `TIME` разрешается использовать только `HOUR`, `MINUTE`, `SECOND` и `MILLISECOND`.
====

[[fblangref-funcs-tbl-dateadd-exmpl]]
==== Примеры `DATEADD`

.Использование функции `DATEADD`
[example]
====
[source,sql]
----
DATEADD (28 DAY TO CURRENT_DATE)
DATEADD (-6 HOUR TO CURRENT_TIME)
DATEADD (MONTH, 9, DATEOFCONCEPTION)
DATEADD (-38 WEEK TO DATEOFBIRTH)
DATEADD (MINUTE, 90, CAST('NOW' AS TIME))
DATEADD (? YEAR TO DATE '11-SEP-1973')
----

[source,sql]
----
SELECT 
  CAST(DATEADD(-1 * EXTRACT(MILLISECOND FROM ts) MILLISECOND TO ts) AS VARCHAR(30)) AS t, 
  EXTRACT(MILLISECOND FROM ts) AS ms 
FROM ( 
    SELECT TIMESTAMP'2014-06-09 13:50:17.4971' as ts 
    FROM RDB$DATABASE 
) a
----

[listing]
----
T                             MS
------------------------------------    
2014-06-09 13:50:17.0000	497.1
----
====

.См. также:
<<fblangref-scalarfuncs-datediff>>,
<<fblangref-datatypes-datetimeops>>.

[[fblangref-scalarfuncs-datediff]]
=== `DATEDIFF()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
DATEDIFF (<args>)
                            
<args> ::= <unit> FROM <moment_1> TO <moment_2>
         | <unit>, <moment_1>, <moment_2>
                            
<unit> ::= 
    YEAR | MONTH | WEEK | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
----

[[fblangref-funcs-tbl-datediff]]
.Параметры функции `DATEDIFF`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|unit
|Составляющая даты/времени.

|monent_1
|Выражение типа `DATE`, `TIME` или `TIMESTAMP`.

|monent_2
|Выражение типа `DATE`, `TIME` или `TIMESTAMP`.
|===

.Тип возвращаемого результата:
`BIGINT`

Функция `DATEDIFF` возвращает количество лет, месяцев, недель, дней, часов, минут, секунд или миллисекунд между двумя значениями даты/времени.

Особенности использования: 

* Параметры `DATE` и `TIMESTAMP` могут использоваться совместно. Совместное использование типа `TIME` с типами `DATE` и `TIMESTAMP` не разрешается;
* С аргументом типа `TIMESTAMP` и `DATE` можно использовать любую составляющую даты/времени <unit>;
* Для типа данных TIME разрешается использовать только `HOUR`, `MINUTE`, `SECOND` и `MILLISECOND`.


[NOTE]
====
* Функция `DATEDIFF` не проверяет разницу в более мелких составляющих даты/времени, чем задана в первом аргументе <unit>. В результате получаем:
** `DATEDIFF (YEAR, DATE '1-JAN-2009', DATE '31-DEC-2009')` вернёт 0, но
** `DATEDIFF (YEAR, DATE '31-DEC-2009', DATE '1-JAN-2010')` вернёт 1
* Однако для более мелких составляющих даты/времени имеем: 
** `DATEDIFF (DAY, DATE '26-JUN-1908', DATE '11-SEP-1973')` вернёт 23818
** `DATEDIFF (DAY, DATE '30-NOV-1971', DATE '8-JAN-1972')` вернёт 39
* Отрицательное значение функции говорит о том, что дата/время в _moment_2_ меньше, чем в _moment_1_.
====

[[fblangref-scalarfuncs-datediff-exmpl]]
==== Примеры `DATEDIFF`

.Использование функции `DATEDIFF`
[example]
====
[source,sql]
----
DATEDIFF (HOUR FROM CURRENT_TIMESTAMP TO TIMESTAMP '12-JUN-2059 06:00')
DATEDIFF (MINUTE FROM TIME '0:00' TO CURRENT_TIME)
DATEDIFF (MONTH, CURRENT_DATE, DATE '1-1-1900')
DATEDIFF (DAY FROM CURRENT_DATE TO CAST (? AS DATE))
----
====

.См. также:
<<fblangref-scalarfuncs-dateadd>>,
<<fblangref-datatypes-datetimeops>>.

[[fblangref-scalarfuncs-extract]]
=== `EXTRACT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
EXTRACT (<part> FROM <datetime>)
                            
<part> ::= 
    YEAR | MONTH | WEEK | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
  | TIMEZONE_HOUR | TIMEZONE_MINUTE
----

[[fblangref-funcs-tbl-extract]]
.Параметры функции `EXTRACT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|part
|Составляющая даты/времени.

|datetime
|Выражение типа `DATE`, `TIME` или `TIMESTAMP`.
|===

.Тип возвращаемого результата:
`SMALLINT` или `NUNERIC`

Функция `EXTRACT` извлекает составляющие даты и времени из типов данных `DATE`, `TIME` и `TIMESTAMP`.

[[fblangref-tbl-extractranges]]
.Типы и диапазоны результатов функции `EXTRACT`
[cols="<1m,<1m,<1,<2", options="header"]
|===
| Составляющая даты/времени
| Тип
| Диапазон
| Комментарий

|YEAR 
|SMALLINT 
|1–9999 
|Год

|MONTH 
|SMALLINT 
|1–12 
|Месяц

|WEEK 
|SMALLINT 
|1–53 
|Номер недели в году

|DAY 
|SMALLINT 
|1–31 
|День

|WEEKDAY 
|SMALLINT 
|0–6 
|День недели. 0 -- Воскресенье 

|YEARDAY 
|SMALLINT 
|0–365 
|Номер дня в году. 0 = 1 января 

|HOUR 
|SMALLINT 
|0–23 
|Часы

|MINUTE 
|SMALLINT 
|0–59 
|Минуты

|SECOND 
|NUMERIC(9,4) 
|0.0000–59.9999 
|Секунды. Включает в себя миллисекунды 

|MILLISECOND 
|NUMERIC(9,1) 
|0.0–999.9 
|Миллисекунды

|TIMEZONE_HOUR
|SMALLINT
|от -14 до +14
|Смещение часов часового пояса

|TIMEZONE_MINUTE
|SMALLINT
|от -59 до +59
|Смещение минут часового пояса
|===

[NOTE]
====
Если составляющая даты/времени не присутствует в аргументе дата/время, например SECOND в аргументе с типом DATE или YEAR в TIME, то функция вызовет ошибку.
====

Из аргумента с типом данных `DATE` или `TIMESTAMP` можно извлекать номер недели.
В соответствии со стандартом ISO-8601 неделя начинается с понедельника и всегда включает в себя 7 дней.
Первой неделей года является первая неделя, у которой в ней больше дней в новом году (по крайней мере, 4): дни 1-3 могут принадлежать предыдущей неделе (52 или 53) прошлого года.
По аналогии дни 1-3 текущего года могут принадлежать 1 неделе следующего года. 

.Использование функции `EXTRACT`
[example]
====
[source,sql]
----
/* получить по дате номер квартала */
SELECT (EXTRACT(MONTH FROM CURRENT_TIMESTAMP)-1)/3+1
FROM RDB$DATABASE
----
====

.См. также:
<<fblangref-datatypes-datetime,Типы данных для работы с датой и временем>>.

[[fblangref-scalarfuncs-firstday]]
=== `FIRST_DAY()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
FIRST_DAY(OF <period> FROM _date_or_timestamp_)

<period> ::= YEAR | MONTH | WEEK
----

.Параметры функции `FIRST_DAY`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|date_or_timestamp
|Выражение типа `DATE` или `TIMESTAMP [WITH | WITHOUT] TIME ZONE`.
|===

.Тип возвращаемого результата
`DATE` или `TIMESTAMP [WITH | WITHOUT] TIME ZONE`

Возвращает первый день года, месяца или недели для заданной даты.

[NOTE]
====
* Первым днём недели считается воскресенье, как это возвращает функция `EXTRACT` с частью `WEEKDAY`.
* Когда в качестве аргумента функции передаётся выражение типа `TIMESTAMP`, то возвращаемое значение сохраняет временную часть.
====

[[fblangref-scalarfuncs-firstday-exmpl]]
==== Примеры `FIRST_DAY`

.Использование функции `FIRST_DAY`
[example]
====
[source,sql]
----
SELECT FIRST_DAY(OF MONTH FROM current_date) FROM rdb$database;
SELECT FIRST_DAY(OF YEAR FROM current_timestamp) FROM rdb$database;
SELECT FIRST_DAY(OF WEEK FROM date '2017-11-01') FROM rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-lastday>>.

[[fblangref-scalarfuncs-lastday]]
=== `LAST_DAY()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
LAST_DAY(OF <period> FROM _date_or_timestamp_)
                            
<period> ::=  YEAR | MONTH | WEEK
----

.Параметры функции `LAST_DAY`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|date_or_timestamp
|Выражение типа `DATE` или `TIMESTAMP [WITH | WITHOUT] TIME ZONE`.
|===

.Тип возвращаемого результата
`DATE` или `TIMESTAMP [WITH | WITHOUT] TIME ZONE`

Возвращает последний день года, месяца или недели для заданной даты.

[NOTE]
====
* Последним днём недели считается суббота, как это возвращает функция `EXTRACT` с частью `WEEKDAY`.
* Когда в качестве аргумента функции передаётся выражение типа `TIMESTAMP`, то возвращаемое значение сохраняет временную часть.
====

[[fblangref-scalarfuncs-lastday-lastday]]
==== Примеры `LAST_DAY`

.Использование функции `LAST_DAY`
[example]
====
[source,sql]
----
SELECT LAST_DAY(OF MONTH FROM current_date) FROM rdb$database;
SELECT LAST_DAY(OF YEAR FROM current_timestamp) FROM rdb$database;
SELECT LAST_DAY(OF WEEK FROM date '2017-11-01') FROM rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-firstday>>.

[[fblangref-functions-decfloat]]
== Функции для работы с типом DECFLOAT

[[fblangref-scalarfuncs-comparedecfloat]]
=== `COMPARE_DECFLOAT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
COMPARE_DECFLOAT (_decfloat1_, _decfloat2_)
----

[[fblangref-scalarfuncs-tbl-comparedecfloat]]
.Параметры функции `COMPARE_DECFLOAT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|__decfloat1__, __decfloat2__
|Значения или выражения типа `DECFLOAT` или быть совместимыми с типом `DECFLOAT`.
|===

.Тип возвращаемого результата
`SMALLINT`

Функция `COMPARE_DECFLOAT` сравнивает два значения типа `DECFLOAT`, которые могут быть одинаковыми, разными или неупорядоченными.

Функция возвращает:

[horizontal]
`0`:: Значения равны;
`1`:: Первое значение меньше чем второе;
`2`:: Первое значение больше чем второе;
`3`:: Значения не упорядочены (одно или оба `NaN`/`sNaN`).

В отличие от операторов сравнения ('```<```', '```=```', '```>```' и др.) сравнение является точным,
т.е. `COMPARE_DECFLOAT(2.17, 2.170)` вернёт `2`, а не `0`.

См. также:
<<fblangref-scalarfuncs-totalorder>>

[[fblangref-scalarfuncs-normalize_decfloat]]
=== `NORMALIZE_DECFLOAT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
NORMALIZE_DECFLOAT (_decfloat_value_)
----

[[fblangref-scalarfuncs-tbl-normalizedecfloat]]
.Параметры функции `NORMALIZE_DECFLOAT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|decfloat_value
|Значение или выражение типа `DECFLOAT` или быть совместимым с типом `DECFLOAT`.
|===

.Тип возвращаемого результата
`DECFLOAT`

Функция `NORMALIZE_DECFLOAT` возвращает число в нормализованном виде.
Это обозначает, что для любого ненулевого значения удаляются завершающие нули с соответствующей коррекцией экспоненты.

[[fblangref-scalarfuncs-normalizedecfloat-exmpl]]
==== Примеры `NORMALIZE_DECFLOAT`

.Нормализация различных значений типа `DECFLOAT`
[example]
====
[source,sql]
----
NORMALIZE_DECFLOAT(12.00) -- возвращает 12
NORMALIZE_DECFLOAT(120) -- возвращает 1.2E+2
----
====

[[fblangref-scalarfuncs-quantize]]
=== `QUANTIZE()`

.Доступно в
DSQL, PSQL

.Синтаксис

[listing,subs=+quotes]
----
QUANTIZE (_decfloat_value_, _exp_value_)
----

[[fblangref-scalarfuncs-tbl-quantize]]
.Параметры функции `QUANTIZE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|decfloat_value
|Значение или выражение типа `DECFLOAT` или быть совместимым с типом `DECFLOAT`.

|exp_value
|Значение или выражение для использования в качестве показателя степени;
должно иметь тип `DECFLOAT` или быть совместимым с типом `DECFLOAT`.
|===

.Тип возвращаемого результата
`DECFLOAT`

Функция `QUANTIZE` возвращает значение первого аргумента масштабированным с использованием второго значения в качестве шаблона.
Другими словами функция `QUANTIZE` возвращает значение `DECFLOAT`, равное по значению (за исключением любого округления) и знаку _decfloat_value_, а также экспоненте, равной по значению экспоненте _exp_value_.
Функцию `QUANTIZE` можно использовать для реализации округления с точностью до нужного знака, например, округление до ближайшего цента с использованием установленного режима округления `DECFLOAT`.

Тип возвращаемого значения -- `DECFLOAT(16)`, если оба аргумента -- `DECFLOAT(16)`, в противном случае тип результата -- `DECFLOAT(34)`.

[NOTE]
====
Целевой показатель -- это показатель, используемый в формате хранения `Decimal64` или `Decimal128` для `DECFLOAT` из _exp_value_.
Это не обязательно то же самое, что экспонента, отображаемая в таких инструментах, как _isql_.
Например, значение `1.23E+2` - это коэффициент `123` и показатель степени `0`,
а значение `1.2` - это коэффициент `12` и показатель степени `-1`.
====

Если показатель _decfloat_value_ больше, чем показатель _exp_value_, коэффициент _decfloat_value_ умножается на степень десяти, и его показатель уменьшается, если показатель меньше, то его коэффициент округляется с использованием текущего режима округления decfloat, и его показатель увеличивается.

Когда невозможно достичь целевого показателя экспоненты, поскольку коэффициент превысит целевую точность (16 или 34 десятичных знака), то либо возникает ошибка "`__Decfloat float invalid operation__`", либо возвращается `NaN` (в зависимости от текущего конфигурация decfloat traps).

Ограничений на _exp_value_ практически нет.
Однако почти во всех случаях использования `NaN`/`sNaN`/`Infinity` будет вызывать исключение
(если это не разрешено текущей конфигурацией decfloat traps)

Если одно из значений `NULL`, то результатом функции будет `NULL` и т.д.

.Использование функции `QUANTIZE`
[example]
====
[source,sql]
----
select v, pic, quantize(v, pic) from examples;
----

[listing]
----
V                       PIC                   QUANTIZE
======================= ===================== ==================
                   3.16                 0.001              3.160
                   3.16                 0.01               3.16
                   3.16                 0.1                3.2
                   3.16                 1                  3
                   3.16                 1E+1               0E+1
                   -0.1                 1                 -0
                      0                 1E+5               0E+5
                    316                 0.1              316.0
                    316                 1                316
                    316                 1E+1             3.2E+2
                    316                 1E+2               3E+2
----
====

[[fblangref-scalarfuncs-totalorder]]
=== `TOTALORDER()`

.Доступно в
DSQL, PSQL

.Синтаксис

[listing,subs=+quotes]
----
TOTALORDER (_decfloat1_, _decfloat2_)
----

.Параметры функции `TOTALORDER`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|_decfloat1_, _decfloat2_
|Значение или выражение типа `DECFLOAT` или быть совместимым с типом `DECFLOAT`.
|===

.Тип возвращаемого результата
`SMALLINT`

Функция `TOTALORDER` сравнивает два значения типа `DECFLOAT`, включая специальные значения.
Сравнение является точным. 

Функция возвращает:

* -1 -- если первое значение меньше второго;
* 0 -- если значения равны;
* 1 -- если первое значение больше второго.

Сравнений значений `DEFLOAT` происходит в следующем порядке:

[listing]
----
-nan < -snan < -inf < -0.1 < -0.10 < -0 < 0 < 0.10 < 0.1 < inf < snan < nan
----

См. также:
<<fblangref-scalarfuncs-comparedecfloat>>

[[fblangref-functions-binary]]
== Кодирование и декодирование бинарных данных

[[fblangref-scalarfuncs-base64decode]]
=== `BASE64_DECODE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BASE64_DECODE (_base64_data_)
----

[[fblangref40-scalarfuncs-tbl-base64decode]]
.Параметры функции `BASE64_DECODE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|base64_data
|Данные в кодировке Base64, дополненные знаком `=` до длины кратной 4
|===

.Тип возвращаемого результата
`BLOB` или `VARBINARY`

`BASE64_DECODE` декодирует строку с данными закодированными алгоритмом base64
и возвращает декодированное значение как `VARBINARY` или `BLOB` в зависимости от входного аргумента.

Если длина типа _base64_data_ не кратна 4, то во время подготовки возникает ошибка.
Если длина значения _base64_data_ не кратна 4, то во время выполнения возникает ошибка.

Когда входной аргумент не является `BLOB`, то длина результирующего типа вычисляется как
`__type_length__ * 3/4`, где _type_length_ -- максимальная длина в байтах типа входного аргумента.


[[fblangref-scalarfuncs-base64decode-exmpl]]
==== Примеры `BASE64_DECODE`

.Использование `BASE64_DECODE`
[example]
====
[source,sql]
----
select cast(base64_decode('VGVzdCBiYXNlNjQ=') as varchar(12))
from rdb$database;
----

[listing]
----
CAST

============
Test base64
----
====

.См. также:
<<fblangref-scalarfuncs-base64encode>>.

[[fblangref-scalarfuncs-base64encode]]
=== `BASE64_ENCODE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BASE64_ENCODE (_binary_data_)
----

[[fblangref-scalarfuncs-tbl-base64encode]]
.Параметры функции `BASE64_ENCODE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|binary_data
|Двоичные данные для кодирования
|===

.Тип возвращаемого результата
`VARCHAR CHARACTER SET ASCII` или `BLOB SUB_TYPE TEXT CHARACTER SET ASCII`

Функция `BASE64_ENCODE` кодирует _binary_data_ с помощью алгоритма base64 и
возвращает закодированное значение как `VARCHAR CHARACTER SET ASCII` или `BLOB SUB_TYPE TEXT CHARACTER SET ASCII`
в зависимости от типа входного аргумента.
Возвращаемое значение дополняется знаком '```=```', чтобы его длина была кратна 4.

Когда входной аргумент не является `BLOB`, длина результирующего типа вычисляется как `__type_length__ * 4 / 3` с округлением в большую сторону до числа, кратного четырем, где _type_length_ -- максимальная длина входного типа в байтах.

[[fblangref-scalarfuncs-base64encode-exmpl]]
==== Примеры `BASE64_ENCODE`

.Использование функции `BASE64_ENCODE`
[example]
====
[source,sql]
----
select base64_encode('Test base64')
from rdb$database;
----

[listing]
----
BASE64_ENCODE
================
VGVzdCBiYXNlNjQ=
----
====

.См. также:
<<fblangref-scalarfuncs-base64decode>>, <<fblangref-scalarfuncs-hexencode>>.

[[fblangref-scalarfuncs-hexdecode]]
=== `HEX_DECODE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
HEX_DECODE (_hex_data_)
----

[[fblangref-scalarfuncs-tbl-hexdecode]]
.Параметры функции `HEX_DECODE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|hex_data
|Данные в шестнадцатеричном представлении.
|===

.Тип возвращаемого результата
`VARBINARY` или `BLOB`

Функция `HEX_DECODE` декодирует строку с шестнадцатеричными данными и возвращает декодированное значение
как `VARBINARY` или `BLOB` в зависимости от типа входного и размера аргумента.
Если длина типа _hex_data_ не кратна 2, во время подготовки возникает ошибка.
Если длина значения _hex_data_ не кратна 2, во время выполнения возникает ошибка.

Когда входной аргумент не является `BLOB`, то длина результирующего типа вычисляется как `__type_length__ / 2`,
где _type_length_ -- максимальная длина в байтах типа входного аргумента.

[[fblangref-scalarfuncs-hexdecode-exmpl]]
==== Примеры `HEX_DECODE`

.Использование функции `HEX_DECODE`
[example]
====
[source,sql]
----
select cast(hex_decode('48657861646563696D616C') as varchar(12))
from rdb$database;
----

[listing]
----
CAST
============
Hexadecimal
----
====

.См. также:
<<fblangref-scalarfuncs-hexencode>>, <<fblangref-scalarfuncs-base64decode>>.


[[fblangref-scalarfuncs-hexencode]]
=== `HEX_ENCODE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
HEX_ENCODE (_binary_data_)
----

[[fblangref40-scalarfuncs-tbl-hexencode]]
.Параметры функции `HEX_ENCODE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|binary_data
|Двоичные данные для кодирования
|===

.Тип возвращаемого результата:
`VARCHAR CHARACTER SET ASCII` или `BLOB SUB_TYPE TEXT CHARACTER SET ASCII`

Функция `HEX_ENCODE` кодирует _binary_data_ шестнадцатеричным числом и возвращает закодированное значение
как `VARCHAR CHARACTER SET ASCII` или `BLOB SUB_TYPE TEXT CHARACTER SET ASCII` в зависимости от входного аргумента.

Когда входной аргумент не является `BLOB`, то длина результирующего типа вычисляется как `__type_length__ * 2`,
где _type_length_ -- максимальная длина в байтах типа входного аргумента.

[[fblangref-scalarfuncs-hexencode-exmpl]]
==== Примеры `HEX_ENCODE`

.Использование функции `HEX_ENCODE`
[example]
====
[source,sql]
----
select hex_encode('Hexadecimal')
from rdb$database;
----

[listing]
----
HEX_ENCODE
======================
48657861646563696D616C
----
====

.См. также:
<<fblangref-scalarfuncs-hexdecode>>, <<fblangref-scalarfuncs-base64encode>>


[[fblangref-functions-crypt]]
== Криптографические функции

В Firebird 4.0 поддерживается только подмножество симметричных алгоритмов шифрования (как блочных так и потоковых), так и RSA.

[[fblangref-scalarfuncs-crypthash]]
=== `CRYPT_HASH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
CRYPT_HASH (_value_ USING <algorithm>)

<algorithm> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----

[[fblangref-scalarfuncs-tbl-crypthash]]
.Параметры функции `CRYPT_HASH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение любого типа. Не строковые и не бинарные типы приводятся к строке.

|algorithm
|Алгоритм хеширования.
|===

.Тип возвращаемого результата
`VARBINARY`

Функция `CRYPT_HASH` возвращает криптографический хэш входной строки, используя указанный алгоритм.
Эта функция полностью поддерживает текстовые `BLOB` любой длины и с любым набором символов.
Предложение `USING` позволяет указать алгоритм по которому вычисляет хэш.

[NOTE]
====
Алгоритмы `MD5` и `SHA1` не рекомендуются для использования из-за известных серьезных проблем, которые предоставляются *только* для обратной совместимости.
====

[[fblangref-scalarfuncs-crypthash-exmpl]]
==== Примеры `CRYPT_HASH`

.Использование функции `CRYPT_HASH`
[example]
====
[source,sql]
----
SELECT CRYPT_HASH(x USING SHA256) FROM MyTable;
-- результат типа VARBINARY
----
====


[[fblangref-scalarfuncs-decrypt]]
=== `DECRYPT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
DECRYPT (_encrypted_input_
  [USING <algorithm>] [MODE <mode>]
  KEY _key_
  [IV _iv_] [<ctr_type>] [CTR_LENGTH _ctr_length_]
  [COUNTER _initial_counter_] )

<algorithm> ::= <block_cipher> | <stream_cipher>

<block_cipher> ::=
    AES | ANUBIS | BLOWFISH | KHAZAD | RC5
  | RC6 | SAFER+ | TWOFISH | XTEA

<stream_cipher> ::= CHACHA20 | RC4 | SOBER128

<mode> ::= CBC | CFB | CTR | ECB | OFB

<ctr_type> ::= CTR_BIG_ENDIAN | CTR_LITTLE_ENDIAN
----


.Параметры функции `DECRYPT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|encrypted_input
|Зашифрованный BLOB или (двоичная) строка

|algorithm
|Алгоритм шифрования.
Поддерживаются как блочные, так и потоковые алгоритмы.

|mode
|Режим шифрования.
Обязателен для блочных алгоритмов шифрования.

|key
|Ключ шифрования.

|iv
|Вектор инициализации (IV). Должен быть указан для всех блочных алгоритмов шифрования за исключением `ECB` и всех потоковых алгоритмов шифрования за исключением `RC4`.

|ctr_type
|Порядок байтов счётчика.
Может быть указан только в режиме `CTR`.
По умолчанию используется `CTR_LITTLE_ENDIAN`.

|ctr_length
|Длина счётчика в байтах.
Может быть указана только в режиме `CTR`.
По умолчанию равна длине вектора инициализации IV.

|initial_counter
|Начальное значение счётчика.
Может быть указана только для алгоритма `CHACHA20`.
По умолчанию равно 0.
|===

.Тип возвращаемого результата
`BLOB` или `VARBINARY`.

Функция `DECRYPT` дешифрует данные с использованием симметричного шифра.
Размеры строк передаваемых в эту функцию должны соответствовать требованиям выбранного алгоритма и режима.


.Использование функции `DECRYPT`
[example]
====
[source,sql]
----
select decrypt(x'0154090759DF' using sober128 key 'AbcdAbcdAbcdAbcd'
               iv '01234567')
from rdb$database;

select decrypt(secret_field using aes mode ofb key '0123456701234567'
               iv init_vector)
from secure_table;
----
====

.См. также:
<<fblangref-scalarfuncs-encrypt>>.


[[fblangref-scalarfuncs-encrypt]]
=== `ENCRYPT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
ENCRYPT (_input_
  [USING <algorithm>] [MODE <mode>]
  KEY _key_
  [IV _iv_] [<ctr_type>] [CTR_LENGTH _ctr_length_]
  [COUNTER _initial_counter_] )
                            
<algorithm> ::= <block_cipher> | <stream_cipher>

<block_cipher> ::= 
    AES | ANUBIS | BLOWFISH | KHAZAD | RC5
  | RC6 | SAFER+ | TWOFISH | XTEA

<stream_cipher> ::= CHACHA20 | RC4 | SOBER128

<mode> ::= CBC | CFB | CTR | ECB | OFB

<ctr_type> ::= CTR_BIG_ENDIAN | CTR_LITTLE_ENDIAN
----

.Параметры функции `ENCRYPT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|input
|Выражение строкового типа или `BLOB`, которое необходимо зашифровать.

|algorithm
|Алгоритм шифрования.
Поддерживаются как блочные, так и потоковые алгоритмы.

|mode
|Режим шифрования.
Обязателен для блочных алгоритмов шифрования.

|key
|Ключ шифрования.

|iv
|Вектор инициализации (IV). Должен быть указан для всех блочных алгоритмов шифрования за исключением `ECB` и всех потоковых алгоритмов шифрования за исключением `RC4`.

|ctr_type
|Порядок байтов счётчика.
Может быть указан только в режиме `CTR`.
По умолчанию используется `CTR_LITTLE_ENDIAN`.

|ctr_length
|Длина счётчика в байтах.
Может быть указана только в режиме `CTR`.
По умолчанию равна длине вектора инициализации IV.

|initial_counter
|Начальное значение счётчика.
Может быть указана только для алгоритма `CHACHA20`.
По умолчанию равно 0.
|===

.Тип возвращаемого результата
`BLOB` или `VARBINARY`

Функция `ENCRYPT` шифрует данные с использованием симметричного шифра.
Размеры строк передаваемых в эту функцию должны соответствовать требованиям выбранного алгоритма и режима.


.Использование функции `ENCRYPT`
[example]
====
[source,sql]
----
select encrypt('897897' using sober128 key 'AbcdAbcdAbcdAbcd' iv '01234567') 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-decrypt>>.


[[fblangref-scalarfuncs-rsa_private]]
=== `RSA_PRIVATE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RSA_PRIVATE (_size_)
----

.Параметры функции RSA_PRIVATE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|size
|Размер ключа в байтах.
|===

.Тип возвращаемого результата:
`VARBINARY`

Функция `RSA_PRIVATE` возвращает RSA закрытый ключ заданной длины (в байтах) в PKCS#1 формате как строку `VARBINARY`.


.Использование функции `RSA_PRIVATE`
[example]
====
[source,sql]
----
select rdb$set_context('USER_SESSION', 'private_key', rsa_private(256))
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_public>>.

[[fblangref-scalarfuncs-rsa_public]]
=== `RSA_PUBLIC()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RSA_PUBLIC (_private-key_)
----

.Параметры функции RSA_PUBLIC
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|private-key
|RSA закрытый ключ.
|===

.Тип возвращаемого результата:
`VARBINARY`

Функция `RSA_PUBLIC` возвращает RSA открытый ключ для заданного RSA закрытого ключа.
Оба ключа должны быть в PKCS#1 формате.

.Использование функции `RSA_PUBLIC`
[example]
====
Закрытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_private,RSA_PRIVATE>>

[source,sql]
----
select rdb$set_context('USER_SESSION', 'public_key',
    rsa_public(rdb$get_context('USER_SESSION', 'private_key'))) 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_private>>.

[[fblangref-scalarfuncs-rsa_encrypt]]
=== `RSA_ENCRYPT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RSA_ENCRYPT (<data> KEY <public_key> [LPARAM <tag>] [HASH <hash>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----

.Параметры функции `RSA_ENCRYPT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|data
|Данные (строка или BLOB) для шифрования.

|public_key
|Открытый RSA ключ, который возвращает функция `RSA_PUBLIC`.

|tag
|Дополнительный системный тег, который можно применять для определения того, какая система закодировала сообщение.
Значением по умолчанию является `NULL`.

|hash
|Алгоритм хеширования.
По умолчанию SHA256.
|===

.Тип возвращаемого результата:
`VARBINARY`

Заполняет данные, используя заполнение OAEP, и шифрует их, используя открытый ключ RSA.
Обычно используется для шифрования коротких симметричных ключей, которые затем используются в блочных шифрах для шифрования сообщения.

.Использование функции `RSA_ENCRYPT`
[example]
====
Открытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_public>>


[source,sql]
----
select rdb$set_context('USER_SESSION', 'msg', 
    rsa_encrypt('Some message' key rdb$get_context('USER_SESSION', 'public_key'))) 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_public>>, <<fblangref-scalarfuncs-rsa_decrypt>>.

[[fblangref-scalarfuncs-rsa_decrypt]]
=== `RSA_DECRYPT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RSA_DECRYPT (<data> KEY <private_key> [LPARAM <tag>] [HASH <hash>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----


.Параметры функции `RSA_DECRYPT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|data
|Данные (строка или BLOB) для дешифрования.

|private_key
|Закрытый RSA ключ, который возвращает функция `RSA_PRIVATE`.

|tag
|Дополнительный системный тег.
Должно быть тем же самым значением, которое передавалось `RSA_ENCRYPT`.
Если оно не совпадает с тем, который использовался во время кодирования, эта функция не расшифровывает пакет.
Значением по умолчанию является `NULL`.

|hash
|Алгоритм хеширования.
По умолчанию SHA256.
|===

.Тип возвращаемого результата:
`VARCHAR`

Расшифровывает с использованием закрытого ключа RSA, и удаляет OAEP дополненные данные.

.Использование функции RSA_DECRYPT
[example]
====
Закрытый ключ должен быть инициализирован ранее см. пример в <<fblangref-scalarfuncs-rsa_private>>.
Данные для расшифровки используются из примера в <<fblangref-scalarfuncs-rsa_encrypt>>.

[source,sql]
----
select RSA_DECRYPT(rdb$get_context('USER_SESSION', 'msg')
    key rdb$get_context('USER_SESSION', 'private_key'))
from RDB$DATABASE;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_private>>, <<fblangref-scalarfuncs-rsa_encrypt>>.

[[fblangref-scalarfuncs-rsa_sign_hash]]
=== `RSA_SIGN_HASH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RSA_SIGN_HASH (<data> KEY <private_key> [HASH <hash>] [SALT_LENGTH <length>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----

.Параметры функции `RSA_SIGN_HASH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|data
|Данные (строка или BLOB) для кодирования.

|private_key
|Закрытый RSA ключ, который возвращает функция `RSA_PRIVATE`.

|hash
|Алгоритм хеширования.
По умолчанию SHA256.

|length
|Указывает на длину желаемой соли и, как правило, должен быть небольшим.
Хорошее значение от 8 до 16.
|===

.Тип возвращаемого результата:
`VARBINARY`

Выполняет PSS-кодирование дайджеста сообщения для подписи и подписывает его с использованием закрытого ключа RSA.
Возвращает подпись сообщения.

.Использование функции `RSA_SIGN_HASH`
====
Закрытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_private>>.

[source,sql]
----
select rdb$set_context('USER_SESSION', 'msg', 
    rsa_sign_hash(crypt_hash('Test message' using sha256)
                  key rdb$get_context('USER_SESSION', 'private_key')))
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_private>>, <<fblangref-scalarfuncs-rsa_verify_hash>>.

[[fblangref-scalarfuncs-rsa_verify_hash]]
=== `RSA_VERIFY_HASH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RSA_VERIFY_HASH (<data> SIGNATURE <signature> KEY <public_key> [HASH <hash>] 
  [SALT_LENGTH <length>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----

.Параметры функции `RSA_VERIFY_HASH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|data
|Данные (строка или BLOB) для кодирования.

|signature
|Подпись.
Должно быть значением возвращаемым функцией `RSA_SIGN_HASH`.

|public_key
|Открытый RSA ключ, который возвращает функция `RSA_PUBLIC`.

|hash
|Алгоритм хеширования.
По умолчанию SHA256.

|length
|Указывает на длину желаемой соли и, как правило, должен быть небольшим.
Хорошее значение от 8 до 16.
|===

.Тип возвращаемого результата
`BOOLEAN`

Выполняет PSS-кодирование дайджеста сообщения для подписи и проверяет его цифровую подпись, используя открытый ключ RSA.
Возвращает результат проверки подписи.


.Использование функции `RSA_VERIFY_HASH`
[example]
====
Открытый ключ должен быть инициализирован ранее см. пример в <<fblangref-scalarfuncs-rsa_public>>.
Цифровая подпись получена ранее с помощью функции <<fblangref-scalarfuncs-rsa_sign_hash>>.

[source,sql]
----
select rsa_verify_hash(crypt_hash('Test message' using sha256) 
    signature rdb$get_context('USER_SESSION', 'msg')
    key rdb$get_context('USER_SESSION', 'public_key')) 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_sign_hash>>, <<fblangref-scalarfuncs-rsa_public>>.

[[_fblangref_functions_casting]]
== Функции преобразования типов

[[fblangref-scalarfuncs-cast]]
=== `CAST()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes,macros"]
----
CAST(_value_ | NULL AS <type>)
                            
<type> ::= 
    <datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN _relname_._colname_

<datatype> ::= 
    <scalar_datatype> | <blob_datatype> | <array_datatype>                    
                    
<scalar_datatype> ::=  См. <<fblangref-datatypes-syntax-scalar,Синтаксис скалярных типов данных>>

<blob_datatype> ::= См. <<fblangref-datatypes-syntax-blob,Синтаксис типа данных BLOB>>

<array_datatype> ::= См. <<fblangref-datatypes-syntax-array,Синтаксис массивов>>
----

.Параметры функции CAST
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|SQL выражение.

|datatype
|Тип данных SQL.

|domain
|Домен.

|relname
|Имя таблицы или представления.

|colname
|Имя столбца таблицы или представления.
|===

.Тип возвращаемого результата:
[replaceable]``<type>``.

Функция CAST служит для явного преобразования данных из одного типа данных в другой тип данных или домен.
Если это невозможно будет выдана ошибка.

.Допустимые преобразования для функции `CAST`
[cols="<1,<3", options="header",stripes="none"]
|===
| Из типа
| В тип

|Числовые типы
|Числовые типы, `[VAR]CHAR`, `BLOB`

|`[VAR]CHAR`, `BLOB`
|`[VAR]CHAR`, `BLOB`, `BOOLEAN`, Числовые типы, `DATE`, `TIME`, `TIMESTAMP`

|`DATE`, `TIME`
|`[VAR]CHAR`, `BLOB`, `TIMESTAMP`

|`TIMESTAMP`
|`[VAR]CHAR`, `BLOB`, `TIME`, `DATE`

|`BOOLEAN`
|`[VAR]CHAR`, `BLOB`
|===

Имейте в виду, что иногда информация может быть потерянна, например, когда вы преобразуете тип `TIMESTAMP` к `DATE`.
Кроме того, тот факт, что типы совместимы для функции `CAST`, ещё не гарантирует, что преобразование будет успешным.
"`CAST (123456789 AS SMALLINT)`" безусловно приведёт к ошибке, так же как и "`CAST('Judgement Day' as DATE)`".

Вы можете применить преобразование типа к параметрам оператора:

[source,sql]
----
CAST (? AS INTEGER)
----

Это дает вам контроль над типом полей ввода. 

==== Преобразование к домену или к его базовому типу

При преобразовании к домену должны быть удовлетворены любые ограничения (NOT NULL и/или CHECK) объявленные для домена, иначе преобразование не будет выполнено.
Помните, что проверка CHECK проходит, если его вычисление даёт TRUE или UNKNOWN (NULL). Для следующих операторов: 

[source,sql]
----
CREATE DOMAIN quint AS INT CHECK (VALUE >= 5000)
SELECT CAST (2000 AS quint) FROM rdb$database -- (1)
SELECT CAST (8000 AS quint) FROM rdb$database -- (2)
SELECT CAST (null AS quint) FROM rdb$database -- (3)
----

только (1) завершится с ошибкой. 

При использовании модификатора `TYPE OF` выражение будет преобразовано к базовому типу домена, игнорируя любые ограничения.
Для домена quint, объявленного выше, оба преобразования будут эквивалентны и оба будут успешно выполнены: 

[source,sql]
----
SELECT CAST (2000 AS TYPE OF quint) FROM rdb$database
SELECT CAST (2000 AS INT) FROM rdb$database
----

При использовании `TYPE OF` с `[VAR]CHAR` типом, его набор символов и порядок сортировки (collate) сохраняются.

[source,sql]
----
CREATE DOMAIN iso20 VARCHAR(20) CHARACTER SET iso8859_1;
CREATE DOMAIN dunl20 VARCHAR(20) CHARACTER SET iso8859_1 COLLATE du_nl;
CREATE TABLE zinnen (zin VARCHAR(20));
COMMIT;
INSERT INTO zinnen VALUES ('Deze');
INSERT INTO zinnen VALUES ('Die');
INSERT INTO zinnen VALUES ('die');
INSERT INTO zinnen VALUES ('deze');
SELECT CAST(zin AS TYPE OF iso20) FROM zinnen ORDER BY 1;
-- returns Deze -> Die -> deze -> die
SELECT CAST(zin AS TYPE OF dunl20) FROM zinnen ORDER BY 1;
-- returns deze -> Deze -> die -> Die
----

[WARNING]
====
Если определение домена изменяется, то существующие преобразования к домену или его типу могут стать ошибочными.
Если такие преобразования происходят в PSQL модулях, то их ошибки могут быть обнаружены.
См. <<fblangref-appx-supp-rdb-validblr,Поле RDB$VALID_BLR>>. 
====

==== Преобразование к типу столбца

Разрешено преобразовывать выражение к типу столбца существующей таблицы или представления.
При этом будет использован только сам тип, для строковых типов будет использован так же набор символов, но не последовательность сортировки.
Ограничения и значения по умолчанию исходного столбца не применяются. 

[source,sql]
----
CREATE TABLE ttt (
  s VARCHAR(40) CHARACTER SET utf8 COLLATE unicode_ci_ai
);
COMMIT;  
SELECT CAST ('Jag har många vänner' AS TYPE OF COLUMN ttt.s) 
FROM rdb$database;
----

[WARNING]
====
Если определение столбца изменяется, то существующие преобразования к его типу могут стать ошибочными.
Если такие преобразования происходят в PSQL модулях, то их ошибки могут быть обнаружены.
См. <<fblangref-appx-supp-rdb-validblr,Поле RDB$VALID_BLR>>.
====

.См. также:
<<fblangref-datatypes-convert-explicit>>.

==== Примеры приведения типов

[source,sql]
----
SELECT CAST ('12' || '-June-' || '1959' AS DATE) FROM rdb$database
----

Заметьте, что в некоторых случаях вы можете не использовать синтаксис преобразования как в примере выше, так как Firebird поймёт из контекста (сравнение с полем типа `DATE`) как интерпретировать строку:

[source,sql]
----
UPDATE People SET AgeCat = 'Old'
WHERE BirthDate < '1-Jan-1943'
----

Но это не всегда возможно.
Преобразование в примере ниже не может быть опущено, так как система будет пытаться преобразовать строку к числу чтобы вычесть из неё число: 

[source,sql]
----
SELECT CAST('TODAY' AS DATE) - 7 FROM rdb$database
----

[[fblangref-functions-bitwise]]
== Функции побитовых операций

[[fblangref-scalarfuncs-bin-and]]
=== `BIN_AND()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BIN_AND (_number_, _number_ [, _number_ ...])
----

[[fblangref-funcs-tbl-binand]]
.Параметры функции `BIN_AND`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Целое число.
|===

.Тип возвращаемого результата
`SMALLINT`, `INTEGER`, `BIGINT` или `INT128`

Функция `BIN_AND` возвращает результат побитовой операции AND (И) аргументов.

.См. также:
<<fblangref-scalarfuncs-bin-or>>, <<fblangref-scalarfuncs-bin-xor>>.

[[fblangref-scalarfuncs-bin-not]]
=== `BIN_NOT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BIN_NOT (_number_)
----

[[fblangref-funcs-tbl-binnot]]
.Параметры функции `BIN_NOT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Целое число.
|===

.Тип возвращаемого результата
`SMALLINT`, `INTEGER`, `BIGINT` или `INT128`

Функция `BIN_NOT` возвращает результат побитовой операции `NOT` над аргументом.

.См. также:
<<fblangref-scalarfuncs-bin-or>>, <<fblangref-scalarfuncs-bin-and>>.

[[fblangref-scalarfuncs-bin-or]]
=== `BIN_OR()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BIN_OR (_number_, _number_ [, _number_ ...])
----

[[fblangref-funcs-tbl-binor]]
.Параметры функции `BIN_OR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Целое число.
|===

.Тип возвращаемого результата
`SMALLINT`, `INTEGER`, `BIGINT` или `INT128`

Функция `BIN_OR` возвращает результат побитовой операции OR (ИЛИ) аргументов.

.См. также:
<<fblangref-scalarfuncs-bin-and>>, <<fblangref-scalarfuncs-bin-xor>>.

[[fblangref-scalarfuncs-bin-shl]]
=== `BIN_SHL()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BIN_SHL (_number_, _shift_)
----

[[fblangref-funcs-tbl-binshl]]
.Параметры функции BIN_SHL
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Целое число.

|shift
|Количество бит, на которое смещается значение _number_.
|===

.Тип возвращаемого результата
`BIGINT` или `INT128`.

Функция `BIN_SHL` возвращает первый параметр, побитно смещённый влево на значение второго параметра, т.е. `a << b` или `a·2^b^`.

.См. также:
<<fblangref-scalarfuncs-bin-shr>>.

[[fblangref-scalarfuncs-bin-shr]]
=== `BIN_SHR()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BIN_SHR (_number_, _shift_)
----

[[fblangref-funcs-tbl-binshr]]
.Параметры функции `BIN_SHR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Целое число.

|shift
|Количество бит на которое смещается значение number.
|===

.Тип возвращаемого результата:
`BIGINT` или `INT128`.

Функция `BIN_SHR` возвращает первый параметр, побитно смещённый вправо на значение второго параметра, т.е. `a >> b` или `a/2^b^`.

* Выполняемая операция является арифметическим сдвигом вправо (SAR), а это означает, что знак первого операнда всегда сохраняется.

.См. также:
<<fblangref-scalarfuncs-bin-shl>>.

[[fblangref-scalarfuncs-bin-xor]]
=== `BIN_XOR()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
BIN_XOR (_number_, _number_ [, _number_ ...])
----

[[fblangref-funcs-tbl-binxor]]
.Параметры функции `BIN_XOR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Целое число.
|===

.Тип возвращаемого результата
`SMALLINT`, `INTEGER`, `BIGINT` или `INT128`

Функция `BIN_XOR` возвращает результат побитовой операции `XOR` аргументов.

.См. также:
<<fblangref-scalarfuncs-bin-and>>, <<fblangref-scalarfuncs-bin-or>>.

[[fblangref-functions-uuid]]
== Функции для работы с UUID

[[fblangref-scalarfuncs-char-to-uuid]]
=== `CHAR_TO_UUID()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
CHAR_TO_UUID (_ascii_uuid_)
----

[[fblangref-funcs-tbl-char-to-uuid]]
.Параметры функции `CHAR_TO_UUID`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|ascii_uuid
|36-символьное представление UUID.
'```-```' (дефис) в положениях 9, 14, 19 и 24; допустимые шестнадцатеричные цифры в любых других позициях, т.е.
'A0bF4E45-3029-2a44-D493-4998c9b439A3'.
|===

.Тип возвращаемого результата
`BINARY(16)`

Функция `CHAR_TO_UUID` преобразует читабельную 36-ти символьную символику UUID к соответствующему 16-ти байтовому значению UUID.

[[fblangref-scalarfuncs-char-to-uuid-exmpl]]
==== Примеры `CHAR_TO_UUID`

.Использование функции `CHAR_TO_UUID`
[example]
====
[source,sql]
----
SELECT CHAR_TO_UUID('A0bF4E45-3029-2a44-D493-4998c9b439A3') FROM rdb$database
-- returns A0BF4E4530292A44D4934998C9B439A3 (16-byte string)

SELECT CHAR_TO_UUID('A0bF4E45-3029-2A44-X493-4998c9b439A3') FROM rdb$database
-- error: -Human readable UUID argument for CHAR_TO_UUID must
-- have hex digit at position 20 instead of "X (ASCII 88)"
----
====

.См. также:
<<fblangref-scalarfuncs-gen-uuid>>, <<fblangref-scalarfuncs-uuid-to-char>>.

[[fblangref-scalarfuncs-gen-uuid]]
=== `GEN_UUID()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
GEN_UUID()
----

.Тип возвращаемого результата
`BINARY(16)`

Функция возвращает универсальный уникальный идентификатор ID в виде 16-байтной строки символов, отвечающий требованиям стандарта RFC-4122.
Функция возвращает строку UUID 4-ой версии, где несколько битов зарезервированы, а остальные являются случайными.

[[fblangref30-scalarfuncs-gen-uuid-exmpl]]
==== Примеры `GEN_UUID`

.Использование функции `GEN_UUID`
[example]
====
[source,sql]
----
SELECT GEN_UUID() AS GUID FROM RDB$DATABASE
----

[listing]
----
GUID
========

017347BFE212B2479C00FA4323B36320
----
====

.См. также:
<<fblangref-scalarfuncs-char-to-uuid,CHAR_TO_UUID>>, <<fblangref-scalarfuncs-uuid-to-char,UUID_TO_CHAR>>.

[[fblangref-scalarfuncs-uuid-to-char]]
=== `UUID_TO_CHAR()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
UUID_TO_CHAR (_uuid_)
----

[[fblangref-funcs-tbl-uuid-to-char]]
.Параметры функции `UUID_TO_CHAR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|uuid
|16-байтный UUID.
|===

.Тип возвращаемого результата
`CHAR(36)`

Функция `UUID_TO_CHAR` конвертирует 16-ти байтный UUID в его 36-ти знаковое ASCII человеко-читаемое представление.
Тип возвращаемого значения `CHAR(36)`.

[[fblangref-scalarfuncs-uuid-to-char-exmpl]]
==== Примеры `UUID_TO_CHAR`

.Использование функции `UUID_TO_CHAR`
[example]
====
[source,sql]
----
SELECT UUID_TO_CHAR(GEN_UUID()) FROM RDB$DATABASE;

SELECT UUID_TO_CHAR(x'876C45F4569B320DBCB4735AC3509E5F') FROM RDB$DATABASE;
-- returns '876C45F4-569B-320D-BCB4-735AC3509E5F'

SELECT UUID_TO_CHAR(GEN_UUID()) FROM RDB$DATABASE;
-- returns e.g. '680D946B-45FF-DB4E-B103-BB5711529B86'

SELECT UUID_TO_CHAR('Firebird swings!') FROM RDB$DATABASE;
-- returns '46697265-6269-7264-2073-77696E677321'
----
====

.См. также:
<<fblangref-scalarfuncs-gen-uuid>>, <<fblangref-scalarfuncs-char-to-uuid>>.

[[fblangref-functions-generators]]
== Функции для работы с генераторами (последовательностями)

[[fblangref-scalarfuncs-gen-id]]
=== `GEN_ID()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
GEN_ID (_generator-name_, _step_)
----

[[fblangref-funcs-tbl-gen-id]]
.Параметры функции `GEN_ID`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|generator-name
|Имя генератора (последовательности).

|step
|Шаг приращения.
|===

.Тип возвращаемого результата
`BIGINT`

Функция `GEN_ID` увеличивает значение генератора или последовательности и возвращает новое значение.

Если _step_ равен 0, функция не будет ничего делать со значением генератора и вернёт его текущее значение.

* Начиная с Firebird 2.0 для получения следующего значение последовательности (генератора) стало доступно использование
совместимого с SQL-стандартом оператора <<fblangref-commons-nxtvlufor,`NEXT VALUE FOR`>>.

[WARINING]
====
Если значение параметра _step_ меньше нуля, произойдёт уменьшение значения генератора.
Следует быть крайне аккуратным при таких манипуляциях в базе данных, они могут привести к потере целостности данных.
====

[[fblangref-scalarfuncs-gen-id-exmpl]]
==== Примеры `GEN_ID`

.Использование функции `GEN_ID`
[example]
====
[source,sql]
----
NEW.ID = GEN_ID (GEN_TABLE_ID, 1);
----
====

.См. также:
<<fblangref-commons-nxtvlufor,`NEXT VALUE FOR`>>,
<<fblangref-ddl-sequence,SEQUENCE (GENERATOR)>>,
<<fblangref-ddl-sequence-alter,`ALTER SEQUENCE`>>,
<<fblangref-ddl-sequence-setgen,`SET GENERATOR`>>.


[[fblangref-functions-conditional]]
== Условные функции

[[fblangref-scalarfuncs-coalesce]]
=== `COALESCE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
COALESCE (<exp1>, <exp2> [, <expN> ... ])
----

[[fblangref-funcs-tbl-coalesce]]
.Параметры функции `COALESCE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|exp1, exp2 ... expN
|Выражения любого совместимого типа.
|===

.Тип возвращаемого результата
зависит от типов входных аргументов

Функция `COALESCE` принимает два или более аргумента возвращает значение первого не-`NULL` аргумента.
Если все аргументы имеют значение `NULL`, то и результат будет `NULL`.

[[fblangref-scalarfuncs-coalesce-exmpl]]
==== Примеры `COALESCE`

.Использование функции COALESCE
[example]
====
В данном примере предпринимается попытка использовать все имеющиеся данные для составления полного имени.
Выбирается поле `NICKNAME` из таблицы `PERSONS`.
Если оно имеет значение `NULL`, то берётся значение из поля `FIRSTNAME`.
Если и оно имеет значение `NULL`, то используется строка "```'Mr./Mrs.'```".
Затем к значению функции `COALESCE` добавляется фамилия (поле `LASTNAME`). Обратите внимание, что эта схема нормально работает, только если выбираемые поля имеют значение `NULL` или не пустое значение: если одно из них является пустой строкой, то именно оно и возвратится в качестве значения функции `COALESCE`.

[source,sql]
----
SELECT 
  COALESCE(PE.NICKNAME, PE.FIRSTNAME, 'Mr./Mrs.') ||
  ' ' || PE.LASTNAME AS FULLNAME
FROM PERSONS PE
----
====

.Использование функции COALESCE с агрегатными функциями
[example]
====
В данном примере в случае получения при суммировании значения `NULL` запрос вернёт `0`.

[source,sql]
----
SELECT coalesce (sum (q), 0) 
FROM bills 
WHERE ...
----
====

.См. также:
<<fblangref-commons-conditional-case,`CASE`>>.

[[fblangref-scalarfuncs-decode]]
=== `DECODE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
DECODE(<testexpr>,
  <expr1>, <result1>
  [<expr2>, <result2> …]
  [, <defaultresult>])
----

эквивалентная конструкция `CASE`

[listing]
----
CASE <testexpr>
  WHEN <expr1> THEN <result1>
  [WHEN <expr2> THEN <result2> …]
  [ELSE <defaultresult>]
END
----

[[fblangref-funcs-tbl-decode]]
.Параметры функции `DECODE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|testexpr
|Выражения любого совместимого типа, которое сравнивается с выражениями [replaceable]``expr1``, [replaceable]``expr2`` ... [replaceable]``exprN``

|expr1, expr2, ... exprN
|Выражения любого совместимого типа, с которыми сравнивают с выражением _testexpr_.

|result1, result2, ... resultN
|Возвращаемые выражения любого типа.

|defaultresult
|Выражение, возвращаемое если ни одно из условий не было выполнено.
|===

.Тип возвращаемого результата
зависит от типов входных аргументов

Данная функция эквивалентна конструкции <<fblangref-commons-conditional-case-simple,Простой `CASE`>>, в которой заданное выражение сравнивается с другими выражениями до нахождения совпадения.
Результатом является значение, указанное после выражения, с которым найдено совпадение.
Если совпадений не найдено, то возвращается значение по умолчанию (если оно, конечно, задано -- в противном случае возвращается `NULL`).

[CAUTION]
====
Совпадение эквивалентно оператору '```=```', т.е.
если _testexpr_ имеет значение `NULL`, то он не соответствует ни одному из _expr_, даже тем, которые имеют значение `NULL`.
====

[[fblangref-scalarfuncs-decode-exmpl]]
==== Примеры `DECODE`

.Использование функции `DECODE`
[example]
====
[source,sql]
----
select name,
  age,
  decode(upper(sex),
         'M', 'Male',
         'F', 'Female',
         'Unknown'),
  religion
from people
----
====

.См. также:
<<fblangref-commons-conditional-case,`CASE`>>.

[[fblangref-scalarfuncs-iif]]
=== `IIF()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
IIF (<condition>, _ResultT_, _ResultF_)
----

.Параметры функции IIF
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|condition
|Выражение логического типа.

|resultT
|Возвращаемое значение, если _condition_ является истинным.

|resultF
|Возвращаемое значение, если _condition_ является ложным.
|===

.Тип возвращаемого результата
зависит от типов входных аргументов

Функция `IIF` имеет три аргумента.
Если первый аргумент является истиной, то результатом будет второй параметр, в противном случае результатом будет третий параметр.

Оператор `IIF` также можно сравнить в тройным оператором "```?:```" в C-подобных языках.

[NOTE]
====
По сути, функция `IIF` это короткая запись оператора `CASE`

[listing,subs=+quotes]
----
CASE WHEN <condition> THEN _resultT_ ELSE _resultF_ END
----
====

[[fblangref-scalarfuncs-iif-exmpl]]
==== Примеры `IIF`

.Использование функции `IIF`
[example]
====
[source,sql]
----
SELECT IIF(SEX = 'M', 'Sir', 'Madam') FROM CUSTOMERS
----
====

.См. также:
<<fblangref-commons-conditional-case,`CASE`>>.

[[fblangref-scalarfuncs-maxvalue]]
=== `MAXVALUE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
MAXVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref-funcs-tbl-maxvalue]]
.Параметры функции `MAXVALUE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr1 ... exprN
|Выражения любого совместимого типа.
|===

.Тип возвращаемого результата:
тот же что и первый аргумент функции _expr1_

Возвращает максимальное значение из входного списка чисел, строк или параметров с типом `DATE`/`TIME`/`TIMESTAMP`.

[NOTE]
====
Если один или более входных параметров имеют значение `NULL`, то результатом функции `MAXVALUE` тоже будет `NULL` в отличие от агрегатной функции `MAX`.
====

[[fblangref-scalarfuncs-maxvalue-exmpl]]
==== Примеры `MAXVALUE`

.Использование функции `MAXVALUE`
[example]
====
[source,sql]
----
SELECT MAXVALUE(PRICE_1, PRICE_2) AS PRICE
FROM PRICELIST
----
====

.См. также:
<<fblangref-scalarfuncs-minvalue>>.

[[fblangref-scalarfuncs-minvalue]]
=== `MINVALUE()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
MINVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref-funcs-tbl-minvalue]]
.Параметры функции MINVALUE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr1 ... exprN
|Выражения любого совместимого типа.
|===

.Тип возвращаемого результата
тот же что и первый аргумент функции _expr1_

Возвращает минимальное значение из входного списка чисел, строк или параметров с типом `DATE`/`TIME`/`TIMESTAMP`.

[NOTE]
====
Если один или более входных параметров имеют значение `NULL`, то результатом функции `MINVALUE` тоже будет `NULL` в отличие от агрегатной функции `MIN`.
====

[[fblangref-scalarfuncs-minvalue-exmpl]]
==== Примеры `MINVALUE`

.Использование функции `MINVALUE`
[example]
====
[source,sql]
----
SELECT MINVALUE(PRICE_1, PRICE_2) AS PRICE
FROM PRICELIST
----
====

.См. также:
<<fblangref-scalarfuncs-maxvalue>>.

[[fblangref-scalarfuncs-nullif]]
=== `NULLIF()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
NULLIF (<exp1>, <exp2>)
----

[[fblangref-funcs-tbl-nullif]]
.Параметры функции `NULLIF`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|expr1, expr2
|Выражения любого совместимого типа.
|===

.Тип возвращаемого результата
зависит от типов входных аргументов

Функция возвращает значение первого аргумента, если он неравен второму.
В случае равенства аргументов возвращается `NULL`.

[[fblangref-scalarfuncs-nullif-exmpl]]
==== Примеры `NULLIF`

.Использование функции `NULLIF`
[example]
====
[source,sql]
----
SELECT AVG(NULLIF(weight, -1)) FROM cargo;
----

Этот запрос возвращает среднее значение поля `weight` по таблице,
за исключением строк, где он не указан (равен -1).
Если бы не было этой функции простой оператор `avg(weight)`
вернул бы некорректное значение.
====

.См. также:
<<fblangref-scalarfuncs-coalesce>>, <<fblangref-commons-conditional-case,`CASE`>>.

[[fblangref-functions-others]]
== Другие функции

В этом разделе расположены функции, которые сложно отнести к какой-либо категории.

[[fblangref-scalarfuncs-makedbkey]]
=== `MAKE_DBKEY()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
MAKE_DBKEY (<relation>, _recnum_ [, _dpnum_ [, _ppnum_]]})

<relation> ::= _rel_name_ | _rel_id_
----

[[fblangref-scalarfuncs-tbl-makedbkey]]
.Параметры функции `MAKE_DBKEY`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|rel_name
|Имя таблицы.

|rel_id
|Идентификатор таблицы.
Можно найти в `RDB$RELATIONS.RDB$RELATION_ID`.

|recnum
|Номер записи.
Либо абсолютный (если _dpnum_ и _ppnum_ отсутствуют), либо относительный (если _dpnum_ присутствует)

|dpnum
|Номер страницы данных DP.
Либо абсолютный (если _ppnum_ отсутствует), либо относительный (если _ppnum_ присутствует)

|ppnum
|Номер страницы указателей на данные PP.
|===

Функция `MAKE_DBKEY` создает значение `DBKEY`, используя имя или идентификатор таблицы, номер записи и, необязательно, логический номер страницы данных и страницы указателя.

.Замечания
[NOTE]
====
. Если первый аргумент (таблица) является строковым выражением или литералом, то он обрабатывается как имя таблицы, и Firebird ищет соответствующий идентификатор таблицы. Поиск чувствителен к регистру.
+
В случае строкового литерала идентификатор таблицы оценивается во время подготовки.
В случае выражения, идентификатор таблицы оценивается во время выполнения.
+
Если таблица не может быть найдена, возникает ошибка `isc_relnotdef`.
. Если первый аргумент (таблица) является числовым выражением или литералом, то он обрабатывается как идентификатор таблицы и используется «как есть», без проверки существования таблицы.
+
Если значение аргумента отрицательно или превышает максимально допустимый идентификатор таблицы (в настоящее время 65535), то возвращается `NULL`.
. Второй аргумент (_recnum_) представляет собой абсолютный номер записи в отношении (если следующие аргументы -- _dpnum_ и _ppnum_ -- отсутствуют) или номер записи относительно первой записи, указанной в следующих аргументах.
. Третий аргумент (_dpnum_) -- это логический номер страницы данных (DP) в таблице (если следующий аргумент -- _ppnum_ -- отсутствует) или номер страницы данных относительно первой страницы данных, адресованной заданным _ppnum_.
. Четвёртый аргумент (_ppnum_) -- это логический номер страницы указателя (PP) в таблице.
. Все числа начинаются с нуля. Максимально допустимое значение для _dpnum_ и _ppnum_ составляет 2^32^ (4294967296).
+
Если указан параметр _dpnum_, значение _recnum_ может быть отрицательным.
+
Если _dpnum_ отсутствует и _recnum_ отрицательно, возвращается `NULL`.
+
Если указан _ppnum_, то _dpnum_ может быть отрицательным.
+
Если _ppnum_ отсутствует и _dpnum_ отрицателен, возвращается `NULL`.
. Если какой-либо из указанных аргументов имеет значение `NULL`, результат также равен `NULL`.
. Первый аргумент (таблица) описывается как `INTEGER`, но может быть переопределен приложением как `VARCHAR` или `CHAR`.
+
_recnum_, _dpnum_ и _ppnum_ описываются как `BIGINT` (64-разрядное целое число со знаком).

====

.Примеры:

. Запрос выбирает запись, используя имя таблицы (имя таблицы в верхнем регистре)
+
[source,sql]
----
select * from rdb$relations where rdb$db_key = make_dbkey('RDB$RELATIONS', 0)
----
. Запрос выбирает запись, используя идентификатор таблицы
+
[source,sql]
----
select * from rdb$relations where rdb$db_key = make_dbkey(6, 0)
----
. Запрос выбирает все записи, которые физически находятся на первой странице данных в таблице
+
[source,sql]
----
select * from rdb$relations
where rdb$db_key >= make_dbkey(6, 0, 0)
  and rdb$db_key <  make_dbkey(6, 0, 1)
----
. Запрос выбирает все записи, которые физически находятся на первой странице данных 6-й страницы указателя в таблице
+
[source,sql]
----
select * from SOMETABLE
where rdb$db_key >= make_dbkey('SOMETABLE', 0, 0, 5)
  and rdb$db_key <  make_dbkey('SOMETABLE', 0, 1, 5)
----


[[fblangref-scalarfuncs-transaction-cn]]
=== `RDB$GET_TRANSACTION_CN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$GET_TRANSACTION_CN (_transaction_id_)
----

.Параметры функции RDB$GET_TRANSACTION_CN
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|transaction_id
|Номер (идентификатор) транзакции
|===

.Тип возвращаемого результата:
`BIGINT`

Возвращает номер подтверждения (Commit Number) для заданной транзакции.

[NOTE]
====
Внутренние механизмы Firebird используют беззнаковое 8-байтное целое для Commit Number и беззнаковое 6-байтное целое для номера транзакции.
Поэтому, несмотря на то, что язык SQL не имеет без знаковых целых, а `RDB$GET_TRANSACTION_CN` возвращает знаковый `BIGINT`, невозможно увидеть отрицательный номер подтверждения, за исключением нескольких специальных значений, используемых для неподтверждённых транзакций.
====


Если функция `RDB$GET_TRANSACTION_CN` возвращает значение больше 1, то это фактический (Commit Number) транзакции,
то есть эта транзакция была зафиксирована после запуска базы данных.

В остальных случая функция может возвращать одно из следующих результатов, указывающих статус фиксации транзакции:

[horizontal]
`-2`:: мёртвые транзакции (отмененные);
`-1`:: зависшие транзакции (в состоянии limbo 2PC транзакций);
`{nbsp}0`:: активные транзакции;
`{nbsp}1`:: для транзакций подтверждённых до старта базы данных или с номером меньше чем OIT (Oldest Interesting Transaction);
`NULL`:: если номер транзакции равен `NULL` или больше чем Next Transaction.


.Использование `RDB$GET_TRANSACTION_CN`
[example]
====
[source,sql]
----
select rdb$get_transaction_cn(current_transaction) from rdb$database;

select rdb$get_transaction_cn(123) from rdb$database;
----
====

[NOTE]
====
За более детальной информацией о Commit Number, обратитесь к _Firebird 4.0 Release Notes_.
====

