[[fblangref-functions]]
= Встроенные скалярные функции

[[fblangref-functions-workcontext]]
== Функции для работы с контекстными переменными

[[fblangref-scalarfuncs-get-context]]
=== `RDB$GET_CONTEXT`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$GET_CONTEXT('<namespace>', '_varname_')
                            
<namespace> ::= SYSTEM | DDL_TRIGGER | USER_SESSION | USER_TRANSACTION
----

[[fblangref-funcs-tbl-rdbgetcontext]]
.Параметры функции `RDB$GET_CONTEXT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|namespace
|Пространство имён.

|varname
|Имя переменной.
Зависит от регистра.
Максимальная длина 80 байт.
|===

.Тип возвращаемого результата:
VARCHAR(32765) CHARACTER SET NONE

Функция `RDB$GET_CONTEXT` возвращает значение контекстной переменной из одного из пространства имён.

В настоящий момент существуют следующие пространства имён: 

* `SYSTEM` -- предоставляет доступ к системным контекстным переменным. Эти переменные доступны только для чтения;
* `USER_SESSION` -- предоставляет доступ к пользовательским контекстным переменным, заданным через функцию `RDB$SET_CONTEXT`. Переменные существуют в течение подключения;
* `USER_TRANSACTION` -- предоставляет доступ к пользовательским контекстным переменным, заданным через функцию `RDB$SET_CONTEXT`. Переменные существуют в течение транзакции;
* `DDL_TRIGGER` -- предоставляет доступ к системным контекстным переменным, доступным только во время выполнения DDL триггера. Эти переменные доступны только для чтения.

Пространства имён `USER_SESSION` и `USER_TRANSACTION` -- изначально пусты и пользователь сам создаёт переменные и наполняет их при помощи функции `RDB$SET_CONTEXT`.

[NOTE]
====
Для предотвращения DoS атак, существует ограничение на 1000 переменных в одном "`пространстве имён`".
====

Если запрашиваемая функцией переменная существует в указанном пространстве имён, то будет возвращено её значение в виде строки `VARCHAR(32765) CHARACTER SET NONE`.
При обращении к несуществующей переменной в пространстве `SYSTEM` возникает ошибка, если такое происходит с пространствами имён `USER_SESSION` или `USER_TRANSACTION` -- функция возвращает NULL.

[[fblangref-funcs-tbl-rdbgetcontext-system]]
==== Пространство имён `SYSTEM`

[[fblangref-funcs-tbl-systemnamespace]]
.Переменные пространства имён SYSTEM

`CLIENT_ADDRESS`::
Для TCPv4 – IP адрес, для XNET – локальный ID процесса. Для
остальных случаев `NULL`.

`CLIENT_HOST`::
Имя хоста сетевого протокола удаленного клиента. Значение
возвращается для всех поддерживаемых протоколов.

`CLIENT_PID`::
PID процесса на клиентском компьютере.

`CLIENT_PROCESS`::
Полный путь к клиентскому приложению, подключившемуся к базе
данных. Позволяет не использовать системную таблицу
`MON$ATTACHMENTS` (поле `MON$REMOTE_PROCESS`).

`CURRENT_ROLE`::
Глобальная переменная `CURRENT_ROLE`.

`CURRENT_USER`::
Глобальная переменная `CURRENT_USER`.

`DB_NAME`::
Каноническое имя текущей базы данных. Это либо имя псевдонима
(если соединение с помощью имён файлов запрещено `DatabaseAccess = NONE`) или,
в противном случае, полностью расширенное имя файла базы данных.

`DB_FILE_ID`::
Уникальный идентификатор текущей базы данных на уровне
файловой системы.

`DB_GUID`::
GUID базы данных.

`EFFECTIVE_USER`::
Эффективный пользователь в текущий момент. Указывает
пользователя с привилегиями которого в текущий момент времени
выполняется процедура, функция или триггер.

`ENGINE_VERSION`::
Версия сервера Firebird.

`EXT_CONN_POOL_SIZE`::
Размер пула внешних соединений.

`EXT_CONN_POOL_LIFETIME`::
Время жизни неактивных соединений в пуле внешних
соединений.

`EXT_CONN_POOL_IDLE_COUNT`::
Текущее количество неактивных соединений в пуле внешних
соединений.

`EXT_CONN_POOL_ACTIVE_COUNT`::
Текущее количество активных соединений в пуле внешних
соединений.

`GLOBAL_CN`::
Последнее значение текущего глобального счётчика Commit Number

`ISOLATION_LEVEL`::
Уровень изоляции текущей транзакции -- `CURRENT_TRANSACTION`.
Значения: `'READ_COMMITED'`, `'SNAPSHOT'` или `'CONSISTENCY'`.

`LOCK_TIMEOUT`::
Время ожидания транзакцией высвобождения ресурса при
блокировке, в секундах.

`NETWORK_PROTOCOL`::
Протокол, используемый для соединения с базой данных.
Возможные значения: `'TCPv4'`, `'TCPv6'`, `'WNET'`, `'XNET'`, `NULL`.

`READ_ONLY`::
Отображает, является ли транзакция, транзакцией только для
чтения. `'FALSE'` для Read-Write транзакций `'TRUE'` для Read Only.

`REPLICA_MODE`::
Режим репликации: пустая строка или `NULL` -- первичная база данных,
`'READ-ONLY'` -- реплика в режиме только чтение, `'READ-WRITE'` -- реплика в режиме чтение и запись.

`REPLICATION_SEQUENCE`::
Текущее значение последовательности репликации (номер
последнего сегмента, записанного в журнал репликации).

`SESSION_ID`::
Глобальная переменная `CURRENT_CONNECTION`.

SESSION_IDLE_TIMEOUT`::
Содержит текущее значение тайм-аут простоя соединения в
секундах, который был установлен на уровне соединения, или ноль,
если тайм-аут не был установлен.

`SESSION_TIMEZONE`::
Текущий часовой пояс, установленный в текущей сессии.

`SNAPSHOT_NUMBER`::
Номер моментального снимка базы данных: уровня транзакции
(для транзакции `SNAPSHOT` или `CONSISTENCY`) или уровня запроса
(для транзакции `READ COMMITTED READ CONSISTENCY`). NULL, если
моментальный снимок не существует.

`STATEMENT_TIMEOUT`::
Содержит текущее значение тайм-аута выполнения оператора в
миллисекундах, который был установлен на уровне подключения, или
ноль, если тайм-аут не был установлен.

`TRANSACTION_ID`::
Глобальная переменная `CURRENT_TRANSACTION`.

`WIRE_COMPRESSED`::
Используется ли сжатие сетевого трафика. Если используется
сжатие сетевого трафика возвращает `'TRUE'`, если не используется
-- `'FALSE'`. Для встроенных соединений -- возвращает `NULL`.

`WIRE_ENCRYPTED`::
Используется ли шифрование сетевого трафика. Если
используется шифрование сетевого трафика возвращает `'TRUE'`, если
не используется -- `'FALSE'`. Для встроенных соединений --
возвращает `NULL`.

`WIRE_CRYPT_PLUGIN`::
Если используется шифрование сетевого трафика, то возвращает
имя текущего плагина шифрования, в противном случае `NULL`.

[[fblangref-funcs-tbl-rdbgetcontext-ddl-trigger]]
==== Пространство имён `DDL_TRIGGER`

Использование пространства имён `DDL_TRIGGER` допустимо, только во время работы DDL триггера.
Его использование также допустимо в хранимых процедурах и функциях, вызванных триггерами DDL.

Контекст `DDL_TRIGGER` работает как стек.
Перед возбуждением DDL триггера, значения, относящиеся к выполняемой команде, помещаются в этот стек.
После завершения работы триггера значения выталкиваются.
Таким образом в случае каскадных DDL операторов, когда каждая пользовательская DDL команда возбуждает DDL триггер, и этот триггер запускает другие DDL команды, с помощью `EXECUTE STATEMENT`, значения переменных в пространстве имён `DDL_TRIGGER` будут соответствовать команде, которая вызвала последний DDL триггер в стеке вызовов.


.Переменные пространства имён `DDL_TRIGGER`

`EVENT_TYPE`:: тип события (`CREATE`, `ALTER`, `DROP`).

`OBJECT_TYPE`:: тип объекта (`TABLE`, `VIEW` и др.).

`DDL_EVENT`:: (`<ddl event item>`), где `<ddl_event_item>` это `EVENT_TYPE || ' ' || OBJECT_TYPE`

OBJECT_NAME:: имя объекта метаданных.

OLD_OBJECT_NAME:: имя объекта метаданных до переименования.

NEW_OBJECT_NAME:: имя объекта метаданных после переименования.

SQL_TEXT:: текст SQL запроса.


[NOTE]
====
Ещё раз обратите внимание на то, что пространства имён и имена переменных регистрочувствительны, должны быть не пустыми строками, и заключены в кавычки!
====

[[fblangref-funcs-tbl-rdbgetcontext-exmpl]]
==== Примеры

.Использование функции RDB$GET_CONTEXT
[example]
====
[source,sql]
----
NEW.USER_ADR = RDB$GET_CONTEXT ('SYSTEM', 'CLIENT_ADDRESS');
----
====

.См. также:
<<fblangref-scalarfuncs-set-context,RDB$SET_CONTEXT>>. 

[[fblangref-scalarfuncs-set-context]]
=== RDB$SET_CONTEXT

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$SET_CONTEXT('<namespace>', 'varname', {<value> | NULL})   
                            
<namespace> ::= USER_SESSION | USER_TRANSACTION
----

[[fblangref-funcs-tbl-rdbsetcontext]]
.Параметры функции `RDB$SET_CONTEXT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|namespace
|Пространство имён.

|varname
|Имя переменной.
Зависит от регистра.
Максимальная длина 80 байт.

|value
|Данные любого типа при условии, что их можно привести к типу VARCHAR(32765) CHARACTER SET NONE.
|===

.Тип возвращаемого результата
`INTEGER`

Функция `RDB$SET_CONTEXT` создаёт, устанавливает значение или обнуляет переменную в одном из используемых пользователем пространстве имён: `USER_SESSION` или `USER_TRANSACTION`.

Функция возвращает 1, если переменная уже существовала до вызова и 0, если не существовала.
Для удаления переменной надо установить её значение в `NULL`.
Если данное пространство имён не существует, то функция вернёт ошибку.
Пространство имён и имя переменной зависят от регистра, должны быть не пустыми строками, и заключены в кавычки.

[NOTE]
====
* Пространство имён `SYSTEM` доступно только для чтения;
* Максимальное число переменных в рамках одного соединения (для пространства `USER_SESSION`) или одной транзакции (для пространства `USER_TRANSACTION`) равно 1000;
* Все переменные в пространстве имён `USER_TRANSACTION` сохраняются при `ROLLBACK RETAIN` или `ROLLBACK TO SAVEPOINT`, независимо от того, в какой точке во время выполнения транзакции они были установлены.
====

.Использование функции RDB$SET_CONTEXT
[example]
====
[source,sql]
----

SELECT RDB$SET_CONTEXT ('USER_SESSION', 'DEBUGL', 3)	
FROM RDB$DATABASE;

-- в PSQL доступен такой синтаксис
RDB$SET_CONTEXT('USER_SESSION', 'RECORDSFOUND', RECCOUNTER);

SELECT RDB$SET_CONTEXT ('USER_TRANSACTION', 'SAVEPOINTS', 'YES')
FROM RDB$DATABASE;
----
====

.Использование функций для работы с контекстными переменными
[example]
====
[source,sql]
----
SET TERM ^;
CREATE PROCEDURE set_context(User_ID VARCHAR(40), 
                             Trn_ID INT) AS
BEGIN
  RDB$SET_CONTEXT('USER_TRANSACTION', 'Trn_ID', Trn_ID);
  RDB$SET_CONTEXT('USER_TRANSACTION', 'User_ID', User_ID);
END^
SET TERM ;^

CREATE TABLE journal (
   jrn_id INTEGER NOT NULL PRIMARY KEY,
   jrn_lastuser VARCHAR(40),
   jrn_lastaddr VARCHAR(255),
   jrn_lasttran INTEGER
);

SET TERM ^;
CREATE TRIGGER UI_JOURNAL 
FOR JOURNAL BEFORE INSERT OR UPDATE
AS 
BEGIN
  new.jrn_lastuser = RDB$GET_CONTEXT('USER_TRANSACTION',
                                     'User_ID');
  new.jrn_lastaddr = RDB$GET_CONTEXT('SYSTEM',
                                     'CLIENT_ADDRESS');
  new.jrn_lasttran = RDB$GET_CONTEXT('USER_TRANSACTION',
                                         'Trn_ID');
END^
SET TERM ;^

EXECUTE PROCEDURE set_context('skidder', 1);

INSERT INTO journal(jrn_id) VALUES(0);

COMMIT;
----
====

.См. также:
<<fblangref-scalarfuncs-get-context,`RDB$GET_CONTEXT`>>.

[[fblangref-functions-security]]
== Функции подсистемы безопасности

[[fblangref-scalarfuncs-roleinuse]]
=== `RDB$ROLE_IN_USE`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$ROLE_IN_USE (_role_name_)
----

.Параметры функции `RDB$ROLE_IN_USE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|role_name
|Имя роли использование которой проверяется
|===

.Тип возвращаемого результата
BOOLEAN.

Функция `RDB$ROLE_IN_USE` возвращает используется ли роль текущим пользователем.

[NOTE]
====
Данная функция позволяет проверить использование любой роли: указанной явно (при входе в систему или изменённой с помощью оператора SET ROLE) и назначенной неявно (роли назначенные пользователю с использованием предложения DEFAULT).
====


.Использование функции `RDB$ROLE_IN_USE`
[example]
====
[source,sql]
----
-- Проверяем используется ли явно назначенная или 
-- неявно полученная роль MANAGER                                
IF (RDB$ROLE_IN_USE('MANAGER')) THEN
BEGIN
  ...
END
----
====

.Список ролей используемых текущим подключением
[example]
====
[source,sql]
----
SELECT * FROM RDB$ROLES WHERE RDB$ROLE_IN_USE(RDB$ROLE_NAME)
----
====

.См. также:
<<fblangref-security-priv-grant-role,GRANT ROLE>>, <<fblangref-session-role-setrole,SET ROLE>>, <<fblangref-contextvars-current-role,CURRENT_ROLE>>.

[[fblangref-scalarfuncs-system-privelege]]
=== `RDB$SYSTEM_PRIVILEGE`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$SYSTEM_PRIVILEGE (<privilege>)
----

.Параметры функции `RDB$SYSTEM_PRIVILEGE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|privilege
|Проверяемая системная привилегия
|===

.Тип возвращаемого результата
BOOLEAN

Функция `RDB$SYSTEM_PRIVILEGE` используется системная привилегия текущим соединением.
Список системных привилегий см.
в <<fblangref-security-roles-create,CREATE ROLE>>.

.Использование функции `RDB$SYSTEM_PRIVILEGE`
[example]
====
[source,sql]
----
SELECT RDB$SYSTEM_PRIVILEGE(USER_MANAGEMENT) FROM RDB$DATABASE;
----
====

.См. также:
<<fblangref-security-roles-create,CREATE ROLE>>. 

[[fblangref-functions-error]]
== Функции для обработки ошибок

[[fblangref-scalarfuncs-rdberror]]
=== RDB$ERROR

.Доступно в
PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$ERROR (<context>)   
                            
<context> ::= GDSCODE | SQLCODE | SQLSTATE | EXCEPTION | MESSAGE
----

.Тип возвращаемого результата
Зависит от контекста

Возвращает значение контекста активного исключения.
Тип возвращаемого значения зависит от контекста.

[NOTE]
====
Функция `RDB$ERROR` всегда возвращает `NULL` вне блока обработки ошибок `WHEN ... DO`.
====

Доступные контексты в качестве аргумента функции `RDB$ERROR`:

`EXCEPTION`:: функция возвращает имя исключения, если активно исключение определённое пользователем, или `NULL` если активно одно из системных исключений.
Для контекста `EXCEPTION` тип возвращаемого значения: `VARCHAR(63) CHARACTER SET UTF8`.

`MESSAGE`:: функция возвращает интерпретированный текст активного исключения.
Для контекста `MESSAGE` тип возвращаемого значения: `VARCHAR(1024) CHARACTER SET UTF8`.

`GDSCODE`:: функция возвращает значение контекстной переменной `GDSCODE`.

`SQLCODE`:: функция возвращает значение контекстной переменной `SQLCODE`.

`SQLSTATE`:: функция возвращает значение контекстной переменной `SQLSTATE`.


.Использование функции `RDB$ERROR` для сохранения текста ошибки в журнал
[example]
====
[source,sql]
----
...
BEGIN
...
WHEN ANY DO
  EXECUTE PROCEDURE P_LOG_EXCEPTION(RDB$ERROR(MESSAGE));
END
...
----
====

.См. также:
<<fblangref-psql-statements-when,`WHEN ... DO`>>,
<<fblangref-psql-statements-exception,`EXCEPTION`>>,
<<fblangref-contextvars-gdscode,`GDSCODE`>>,
<<fblangref-contextvars-sqlcode,`SQLCODE`>>,
<<fblangref-contextvars-sqlstate,`SQLSTATE`>>.

[[fblangref-functions-transaction]]
== Функции работы с транзакциями

[[fblangref-scalarfuncs-transaction-cn]]
=== RDB$GET_TRANSACTION_CN

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
RDB$GET_TRANSACTION_CN (_transaction-number_)
----

.Параметры функции RDB$GET_TRANSACTION_CN
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|transaction-number
|Номер (идентификатор) транзакции
|===

.Тип возвращаемого результата:
`BIGINT`

Возвращает номер подтверждения (Commit Number) для заданной транзакции.

[NOTE]
====
Внутренние механизмы Firebird используют беззнаковое 8-байтное целое для Commit Number и беззнаковое 6-байтное целое для номера транзакции.
Поэтому, несмотря на то, что язык SQL не имеет без знаковых целых, а `RDB$GET_TRANSACTION_CN` возвращает знаковый BIGINT, невозможно увидеть отрицательный номер подтверждения, за исключением нескольких специальных значений, используемых для неподтверждённых транзакций.
====

Таким образом, числа возвращаемые `RDB$GET_TRANSACTION_CN` могут иметь следующие значения: 

* -2 -- мёртвые транзакции (отмененные);
* -1 -- зависшие транзакции (в состоянии limbo 2PC транзакций);
* 0 -- активные транзакции;
* 1 -- для транзакций подтверждённых до старта базы данных или с номером меньше чем OIT (Oldest Interesting Transaction);
* >1 -- транзакции подтверждённые после старта базы данных;
* `NULL` -- если номер транзакции равен `NULL` или больше чем Next Transaction.


.Использование `RDB$GET_TRANSACTION_CN`
[example]
====
[source,sql]
----
select rdb$get_transaction_cn(current_transaction) from rdb$database;

select rdb$get_transaction_cn(123) from rdb$database;
----
====

.См. также:
_README.read_consistency.md_

[[fblangref-scalarfuncs-make-dbkey]]
== `MAKE_DBKEY`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
MAKE_DBKEY ({_rel_name_ | _rel_id_}, _recnum_ [, _dpnum_ [, _ppnum_]]})
----

.Параметры функции `MAKE_DBKEY`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|rel_name
|Имя таблицы

|rel_id
|Идентификатор таблицы.
Можно найти в `RDB$RELATIONS.RDB$RELATION_ID`

|recnum
|Номер записи

|dpnum
|Номер страницы данных DP

|ppnum
|Номер страницы указателей на данные PP
|===

Функция `MAKE_DBKEY` создает значение `DBKEY`, используя имя или идентификатор таблицы, номер записи и, необязательно, логический номер страницы данных и страницы указателя.

.Замечания
[NOTE]
====
. Если первый аргумент (таблица) является строковым выражением или литералом, то он обрабатывается как имя таблицы, и Firebird ищет соответствующий идентификатор таблицы. Поиск чувствителен к регистру.
+
В случае строкового литерала идентификатор таблицы оценивается во время подготовки.
В случае выражения, идентификатор таблицы оценивается во время выполнения.
+
Если таблица не может быть найдена, возникает ошибка `isc_relnotdef`.
. Если первый аргумент (таблица) является числовым выражением или литералом, то он обрабатывается как идентификатор таблицы и используется «как есть», без проверки существования таблицы.
+
Если значение аргумента отрицательно или превышает максимально допустимый идентификатор таблицы (в настоящее время 65535), то возвращается `NULL`.
. Второй аргумент (_recnum_) представляет собой абсолютный номер записи в отношении (если следующие аргументы -- _dpnum_ и _ppnum_ -- отсутствуют) или номер записи относительно первой записи, указанной в следующих аргументах.
. Третий аргумент (_dpnum_) -- это логический номер страницы данных (DP) в таблице (если следующий аргумент -- _ppnum_ -- отсутствует) или номер страницы данных относительно первой страницы данных, адресованной заданным _ppnum_.
. Четвёртый аргумент (_ppnum_) -- это логический номер страницы указателя (PP) в таблице.
. Все числа начинаются с нуля. Максимально допустимое значение для _dpnum_ и _ppnum_ составляет 2^32^ (4294967296).
+
Если указан параметр _dpnum_, значение _recnum_ может быть отрицательным.
+
Если _dpnum_ отсутствует и _recnum_ отрицательно, возвращается `NULL`.
+
Если указан _ppnum_, то _dpnum_ может быть отрицательным.
+
Если _ppnum_ отсутствует и _dpnum_ отрицателен, возвращается `NULL`.
. Если какой-либо из указанных аргументов имеет значение `NULL`, результат также равен `NULL`.
. Первый аргумент (таблица) описывается как `INTEGER`, но может быть переопределен приложением как `VARCHAR` или `CHAR`.
+
_recnum_, _dpnum_ и _ppnum_ описываются как `BIGINT` (64-разрядное целое число со знаком).

====

.Примеры:

. Запрос выбирает запись, используя имя таблицы (имя таблицы в верхнем регистре) 
+
[source,sql]
----
select * from rdb$relations where rdb$db_key = make_dbkey('RDB$RELATIONS', 0)
----
. Запрос выбирает запись, используя идентификатор таблицы 
+
[source,sql]
----
select * from rdb$relations where rdb$db_key = make_dbkey(6, 0)
----
. Запрос выбирает все записи, которые физически находятся на первой странице данных в таблице 
+
[source,sql]
----
select * from rdb$relations
where rdb$db_key >= make_dbkey(6, 0, 0)
  and rdb$db_key <  make_dbkey(6, 0, 1)
----
. Запрос выбирает все записи, которые физически находятся на первой странице данных 6-й страницы указателя в таблице 
+
[source,sql]
----
select * from SOMETABLE
where rdb$db_key >= make_dbkey('SOMETABLE', 0, 0, 5)
  and rdb$db_key <  make_dbkey('SOMETABLE', 0, 1, 5)
----


[[fblangref-functions-math]]
== Математические функции

[[fblangref-scalarfuncs-abs]]
=== `ABS()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
ABS (<value>)
----

.Параметры функции `ABS`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа
|===

.Тип возвращаемого результата:
тот же что и входной аргумент.

Функция `ABS` возвращает абсолютное значение (модуль) аргумента.

[[fblangref-scalarfuncs-acos]]
=== `ACOS()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
ACOS (<value>)
----

.Параметры функции ACOS
[cols="<1,<3", options="header",stripes="none"]
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа в диапазоне [-1; 1].
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ACOS` возвращает арккосинус (в радианах) аргумента.

В случае если аргумент функции вне границы диапазона [-1, 1], то функция вернёт неопределённое значения `NaN`.

.См. также:
<<fblangref-scalarfuncs-cos>>.

[[fblangref-scalarfuncs-acosh]]
=== `ACOSH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
ACOSH (<value>)
----

.Параметры функции `ACOSH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа в диапазоне [1; +∞].
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ACOSH` возвращает гиперболический арккосинус (в радианах) аргумента.

.См. также:
<<fblangref-scalarfuncs-cosh>>.

[[fblangref-scalarfuncs-asin]]
=== `ASIN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
ASIN (<value>)
----

.Параметры функции `ASIN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа в диапазоне [-1; 1].
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ASIN` возвращает арксинус (в радианах) аргумента.

В случае если аргумент функции вне границы диапазона [-1, 1], то функция вернёт неопределённое значения `NaN`.

.См. также:
<<fblangref-scalarfuncs-sin>>.

[[fblangref-scalarfuncs-asinh]]
=== `ASINH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
ASINH (<value>)
----

.Параметры функции `ASINH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ASINH` возвращает гиперболический арксинус (в радианах) аргумента.

.См. также:
<<fblangref-scalarfuncs-sinh>>.

[[fblangref-scalarfuncs-atan]]
=== ATAN

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
ATAN (<value>)
----

.Параметры функции `ATAN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|

Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ATAN` возвращает арктангенс аргумента. 

Функция возвращает угол в радианах в диапазоне [-π/2; π/2].

.См. также:
<<fblangref-scalarfuncs-atan2>>, <<fblangref-scalarfuncs-tan>>. 

[[fblangref-scalarfuncs-atan2]]
=== `ATAN2()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
ATAN2 (_y_, _x_)
----

.Параметры функции ATAN2
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|x
|Выражение числового типа.

|y
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ATAN2` возвращает угол как отношение синуса к косинусу, аргументы, у которых задаются этими двумя параметрами, а знаки синуса и косинуса соответствуют знакам параметров.
Это позволяет получать результаты по всей окружности, включая углы -π/2 и π/2. 

Особенности использования: 

* Результат -- угол в диапазоне [-π, π] радиан;
* Если _х_ отрицательный, то при нулевом значении _y_ результат равен π, а при значении 0 равен -π;
* Если и _y_ и _x_ равны 0, то результат бессмыслен.

[NOTE]
====
* Полностью эквивалентное описание этой функции следующее: `ATAN2 (_y_, _x_)` является углом между положительной осью X и линией от начала координат до точки (_x_, _y_). Это также делает очевидным, что значение `ATAN2 (0, 0)` не определено;
* Если _x_ больше, чем 0, `ATAN2 (_y_, _x_)` совпадает с `ATAN (_y_/_x_)`;
* Если известны и синус, и косинус угла, то `ATAN2 (_SIN_, _COS_)` возвращает угол.
====

.См. также:
<<fblangref-scalarfuncs-atan>>, <<fblangref-scalarfuncs-sin>>, <<fblangref-scalarfuncs-cos>>.

[[fblangref-scalarfuncs-atanh]]
=== `ATANH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
ATANH (<value>)
----

.Параметры функции `ATANH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `ATANH` возвращает гиперболический арктангенс (в радианах) аргумента.

.См. также:
<<fblangref-scalarfuncs-tanh>>.

[[fblangref-scalarfuncs-ceil]]
=== `CEIL()`, `CEILING()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
CEIL[ING] (<value>)
----

.Параметры функции CEIL[ING]
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`BIGINT`, `INT128`, `DECFLOAT` или `DOUBLE PRECISION` в зависимости от типа аргумента.

Функция `CEIL` возвращает наименьшее целое число, большее или равное аргументу.

.См. также:
<<fblangref-scalarfuncs-floor>>, <<fblangref-scalarfuncs-trunc>>.

[[fblangref-scalarfuncs-cos]]
=== `COS()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
COS (_angle_)
----

.Параметры функции `COS`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `COS` возвращает косинус угла.
Аргумент должен быть задан в радианах.

Любой `NOT NULL` результат находится в диапазоне [-1, 1].

.См. также:
<<fblangref-scalarfuncs-acos>>.

[[fblangref-scalarfuncs-cosh]]
=== `COSH`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
COSH (<value>)
----

.Параметры функции `COSH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `COSH` возвращает гиперболический косинус аргумента.

Любой `NOT NULL` результат находится в диапазоне [1, +∞].

.См. также:
<<fblangref-scalarfuncs-acosh>>.

[[fblangref-scalarfuncs-cot]]
=== `COT`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
COT (_angle_)
----

.Параметры функции `COT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `COT` возвращает котангенс угла.
Аргумент должен быть задан в радианах.

.См. также:
<<fblangref-scalarfuncs-tan>>.

[[fblangref-scalarfuncs-exp]]
=== `EXP`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
EXP (<value>)
----

.Параметры функции `EXP`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `EXP` возвращает значение натуральной экспоненты, e^value^

.См. также:
<<fblangref-scalarfuncs-ln>>.

[[fblangref-scalarfuncs-floor]]
=== `FLOOR`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
FLOOR (<value>)
----

.Параметры функции `FLOOR`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`BIGINT`, `INT128`, `DECFLOAT` или `DOUBLE PRECISION` в зависимости от типа аргумента.

Функция `FLOOR` возвращает целое число, меньшее или равное аргументу.

.См. также:
<<fblangref-scalarfuncs-ceil>>, <<fblangref-scalarfuncs-trunc>>.

[[fblangref-scalarfuncs-ln]]
=== `LN`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
LN (<value>)
----

.Параметры функции `LN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `LN` возвращает натуральный логарифм аргумента.

[NOTE]
====
В случае если передан отрицательный или нулевой аргумент функция вернёт ошибку. 
====

.См. также:
<<fblangref-scalarfuncs-exp>>.

[[fblangref-scalarfuncs-log]]
=== `LOG`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
LOG (_x_, _y_)
----

.Параметры функции `LOG`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|x
|Основание.
Выражение числового типа.

|y
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `LOG` возвращает логарифм _y_ (второй аргумент) по основанию _x_ (первый аргумент).

Особенности использования: 

* Если один из аргументов меньше или равен 0, то возникает ошибка;
* Если оба аргумента равны 1, то результатом функции будет `NaN` (Not-a-Number -- не число);
* Если _x_ = 1 и _y_ < 1, то результатом функции будет `-INF` (-∞);
* Если _x_ = 1 и _y_ > 1, то результатом функции будет `+INF` (+∞).


[[fblangref-scalarfuncs-log10]]
=== `LOG10`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
LOG10 (<value>)
----

.Параметры функции `LOG10`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `LOG10` возвращает десятичный логарифм аргумента.

[NOTE]
====
Если входной аргумент отрицательный или равен 0, возникает ошибка. 
====

[[fblangref-scalarfuncs-mod]]
=== `MOD`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
MOD (_a_, _b_)
----

.Параметры функции `MOD`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|a
|Выражение числового типа.

|b
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`INTEGER`, `BIGINT` или `INT128` в зависимости от типов аргументов.

Функция `MOD` возвращает остаток от целочисленного деления.

[NOTE]
====
Вещественные числа округляются до выполнения деления.
Например, результатом `MOD(7.5, 2.5)` будет 2 (8 mod 3), а не 0.
====

[[fblangref-scalarfuncs-pi]]
=== `PI`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
PI ()
----

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `PI` возвращает число π.

[[fblangref-scalarfuncs-power]]
=== POWER

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
POWER (_x_, _y_)
----

.Параметры функции `POWER`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|x
|Выражение числового типа.

|y
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `POWER` возвращает результат возведения числа _x_ в степень _y_.

[NOTE]
====
Если _x_ меньше нуля, возникает ошибка.
====

[[fblangref-scalarfuncs-rand]]
=== `RAND`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing]
----
RAND ()
----

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `RAND` возвращает псевдослучайное число в интервале от 0 до 1.

[[fblangref-scalarfuncs-round]]
=== `ROUND`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs="+quotes"]
----
ROUND (_number_ [, _scale_])
----

.Параметры функции `ROUND`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.

|scale
a|Масштаб -- целое число, определяющее число десятичных разрядов, к которым должен быть проведено округление, т.е.

* {nbsp}2 для округления к самому близкому кратному 0.01 числу
* {nbsp}1 для округления к самому близкому кратному 0.1 числу
* {nbsp}0 для округления к самому близкому целому числу
* -1 для округления к самому близкому кратному 10 числу
* -2 для округления к самому близкому кратному 100 числу

По умолчанию 0.
|===

.Тип возвращаемого результата
масштабируемое целое (`INTEGER`, `BIGINT` или `INT128`) или `DECFLOAT`, или `DOUBLE PRECISION` в зависимости от типа _number_.

Функция `ROUND` округляет число до ближайшего целого числа.
Если дробная часть равна 0.5, то округление до ближайшего большего целого числа для положительных чисел и до ближайшего меньшего для отрицательных чисел.
С дополнительным опциональным параметром _scale_ число может быть округлено до одной из степеней числа 10 (десятки, сотни, десятые части, сотые части и т.д.) вместо просто целого числа.

[NOTE]
====
Если используется параметр _scale_, то результат имеет такой же масштаб, как и первый параметр _number_.
====

[[fblangref-scalarfuncs-round-exmpl]]
==== Примеры `ROUND`

.Использование функции `ROUND`
[example]
====
[source,sql]
----
ROUND(123.654, 1) -- Результат: 123.700 (а не 123.7)
ROUND(8341.7, -3) -- Результат: 8000.0 (а не 8000)
ROUND(45.1212, 0) -- Результат: 45.0000 (а не 45)
ROUND(45.1212)    -- Результат: 45
----
====

.См. также:
<<fblangref-scalarfuncs-trunc>>.

[[fblangref-scalarfuncs-sign]]
=== `SIGN`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SIGN (_number_)
----

.Параметры функции `SIGN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`SMALLINT`

Функция `SIGN` возвращает знак входного параметра.

* -1 -- число меньше нуля
* {nbsp}0 -- число равно нулю
* {nbsp}1 -- число больше нуля

[[fblangref-scalarfuncs-sin]]
=== `SIN`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SIN (_angle_)
----

.Параметры функции `SIN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `SIN` возвращает синус угла.
Аргумент должен быть задан в радианах.

Любой `NOT NULL` результат находится в диапазоне [-1, 1].

.См. также:
<<fblangref-scalarfuncs-asin>>.

[[fblangref-scalarfuncs-sinh]]
=== `SINH`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SINH (_number_)
----

.Параметры функции `SINH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `SINH` возвращает гиперболический синус аргумента.

.См. также:
<<fblangref-scalarfuncs-asinh>>.

[[fblangref-scalarfuncs-sqrt]]
=== `SQRT()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
SQRT (_number_)
----

.Параметры функции `SQRT`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `SQRT` возвращает квадратный корень аргумента.

[[fblangref-scalarfuncs-tan]]
=== `TAN()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
TAN (_angle_)
----

.Параметры функции `TAN`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|angle
|Угол, выраженный в радианах.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `TAN` возвращает тангенс угла.
Аргумент должен быть задан в радианах.

.См. также:
<<fblangref-scalarfuncs-atan>>, <<fblangref-scalarfuncs-atan2>>.

[[fblangref-scalarfuncs-tanh]]
=== `TANH()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
TANH (_number_)
----

.Параметры функции `TANH`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.
|===

.Тип возвращаемого результата:
`DOUBLE PRECISION`

Функция `TANH` возвращает гиперболический тангенс аргумента.

Любой `NOT NULL` результат находится в диапазоне [-1, 1].

.См. также:
<<fblangref-scalarfuncs-atanh>>.

[[fblangref-scalarfuncs-trunc]]
=== `TRUNC()`

.Доступно в
DSQL, PSQL

.Синтаксис
[listing,subs=+quotes]
----
TRUNC (_number_ [, _scale_])
----

.Параметры функции `TRUNC`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|number
|Выражение числового типа.

|scale
a|Масштаб -- целое число, определяющее число десятичных разрядов, к которым должен быть проведено усечение, т.е.

* {nbsp}2 для усечения к самому близкому кратному 0.01 числу
* {nbsp}1 для усечения к самому близкому кратному 0.1 числу
* {nbsp}0 для усечения к самому близкому целому числу
* -1 для усечения к самому близкому кратному 10 числу
* -2 для усечения к самому близкому кратному 100 числу

По умолчанию 0.
|===

.Тип возвращаемого результата
масштабируемое целое (`INTEGER`, `BIGINT` или `INT128`) или `DECFLOAT`, или `DOUBLE PRECISION` в зависимости от типа _number_.

Функция `TRUNC` усекает число до ближайшего целого числа.
С дополнительным опциональным параметром _scale_ число может быть усечено до одной из степеней числа 10 (десятки, сотни, десятые части, сотые части и т.д.) вместо просто целого числа.

[NOTE]
====
Если используется параметр _scale_, то результат имеет такой же масштаб, как и первый параметр _number_.
====

[IMPORTANT]
====
Функция всегда увеличивает отрицательные числа, поскольку она обрезает дробную часть. 
====

.Использование функции TRUNC
[example]
====
[source,sql]
----
TRUNC(789.2225, 2)  -- Результат: 789.2200 (а не 789.22)
TRUNC(345.4, -2) 	-- Результат: 300.0 (а не 300)
TRUNC(-163.41, 0)	-- Результат: -163.00 (а не -163)
TRUNC(-163.41)      -- Результат: -163
----
====

.См. также:
<<fblangref-scalarfuncs-round,ROUND>>, <<fblangref-scalarfuncs-ceil,"CEIL, CEILING">>, <<fblangref-scalarfuncs-floor,FLOOR>>. 

[[_fblangref_functions_string]]
== Функции для работы со строками

[[fblangref-scalarfuncs-ascii-char]]
=== ASCII_CHAR

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

ASCII_CHAR (code)
----



.Параметры функции ASCII_CHAR
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``code``
|

Целое число в диапазоне от 0 до 255.
|===

.Тип возвращаемого результата:
[VAR]CHAR(1) CHARSET NONE.

Функция ASCII_CHAR возвращает ASCII символ соответствующий номеру, переданному в качестве аргумента.

.См. также:
<<fblangref-scalarfuncs-ascii-val,ASCII_VAL>>.

[[fblangref-scalarfuncs-ascii-val]]
=== ASCII_VAL

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

ASCII_VAL (ch)
----



.Параметры функции ASCII_VAL
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``ch``
|

Строка типа данных [VAR]CHAR или текстовый BLOB максимального размера 32767 байт.
|===

.Тип возвращаемого результата:
SMALLINT.

Функция ASCII_VAL возвращает ASCII код символа, переданного в качестве аргумента.

Особенности использования: 

* Если строка содержит более одного символа, то возвращается код первого символа строки;
* Если строка пустая, возвращается ноль;
* Если аргумент NULL, то возвращаемое значение также NULL.


.См. также:
<<fblangref-scalarfuncs-ascii-char,ASCII_CHAR>>.

[[fblangref-scalarfuncs-bit_length]]
=== BIT_LENGTH

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BIT_LENGTH (str)
----



.Параметры функции BIT_LENGTH
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
BIGINT.

Функция BIT_LENGTH возвращает длину входной строки в битах.
Для многобайтных наборов символов результат может быть в 8 раз больше, чем количество символов в "`формальном`" числе байт на символ, записанном в RDB$CHARACTER_SETS.

С параметрами типа CHAR эта функция берет во внимание всю формальную строковую длину (например, объявленная длина поля или переменной). Если вы хотите получить "`логическую`" длину в битах, не считая пробелов, то перед передачей аргумента в BIT_LENGTH надо выполнить над ним операцию RIGHT TRIM. 

.Примеры:


.Использование функции BIT_LENGTH
[example]

[source,sql]
----

SELECT BIT_LENGTH ('Hello!') FROM RDB$DATABASE
-- возвращает 48

SELECT BIT_LENGTH (_ISO8859_1 'Grüß Di!')
FROM RDB$DATABASE
-- возвращает 64: каждый, и ü, и ß занимают один байт в ISO8859_1

SELECT BIT_LENGTH (
CAST (_ISO8859_1 'Grüß di!' AS VARCHAR (24)
CHARACTER SET UTF8))
FROM RDB$DATABASE
-- возвращает 80: каждый, и ü, и ß занимают по два байта в UTF8

SELECT BIT_LENGTH (
CAST (_ISO8859_1 'Grüß di!' AS CHAR (24)
CHARACTER SET UTF8))
FROM RDB$DATABASE
-- возвращает 208: размер всех 24 позиций CHAR и два из них 16-битные
----

.См. также:
<<fblangref-scalarfuncs-char_length,CHAR_LENGTH>>, <<fblangref-scalarfuncs-octet_length,OCTET_LENGTH>>. 

[[fblangref-scalarfuncs-char_length]]
=== CHAR_LENGTH, CHARACTER_LENGTH

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

CHAR_LENGTH (str)    
                            
CHARACTER_LENGTH (str)
----



.Параметры функции CHAR_LENGTH
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
BIGINT.

Функция CHAR_LENGTH возвращает длину (в символах) строки, переданной в качестве аргумента.

[NOTE]
====
С параметрами типа CHAR эта функция берет во внимание всю формальную строковую длину (например, объявленная длина поля или переменной). Если вы хотите получить "`логическую`" длину без учёта пробелов, то перед передачей аргумента в CHAR[ACTER]_LENGTH надо выполнить над ним операцию RIGHT TRIM.
====

.См. также:
<<fblangref-scalarfuncs-bit_length,BIT_LENGTH>>, <<fblangref-scalarfuncs-octet_length,OCTET_LENGTH>>. 

[[fblangref-scalarfuncs-left]]
=== LEFT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

LEFT (str, num)
----



.Параметры функции LEFT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.

|[replaceable]``num``
|

Целое число.
Определяет количество возвращаемых символов.
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция LEFT возвращает левую часть строки, количество возвращаемых символов определяется вторым параметром. 

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если строковый аргумент BLOB, результатом будет BLOB, в противном случае результатом будет VARCHAR(N), при этом N – будет равно длине строкового параметра;
* Если числовой параметр превысит длину текста, результатом будет исходный текст.


[WARNING]
====
При использовании BLOB в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах BLOB могут наблюдаться потери производительности. 
====

.Примеры:


.Использование функции LEFT
[example]

[source,sql]
----

SELECT LEFT('ABC', 2) FROM rdb$database;
-- результат AB
----

.См. также:
<<fblangref-scalarfuncs-right,RIGHT>>, <<fblangref-scalarfuncs-substring,SUBSTRING>>. 

[[fblangref-scalarfuncs-lower]]
=== LOWER

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис

[source]
----

LOWER (str)
----



.Параметры функции LOWER
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция LOWER возвращает входную строку в нижнем регистре.
Точный результат зависит от набора символов входной строки.
Например, для наборов символов NONE и ASCII только ASCII символы переводятся в нижний регистр; для OCTETS -- вся входная строка возвращается без изменений. 

_Примеры:_

.Использование функции LOWER
[example]

[source,sql]
----

/* Результат: 'debacle', в соответствии с французскими 
 * правилами приведения в нижний регистр 
 */                        
SELECT LOWER(_ISO8859_1 'Débâcle' COLLATE FR_FR)
FROM RDB$DATABASE
----

.См. также:
<<fblangref-scalarfuncs-upper,UPPER>>. 

[[fblangref-scalarfuncs-lpad]]
=== LPAD

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

LPAD (str, endlen [, padstr])
----



.Параметры функции LPAD
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.

|[replaceable]``endlen``
|

Длина выходной строки.

|[replaceable]``padstr``
|

Строка, которой дополняется исходная строка до указанной длины.
По умолчанию является пробелом (' ').
|===

.Тип возвращаемого результата:
VARCHAR([replaceable]``endlen``) или BLOB.

Функция LPAD дополняет слева входную строку пробелами или определённой пользователем строкой до заданной длины. 

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если входная строка имеет тип BLOB, то результат также будет BLOB, в противном случае результат будет VARCHAR([replaceable]``endlen``).
* Если аргумент [replaceable]``padstr`` задан, но равен пустой строке (''), то дополнения строки не происходит! В случае если [replaceable]``endlen`` меньше длины входной строки, то в результате происходит её усечение до длины [replaceable]``endlen``, даже если параметр [replaceable]``padstr`` равен пустой строке.


[WARNING]
====
При использовании BLOB в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах BLOB могут наблюдаться потери производительности. 
====

.Примеры:


.Использование функции LPAD
[example]

[source,sql]
----

LPAD ('Hello', 12)                -- возвращает '       Hello'
LPAD ('Hello', 12, '-')           -- возвращает '-------Hello'
LPAD ('Hello', 12, '')            -- возвращает 'Hello'
LPAD ('Hello', 12, 'abc')         -- возвращает 'abcabcaHello'
LPAD ('Hello', 12, 'abcdefghij')  -- возвращает 'abcdefgHello'
LPAD ('Hello', 2)                 -- возвращает 'He'
LPAD ('Hello', 2, '-')            -- возвращает 'He'
LPAD ('Hello', 2, '')             -- возвращает 'He'
----

.См. также:
<<fblangref-scalarfuncs-rpad,RPAD>>. 

[[fblangref-scalarfuncs-octet_length]]
=== OCTET_LENGTH

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

OCTET_LENGTH (str)
----



.Параметры функции OCTET_LENGTH
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
BIGINT.

Функция OCTET_LENGTH возвращает количество байт занимаемое строкой.

При работе с параметрами типа CHAR функция возвращает значение всей формальной строковой длины.
Для того чтобы узнать "логическую" длину строки в байтах, то перед передачей аргумента функции следует применить RIGHT TRIM.

[NOTE]
====
Следует помнить, что не во всех наборах символов количество байт занимаемых строкой равно количеству символов.
====

.Примеры:


.Использование функции OCTET_LENGTH
[example]

[source,sql]
----

SELECT OCTET_LENGTH('Hello!') 
FROM rdb$database
-- возвратит 6

SELECT OCTET_LENGTH(_iso8859_1 'Grüß di!') 
FROM rdb$database
-- возвратит 8: ü и ß занимают не более 1 байта в ISO8859_1

SELECT 
  OCTET_LENGTH(CAST(_iso8859_1 'Grüß di!' AS VARCHAR(24) CHARACTER SET utf8))
FROM rdb$database
-- возвратит 10: ü и ß занимают 2 байта в UTF8

SELECT 
  OCTET_LENGTH(CAST(_iso8859_1 'Grüß di!' AS CHAR(24) CHARACTER SET utf8))
FROM rdb$database
-- возвратит 26: всего 24 CHAR позиции, и две из них занимают 2 байта
----

.См. также:
<<fblangref-scalarfuncs-bit_length,BIT_LENGTH>>, <<fblangref-scalarfuncs-char_length,CHAR_LENGTH>>. 

[[fblangref-scalarfuncs-overlay]]
=== OVERLAY

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

OVERLAY (string PLACING replacement FROM pos [FOR length])
----



.Параметры функции OVERLAY
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``string``
|

Строка, в которой происходит замена.

|[replaceable]``replacement``
|

Строка, которой заменяется.

|[replaceable]``pos``
|

Позиция, с которой происходит замена. 

|[replaceable]``length``
|

Количество символов, которые будут удалены из исходной строки. 
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция OVERLAY предназначена для замены части строки другой строкой. 

По умолчанию число удаляемых из строки символов равняется длине заменяемой строки.
Дополнительный четвёртый параметр позволяет пользователю задать своё число символов, которые будут удалены.

Особенности использования: 

* Функция полностью поддерживает тестовые BLOB с любым набором символов и любой длины;
* Если входная строка имеет тип BLOB, то и результат будет иметь тип BLOB. В противном случае тип результата будет VARCHAR(n), где n является суммой длин параметров [replaceable]``string`` и [replaceable]``replacement``;
* Как и во всех строковых функциях SQL параметр [replaceable]``pos`` является определяющим;
* Если [replaceable]``pos`` больше длины строки, то [replaceable]``replacement`` помещается сразу после окончания строки;
* Если число символов от [replaceable]``pos`` до конца строки меньше, чем длина [replaceable]``replacement`` (или, чем параметр [replaceable]``length``, если он задан), то строка усекается до значения pos и [replaceable]``replacement`` помещается после него;
* При нулевом параметре [replaceable]``length`` (FOR 0) [replaceable]``replacement`` просто вставляется в строку, начиная с позиции [replaceable]``pos``;
* Если любой из параметров имеет значение NULL, то и результат будет NULL;
* Если параметры [replaceable]``pos`` и [replaceable]``length`` не являются целым числом, то используется банковское округление (до чётного): 0.5 становится 0, 1.5 становится 2, 2.5 становится 2, 3.5 становится 4 и т.д.


[WARNING]
====
При использовании BLOB функции может потребоваться загрузить весь объект в память.
При больших размерах BLOB это может повлиять на производительность. 
====

.Примеры:


.Использование функции OVERLAY
[example]

[source,sql]
----

OVERLAY ('Goodbye' PLACING 'Hello' FROM 2) -- Результат: 'Ghelloe'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 5) -- Результат: 'GoodHello'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 8) -- Результат: 'GoodbyeHello'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 20) -- Результат: 'GoodbyeHello'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 0) -– Результат: 'GHellooodbye'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 3) -- Результат: 'GHellobye'
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 6) -- Результат: 'GHello'	
OVERLAY ('Goodbye' PLACING 'Hello' FROM 2 FOR 9) -- Результат: 'Ghello'
OVERLAY ('Goodbye' PLACING '' FROM 4) -- Результат: 'Goodbye'
OVERLAY ('Goodbye' PLACING '' FROM 4 FOR 3) -- Результат: 'Gooe'
OVERLAY ('Goodbye' PLACING '' FROM 4 FOR 20) -- Результат: 'Goo'
OVERLAY ('' PLACING 'Hello' FROM 4) -- Результат: 'Hello'
OVERLAY ('' PLACING 'Hello' FROM 4 FOR 0) -- Результат: 'Hello'
OVERLAY ('' PLACING 'Hello' FROM 4 FOR 20) -- Результат: 'Hello'
----

.См. также:
<<fblangref-scalarfuncs-substring,SUBSTRING>>, <<fblangref-scalarfuncs-replace,REPLACE>>. 

[[fblangref-scalarfuncs-position]]
=== POSITION

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

POSITION (<args>)

<args> ::= 
    substr IN string
  | substr, string [, startpos]
----



.Параметры функции POSITION
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``substr``
|

Подстрока, позиция которой ищется.

|[replaceable]``string``
|

Строка, в которой ищется позиция.

|[replaceable]``startpos``
|

Позиция, с которой начинается поиск подстроки.
|===

.Тип возвращаемого результата:
INTEGER.

Функция POSITION возвращает позицию первого вхождения подстроки в строку.
Отсчёт начинается с 1.
Третий аргумент (опциональный) задаёт позицию в строке, с которой начинается поиск подстроки, тем самым игнорирую любые вхождения подстроки в строку до этой позиции.
Если совпадение не найдено, функция возвращает 0. 

Особенности использования: 

* Опциональный третий параметр поддерживается только вторым вариантом синтаксиса (синтаксис с запятой);
* Пустую строку, функция считает подстрокой любой строки. Поэтому при входном параметре [replaceable]``substr``, равном '' (пустая строка), и при параметре [replaceable]``string``, отличном от NULL, результатом будет:
+
** 1, если параметр [replaceable]``startpos`` не задан;
** 1, если параметр [replaceable]``startpos`` не задан;
** [replaceable]``startpos``, если [replaceable]``startpos`` не превышает длину параметра [replaceable]``string``.


.Примеры:


.Использование функции POSITION
[example]

[source,sql]
----

POSITION ('be' IN 'To be or not to be')   -- Результат: 4
POSITION ('be', 'To be or not to be')     -- Результат: 4
POSITION ('be', 'To be or not to be', 4)  -- Результат: 4
POSITION ('be', 'To be or not to be', 8)  -- Результат: 17
POSITION ('be', 'To be or not to be', 18) -- Результат: 0
POSITION ('be' in 'Alas, poor Yorick!') -- Результат: 0
----

.См. также:
<<fblangref-scalarfuncs-substring,SUBSTRING>>. 

[[fblangref-scalarfuncs-replace]]
=== REPLACE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

REPLACE (str, find, repl)
----



.Параметры функции REPLACE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Строка, в которой делается замена.

|[replaceable]``find``
|

Строка, которая ищется.

|[replaceable]``repl``
|

Строка, на которую происходит замена.
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция REPLACE заменяет в строке все вхождения одной строки на другую строку. 

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если один из аргументов имеет тип BLOB, то результат будет иметь тип BLOB. В противном случае результат будет иметь тип VARCHAR(N), где N рассчитывается из длин [replaceable]``str``, [replaceable]``find`` и [replaceable]``repl`` таким образом, что даже максимальное количество замен не будет вызывать переполнения поля.
* Если параметр [replaceable]``find`` является пустой строкой, то возвращается [replaceable]``str`` без изменений;
* Если параметр [replaceable]``repl`` является пустой строкой, то все вхождения [replaceable]``find`` удаляются из строки [replaceable]``str``;
* Если любой из аргументов равен NULL, то результатом всегда будет NULL, даже если не было произведено ни одной замены.


[WARNING]
====
При использовании BLOB в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах BLOB могут наблюдаться потери производительности. 
====

.Примеры:


.Использование функции REPLACE
[example]

[source,sql]
----

REPLACE ('Billy Wilder', 'il', 'oog')  -- возвращает 'Boogly Woogder'
REPLACE ('Billy Wilder', 'il', '')     -- возвращает 'Bly Wder'
REPLACE ('Billy Wilder', null, 'oog')  -- возвращает NULL
REPLACE ('Billy Wilder', 'il', null)   -- возвращает NULL
REPLACE ('Billy Wilder', 'xyz', null)  -- возвращает NULL (!)
REPLACE ('Billy Wilder', 'xyz', 'abc') -- возвращает 'Billy Wilder'
REPLACE ('Billy Wilder', '', 'abc')    -- возвращает 'Billy Wilder'
----

.См. также:
<<fblangref-scalarfuncs-overlay,OVERLAY>>. 

[[fblangref-scalarfuncs-reverse]]
=== REVERSE

.Доступно в
DSQL, PSQL

.Синтаксис
[source]
----
REVERSE (str)
----



.Параметры функции REVERSE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
VARCHAR(N).

Функция REVERSE возвратит строку перевёрнутую "задом наперёд". 

_Примеры:_

.Использование функции REVERSE
[example]

[source,sql]
----

REVERSE ('spoonful')             -- возвращает 'lufnoops'
REVERSE ('Was it a cat I saw?')  -- возвращает '?was I tac a ti saW'
----

[TIP]
====
Данная функция очень удобна, если вам предстоит работать (сортировать или группировать информацию) которая находится в окончаниях строк.
Пример такой информации – доменные имена или имена адресов электронной почты. 

[source,sql]
----

CREATE INDEX ix_people_email ON people
COMPUTED BY (reverse(email));

SELECT * FROM people
WHERE REVERSE(email) STARTING WITH reverse('.br');
----
====

[[fblangref-scalarfuncs-right]]
=== RIGHT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RIGHT (str, num)
----



.Параметры функции RIGHT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.

|[replaceable]``num``
|

Целое число.
Определяет количество возвращаемых символов.
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция RIGHT возвращает конечную (правую) часть входной строки.
Длина возвращаемой подстроки определяется вторым параметром. 

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если строковый аргумент BLOB, результатом будет BLOB, в противном случае результатом будет VARCHAR(N), при этом N – будет равно длине строкового параметра;
* Если числовой параметр превысит длину текста, результатом будет исходный текст.


[WARNING]
====
При использовании BLOB в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах BLOB могут наблюдаться потери производительности. 
====

.Примеры:


.Использование функции RIGHT
[example]

[source,sql]
----

SELECT RIGHT('ABC', 1) FROM rdb$database;
-- результат C
----

.См. также:
<<fblangref-scalarfuncs-left,LEFT>>, <<fblangref-scalarfuncs-substring,SUBSTRING>>. 

[[fblangref-scalarfuncs-rpad]]
=== RPAD

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RPAD (str, endlen [, padstr])
----



.Параметры функции RPAD
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.

|[replaceable]``endlen``
|

Длина выходной строки.

|[replaceable]``padstr``
|

Строка, которой дополняется исходная строка до указанной длины.
По умолчанию является пробелом (' ').
|===

.Тип возвращаемого результата:
VARCHAR([replaceable]``endlen``) или BLOB.

Функция RPAD дополняет справа входную строку пробелами или определённой пользователем строкой до заданной длины. 

Особенности использования: 

* Функция поддерживает текстовые блоки любой длины и с любыми наборами символов;
* Если входная строка имеет тип BLOB, то результат также будет BLOB, в противном случае результат будет VARCHAR([replaceable]``endlen``).
* Если аргумент [replaceable]``padstr`` задан, но равен пустой строке (''), то дополнения строки не происходит! В случае если [replaceable]``endlen`` меньше длины входной строки, то в результате происходит её усечение до длины [replaceable]``endlen``, даже если параметр [replaceable]``padstr`` равен пустой строке.


[WARNING]
====
При использовании BLOB в параметрах функции может потребоваться загрузить объект полностью в память.
При больших объёмах BLOB могут наблюдаться потери производительности. 
====

.Примеры:


.Использование функции RPAD
[example]

[source,sql]
----

RPAD ('Hello', 12)                -- возвращает 'Hello       '
RPAD ('Hello', 12, '-')           -- возвращает 'Hello-------'
RPAD ('Hello', 12, '')            -- возвращает 'Hello'
RPAD ('Hello', 12, 'abc')         -- возвращает 'Helloabcabca'
RPAD ('Hello', 12, 'abcdefghij')  -- возвращает 'Helloabcdefg'
RPAD ('Hello', 2)                 -- возвращает 'He'
RPAD ('Hello', 2, '-')            -- возвращает 'He'
RPAD ('Hello', 2, '')             -- возвращает 'He'
----

.См. также:
<<fblangref-scalarfuncs-lpad,LPAD>>. 

[[fblangref-scalarfuncs-substring]]
=== SUBSTRING


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

SUBSTRING (<args>)                                                                                
                        
<args> ::= 
    str FROM startpos [FOR length]                        
  | str SIMILAR <similar_pattern> ESCAPE <escape>                     
                            
<similar_pattern> ::=
  <similar pattern: R1>
  <escape>"<similar pattern: R2><escape>"
  <similar pattern: R3>
----



.Параметры функции SUBSTRING
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.

|[replaceable]``startpos``
|

Позиция, с которой начинается извлечение подстроки.
Целочисленное выражение.

|[replaceable]``length``
|

Длина возвращаемой подстроки.
Целочисленное выражение.

|[replaceable]``similar_pattern``
|

Шаблон регулярного выражения SQL, по которому ищется подстрока.

|[replaceable]``escape``
|

Символ экранирования.
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция SUBSTRING возвращает подстроку из строки, начиная с заданной позиции до конца строки или до указанной длины, либо извлекает подстроку с использованием шаблона регулярного выражения SQL. 

Если любой из входных параметров имеет значение NULL, то и результат тоже будет иметь значение NULL.

[WARNING]
====
При использовании BLOB в параметрах функции может потребоваться загрузить объект в память полностью.
При больших объёмах BLOB могут наблюдаться потери производительности. 
====

==== Позиционный SUBSTRING

В простой позиционной форме (с FROM) эта функция возвращает подстроку, начинающуюся с позиции символа [replaceable]``startpos`` (первая позиция равна 1). Без аргумента FOR он возвращает все оставшиеся символы в строке.
С использованием FOR возвращается [replaceable]``length`` символов или остаток строки, в зависимости от того что короче. 

Функция полностью поддерживает двоичные и текстовые BLOB любой длины и с любым набором символов.
Если параметр [replaceable]``str`` имеет тип BLOB, то и результат будет иметь тип BLOB.
Для любых других типов результатом будет тип VARCHAR(n).

Для входного параметра [replaceable]``str``, не являющегося BLOB, длина результата функции всегда будет равна длине строки [replaceable]``str``, независимо от значений параметров [replaceable]``startpos`` и [replaceable]``length``. 

.Примеры:


.Использование функции SUBSTRING
[example]

[source,sql]
----

SUBSTRING('Привет!' FROM 4 FOR 3)  -- вернёт подстроку 'вет'
----

==== SUBSTRING по регулярному выражению

Функция SUBSTRING с регулярным выражением (с SIMILAR) возвращает часть строки соответствующей шаблону регулярного выражения SQL.
Если соответствия не найдено, то возвращается NULL. 

Шаблон SIMILAR формируется из трех шаблонов регулярных выражений SQL: R1, R2 и R3.
Полностью шаблон имеет форму `R1 ||
                            '[replaceable]``<escape>``"' || R2 ||
                            '[replaceable]``<escape>``"' || R3` , где [replaceable]``<escape>`` -- это escape-символ, определенный в предложении ESCAPE.
R2 -- это шаблон, который соответствует подстроке для извлечения и заключен в экранированные двойные кавычки ([replaceable]``<;escape>``", например, "`#"`" с escape-символом "`#`"). R1 соответствует префиксу строки, а R3 -- суффиксу строки.
И R1, и R3 необязательны (они могут быть пустыми), но шаблон должен соответствовать всей строке.
Другими словами, недостаточно указать шаблон, который находит только подстроку для извлечения. 

[TIP]
====
Экранированные двойные кавычки вокруг R2 можно сравнить с определением одной группы захвата в более распространенном синтаксисе регулярных выражений, таком как PCRE.
То есть полный шаблон эквивалентен ``R1(R2)R3``, который должен соответствовать всей входной строке, а группа захвата -- это возвращаемая подстрока. 

Возвращаемое значение соответствует части R2 регулярного выражения.
Для этого значения истинно выражение 
[source]
----

str SIMILAR TO R1 || R2 || R3 ESCAPE <escape>
----
====

[NOTE]
====
Если любая часть шаблона из R1, R2 или R3 не является пустой строкой и не имеет формата регулярного выражения SQL, возникает исключение. 
====

Полный формат регулярных выражений SQL описан в <<_fblangref_commons_syntaxregex,Синтаксис регулярных выражений
                        SQL>>. 

.Примеры:


.Использование функции SUBSTRING с регулярными выражениями
[example]

[source,sql]
----

SUBSTRING('abcabc' SIMILAR 'a#"bcab#"c' ESCAPE '#')  -- bcab
SUBSTRING('abcabc' SIMILAR 'a#"%#"c' ESCAPE '#')     -- bcab
SUBSTRING('abcabc' SIMILAR '_#"%#"_' ESCAPE '#')     -- bcab
SUBSTRING('abcabc' SIMILAR '#"(abc)*#"' ESCAPE '#')  -- abcabc
SUBSTRING('abcabc' SIMILAR '#"abc#"' ESCAPE '#')     -- <null>
----

.См. также:
<<fblangref-scalarfuncs-position,POSITION>>, <<fblangref-scalarfuncs-left,LEFT>>, <<fblangref-scalarfuncs-right,RIGHT>>, <<fblangref-scalarfuncs-char_length,CHAR_LENGTH>>, <<fblangref-commons-predsimilarto,SIMILAR TO>>. 

[[fblangref-scalarfuncs-trim]]
=== TRIM


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

TRIM ([<adjust>] str)

<adjust> ::=  {[<where>] [what]} FROM

<where> ::=  BOTH | LEADING | TRAILING
----



.Параметры функции TRIM
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.

|[replaceable]``where``
|

Из какого места необходимо удалить подстроку.
По умолчанию BOTH.

|[replaceable]``what``
|

Подстрока, которую надо удалить (неоднократно, если таких вхождений несколько) из входной строки [replaceable]``str`` в её начале и/или конце.
По умолчанию является пробелом (' ').
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция TRIM удаляет начальные и /или концевые пробелы (или текст согласно настройкам) из входной строки.



.Спецификация опций функции TRIM
[cols="<1,<3", options="header",stripes="none"]
|===
|  Опция 
|  Описание 

| BOTH 
| с обеих сторон строки (по умолчанию) 

| LEADING 
| с начала строки 

| TRAILING 
| с конца строки 
|===

Особенности использования: 

* Если входной параметр [replaceable]``str`` имеет тип BLOB, то и результат будет иметь тип BLOB. В противном случае результат будет иметь тип VARCHAR(n), где n является длиной параметра [replaceable]``str``;
* Подстрока для удаления, если она, конечно, задана, не должна иметь длину больше, чем 32767 байта. Однако при повторениях подстроки в начале и/или конце входного параметра [replaceable]``str`` общее число удаляемых байтов может быть гораздо больше.


[WARNING]
====
При использовании BLOB в параметрах функции может потребоваться загрузить объект в память полностью.
При больших объёмах BLOB могут наблюдаться потери производительности.
====

.Примеры:


.Использование функции TRIM
[example]

[source,sql]
----

SELECT TRIM (' Waste no space ')
FROM RDB$DATABASE -- Результат: 'Waste no space'

SELECT TRIM (LEADING FROM ' Waste no space ')
FROM RDB$DATABASE -- Результат: 'Waste no space '

SELECT TRIM (LEADING '.' FROM ' Waste no space ')
FROM RDB$DATABASE -- Результат: ' Waste no space '

SELECT TRIM (TRAILING '!' FROM 'Help!!!!')
FROM RDB$DATABASE -- Результат: 'Help'

SELECT TRIM ('la' FROM 'lalala I love you Ella')
FROM RDB$DATABASE -- Результат: ' I love you El'
----

.См. также:
<<fblangref-scalarfuncs-overlay,OVERLAY>>, <<fblangref-scalarfuncs-replace,REPLACE>>. 

[[fblangref-scalarfuncs-upper]]
=== UPPER

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис

[source]
----

UPPER (str)
----



.Параметры функции UPPER
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
VARCHAR(N) или BLOB.

Функция UPPER возвращает входную строку в верхнем регистре.
Точный результат зависит от набора символов входной строки.
Например, для наборов символов NONE и ASCII только ASCII символы переводятся в верхний регистр; для OCTETS -- вся входная строка возвращается без изменений. 

.Примеры:


.Использование функции UPPER
[example]

[source,sql]
----

/* Результат: 'DEBACLE', в соответствии с французскими 
 * правилами приведения в верхний регистр 
 */                        
SELECT UPPER(_ISO8859_1 'Débâcle' COLLATE FR_FR)
FROM RDB$DATABASE
----

.См. также:
<<fblangref-scalarfuncs-lower,LOWER>>. 

[[_fblangref_functions_datetime]]
== Функции для работы с датой и временем

[[fblangref-scalarfuncs-at]]
=== AT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----
                                                           
<expr> AT {TIME ZONE <time zone string> | LOCAL}                       
                        
<time zone string> ::=
    '<time zone>'                            
                            
<time zone> ::=
    <time zone region> |
    [+/-] <hour displacement> [: <minute displacement>]
----

Преобразует время или временную метку в указанный часовой пояс.
Если используется ключевое слово LOCAL, то преобразование происходит в часовой пояс сессии.

.Примеры:


.Использование функции AT
[example]

[source,sql]
----

select time '12:00 GMT' at time zone '-03'
  from rdb$database;

select current_timestamp at time zone 'America/Sao_Paulo'
  from rdb$database;

select timestamp '2018-01-01 12:00 GMT' at local
  from rdb$database;
----

[[fblangref-scalarfuncs-dateadd]]
=== DATEADD

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

DATEADD (<args>)
                            
<args> ::= amount <unit> TO datetime
         | <unit>, amount, datetime 
                            
<unit> ::= 
    YEAR | MONTH | WEEK | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
----



.Параметры функции DATEADD
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``amount``
|

Выражение типа SMALLINT, INTEGER, BIGINT или NUMERIC (отрицательное вычитается).

|[replaceable]``unit``
|

Составляющая даты/времени.

|[replaceable]``datetime``
|

Выражение типа DATE, TIME или TIMESTAMP.
|===

.Тип возвращаемого результата:
определяется третьим аргументом функции. 

Функция DATEADD позволяет добавить заданное число лет, месяцев, недель, часов, минут, секунд, миллисекунд к заданному значению даты/времени.

[NOTE]
====


* С аргументом типа TIMESTAMP и DATE можно использовать любую составляющую даты/времени ([replaceable]``<unit>``);
* Для типа данных TIME разрешается использовать только HOUR, MINUTE, SECOND и MILLISECOND.

====

.Примеры:


.Использование функции DATEADD
[example]

[source,sql]
----

DATEADD (28 DAY TO CURRENT_DATE)
DATEADD (-6 HOUR TO CURRENT_TIME)
DATEADD (MONTH, 9, DATEOFCONCEPTION)
DATEADD (-38 WEEK TO DATEOFBIRTH)
DATEADD (MINUTE, 90, CAST('NOW' AS TIME))
DATEADD (? YEAR TO DATE '11-SEP-1973')

SELECT 
  CAST(DATEADD(-1 * EXTRACT(MILLISECOND FROM ts) MILLISECOND TO ts) AS VARCHAR(30)) AS t, 
  EXTRACT(MILLISECOND FROM ts) AS ms 
FROM ( 
    SELECT TIMESTAMP'2014-06-09 13:50:17.4971' as ts 
    FROM RDB$DATABASE 
) a
----
[listing]
....

T                             MS
------------------------------------    
2014-06-09 13:50:17.0000	497.1
....

.См. также:
<<fblangref-scalarfuncs-datediff,DATEDIFF>>, <<_fblangref_datatypes_datetime_operation,"Операции, использующие
                        значения даты и времени">>. 

[[fblangref-scalarfuncs-datediff]]
=== DATEDIFF

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

DATEDIFF (<args>)
                            
<args> ::= <unit> FROM moment_1 TO moment_2
         | <unit>, moment_1, moment_2 
                            
<unit> ::= 
    YEAR | MONTH | WEEK | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
----



.Параметры функции DATEDIFF
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``unit``
|

Составляющая даты/времени.

|[replaceable]``monent_1``
|

Выражение типа DATE, TIME или TIMESTAMP.

|[replaceable]``monent_2``
|

Выражение типа DATE, TIME или TIMESTAMP.
|===

.Тип возвращаемого результата:
BIGINT.

Функция DATEDIFF возвращает количество лет, месяцев, недель, дней, часов, минут, секунд или миллисекунд между двумя значениями даты/времени.

Особенности использования: 

* Параметры DATE и TIMESTAMP могут использоваться совместно. Совместное использование типа TIME с типами DATE и TIMESTAMP не разрешается;
* С аргументом типа TIMESTAMP и DATE можно использовать любую составляющую даты/времени ([replaceable]``<unit>``);
* Для типа данных TIME разрешается использовать только HOUR, MINUTE, SECOND и MILLISECOND.


[NOTE]
====


* Функция DATEDIFF не проверяет разницу в более мелких составляющих даты/времени, чем задана в первом аргументе ([replaceable]``<unit>``). В результате получаем: 
+
[source]
----

- DATEDIFF (YEAR, DATE '1-JAN-2009', DATE '31-DEC-2009') = 0, но 
- DATEDIFF (YEAR, DATE '31-DEC-2009', DATE '1-JAN-2010') = 1
----
* Однако для более мелких составляющих даты/времени имеем: 
+
[source]
----

- DATEDIFF (DAY, DATE '26-JUN-1908', DATE '11-SEP-1973') = 23818 
- DATEDIFF (DAY, DATE '30-NOV-1971', DATE '8-JAN-1972') = 39
----
* Отрицательное значение функции говорит о том, что дата/время в [replaceable]``moment_2`` меньше, чем в [replaceable]``moment_1``. 

====

.Примеры:


.Использование функции DATEDIFF
[example]

[source,sql]
----

DATEDIFF (HOUR FROM CURRENT_TIMESTAMP TO TIMESTAMP '12-JUN-2059 06:00')
DATEDIFF (MINUTE FROM TIME '0:00' TO CURRENT_TIME)
DATEDIFF (MONTH, CURRENT_DATE, DATE '1-1-1900')
DATEDIFF (DAY FROM CURRENT_DATE TO CAST (? AS DATE))
----

.См. также:
<<fblangref-scalarfuncs-dateadd,DATEADD>>, <<_fblangref_datatypes_datetime_operation,"Операции, использующие
                        значения даты и времени">>. 

[[fblangref-scalarfuncs-extract]]
=== EXTRACT

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис

[source]
----

EXTRACT (<part> FROM datetime) 
                            
<part> ::= 
    YEAR | MONTH | WEEK | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
  | TIMEZONE_HOUR | TIMEZONE_MINUTE
----



.Параметры функции EXTRACT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``part``
|

Составляющая даты/времени.

|[replaceable]``datetime``
|

Выражение типа DATE, TIME или TIMESTAMP.
|===

.Тип возвращаемого результата:
SMALLINT или NUNERIC.

Функция EXTRACT извлекает составляющие даты и времени из типов данных DATE, TIME и TIMESTAMP.



.Типы и диапазоны результатов функции EXTRACT
[cols="1,1,1,1", frame="all", options="header"]
|===
|  Составляющая даты/времени 
|  Тип 
|  Диапазон 
|  Комментарий 

|YEAR 
|SMALLINT 
|1–9999 
|Год

|MONTH 
|SMALLINT 
|1–12 
|Месяц

|WEEK 
|SMALLINT 
|1–53 
|Номер недели в году

|DAY 
|SMALLINT 
|1–31 
|День

|WEEKDAY 
|SMALLINT 
|0–6 
|День недели. 0 -- Воскресенье 

|YEARDAY 
|SMALLINT 
|0–365 
|Номер дня в году. 0 = 1 января 

|HOUR 
|SMALLINT 
|0–23 
|Часы

|MINUTE 
|SMALLINT 
|0–59 
|Минуты

|SECOND 
|NUMERIC(9,4) 
|0.0000–59.9999 
|Секунды. Включает в себя миллисекунды 

|MILLISECOND 
|NUMERIC(9,1) 
|0.0–999.9 
|Миллисекунды

|TIMEZONE_HOUR
|SMALLINT
|от -14 до +14
|Смещение часов часового пояса

|TIMEZONE_MINUTE
|SMALLINT
|от -59 до +59
|Смещение минут часового пояса
|===

[NOTE]
====
Если составляющая даты/времени не присутствует в аргументе дата/время, например SECOND в аргументе с типом DATE или YEAR в TIME, то функция вызовет ошибку.
====

Из аргумента с типом данных DATE или TIMESTAMP можно извлекать номер недели.
В соответствии со стандартом ISO-8601 неделя начинается с понедельника и всегда включает в себя 7 дней.
Первой неделей года является первая неделя, у которой в ней больше дней в новом году (по крайней мере, 4): дни 1-3 могут принадлежать предыдущей неделе (52 или 53) прошлого года.
По аналогии дни 1-3 текущего года могут принадлежать 1 неделе следующего года. 

.Примеры:


.Использование функции EXTRACT
[example]

[source,sql]
----

/* получить по дате номер квартала */
SELECT (EXTRACT(MONTH FROM CURRENT_TIMESTAMP)-1)/3+1
FROM RDB$DATABASE
----

.См. также:
<<_fblangref_datatypes_datetime,Типы данных для работы с датой и
                        временем>>. 

[[fblangref-scalarfuncs-firstday]]
=== FIRST_DAY

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис

[source]
----

FIRST_DAY( OF <part> FROM <date_or_timestamp> )   
                            
<part> ::= { YEAR | MONTH | WEEK }
----



.Параметры функции FIRST_DAY
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``part``
|

Составляющая даты/времени.

|[replaceable]``date_or_timestamp``
|

Выражение типа DATE или TIMESTAMP.
|===

.Тип возвращаемого результата:
DATE или TIMESTAMP.

Возвращает первый день года, месяца или недели для заданной даты.

[NOTE]
====


* Первым днём недели считается воскресенье, как это возвращает функция EXTRACT с частью WEEKDAY.
* Когда в качестве аргумента функции передаётся выражение типа TIMESTAMP, то возвращаемое значение сохраняет временную часть.

====

.Примеры:


.Использование функции FIRST_DAY
[example]

[source,sql]
----

SELECT FIRST_DAY(OF MONTH FROM current_date) FROM rdb$database;
SELECT FIRST_DAY(OF YEAR FROM current_timestamp) FROM rdb$database;
SELECT FIRST_DAY(OF WEEK FROM date '2017-11-01') FROM rdb$database;
----

.См. также:
<<fblangref-scalarfuncs-lastday,LAST_DAY>>. 

[[fblangref-scalarfuncs-lastday]]
=== LAST_DAY

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис

[source]
----

LAST_DAY( OF <part> FROM <date_or_timestamp> )   
                            
<part> ::= { YEAR | MONTH | WEEK }
----



.Параметры функции LAST_DAY
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``part``
|

Составляющая даты/времени.

|[replaceable]``date_or_timestamp``
|

Выражение типа DATE или TIMESTAMP.
|===

.Тип возвращаемого результата:
DATE или TIMESTAMP.

Возвращает последний день года, месяца или недели для заданной даты.

[NOTE]
====


* Последним днём недели считается суббота, как это возвращает функция EXTRACT с частью WEEKDAY.
* Когда в качестве аргумента функции передаётся выражение типа TIMESTAMP, то возвращаемое значение сохраняет временную часть.

====

.Примеры:


.Использование функции LAST_DAY
[example]

[source,sql]
----

SELECT LAST_DAY(OF MONTH FROM current_date) FROM rdb$database;
SELECT LAST_DAY(OF YEAR FROM current_timestamp) FROM rdb$database;
SELECT LAST_DAY(OF WEEK FROM date '2017-11-01') FROM rdb$database;
----

.См. также:
<<fblangref-scalarfuncs-firstday,FIRST_DAY>>. 

[[_fblangref_functions_decfloat]]
== Функции для работы с типом DECFLOAT

[[fblangref-scalarfuncs-compare_decfloat]]
=== COMPARE_DECFLOAT


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

COMPARE_DECFLOAT (value1, value2)
----



.Параметры функции COMPARE_DECFLOAT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``value1``, [replaceable]``value2``
|

Значения типа DECFLOAT.
|===

.Тип возвращаемого результата:
SMALLINT.

Функция COMPARE_DECFLOAT сравнивает два значения типа DECFLOAT, которые могут быть одинаковыми, разными или неупорядоченными.

Функция возвращает: 

* 0 - если значения равны;
* 1 - если первое значение меньше чем второе;
* 2 - если первое значение больше чем второе;
* 3 - значения не упорядочены (одно или оба NAN / SNAN).

В отличие от операторов сравнения (<, >, = и др.) сравнение с помощью COMPARE_DECFLOAT является точным, т.е. 
[source,sql]
----

COMPARE_DECFLOAT(2.17, 2.170)
----
вернёт 2, а не 0. 

[[fblangref-scalarfuncs-normalize_decfloat]]
=== NORMALIZE_DECFLOAT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

NORMALIZE_DECFLOAT (value)
----



.Параметры функции NORMALIZE_DECFLOAT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|

Значение типа DECFLOAT.
|===

.Тип возвращаемого результата:
DECFLOAT.

Функция NORMALIZE_DECFLOAT возвращает число в нормализованном виде.
Это обозначает, что для любого ненулевого значения удаляются завершающие нули с соответствующей коррекцией экспоненты.

.Нормализация различных значений типа DECFLOAT
[example]

[source,sql]
----
 
NORMALIZE_DECFLOAT(12.00) -- возвращает 12
NORMALIZE_DECFLOAT(120) -- возвращает 1.2E+2
----

[[fblangref-scalarfuncs-quantize]]
=== QUANTIZE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

QUANTIZE (value, pattern)
----



.Параметры функции NORMALIZE_DECFLOAT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|

Значение типа DECFLOAT.

|[replaceable]``pattern``
|

Значение шаблона типа DECFLOAT, по которому будет отмасштабирован значение первого аргумента.
|===

.Тип возвращаемого результата:
DECFLOAT.

Функция QUANTIZE возвращает значение первого аргумента масштабированным с использованием второго значения в качестве шаблона.
Другими словами функция QUANTIZE возвращает значение DECFLOAT, равное по значению (за исключением любого округления) и знаку value, а также экспоненте, равной по значению экспоненте [replaceable]``pattern``.
Функцию QUANTIZE можно использовать для реализации округления с точностью до нужного знака, например, округление до ближайшего цента с использованием установленного режима округления DECFLOAT.

[NOTE]
====
Для значения шаблона не никаких ограничений, тем не менее при использовании SNaN функция выдаст исключение, при использовании NULL результатом будет NULL и т.д.
====

.Примеры:


.Использование функции QUANTIZE
====

[source,sql]
----

select v, pic, quantize(v, pic) from examples;
----


----

V                       PIC                   QUANTIZE
======================= ===================== ==================
                   3.16                 0.001              3.160
                   3.16                 0.01               3.16
                   3.16                 0.1                3.2
                   3.16                 1                  3
                   3.16                 1E+1               0E+1
                   -0.1                 1                 -0
                      0                 1E+5               0E+5
                    316                 0.1              316.0
                    316                 1                316
                    316                 1E+1             3.2E+2
                    316                 1E+2               3E+2
----
====

[[fblangref-scalarfuncs-totalorder]]
=== TOTALORDER

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

TOTALORDER (value1, value2)
----



.Параметры функции TOTALORDER
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``value1``, [replaceable]``value2``
|

Значения типа DECFLOAT.
|===

.Тип возвращаемого результата:
SMALLINT.

Функция TOTALORDER сравнивает два значения типа DECFLOAT, включая специальные значения.
Сравнение является точным. 

Функция возвращает:

* -1 -- если первое значение меньше второго;
* 0 -- если значения равны;
* 1 -- если первое значение больше второго.

Значения DEFLOAT в следующем виде: 
[source]
----

-nan < -snan < -inf < -0.1 < -0.10 < -0 < 0 < 0.10 < 0.1 < inf < snan < nan
----

[[_fblangref_functions_binary]]
== Кодирование и декодирование бинарных данных

[[fblangref-scalarfuncs-base64_encode]]
=== BASE64_ENCODE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BASE64_ENCODE (<binary data>)
----

.Тип возвращаемого результата:
BLOB или VARCHAR.

Функция BASE64_ENCODE кодирует входные данные в представлении BASE64.
Функция может работать как с символьной строкой, так и с BLOB.

.Примеры:


.Использование функции BASE64_ENCODE
[example]

[source,sql]
----

select base64_encode(public_key) from clients;
----

.См. также:
<<fblangref-scalarfuncs-base64_decode,BASE64_DECODE>>. 

[[fblangref-scalarfuncs-base64_decode]]
=== BASE64_DECODE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BASE64_DECODE (<base64 data>)
----

.Тип возвращаемого результата:
BLOB или VARCHAR.

Функция BASE64_DECODE декодирует входные данные из представления BASE64.
Функция может работать как с символьной строкой, так и с BLOB.

.См. также:
<<fblangref-scalarfuncs-base64_encode,BASE64_ENCODE>>. 

[[fblangref-scalarfuncs-hex_encode]]
=== HEX_ENCODE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

HEX_ENCODE (<binary data>)
----

.Тип возвращаемого результата:
BLOB или VARCHAR.

Функция HEX_ENCODE кодирует двоичные данные в шестнадцатеричное представлении.
Функция может работать как с символьной строкой, так и с BLOB.

.Примеры:


.Использование функции HEX_ENCODE
[example]

[source,sql]
----

select hex_encode(public_key) from clients;
----

.См. также:
<<fblangref-scalarfuncs-hex_decode,HEX_DECODE>>. 

[[fblangref-scalarfuncs-hex_decode]]
=== HEX_DECODE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

HEX_DECODE (<hex data>)
----

.Тип возвращаемого результата:
BLOB или VARBINARY.

Функция HEX_DECODE декодирует данные в шестнадцатеричном представлении в двоичные данные.
Функция может работать как с символьной строкой, так и с BLOB.

.См. также:
<<fblangref-scalarfuncs-hex_encode,HEX_ENCODE>>. 

[[_fblangref_functions_hash]]
== Хеш функции

[[fblangref-scalarfuncs-hash]]
=== HASH

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

HASH (str [USING <algorithm>])        
                            
<algorithm> ::= { CRC32 }
----



.Параметры функции HASH
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
BIGINT.

Функция HASH возвращает некриптографический хэш входной строки.
Эта функция полностью поддерживает текстовые BLOB любой длины и с любым набором символов. 

Если предложение USING не указано, то функция возвращает BIGINT.
В этом случае используется 64-битный вариант некриптографической хэш-функции PJW (также известной как ELF64) https://en.wikipedia.org/wiki/PJW_hash_function.
Эта функция очень быстра и может использоваться для общих целей (хеш-таблицы и т.
д.), но имеет большое количество коллизий. 

Предложение USING позволяет указать алгоритм по которому вычисляет хэш.
На данный момент поддерживается только один алгоритм CRC32, использующий полиномом 0x04C11DB7.
В этом случае функция возвращает результат с типом INTEGER.

.Примеры:


.Использование функции HASH
[example]

[source,sql]
----

SELECT HASH(x) FROM MyTable;
-- результат типа BIGINT

SELECT HASH(x USING CRC32) FROM MyTable;
-- результат типа INTEGER
----

[[fblangref-scalarfuncs-crypt_hash]]
=== CRYPT_HASH

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

CRYPT_HASH (str USING <algorithm>)        
                            
<algorithm> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----



.Параметры функции CRYPT_HASH
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``str``
|

Выражение строкового типа.
|===

.Тип возвращаемого результата:
VARBINARY.

Функция CRYPT_HASH возвращает криптографический хэш входной строки, используя указанный алгоритм.
Эта функция полностью поддерживает текстовые BLOB любой длины и с любым набором символов.
Предложение USING позволяет указать алгоритм по которому вычисляет хэш. 

[NOTE]
====
Алгоритмы MD5 и SHA1 не рекомендуются для использования из-за известных серьезных проблем, которые предоставляются ТОЛЬКО для обратной совместимости.
====

.Примеры:


.Использование функции CRYPT_HASH
[example]

[source,sql]
----

SELECT CRYPT_HASH(x USING SHA256) FROM MyTable;
-- результат типа VARBINARY
----

[[_fblangref_functions_crypt]]
== Криптографические функции

В Firebird 4.0 поддерживается только подмножество симметричных алгоритмов шифрования (как блочных так и потоковых), так и RSA.

[[fblangref-scalarfuncs-encrypt]]
=== ENCRYPT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

ENCRYPT (<data> [USING <algorithm>] [MODE <mode>] KEY <key>
  [IV <iv>] [<endianness>] [CTR_LENGTH <ctr_length>] [COUNTER <counter>])        
                            
<algorithm> ::= { <block_cipher> | <stream_cipher> }

<block_cipher> ::= 
  { AES | ANUBIS | BLOWFISH | KHAZAD | RC5 | RC6 | SAFER+ | TWOFISH | XTEA }  

<stream_cipher> ::= { CHACHA20 | RC4 | SOBER128 }

<mode> ::= { CBC | CFB | CTR | ECB | OFB }

<endianness> ::= { CTR_BIG_ENDIAN | CTR_LITTLE_ENDIAN }
----



.Параметры функции ENCRYPT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``data``
|

Выражение строкового типа или BLOB, которое необходимо зашифровать.

|[replaceable]``algorithm``
|

Алгоритм шифрования.
Поддерживаются как блочные, так и потоковые алгоритмы.

|[replaceable]``mode``
|

Режим шифрования.
Обязателен для блочных алгоритмов шифрования.

|[replaceable]``key``
|

Ключ шифрования.

|[replaceable]``iv``
|

Вектор инициализации (IV). Должен быть указан для всех блочных алгоритмов шифрования за исключением ECB и всех потоковых алгоритмов шифрования за исключением RC4.

|[replaceable]``endianness``
|

Порядок байтов счётчика.
Может быть указан только в режиме CTR.
По умолчанию используется CTR_LITTLE_ENDIAN.

|[replaceable]``ctr_length``
|

Длина счётчика в байтах.
Может быть указана только в режиме CTR.
По умолчанию равна длине вектора инициализации IV.

|[replaceable]``counter``
|

Начальное значение счётчика.
Может быть указана только для алгоритма CHACHA20.
По умолчанию равно 0.
|===

.Тип возвращаемого результата:
BLOB или VARBINARY.

Функция ENCRYPT шифрует данные с использованием симметричного шифра.
Размеры строк передаваемых в эту функцию должны соответствовать требованиям выбранного алгоритма и режима.

.Примеры:


.Использование функции ENCRYPT
[example]

[source,sql]
----

select encrypt('897897' using sober128 key 'AbcdAbcdAbcdAbcd' iv '01234567') 
from rdb$database;
----

.См. также:
<<fblangref-scalarfuncs-decrypt,DECRYPT>>. 

[[fblangref-scalarfuncs-decrypt]]
=== DECRYPT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

DECRYPT (<data> [USING <algorithm>] [MODE <mode>] KEY <key>
  [IV <iv>] [<endianness>] [CTR_LENGTH <ctr_length>] [COUNTER <counter>])        
                            
<algorithm> ::= { <block_cipher> | <stream_cipher> }

<block_cipher> ::= 
  { AES | ANUBIS | BLOWFISH | KHAZAD | RC5 | RC6 | SAFER+ | TWOFISH | XTEA }  

<stream_cipher> ::= { CHACHA20 | RC4 | SOBER128 }

<mode> ::= { CBC | CFB | CTR | ECB | OFB }

<endianness> ::= { CTR_BIG_ENDIAN | CTR_LITTLE_ENDIAN }
----



.Параметры функции DECRYPT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``data``
|

Выражение строкового типа или BLOB, которое необходимо зашифровать.

|[replaceable]``algorithm``
|

Алгоритм шифрования.
Поддерживаются как блочные, так и потоковые алгоритмы.

|[replaceable]``mode``
|

Режим шифрования.
Обязателен для блочных алгоритмов шифрования.

|[replaceable]``key``
|

Ключ шифрования.

|[replaceable]``iv``
|

Вектор инициализации (IV). Должен быть указан для всех блочных алгоритмов шифрования за исключением ECB и всех потоковых алгоритмов шифрования за исключением RC4.

|[replaceable]``endianness``
|

Порядок байтов счётчика.
Может быть указан только в режиме CTR.
По умолчанию используется CTR_LITTLE_ENDIAN.

|[replaceable]``ctr_length``
|

Длина счётчика в байтах.
Может быть указана только в режиме CTR.
По умолчанию равна длине вектора инициализации IV.

|[replaceable]``counter``
|

Начальное значение счётчика.
Может быть указана только для алгоритма CHACHA20.
По умолчанию равно 0.
|===

.Тип возвращаемого результата:
BLOB или VARBINARY.

Функция DECRYPT дешифрует данные с использованием симметричного шифра.
Размеры строк передаваемых в эту функцию должны соответствовать требованиям выбранного алгоритма и режима.

.Примеры:


.Использование функции DECRYPT
[example]

[source,sql]
----

select decrypt(x'0154090759DF' using sober128 key 'AbcdAbcdAbcdAbcd' 
               iv '01234567') 
from rdb$database;

select decrypt(secret_field using aes mode ofb key '0123456701234567' 
               iv init_vector) 
from secure_table;
----

.См. также:
<<fblangref-scalarfuncs-encrypt,ENCRYPT>>. 

[[fblangref-scalarfuncs-rsa_private]]
=== RSA_PRIVATE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RSA_PRIVATE (<size>)
----



.Параметры функции RSA_PRIVATE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``size``
|

Размер ключа в байтах.
|===

.Тип возвращаемого результата:
VARBINARY.

Функция RSA_PRIVATE возвращает RSA закрытый ключ заданной длины (в байтах) в PKCS#1 формате как строку VARBINARY.

.Примеры:


.Использование функции RSA_PRIVATE
[example]

[source,sql]
----

select rdb$set_context('USER_SESSION', 'private_key', rsa_private(256))
from rdb$database;
----

.См. также:
<<fblangref-scalarfuncs-rsa_public,RSA_PUBLIC>>. 

[[fblangref-scalarfuncs-rsa_public]]
=== RSA_PUBLIC

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RSA_PUBLIC (<private key>)
----



.Параметры функции RSA_PUBLIC
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``private key``
|

RSA закрытый ключ.
|===

.Тип возвращаемого результата:
VARBINARY.

Функция RSA_PUBLIC возвращает RSA открытый ключ для заданного RSA закрытого ключа.
Оба ключа должны быть в PKCS#1 формате.

.Примеры:


.Использование функции RSA_PUBLIC
====
Закрытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_private,RSA_PRIVATE>>


[source,sql]
----

select rdb$set_context('USER_SESSION', 'public_key',
    rsa_public(rdb$get_context('USER_SESSION', 'private_key'))) 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_private,RSA_PRIVATE>>. 

[[fblangref-scalarfuncs-rsa_encrypt]]
=== RSA_ENCRYPT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RSA_ENCRYPT (<data> KEY <public_key> [LPARAM <tag>] [HASH <hash>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----



.Параметры функции RSA_ENCRYPT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``data``
|

Данные (строка или BLOB) для шифрования.

|[replaceable]``public_key``
|

Открытый RSA ключ, который возвращает функция RSA_UBLIC.

|[replaceable]``tag``
|

Дополнительный системный тег, который можно применять для определения того, какая система закодировала сообщение.
Значением по умолчанию является NULL.

|[replaceable]``hash``
|

Алгоритм хеширования.
По умолчанию SHA256.
|===

.Тип возвращаемого результата:
VARBINARY.

Заполняет данные, используя заполнение OAEP, и шифрует их, используя открытый ключ RSA.
Обычно используется для шифрования коротких симметричных ключей, которые затем используются в блочных шифрах для шифрования сообщения.

.Примеры:


.Использование функции RSA_ENCRYPT
====
Открытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_public,RSA_PUBLIC>>


[source,sql]
----

select rdb$set_context('USER_SESSION', 'msg', 
    rsa_encrypt('Some message' key rdb$get_context('USER_SESSION', 'public_key'))) 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_public,RSA_PUBLIC>>, <<fblangref-scalarfuncs-rsa_decrypt,RSA_DECRYPT>>. 

[[fblangref-scalarfuncs-rsa_decrypt]]
=== RSA_DECRYPT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RSA_DECRYPT (<data> KEY <private_key> [LPARAM <tag>] [HASH <hash>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----



.Параметры функции RSA_DECRYPT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``data``
|

Данные (строка или BLOB) для дешифрования.

|[replaceable]``private_key``
|

Закрытый RSA ключ, который возвращает функция RSA_PRIVATE.

|[replaceable]``tag``
|

Дополнительный системный тег.
Должно быть тем же самым значением, которое передавалось RSA_ENCRYPT.
Если оно не совпадает с тем, который использовался во время кодирования, эта функция не расшифровывает пакет.
Значением по умолчанию является NULL.

|[replaceable]``hash``
|

Алгоритм хеширования.
По умолчанию SHA256.
|===

.Тип возвращаемого результата:
VARCHAR.

Расшифровывает с использованием закрытого ключа RSA, и удаляет OAEP дополненные данные.

.Примеры:


.Использование функции RSA_DECRYPT
====
Закрытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_private,RSA_PRIVATE>>.
Данные для расшифровки сипользуются из примера в <<fblangref-scalarfuncs-rsa_encrypt,RSA_ENCRYPT>>


[source,sql]
----

select RSA_DECRYPT(rdb$get_context('USER_SESSION', 'msg')
    key rdb$get_context('USER_SESSION', 'private_key'))
from RDB$DATABASE;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_private,RSA_PRIVATE>>, <<fblangref-scalarfuncs-rsa_encrypt,RSA_ENCRYPT>>. 

[[fblangref-scalarfuncs-rsa_sign_hash]]
=== RSA_SIGN_HASH

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RSA_SIGN_HASH (<data> KEY <private_key> [HASH <hash>] [SALT_LENGTH <length>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----



.Параметры функции RSA_SIGN_HASH
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``data``
|

Данные (строка или BLOB) для кодирования.

|[replaceable]``private_key``
|

Закрытый RSA ключ, который возвращает функция RSA_PRIVATE.

|[replaceable]``hash``
|

Алгоритм хеширования.
По умолчанию SHA256.

|[replaceable]``length``
|

Указывает на длину желаемой соли и, как правило, должен быть небольшим.
Хорошее значение от 8 до 16.
|===

.Тип возвращаемого результата:
VARBINARY.

Выполняет PSS-кодирование дайджеста сообщения для подписи и подписывает его с использованием закрытого ключа RSA.
Возвращает подпись сообщения.

.Примеры:


.Использование функции RSA_SIGN_HASH
====
Закрытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_private,RSA_PRIVATE>>. 


[source,sql]
----

select rdb$set_context('USER_SESSION', 'msg', 
    rsa_sign_hash(crypt_hash('Test message' using sha256)
    key rdb$get_context('USER_SESSION', 'private_key'))) 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_private,RSA_PRIVATE>>, <<fblangref-scalarfuncs-rsa_verify_hash,RSA_VERIFY_HAS>>. 

[[fblangref-scalarfuncs-rsa_verify_hash]]
=== RSA_VERIFY_HASH

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

RSA_VERIFY_HASH (<data> SIGNATURE <signature> KEY <public_key> [HASH <hash>] 
  [SALT_LENGTH <length>])
                            
<hash> ::= { MD5 | SHA1 | SHA256 | SHA512 }
----



.Параметры функции RSA_VERIFY_HASH
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``data``
|

Данные (строка или BLOB) для кодирования.

|[replaceable]``signature``
|

Подпись.
Должно быть значением возвращаемым функцией RSA_SIGN_HASH.

|[replaceable]``public_key``
|

Открытый RSA ключ, который возвращает функция RSA_PUBLIC.

|[replaceable]``hash``
|

Алгоритм хеширования.
По умолчанию SHA256.

|[replaceable]``length``
|

Указывает на длину желаемой соли и, как правило, должен быть небольшим.
Хорошее значение от 8 до 16.
|===

.Тип возвращаемого результата:
BOOLEAN.

Выполняет PSS-кодирование дайджеста сообщения для подписи и проверяет его цифровую подпись, используя открытый ключ RSA.
Возвращает результат проверки подписи.

.Примеры:


.Использование функции RSA_VERIFY_HASH
====
Открытый ключ должен быть инициализирован ранее см.
пример в <<fblangref-scalarfuncs-rsa_public,RSA_PUBLIC>> Цифровая подпись получена ранее с помощью функции <<fblangref-scalarfuncs-rsa_sign_hash,RSA_SIGN_HASH>>. 


[source,sql]
----

select rsa_verify_hash(crypt_hash('Test message' using sha256) 
    signature rdb$get_context('USER_SESSION', 'msg')
    key rdb$get_context('USER_SESSION', 'public_key')) 
from rdb$database;
----
====

.См. также:
<<fblangref-scalarfuncs-rsa_sign_hash,RSA_SIGN_HASH>>, <<fblangref-scalarfuncs-rsa_public,RSA_PUBLIC>>. 

[[_fblangref_functions_casting]]
== Функции преобразования типов

[[fblangref-scalarfuncs-cast]]
=== CAST

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис

[source]
----

CAST(value | NULL AS <type>)
                            
<type> ::= 
    <datatype>
  | [TYPE OF] domain
  | TYPE OF COLUMN relname.colname

<datatype> ::= 
    <scalar_datatype> | <blob_datatype> | <array_datatype>                    
                    
<scalar_datatype> ::=  См. Синтаксис скалярных типов данных
                    
<blob_datatype> ::= См. Синтаксис типа данных BLOB          
                    
<array_datatype> ::= См. Синтаксис массивов
----



.Параметры функции CAST
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|value
|

SQL выражение.

|[replaceable]``datatype``
|

Тип данных SQL.

|[replaceable]``domain``
|

Домен.

|[replaceable]``relname``
|

Имя таблицы или представления. 

|[replaceable]``colname``
|

Имя столбца таблицы или представления. 
|===

.Тип возвращаемого результата:
[replaceable]``<type>``.

Функция CAST служит для явного преобразования данных из одного типа данных в другой тип данных или домен.
Если это невозможно будет выдана ошибка.



.Допустимые преобразования для функции CAST
[cols="1,1", options="header"]
|===
| Из типа
| В тип

|
// <simplelist type="vert" columns="1">
//                                         <member>&#x427;&#x438;&#x441;&#x43B;&#x43E;&#x432;&#x44B;&#x435; &#x442;&#x438;&#x43F;&#x44B;</member>
//                                     </simplelist>

|
// <simplelist type="vert" columns="1">
//                                         <member>&#x427;&#x438;&#x441;&#x43B;&#x43E;&#x432;&#x44B;&#x435; &#x442;&#x438;&#x43F;&#x44B;</member>
//                                         <member>[VAR]CHAR</member>
//                                         <member>BLOB</member>
//                                     </simplelist>


|
// <simplelist type="vert" columns="1">
//                                         <member>[VAR]CHAR</member>
//                                         <member>BLOB</member>
//                                     </simplelist>

|
// <simplelist type="vert" columns="1">
//                                         <member>[VAR]CHAR</member>
//                                         <member>BLOB</member>
//                                         <member>BOOLEAN</member>
//                                         <member>&#x427;&#x438;&#x441;&#x43B;&#x43E;&#x432;&#x44B;&#x435; &#x442;&#x438;&#x43F;&#x44B;</member>
//                                         <member>DATE</member>
//                                         <member>TIME</member>
//                                         <member>TIMESTAMP</member>
//                                     </simplelist>


|
// <simplelist type="vert" columns="1">
//                                         <member>DATE</member>
//                                         <member>TIME</member>
//                                     </simplelist>

|
// <simplelist type="vert" columns="1">
//                                         <member>[VAR]CHAR</member>
//                                         <member>BLOB</member>
//                                         <member>TIMESTAMP</member>
//                                     </simplelist>


|
// <simplelist type="vert" columns="1">
//                                         <member>TIMESTAMP</member>
//                                     </simplelist>

|
// <simplelist type="vert" columns="1">
//                                         <member>[VAR]CHAR</member>
//                                         <member>BLOB</member>
//                                         <member>TIME</member>
//                                         <member>DATE</member>
//                                     </simplelist>


|
// <simplelist type="vert" columns="1">
//                                         <member>BOOLEAN</member>
//                                     </simplelist>

|
// <simplelist type="vert" columns="1">
//                                         <member>[VAR]CHAR</member>
//                                         <member>BLOB</member>
//                                     </simplelist>

|===

Имейте ввиду, что иногда информация может быть потерянна, например, когда вы преобразуете тип TIMESTAMP к DATE.
Кроме того, тот факт, что типы совместимы для функции CAST, ещё не гарантирует, что преобразование будет успешным.
"CAST (123456789 AS SMALLINT)" безусловно приведёт к ошибке, так же как и "CAST('Judgement Day' as DATE)".

Вы можете применить преобразование типа к параметрам оператора: 
[source,sql]
----

CAST (? AS INTEGER)
----

Это дает вам контроль над типом полей ввода. 

==== Преобразование к домену или к его базовому типу

При преобразовании к домену должны быть удовлетворены любые ограничения (NOT NULL и/или CHECK) объявленные для домена, иначе преобразование не будет выполнено.
Помните, что проверка CHECK проходит, если его вычисление даёт TRUE или UNKNOWN (NULL). Для следующих операторов: 

[source,sql]
----

CREATE DOMAIN quint AS INT CHECK (VALUE >= 5000)
SELECT CAST (2000 AS quint) FROM rdb$database -- (1)
SELECT CAST (8000 AS quint) FROM rdb$database -- (2)
SELECT CAST (null AS quint) FROM rdb$database -- (3)
----

только (1) завершится с ошибкой. 

При использовании модификатора TYPE OF выражение будет преобразовано к базовому типу домена, игнорируя любые ограничения.
Для домена quint, объявленного выше, оба преобразования будут эквивалентны и оба будут успешно выполнены: 

[source,sql]
----

SELECT CAST (2000 AS TYPE OF quint) FROM rdb$database
SELECT CAST (2000 AS INT) FROM rdb$database
----

При использовании TYPE OF с (VAR)CHAR типом, его набор символов и порядок сортировки (collate) сохраняются. 

[source,sql]
----

CREATE DOMAIN iso20 VARCHAR(20) CHARACTER SET iso8859_1;
CREATE DOMAIN dunl20 VARCHAR(20) CHARACTER SET iso8859_1 COLLATE du_nl;
CREATE TABLE zinnen (zin VARCHAR(20));
COMMIT;
INSERT INTO zinnen VALUES ('Deze');
INSERT INTO zinnen VALUES ('Die');
INSERT INTO zinnen VALUES ('die');
INSERT INTO zinnen VALUES ('deze');
SELECT CAST(zin AS TYPE OF iso20) FROM zinnen ORDER BY 1;
-- returns Deze -> Die -> deze -> die
SELECT CAST(zin AS TYPE OF dunl20) FROM zinnen ORDER BY 1;
-- returns deze -> Deze -> die -> Die
----

[WARNING]
====
Если определение домена изменяется, то существующие преобразования к домену или его типу могут стать ошибочными.
Если такие преобразования происходят в PSQL модулях, то их ошибки могут быть обнаружены.
См. <<fblangref-appx-supp-rdb-validblr,Поле RDB$VALID_BLR>>. 
====

==== Преобразование к типу столбца

Разрешено преобразовывать выражение к типу столбца существующей таблицы или представления.
При этом будет использован только сам тип, для строковых типов будет использован так же набор символов, но не последовательность сортировки.
Ограничения и значения по умолчанию исходного столбца не применяются. 

[source,sql]
----

CREATE TABLE ttt (
  s VARCHAR(40) CHARACTER SET utf8 COLLATE unicode_ci_ai
);
COMMIT;  
SELECT CAST ('Jag har många vänner' AS TYPE OF COLUMN ttt.s) 
FROM rdb$database;
----

[WARNING]
====
Если определение столбца изменяется, то существующие преобразования к его типу могут стать ошибочными.
Если такие преобразования происходят в PSQL модулях, то их ошибки могут быть обнаружены.
См. <<fblangref-appx-supp-rdb-validblr,Поле RDB$VALID_BLR>>.
====

.См. также:
<<fblangref-datatypes-cast-explicit,Явное преобразование типов данных>>. 

==== Примеры приведения типов


[source,sql]
----

SELECT CAST ('12' || '-June-' || '1959' AS DATE) FROM rdb$database
----

Заметьте, что в некоторых случаях вы можете не использовать синтаксис преобразования как в примере выше, так как Firebird поймёт из контекста (сравнение с полем типа DATE) как интерпретировать строку: 

[source,sql]
----

UPDATE People SET AgeCat = 'Old'
WHERE BirthDate < '1-Jan-1943'
----

Но это не всегда возможно.
Преобразование в примере ниже не может быть опущено, так как система будет пытаться преобразовать строку к числу чтобы вычесть из неё число: 

[source,sql]
----

SELECT CAST('TODAY' AS DATE) - 7 FROM rdb$database
----

[[fblangref-functions-bitwise]]
== Функции побитовых операций

[[fblangref-scalarfuncs-bin-and]]
=== BIN_AND

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BIN_AND (number [, number ...])
----



.Параметры функции BIN_AND
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``number``
|

Целое число.
|===

.Тип возвращаемого результата:
INTEGER, BIGINT или INT128.

Функция BIN_AND возвращает результат побитовой операции AND (И) аргументов.

.См. также:
<<fblangref-scalarfuncs-bin-or,BIN_OR>>, <<fblangref-scalarfuncs-bin-xor,BIN_XOR>>. 

[[fblangref-scalarfuncs-bin-not]]
=== BIN_NOT

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BIN_NOT (number)
----



.Параметры функции BIN_NOT
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``number``
|

Целое число.
|===

.Тип возвращаемого результата:
INTEGER, BIGINT или INT128.

Функция BIN_NOT возвращает результат побитовой операции NOT над аргументом.

.См. также:
<<fblangref-scalarfuncs-bin-or,BIN_OR>>, <<fblangref-scalarfuncs-bin-and,BIN_AND>>. 

[[fblangref-scalarfuncs-bin-or]]
=== BIN_OR

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BIN_OR (number [, number ...])
----



.Параметры функции BIN_OR
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``number``
|

Целое число.
|===

.Тип возвращаемого результата:
INTEGER, BIGINT или INT128.

Функция BIN_OR возвращает результат побитовой операции OR (ИЛИ) аргументов. 

.См. также:
<<fblangref-scalarfuncs-bin-and,BIN_AND>>, <<fblangref-scalarfuncs-bin-xor,BIN_XOR>>. 

[[fblangref-scalarfuncs-bin-shl]]
=== BIN_SHL


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BIN_SHL (number, shift)
----



.Параметры функции BIN_SHL
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``number``
|

Целое число.

|[replaceable]``shift``
|

Количество бит, на которое смещается значение [replaceable]``number``. 
|===

.Тип возвращаемого результата:
BIGINT или INT128.

Функция BIN_SHL возвращает первый параметр, побитно смещённый влево на значение второго параметра. 

.См. также:
<<fblangref-scalarfuncs-bin-shr,BIN_SHR>>. 

[[fblangref-scalarfuncs-bin-shr]]
=== BIN_SHR

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BIN_SHR (number, shift)
----



.Параметры функции BIN_SHR
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``number``
|

Целое число.

|[replaceable]``shift``
|

Количество бит на которое смещается значение number. 
|===

.Тип возвращаемого результата:
BIGINT или INT128.

Функция BIN_SHR возвращает первый параметр, побитно смещённый вправо на значение второго параметра. 

[NOTE]
====
Выполняемая операция является арифметическим сдвигом вправо (SAR), а это означает, что знак первого операнда всегда сохраняется.
====

.См. также:
<<fblangref-scalarfuncs-bin-shl,BIN_SHL>>. 

[[fblangref-scalarfuncs-bin-xor]]
=== BIN_XOR


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

BIN_XOR (number [, number ...])
----



.Параметры функции BIN_XOR
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``number``
|

Целое число.
|===

.Тип возвращаемого результата:
INTEGER, BIGINT или INT128.

Функция BIN_XOR возвращает результат побитовой операции XOR аргументов. 

.См. также:
<<fblangref-scalarfuncs-bin-and,BIN_AND>>, <<fblangref-scalarfuncs-bin-or,BIN_OR>>. 

[[fblangref-functions-uuid]]
== Функции для работы с UUID



[[fblangref-scalarfuncs-char-to-uuid]]
=== CHAR_TO_UUID

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

CHAR_TO_UUID (ascii_uuid)
----



.Параметры функции CHAR_TO_UUID
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``ascii_uuid``
|

36-символьное представление UUID.
'-' (дефис) в положениях 9, 14, 19 и 24; допустимые шестнадцатеричные цифры в любых других позициях.
|===

.Тип возвращаемого результата:
CHAR(16) CHARACTER SET OCTETS.

Функция CHAR_TO_UUID преобразует читабельную 36-ти символьную символику UUID к соответствующему 16-ти байтовому значению UUID. 

.Примеры:


.Использование функции CHAR_TO_UUID
[example]

[source,sql]
----

SELECT CHAR_TO_UUID('A0bF4E45-3029-2a44-D493-4998c9b439A3') FROM rdb$database
-- returns A0BF4E4530292A44D4934998C9B439A3 (16-byte string)

SELECT CHAR_TO_UUID('A0bF4E45-3029-2A44-X493-4998c9b439A3') FROM rdb$database
-- error: -Human readable UUID argument for CHAR_TO_UUID must
-- have hex digit at position 20 instead of "X (ASCII 88)"
----

.См. также:
<<fblangref-scalarfuncs-gen-uuid,GEN_UUID>>, <<fblangref-scalarfuncs-uuid-to-char,UUID_TO_CHAR>>.

[[fblangref-scalarfuncs-gen-uuid]]
=== GEN_UUID

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

GEN_UUID()
----

.Тип возвращаемого результата:
CHAR(16) CHARACTER SET OCTETS.

Функция возвращает универсальный уникальный идентификатор ID в виде 16-байтной строки символов, отвечающий требованиям стандарта RFC-4122.
Функция возвращает строку UUID 4-ой версии, где несколько битов зарезервированы, а остальные являются случайными.

.Примеры:


.Использование функции GEN_UUID
[example]

[source,sql]
----

SELECT GEN_UUID() AS GUID FROM RDB$DATABASE
	
/* результат будет возвращён в виде
	XXXXXXXX-XXXX-4XXX-YXXX-XXXXXXXXXXXX 
	где 4 это номер версии, а Y может принимать значение 8, 9, A или B.
*/
----
----

852C5DD9-3453-430B-B697-D0A46B4D2531
----

.См. также:
<<fblangref-scalarfuncs-char-to-uuid,CHAR_TO_UUID>>, <<fblangref-scalarfuncs-uuid-to-char,UUID_TO_CHAR>>.

[[fblangref-scalarfuncs-uuid-to-char]]
=== UUID_TO_CHAR


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

UUID_TO_CHAR (uuid)
----



.Параметры функции UUID_TO_CHAR
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``uuid``
|

16-байтный UUID.
|===

.Тип возвращаемого результата:
CHAR(36).

Функция UUID_TO_CHAR конвертирует 16-ти байтный UUID в его 36-ти знаковое ASCII человекочитаемое представление.
Тип возвращаемого значения CHAR(36).

.Примеры:


.Использование функции UUID_TO_CHAR
[example]

[source,sql]
----

SELECT UUID_TO_CHAR(GEN_UUID()) FROM RDB$DATABASE;

SELECT UUID_TO_CHAR(x'876C45F4569B320DBCB4735AC3509E5F') FROM RDB$DATABASE;
-- returns '876C45F4-569B-320D-BCB4-735AC3509E5F'

SELECT UUID_TO_CHAR(GEN_UUID()) FROM RDB$DATABASE;
-- returns e.g. '680D946B-45FF-DB4E-B103-BB5711529B86'

SELECT UUID_TO_CHAR('Firebird swings!') FROM RDB$DATABASE;
-- returns '46697265-6269-7264-2073-77696E677321'
----

.См. также:
<<fblangref-scalarfuncs-gen-uuid,GEN_UUID>>, <<fblangref-scalarfuncs-char-to-uuid,CHAR_TO_UUID>>.

[[fblangref-functions-generators]]
== Функции для работы с генераторами (последовательностями)

[[fblangref-scalarfuncs-gen-id]]
=== GEN_ID

.Доступно в
DSQL, PSQL, ESQL.

.Синтаксис

[source]
----

GEN_ID(gen_name, step)
----



.Параметры функции GEN_ID
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``gen_name``
|

Имя генератора (последовательности).

|[replaceable]``step``
|

Шаг приращения.
|===

.Тип возвращаемого результата:
BIGINT.

Функция GEN_ID увеличивает значение генератора или последовательности и возвращает новое значение.

[NOTE]
====
Если значение параметра [replaceable]``step`` меньше нуля, произойдёт уменьшение значения генератора.
Внимание! Следует быть крайне аккуратным при таких манипуляциях в базе данных, они могут привести к потере целостности данных.
Если [replaceable]``step`` равен 0, функция не будет ничего делать со значением генератора и вернёт его текущее значение. 
====

Начиная с Firebird 2.0 для получения следующего значение последовательности (генератора) стало доступно использование оператора NEXT VALUE FOR.

.Примеры:


.Использование функции GEN_ID
[example]

[source,sql]
----

NEW.ID = GEN_ID (GEN_TABLE_ID, 1);
----

.См. также:
<<fblangref-commons-nxtvlufor,NEXT VALUE FOR>>, <<fblangref-ddl-sequence,SEQUENCE (GENERATOR)>>, <<fblangref-ddl-sequence-alter,ALTER SEQUENCE>>, <<fblangref-ddl-sequence-setgen,SET GENERATOR>>.

[[fblangref-functions-conditional]]
== Условные функции


[[fblangref-scalarfuncs-coalesce]]
=== COALESCE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

COALESCE(expr1, expr2 [, exprN ...])
----



.Параметры функции COALESCE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``expr1``, [replaceable]``expr2`` ... [replaceable]``exprN``
|

Выражения любого совместимого типа.
|===

.Тип возвращаемого результата:
тот же что и первый аргумент функции [replaceable]``expr1``, если все выражения имеют одинаковый тип, в противном случае происходит преобразование в тип с наибольшей вместимостью.

Функция COALESCE принимает два или более аргумента возвращает значение первого NOT NULL аргумента.
Если все аргументы имеют значение NULL, то и результат будет NULL.

.Примеры:


.Использование функции COALESCE
[example]

[source,sql]
----

SELECT 
  COALESCE(PE.NICKNAME, PE.FIRSTNAME, 'Mr./Mrs.') ||
  ' ' || PE.LASTNAME AS FULLNAME
FROM PERSONS PE
----
В данном примере предпринимается попытка использовать все имеющиеся данные для составления полного имени.
Выбирается поле NICKNAME из таблицы PERSONS.
Если оно имеет значение NULL, то берётся значение из поля FIRSTNAME.
Если и оно имеет значение NULL, то используется строка 'Mr./Mrs.'. Затем к значению функции COALESCE фамилия (поле LASTNAME). Обратите внимание, что эта схема нормально работает, только если выбираемые поля имеют значение NULL или не пустое значение: если одно из них является пустой строкой, то именно оно и возвратится в качестве значения функции COALESCE. 

.Использование функции COALESCE с агрегатными функциями
[example]

[source,sql]
----

-- в случае получения при суммировании NULL, вернёт 0.                        
SELECT coalesce (sum (q), 0) 
FROM bills 
WHERE ...
----

.См. также:
<<fblangref-commons-conditional-case,CASE>>.

[[fblangref-scalarfuncs-decode]]
=== DECODE

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

DECODE(testexpr, 
       expr1, result1
       [, expr2, result2 ...]
       [, defaultresult])
----

эквивалентная конструкция CASE

[source]
----

CASE testexpr 
  WHEN expr1 THEN result1
  [WHEN expr2 THEN result2 ...]
  [ELSE defaultresult]
END
----



.Параметры функции DECODE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``testexpr``
|

Выражения любого совместимого типа, которое сравнивается с выражениями [replaceable]``expr1``, [replaceable]``expr2`` ... [replaceable]``exprN``

|[replaceable]``expr1``, [replaceable]``expr2`` ... [replaceable]``exprN``
|

Выражения любого совместимого типа, с которыми сравнивают с выражением [replaceable]``testexpr``.

|[replaceable]``result1``, [replaceable]``result2`` ... [replaceable]``resultN``
|

Возвращаемые выражения любого типа.

|[replaceable]``defaultresult``
|

Выражения, возвращаемое если ни одно из условий не было выполнено.
|===

.Тип возвращаемого результата:
тот же что и первый результат [replaceable]``result1``, если все выражения [replaceable]``result`` имеют одинаковый тип, в противном случае происходит преобразование в тип с наибольшей вместимостью.

Данная функция эквивалентна конструкции <<fblangref-commons-conditional-case-simple,Простой CASE>>, в которой заданное выражение сравнивается с другими выражениями до нахождения совпадения.
Результатом является значение, указанное после выражения, с которым найдено совпадение.
Если совпадений не найдено, то возвращается значение по умолчанию (если оно, конечно, задано – в противном случае возвращается NULL).

[CAUTION]
====
Совпадение эквивалентно оператору "=", т.е.
если [replaceable]``testexpr`` имеет значение NULL, то он не соответствует ни одному из [replaceable]``expr``, даже тем, которые имеют значение NULL. 
====

.Примеры:


.Использование функции DECODE
[example]

[source,sql]
----

SELECT 
  name, 
  age,
  decode (upper(sex),
          'M', 'М',
          'F', 'Ж',
          'не указано') AS sexname,
  UID 
FROM people
----

.См. также:
<<fblangref-commons-conditional-case,CASE>>.

[[fblangref-scalarfuncs-iif]]
=== IIF

.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

IIF(<condition>, resultT, resultF)
----



.Параметры функции IIF
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``condition``
|

Выражение логического типа.

|[replaceable]``resultT``
|

Возвращаемое значение, если [replaceable]``condition`` является истинным.

|[replaceable]``resultF``
|

Возвращаемое значение, если [replaceable]``condition`` является ложным.
|===

.Тип возвращаемого результата:
тот же что и аргумент функции [replaceable]``resultT``, если выражения [replaceable]``resultT`` и [replaceable]``resultF`` имеют одинаковый тип, в противном случае происходит преобразование в тип с наибольшей вместимостью.

Функция IIF имеет три аргумента.
Если первый аргумент является истиной, то результатом будет второй параметр, в противном случае результатом будет третий параметр.

По сути, функция IIF это короткая запись оператора CASE

[source]
----

CASE WHEN <condition> THEN resultT ELSE resultF END
----

Оператор IIF также можно сравнить в тройным оператором "?:" в C-подобных языках. 

.Примеры:


.Использование функции IIF
[example]

[source,sql]
----

SELECT IIF(SEX = 'M', 'Sir', 'Madam') FROM CUSTOMERS
----

.См. также:
<<fblangref-commons-conditional-case,CASE>>.

[[fblangref-scalarfuncs-maxvalue]]
=== MAXVALUE


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

MAXVALUE(expr1 [, exprN ...])
----



.Параметры функции MAXVALUE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``expr1`` ... [replaceable]``exprN``
|

Выражения любого совместимого типа.
|===

.Тип возвращаемого результата:
тот же что и первый аргумент функции [replaceable]``expr1``.

Возвращает максимальное значение из входного списка чисел, строк или параметров с типом DATE/TIME/TIMESTAMP.

[NOTE]
====
Если один или более входных параметров имеют значение NULL, то результатом функции MAXVALUE тоже будет NULL в отличие от агрегатной функции MAX.
====

.Примеры:


.Использование функции MAXVALUE
[example]

[source,sql]
----

SELECT MAXVALUE(PRICE_1, PRICE_2) AS PRICE
FROM PRICELIST
----

.См. также:
<<fblangref-scalarfuncs-minvalue,MINVALUE>>. 

[[fblangref-scalarfuncs-minvalue]]
=== MINVALUE


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

MINVALUE(expr1 [, exprN ...])
----



.Параметры функции MINVALUE
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``expr1`` ... [replaceable]``exprN``
|

Выражения любого совместимого типа.
|===

.Тип возвращаемого результата:
тот же что и первый аргумент функции [replaceable]``expr1``.

Возвращает минимальное значение из входного списка чисел, строк или параметров с типом DATE/TIME/TIMESTAMP.

[NOTE]
====
Если один или более входных параметров имеют значение NULL, то результатом функции MINVALUE тоже будет NULL в отличие от агрегатной функции MIN.
====

.Примеры:


.Использование функции MINVALUE
[example]

[source,sql]
----

SELECT MINVALUE(PRICE_1, PRICE_2) AS PRICE
FROM PRICELIST
----

.См. также:
<<fblangref-scalarfuncs-maxvalue,MAXVALUE>>. 

[[fblangref-scalarfuncs-nullif]]
=== NULLIF


.Доступно в
DSQL, PSQL

.Синтаксис

[source]
----

NULLIF(expr1, expr2)
----



.Параметры функции NULLIF
[cols="<1,<3", options="header",stripes="none"]
|===
^| Параметр
^| Описание

|[replaceable]``expr1``, [replaceable]``expr2``
|

Выражения любого совместимого типа.
|===

.Тип возвращаемого результата:
тот же что и первый аргумент функции [replaceable]``expr1``.

Функция возвращает значение первого аргумента, если он неравен второму.
В случае равенства аргументов возвращается NULL.

.Примеры:


.Использование функции NULLIF
[example]

[source,sql]
----

/* запрос вернёт среднее значение поля weight по таблице, 
   за исключением строк, где он не указан (равен -1). 
   Если бы не было этой функции простой оператор avg(weight) 
   вернул бы некорректное значение */                        
SELECT AVG(NULLIF(weight, -1)) FROM cargo;
----

.См. также:
<<fblangref-scalarfuncs-coalesce,COALESCE>>, <<fblangref-commons-conditional-case,CASE>>.

