[[_fblangref_security]]
= Безопасность
:doctype: book
:sectnums:
:toc: left
:icons: font
:experimental:
:sourcedir: .

Базы данных, как и данные, хранимые в файлах базы данных, должны быть защищены.
Firebird обеспечивает двухуровневую защиту данных -- аутентификация пользователя на уровне сервера и привилегии на уровне базы данных.
В данной главе рассказывается, каким образом управлять безопасностью вашей базы данных на каждом из уровней.

[[_fblangref_security_auth]]
== Аутентификация пользователя

Безопасность всей базы данных зависит от проверки подлинности идентификатора пользователя.
Подлинность пользователя может выполняться несколькими способами в зависимости от установок параметра [parameter]``AuthServer`` в файле конфигурации [path]_firebird.conf_.
Этот параметр содержит список доступных плагинов проверки подлинности.
Если проверить подлинность с помощью первого плагина не удалось, то сервер переходит к следующему плагину и т.д.
Если ни один плагин не подтвердил подлинность, то пользователь получает сообщение об ошибке.

Информация о пользователях, зарегистрированных для конкретного сервера Firebird, хранится в особой базе данных безопасности (security database) -- [path]_security4.fdb_.
Для каждой базы данных база данных безопасности может переопределена в файле [path]_databases.conf_ (параметр [parameter]``SecurityDatabase``). Любая база данных может быть базой данных безопасности для самой себя. 

Имя пользователя может состоять максимум из 63 символов.
Максимальная длина пароля зависит от плагина проверки подлинности и плагина управления пользователями (параметр [parameter]``UserManager``), регистр -- учитывается.
По умолчанию будет выбран первый плагин из списка плагинов управления пользователями.
Этот плагин можно изменить в SQL командах управления пользователями.
Для плагина SRP эффективная длина пароля ограничена 20 байтами *. Для плагина Legacy_UserManager максимальная длина пароля равна 8 байт. 

.*Почему эффективная длина пароля ограничена 20 символами?
[NOTE]
====
На длину пароля нет ограничения в 20 байт и он может быть использован.
Хэши различных паролей, длина которых более 20 байт, тоже различны.
Предел эффективности наступает из-за ограниченной длины хэша в SHA1 равном 20 байт или 160 бит.
Рано или поздно найдётся более короткий пароль с тем же хэшем с помощью атаки Brute Force.
Именно поэтому часто говорят, что эффективная длина пароля для алгоритма SHA1 составляет 20 байт. 
====

Встроенная версия сервера (embedded), не использует аутентификацию.
Тем не менее, имя пользователя, и если необходимо роль, должны быть указаны в параметрах подключения, поскольку они используются для контроля доступа к объектам базы данных.

Пользователь SYSDBA или пользователь вошедший с ролью RDB$ADMIN, получают неограниченный доступ к базе данных.
Если пользователь является владельцем базы данных, то без указания роли RDB$ADMIN он получает неограниченный доступ ко всем объектам принадлежащим этой базе данных.

[[_fblangref_security_auth_special]]
=== Специальные учётные записи

[[_fblangref_security_auth_special_sysdba]]
==== SYSDBA
(((SYSDBA)))

В Firebird существует специальная учётная запись SYSDBA, которая существует вне всех ограничений безопасности и имеет полный доступ ко всем базам данных сервера. 

[[_fblangref_security_auth_special_posix]]
==== Особенности POSIX

В POSIX системах, включая MacOSX, имя пользователя POSIX будет интерпретировано как имя пользователя Firebird Embedded, если имя пользователя не указано явно. 

[[_fblangref_security_auth_sysdba_posix]]
===== Пользователь `SYSDBA` в POSIX

В POSIX системах, кроме MacOSX, пользователь `SYSDBA` не имеет пароля по умолчанию.
Если полная установка установка осуществляется с помощью стандартных скриптов, то одноразовый пароль будет создан и сохранён в текстовом файле в том же каталоге что и [path]_security4.fdb_, обычно это [path]_/opt/firebird/_.
Файл с паролём имеет имя [path]_SYSDBA.password_.

[NOTE]
====
При выполнении установки с помощью определённого распространяемого установщика, расположение файла базы данных безопасности и файла с паролем может отличаться от стандартного.
====

[[_fblangref_security_auth_root_posix]]
===== Пользователь _root_ в POSIX

В POSIX системах пользователь _root_ может выступать в роли ``SYSDBA``.
Firebird Embedded в этом случае будет трактовать имя пользователя _root_ как ``SYSDBA``, и вы будете иметь доступ ко всем базам данных сервера.

[[_fblangref_security_auth_special_windows]]
==== Особенности Windows

В операционных системах семейства Windows NT вы также можете пользоваться учётными записями ОС.
Для этого необходимо, чтобы в файле конфигурации [path]_firebird.conf_ (параметр [parameter]``AuthServer``) в списке плагинов присутствовал провайдер Win_Sspi.
Кроме того, этот плагин должен присутствовать и в списке плагинов клиентской стороны (параметр [parameter]``AuthClient``).

Администраторы операционной системы Windows автоматически не получают права SYSDBA при подключении к базе данных (если, конечно, разрешена доверенная авторизация). Имеют ли администраторы автоматические права SYSDBA, зависит от установки значения флага AUTO ADMIN MAPPING.

[NOTE]
====
До Firebird 3.0 при включенной доверительной аутентификации, пользователи прошедшие проверку по умолчанию автоматически отображались в CURRENT_USER.
В Firebird 3 и выше отображение должно быть сделано явно для систем с несколькими базами данных безопасности и включенной доверительной аутентификацией.
См. <<_fblangref_security_mapping_create,CREATE
                            MAPPING>>.
====

[[_fblangref_security_auth_special_dbowner]]
==== Владелец базы данных

Владелец базы данных -- это либо текущий пользователь (``CURRENT_USER``), который был момент создания, либо пользователь который был указан в параметрах USER и PASSWORD в операторе CREATE DATABASE.

Владелец базы данных является администратором в ней и имеет полный доступ ко всем объектам этой базы данных, даже созданных другими пользователями.

[[_fblangref_security_sysroles_rdbadmin]]
=== Роль RDB$ADMIN
(((RDB$ADMIN)))

Системная роль RDB$ADMIN, присутствует в каждой базе данных.
Предоставление пользователю роли RDB$ADMIN в базе данных даёт ему права SYSDBA, но только в текущей базе данных.

Привилегии вступают в силу сразу после входа в обычную базу данных с указанием роли RDB$ADMIN, после чего пользователь получает полный контроль над всеми объектами базы данных. 

Роль RDB$ADMIN может быть предоставлена с использованием ключевого слова DEFAULT.
В этом случае пользователь автоматически будет получать административные привилегии даже если он не указал роль RDB$ADMIN при входе.

Предоставление в базе данных безопасности даёт возможность создавать, изменять и удалять учётные записи пользователей.

В обоих случаях пользователь с правами RDB$ADMIN роли может всегда передавать эту роль другим.
Другими словами, "`WITH ADMIN OPTION`" уже встроен в эту роль и эту опцию можно не указывать.

[[_fblangref_security_sysroles_rdbadmin_grantindb]]
==== Предоставление роли RDB$ADMIN в обычной базе данных

Для предоставления и удаления роли RDB$ADMIN в обычной базе данных используются операторы GRANT и REVOKE, как и для назначения и отмены остальных ролей.

.Синтаксис:

[source]
----

GRANT [DEFAULT] RDB$ADMIN TO username
 
REVOKE [DEFAULT] RDB$ADMIN FROM username
----



.Параметры операторов установки и отмены роли RDB$ADMIN
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``username``
|

Имя пользователя, которому назначается роль RDB$ADMIN или у которого она отбирается.
|===

Если в операторе GRANT присутствует ключевое слово DEFAULT, то пользователь автоматически будет получать административные привилегии даже если он не указал роль RDB$ADMIN при входе.
Привилегии на роль RDB$ADMIN могут давать только <<_fblangref_security_administrators,администраторы>>. 

.См. также:
<<_fblangref_security_priv_grant,GRANT>>, <<_fblangref_security_priv_revoke,REVOKE>>. 

[[_fblangref_security_sysroles_rdbadmin_useindb]]
===== Использование роли RDB$ADMIN в обычной базе данных

Для использования прав роли RDB$ADMIN пользователь просто указывает её при соединении с базой данных, или же роль RDB$ADMIN выдали пользователю с использованием ключевого слова DEFAULT.
Он также может указать её позднее с помощью оператора SET ROLE.

[[_fblangref_security_sysroles_rdbadmin_grantinsecuritydb]]
==== Предоставление роли RDB$ADMIN в базе данных пользователей

Так как никто не может соединиться с базой данных пользователей, то операторы GRANT и REVOKE здесь не могут использоваться.
Вместо этого роль RDB$ADMIN предоставляют и удаляют SQL командами управления пользователями: CREATE USER и ALTER USER, в которых указываются специальные опции GRANT ADMIN ROLE и REVOKE ADMIN ROLE. 

.Синтаксис (неполный):

[source]
----

CREATE USER newuser 
PASSWORD 'password' 
GRANT ADMIN ROLE
 
ALTER USER existinguser 
GRANT ADMIN ROLE
 
ALTER USER existinguser 
REVOKE ADMIN ROLE
----



.Параметры операторов установки и отмены роли RDB$ADMIN
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``newuser``
|

Имя вновь создаваемого пользователя.
Максимальная длина 63 символа.

|[replaceable]``existinguser``
|

Имя существующего пользователя.

|[replaceable]``password``
|

Пароль пользователя.
Чувствительно к регистру.
|===

[IMPORTANT]
====
Пожалуйста, помните, что GRANT ADMIN ROLE и REVOKE ADMIN ROLE это не операторы GRANT и REVOKE.
Это параметры для CREATE USER и ALTER USER.
====

Привилегии на роль RDB$ADMIN могут давать только <<_fblangref_security_administrators,администраторы>>. 

.См. также:
<<_fblangref_security_priv_grant,GRANT>>, <<_fblangref_security_priv_revoke,REVOKE>>. 

[[_fblangref_security_rdbadmin_grantinsecuritydb_gsec]]
===== Выполнение той же задачи используя утилиту [app]``gsec``

То же самое можно сделать используя утилиту [app]``gsec`` указав параметр [parameter]``-admin`` для сохранения атрибута `RDB$ADMIN` учётной записи пользователя: 

____
....

gsec -add new_user -pw password -admin yes
gsec -mo existing_user -admin yes
gsec -mo existing_user -admin no
....
____

[NOTE]
====
В зависимости от административного статуса текущего пользователя для утилиты [app]``gsec`` может потребоваться больше параметров, таких как [parameter]``-user`` и [parameter]``-pass``, или [parameter]``-trusted``.
====

[[_fblangref_security_sysroles_rdbadmin_useinsecuritydb]]
===== Использование роли RDB$ADMIN в базе данных пользователей

Для управления учётными записями пользователей через SQL пользователь, имеющий права на роль RDB$ADMIN, должен подключиться к базе данных с этой ролью.
Так как к базе данных пользователей не имеет права соединяться никто, то пользователь должен подключиться к обычной базе данных, где он также имеет права на роль RDB$ADMIN.
Он определяет роль при соединении с обычной базой данных и может в ней выполнить любой SQL запрос.
Это не самое элегантное решение, но это единственный способ управлять пользователями через SQL запросы. 

Если нет обычной базы данных, где у пользователя есть права на роль RDB$ADMIN, то управление учётными записями посредством SQL запросов недоступно.

[[_fblangref_security_sysroles_rdbadmin_useingsec]]
===== Использование роли RDB$ADMIN в [app]``gsec``

Для управления пользователями через утилиту [app]``gsec`` роль RDB$ADMIN должна быть указана в переключателе [parameter]``-role``.

[[_fblangref_security_autoadminmapping]]
==== AUTO ADMIN MAPPING

.Операционная система:
только Windows.

Администраторы операционной системы Windows автоматически не получают права SYSDBA при подключении к базе данных (если, конечно, разрешена доверенная авторизация). Имеют ли администраторы автоматические права SYSDBA зависит от установки значения флага AUTO ADMIN MAPPING.
Это флаг в каждой из баз данных, который по умолчанию выключен.
Если флаг AUTO ADMIN MAPPING включен, то он действует, когда администратор Windows: 

[loweralpha]
. подключается с помощью доверенной аутентификации
. не определяет никакой роли при подключении.

После успешного "`auto admin`" подключения текущей ролью будет являться RDB$ADMIN. 

[[_fblangref_security_autoadminmapping01]]
===== Включение и выключение AUTO ADMIN MAPPING в обычной базеданных
(((ALTER ROLE RDB$ADMIN SET AUTO ADMIN
                            MAPPING)))
(((ALTER ROLE RDB$ADMIN DROP AUTO ADMIN
                            MAPPING)))

Включение и выключение флага AUTO ADMIN MAPPING в обычной базе данных осуществляется следующим образом: 
[source,sql]
----

ALTER ROLE RDB$ADMIN SET AUTO ADMIN MAPPING -- включение
 
ALTER ROLE RDB$ADMIN DROP AUTO ADMIN MAPPING -- выключение
----

Эти операторы могут быть выполнены пользователями с достаточными правами, а именно: 

* владелец базы данных;
* <<_fblangref_security_administrators,администраторы>>. 


[NOTE]
====
Оператор 
[source,sql]
----

ALTER ROLE RDB$ADMIN SET AUTO ADMIN MAPPING
----
является упрощённым видом оператора создания отображения предопределённой группы DOMAIN_ANY_RID_ADMINS на роль RDB$ADMIN. 
[source,sql]
----

CREATE MAPPING WIN_ADMINS
USING PLUGIN WIN_SSPI
FROM Predefined_Group
DOMAIN_ANY_RID_ADMINS
TO ROLE RDB$ADMIN;
----
Соответственно оператор 
[source,sql]
----

ALTER ROLE RDB$ADMIN DROP AUTO ADMIN MAPPING
----
эквивалентен оператору 
[source,sql]
----

DROP MAPPING WIN_ADMINS;
----

Подробней см. <<_fblangref_security_mapping,Отображение
                                    объектов безопасности>>.
====

В обычных базах данных статус AUTO ADMIN MAPPING проверяется только во время подключения.
Если Администратор имеет роль RDB$ADMIN потому, что произошло автоматическое отображение во время входа, то он будет удерживать эту роль на протяжении всей сессии, даже если он или кто-то другой в это же время выключает автоматическое отображение.

Точно также, включение AUTO ADMIN MAPPING не изменит текущую роль в RDB$ADMIN для Администраторов, которые уже подключились.

[[_fblangref_security_autoadminmapping02]]
===== Включение и выключение AUTO ADMIN MAPPING в базе данныхбезопасности

Оператором ALTER ROLE RDB$ADMIN невозможно включить или выключить флаг AUTO ADMIN MAPPING в базе данных пользователей.
Однако вы можете создать глобальное отображение предопределённой группы DOMAIN_ANY_RID_ADMINS на роль RDB$ADMIN следующим образом: 
[source,sql]
----

CREATE GLOBAL MAPPING WIN_ADMINS
USING PLUGIN WIN_SSPI
FROM Predefined_Group
DOMAIN_ANY_RID_ADMINS
TO ROLE RDB$ADMIN;
----

Кроме того для включения AUTO ADMIN MAPPING в базе данных пользователей можно использовать утилиту командной строки [app]``gsec``: 
----

gsec -mapping set
 
gsec -mapping drop
----

[NOTE]
====
В зависимости от административного статуса текущего пользователя для утилиты [app]``gsec`` может потребоваться больше параметров, таких как [parameter]``-user`` и [parameter]``-pass``, или [parameter]``-trusted``.
====

Только SYSDBA может включить AUTO ADMIN MAPPING, если он выключен, но любой администратор может выключить его.

При выключении AUTO ADMIN MAPPING пользователь отключает сам механизм, который предоставлял ему доступ и, таким образом, он не сможет обратно включить AUTO ADMIN MAPPING.
Даже в интерактивном [app]``gsec`` сеансе новая установка флага сразу вступает в силу.

[[_fblangref_security_administrators]]
=== Администраторы

Администратор -- это пользователь, которые имеет достаточные права для чтения и записи, создания, изменения и удаления любого объекта в базе данных.
В таблице показано, как привилегии "`Суперпользователя`" включены в различных контекстах безопасности Firebird.



.Администраторы
[cols="1,1,1", frame="all", options="header"]
|===
| Пользователь
| Роль RDB$ADMIN
| Замечание

|SYSDBA
|Автоматически
|Существует автоматически на уровне сервера. Имеет полные
                                    привилегии ко всем объектам во всех базах данных. Может
                                    создавать. изменять и удалять пользователей, но не имеет прямого
                                    доступа к базе данных безопасности.

|Пользователь _root_ в POSIX
|Автоматически
|Также как ``SYSDBA``. Только в
                                    Firebird Embedded.

|Суперпользователь в POSIX
|Автоматически
|Также как ``SYSDBA``. Только в
                                    Firebird Embedded.

|Владелец базы данных
|Автоматически
|Также как ``SYSDBA``, но только
                                    в этой базе данных.

|Администраторы Windows
|Устанавливается в CURRENT_ROLE, если вход успешен
|

Также как ``SYSDBA``, если соблюдены следующие условия:

* В файле конфигурации [path]_firebird.conf_ (параметр [parameter]``AuthServer``) в списке плагинов присутствовал провайдер Win_Sspi. Кроме того, этот плагин должен присутствовать и в списке плагинов клиентской стороны (параметр [parameter]``AuthClient``).
* Во всех базах данных, где требуется полномочия суперпользователя должен быть включен AUTO ADMIN MAPPING или создано отображение предопределенной группы DOMAIN_ANY_RID_ADMINS на роль RDB$ADMIN.
* При входе не указана роль.


|Обычный пользователь
|Должна быть предварительно выдана и должна быть указана при
                                    входе
|Также как ``SYSDBA``, но только
                                    в тех базах данных, где эта роль предоставлена.

|Пользователь POSIX
|Должна быть предварительно выдана и должна быть указана при
                                    входе
|Также как ``SYSDBA``, но только
                                    в тех базах данных, где эта роль предоставлена. Только в
                                    Firebird Embedded.

|Пользователь Windows
|Должна быть предварительно выдана и должна быть указана при
                                    входе
|Также как ``SYSDBA``, но только
                                    в тех базах данных, где эта роль предоставлена. Доступно только
                                    если в файле конфигурации [path]_firebird.conf_
                                    (параметр [parameter]``AuthServer``) в списке плагинов
                                    присутствовал провайдер Win_Sspi. Кроме того, этот плагин должен
                                    присутствовать и в списке плагинов клиентской стороны (параметр [parameter]``AuthClient``).
|===

[[_fblangref_security_mapping]]
=== Отображение объектов безопасности

С введением поддержки множества баз данных безопасности в Firebird появились новые проблемы, которые не могли произойти с единой глобальной базой данных безопасности.
Кластеры баз данных, использующие одну и ту же базу данных безопасности, были эффективно разделены.
Отображения предоставляют средства для достижения той же эффективности, когда существует множество баз данных, использующих свои собственные базу данных безопасности.
В некоторых случаях требуется управление для ограничения взаимодействия между такими кластерами.
Например: 

* когда EXECUTE STATEMENT ON EXTERNAL DATA SOURCE требует обмена данными между кластерами;
* когда общесерверный SYSDBA доступ к базам данных необходим от других кластеров, использующих службы;
* аналогичные проблемы существовали в Firebird 2.1 и 2.5 под Windows, из-за поддержки доверительной аутентификации: существовало два отдельных списка пользователей -- один в базе данных безопасности, а другой в Windows, в тех случаях когда было необходимо связать их. Примером может служить получение роли, предоставленной группе Windows, автоматически назначаемой членам этой группы.

Единым решением для всех этих случаев является создание правил отображения информации о пользователе, входящего в систему, на внутренние объекты безопасности -- CURRENT_USER и CURRENT_ROLE.

[NOTE]
====
В Firebird имеется одно встроенное глобальное правило, действующее по умолчанию: пользователи прошедшие проверку в базе данных безопасности всегда отображается в любую базу данных один к одному.
Это безопасное правило: для базы данных безопасности не имеет смысла не доверять себе.
====

[[_fblangref_security_mapping_create]]
==== CREATE MAPPING
(((CREATE MAPPING)))

.Назначение:
Создание отображения объекта безопасности.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

CREATE [GLOBAL] MAPPING name
USING {
    PLUGIN plugin_name [IN database] 
  | ANY PLUGIN [IN database | SERVERWIDE] 
  | MAPPING [IN database] 
  | '*' [IN database] }
FROM { ANY type | type from_name }
TO { USER | ROLE } [to_name]
----



.Параметры оператора CREATE MAPPING
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``name``
|

Имя отображения.
Может содержать до 63 символов.

|[replaceable]``plugin_name``
|

Имя плагина аутентификации.

|[replaceable]``database``
|

Имя базы данных, в которой прошла аутентификация.

|[replaceable]``type``
|

Тип объекта, который будет отображён.

|[replaceable]``from_name``
|

Имя объекта, который будет отображён.

|[replaceable]``to_name``
|

Имя объекта (пользователи или роли) на которое будет произведено отображение.
|===

Оператор CREATE MAPPING создаёт отображение объектов безопасности (пользователей, групп, ролей) одного или нескольких плагинов аутентификации на внутренние объекты безопасности – CURRENT_USER и CURRENT_ROLE.
Имя отображения должно быть уникальным среди имён отображений.
(((CREATE MAPPING,GLOBAL)))

Если присутствует опция GLOBAL, то отображение будет применено не только для текущей базы данных, но и для всех баз данных находящимся в том же кластере, в том числе и базы данных безопасности.

[IMPORTANT]
====
Если существуют одноименные глобальные и локальные отображение, то вам следует знать, что это разные объекты.
====

[NOTE]
====
Глобальное отображение работает, если в качестве базы данных безопасности используется база данных Firebird 3 или более высокой версии.
Если вы планируете использовать другую базу данных, например, для целей использования собственного поставщика, то вам необходимо создать таблицу в ней и назвать её RDB$MAP с той же структурой, что и RDB$MAP в базе данных Firebird 3 и дать доступ на запись только для ``SYSDBA``. 
====

Предложение USING описывает источник отображения.
Оно имеет весьма сложный набор опций: 

* явное указание имени плагина (опция PLUGIN) означает, что оно будет работать только с этим плагином;
* оно может использовать любой доступный плагин (опция ANY PLUGIN), даже если источник является продуктом предыдущего отображения;
* оно может быть сделано так, чтобы работать только с обще серверными плагинами (опция SERVERWIDE);
* оно может быть сделано так, чтобы работать только с результатами предыдущего отображения (опция MAPPING);
* вы можете опустить использование любого из методов, используя звёздочку (*) в качестве аргумента;
* оно может содержать имя базы данных (опция IN), из которой происходит отображение объекта FROM. 
+

[NOTE]
====
Этот аргумент не является допустимым для отображения с общесерверной аутентификацией.
====

(((CREATE MAPPING,FROM)))

Предложение FROM описывает отображаемый объект.
Оно принимает обязательный аргумент -- тип объекта.
Особенности:

* при отображении имён из плагинов, тип определяется плагином;
* при отображении продукта предыдущего отображения, типом может быть только USER и ROLE;
* если имя объекта будет указано явно, то оно будет учитываться при отображении;
* при использовании ключевого слова ANY будут отображены объекты с любыми именами данного типа.

Сочетание источник (предложение USING) и объект отображения (предложение FROM) должно быть уникальным, иначе будет сгенерирована ошибка.
Это позволяется только если одно отображение является глобальным, а второе локальным.

В предложении TO указывается пользователь или роль, на которого будет произведено отображение.
NAME является не обязательным аргументом.
Если он не указан, то в качестве имени объекта будет использовано оригинальное имя из отображаемого объекта.

[NOTE]
====
Локальное отображение перекрывает глобальное отображение с одинаковым сочетанием источника и объекта отображения.
Это действует приблизительно так же как с настройками: настройки уровня базы данных ([path]_databases.conf_) перекрывают глобальные настройки ([path]_firebird.conf_).
====



.Создать отображение могут:* SYSDBA;
* Владелец базы данных (если отображение локальное);
* Любой пользователь, вошедший с ролью RDB$ADMIN;
* Пользователь root операционной системы Linux.


.Примеры:


.Включение использования доверительной аутентификации Windows вовсех базах данных, которые используют текущую базу данныхбезопасности.
[example]

[source,sql]
----

CREATE GLOBAL MAPPING TRUSTED_AUTH
USING PLUGIN WIN_SSPI
FROM ANY USER
TO USER;
----

.Включение SYSDBA подобного доступа для администраторов Windows втекущей базе данных.
[example]

[source,sql]
----

CREATE MAPPING WIN_ADMINS
USING PLUGIN WIN_SSPI
FROM Predefined_Group
DOMAIN_ANY_RID_ADMINS
TO ROLE RDB$ADMIN;
----

[NOTE]
====
Группа DOMAIN_ANY_RID_ADMINS не существует в Windows, но такое имя будет добавлено плагином win_sspi для обеспечения точной обратной совместимости. 
====

.Включение доступа определённому пользователю из другой базыданных к текущей базе данных под другим именем.
====

[source,sql]
----

CREATE MAPPING FROM_RT
USING PLUGIN SRP IN "rt"
FROM USER U1 TO USER U2;
----

Пользователь U1 прошедший аутентификацию в базе данных rt будет отображён на пользователя с именем U2.
====

[IMPORTANT]
====
Имена баз данных должны быть заключены в двойные кавычки на операционных системах, которые имею регистр чувствительные имена файлов.
====

.Включение общесерверного SYSDBA (от основной базы данныхбезопасности) для доступа к текущей базе данных.
[example]
Предположим, что база данных использует базу данных безопасности не по умолчанию. 
[source,sql]
----

CREATE MAPPING DEF_SYSDBA
USING PLUGIN SRP IN "security.db"
FROM USER SYSDBA
TO USER;
----

.Создание ограничения прав для пользователей, которые подключаютсяунаследованным плагином аутентификации.
[example]

[source,sql]
----

CREATE MAPPING LEGACY_2_GUEST
USING PLUGIN legacy_auth
FROM ANY USER
TO USER GUEST;
----

.См. также:
<<_fblangref_security_mapping_alter,ALTER MAPPING>>, <<_fblangref_security_mapping_createoralter,CREATE OR ALTER MAPPING>>, <<_fblangref_security_mapping_drop,DROP MAPPING>>. 

[[_fblangref_security_mapping_alter]]
==== ALTER MAPPING
(((ALTER MAPPING)))

.Назначение:
Изменение отображения объекта безопасности.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

ALTER [GLOBAL] MAPPING name
USING {
    PLUGIN plugin_name [IN database] 
  | ANY PLUGIN [IN database | SERVERWIDE] 
  | MAPPING [IN database] 
  | '*' [IN database] }
FROM { ANY type | type from_name }
TO { USER | ROLE } [to_name]
----



.Параметры оператора ALTER MAPPING
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``name``
|

Имя отображения.

|[replaceable]``plugin_name``
|

Имя плагина аутентификации.

|[replaceable]``database``
|

Имя базы данных, в которой прошла аутентификация.

|[replaceable]``type``
|

Тип объекта, который будет отображён.

|[replaceable]``from_name``
|

Имя объекта, который будет отображён.

|[replaceable]``to_name``
|

Имя объекта (пользователи или роли) на которое будет произведено отображение.
|===

Оператор ALTER MAPPING позволяет изменять любые опции существующего отображения.

[IMPORTANT]
====
Одноименные глобальные и локальные отображение -- это разные объекты.
====



.Изменить отображение могут:* ``SYSDBA``;
* Владелец базы данных (если отображение локальное);
* Любой пользователь, вошедший с ролью RDB$ADMIN;
* Пользователь root операционной системы Linux.


.Примеры:


.Изменение отображения.
[example]

[source,sql]
----

ALTER MAPPING FROM_RT
USING PLUGIN SRP IN "rt"
FROM USER U1 TO USER U3;
----

.См. также:
<<_fblangref_security_mapping_create,CREATE MAPPING>>, <<_fblangref_security_mapping_createoralter,CREATE OR ALTER MAPPING>>, <<_fblangref_security_mapping_drop,DROP MAPPING>>. 

[[_fblangref_security_mapping_createoralter]]
==== CREATE OR ALTER MAPPING
(((CREATE OR ALTER MAPPING)))

.Назначение:
Создание или изменение отображения объекта безопасности.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

CREATE OR ALTER [GLOBAL] MAPPING name
USING {
    PLUGIN plugin_name [IN database] 
  | ANY PLUGIN [IN database | SERVERWIDE] 
  | MAPPING [IN database] 
  | '*' [IN database] }
FROM { ANY type | type from_name }
TO { USER | ROLE } [to_name]
----



.Параметры оператора CREATE OR ALTER MAPPING
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``name``
|

Имя отображения.
Может содержать до 63 символов.

|[replaceable]``plugin_name``
|

Имя плагина аутентификации.

|[replaceable]``database``
|

Имя базы данных, в которой прошла аутентификация.

|[replaceable]``type``
|

Тип объекта, который будет отображён.

|[replaceable]``from_name``
|

Имя объекта, который будет отображён.

|[replaceable]``to_name``
|

Имя объекта (пользователи или роли) на которое будет произведено отображение.
|===

Оператор CREATE OR ALTER MAPPING создаёт новое или изменяет существующее отображение.
Если отображение не существует, то оно будет создано с использованием предложения CREATE MAPPING.

[IMPORTANT]
====
Одноименные глобальные и локальные отображение -- это разные объекты.
====

.Примеры:


.Создание нового или изменение существующего отображения.
[example]

[source,sql]
----

CREATE OR ALTER MAPPING FROM_RT
USING PLUGIN SRP IN "rt"
FROM USER U1 TO USER U4;
----

.См. также:
<<_fblangref_security_mapping_create,CREATE MAPPING>>, <<_fblangref_security_mapping_alter,ALTER MAPPING>>, <<_fblangref_security_mapping_drop,DROP MAPPING>>. 

[[_fblangref_security_mapping_drop]]
==== DROP MAPPING
(((DROP MAPPING)))

.Назначение:
Удаление отображения объекта безопасности.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

DROP [GLOBAL] MAPPING name
----



.Параметры оператора DROP MAPPING
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``name``
|

Имя отображения.
|===

Оператор DROP MAPPING удаляет существующее отображение.
Если указана опция GLOBAL, то будет удалено глобальное отображение.

[IMPORTANT]
====
Одноименные глобальные и локальные отображение -- это разные объекты.
====



.Удалить отображение могут:* SYSDBA;
* Владелец базы данных (если отображение локальное);
* Любой пользователь, вошедший с ролью RDB$ADMIN;
* Пользователь root операционной системы Linux.


.Примеры:


.Удаление отображения.
[example]

[source,sql]
----

DROP MAPPING FROM_RT;
----

.См. также:
<<_fblangref_security_mapping_create,CREATE MAPPING>>. 

[[_fblangref_security_user]]
== Управление пользователями

В данном разделе описываются операторы создания, модификации и удаления учётных записей пользователей Firebird средствами операторов SQL.
Такая возможность предоставлена следующим пользователям: 

* SYSDBA;
* Любому пользователю, имеющему права на роль RDB$ADMIN в базе данных пользователей и права на ту же роль для базы данных в активном подключении. Пользователь должен подключаться к базе данных с ролью RDB$ADMIN или получить её права, если роль назначена в качестве роли по умолчанию;
* Любому пользователю с ролью, которой назначена системная привилегия USER_MANAGEMENT в базе данных безопасности. Пользователь должен подключаться к базе данных с этой ролью или получить её права, если роль назначена в качестве роли по умолчанию;
* При включенном флаге AUTO ADMIN MAPPING в базе данных пользователей ([path]_security4.fdb_ или той, что установлена для вашей базы данных в файле [path]_databases.conf_) -- любой администратор операционной системы Windows (при условии использования сервером доверенной авторизации -- trusted authentication) без указания роли. При этом не важно, включен или выключен флаг AUTO ADMIN MAPPING в самой базе данных. 

Непривилегированные пользователи могут использовать только оператор ALTER USER для изменения собственной учётной записи. 

[[_fblangref_security_user_create]]
=== CREATE USER
(((CREATE USER)))

.Назначение:
Создание учётной записи пользователя Firebird.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

CREATE USER username PASSWORD 'password'
{
  [FIRSTNAME 'firstname']
  [MIDDLENAME 'middlename']
  [LASTNAME 'lastname']
  [ACTIVE | INACTIVE]
}
[USING PLUGIN pluginname] 
[GRANT ADMIN ROLE]
[TAGS (<tag> [, <tag> [, <tag> ...]] )]

<tag> ::= tagname = 'string value'
----



.Параметры оператора CREATE USER
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``username``
|

Имя пользователя.
Максимальная длина 63 символов.

|[replaceable]``password``
|

Пароль пользователя.
Чувствительно к регистру.

|[replaceable]``firstname``
|

Вспомогательная информация: имя пользователя.
Максимальная длина 32 символа.

|[replaceable]``middlename``
|

Вспомогательная информация: "второе имя" (отчество, "имя отца") пользователя.
Максимальная длина 32 символа.

|[replaceable]``lastname``
|

Вспомогательная информация: фамилия пользователя.
Максимальная длина 32 символа.

|[replaceable]``pluginname``
|

Имя плагина управления пользователями, в котором необходимо создать нового пользователя.

|[replaceable]``tagname``
|

Имя пользовательского атрибута.
Максимальная длина 63 символа.
Имя атрибута должно подчиняться правилам наименования SQL идентификаторов.

|[replaceable]``string value``
|

Значение пользовательского атрибута.
Максимальная длина 255 символов.
|===

Оператор CREATE USER создаёт учётную запись пользователя Firebird.
Пользователь должен отсутствовать в текущей базе данных безопасности Firebird иначе будет выдано соответствующее сообщение об ошибке.

[IMPORTANT]
====
Начиная с Firebird 3.0 имена пользователей подчиняются общему правилу наименования идентификаторов объектов метаданных.
Таким образом, пользователь с именем "Alex" и с именем "ALEX" будут разными пользователями. 
[source,sql]
----
 
CREATE USER ALEX PASSWORD 'bz23ds';

-- этот пользователь такой же как и первый
CREATE USER Alex PASSWORD 'bz23ds';

-- этот пользователь такой же как и первый
CREATE USER "ALEX" PASSWORD 'bz23ds';

-- а это уже другой пользователь
CREATE USER "Alex" PASSWORD 'bz23ds';
----
====
(((CREATE USER,PASSWORD)))

Предложение PASSWORD задаёт пароль пользователя.
Максимальная длина пароля зависит от того какой менеджер пользователей задействован (параметр [parameter]``UserManager``). Для менеджер пользователей SRP эффективная длина пароля ограничена 20 байтами *. Для менеджер пользователей Legacy_UserManager максимальная длина пароля равна 8 байт. 

.*Почему эффективная длина пароля ограничена 20 символами?
[NOTE]
====
На длину пароля нет ограничения в 20 байт и он может быть использован.
Хэши различных паролей, длина которых более 20 байт, тоже различны.
Предел эффективности наступает из-за ограниченной длины хэша в SHA1 равном 20 байт или 160 бит.
Рано или поздно найдётся более короткий пароль с тем же хэшем с помощью атаки Brute Force.
Именно поэтому часто говорят, что эффективная длина пароля для алгоритма SHA1 составляет 20 байт. 
====
(((CREATE USER,MIDDLENAME)))

Необязательные предложения FIRSTNAME, MIDDLENAME и LASTNAME задают дополнительные атрибуты пользователя, такие как имя пользователя (имя человека), отчество и фамилия соответственно.
(((CREATE USER,INACTIVE)))

Если при создании учётной записи будет указан атрибут INACTIVE, то пользователь будет создан в "неактивном состоянии", т.е.
подключиться с его учётной записью будет невозможно.
При указании атрибута ACTIVE пользователь будет создан в активном состоянии.
По умолчанию пользователь создаётся активным.
Данная возможность доступна только при использовании Srp в качестве менеджера пользователей.
(((CREATE USER,GRANT ADMIN ROLE)))

Если указана опция GRANT ADMIN ROLE, то новая учётная запись пользователя создаётся с правами роли RDB$ADMIN в текущей базе данных безопасности.
Это позволяет вновь созданному пользователю управлять учётными записями пользователей, но не даёт ему специальных полномочий в обычных базах данных.

Необязательное предложение USING PLUGIN позволяет явно указывать какой плагин управления пользователями будет использован.
По умолчанию используется тот плагин, который был указан первым в списке параметра [parameter]``UserManager`` в файле конфигурации [path]_firebird.conf_.
Допустимыми являются только значения, перечисленные в параметре [parameter]``UserManager``.

.Важно:
[IMPORTANT]
====
Учтите что одноименные пользователи, созданные с помощью разных плагинов управления пользователями -- это разные пользователи.
Поэтому пользователя созданного с помощью одного плагина управления пользователями можно удалить или изменить, указав только тот же самый плагин. 
====
(((CREATE USER,TAGS)))

Кроме того вы можете задать неограниченное количество пользовательских атрибутов с помощью необязательного предложения TAGS.
Данная возможность доступна только при использовании Srp в качестве менеджера пользователей.

Создать новую учётную запись могут:

* SYSDBA и другие пользователи являющиеся администраторами в базе данных безопасности (с ролью RDB$ADMIN);
* Пользователи вошедшие с ролью или получившие её привилегии (роль назначена по умолчанию), которой назначена системная привилегия USER_MANAGEMENT.


.Примеры:


.Создание пользователя.
[example]

[source,sql]
----
 
CREATE USER bigshot PASSWORD 'buckshot';
----

.Создание пользователя с помощью плагина управления пользователямиLegacy_UserManager.
[example]

[source,sql]
----
 
CREATE USER godzilla PASSWORD 'robot'
USING PLUGIN Legacy_UserManager;
----

.Создание пользователя с пользовательскими атрибутами.
[example]

[source,sql]
----
 
CREATE USER john PASSWORD 'fYe_3Ksw'
FIRSTNAME 'John'
LASTNAME 'Doe'
TAGS (BIRTHYEAR = '1970', CITY = 'New York');
----

.Создание пользователя в неактивном состоянии.
[example]

[source,sql]
----
 
CREATE USER john PASSWORD 'fYe_3Ksw'
FIRSTNAME 'John'
LASTNAME 'Doe'
INACTIVE;
----

.Создание пользователя с возможностью управленияпользователями.
[example]

[source,sql]
----
 
CREATE USER superuser PASSWORD 'kMn8Kjh'
GRANT ADMIN ROLE;
----

.См. также:
<<_fblangref_security_user_alter,ALTER USER>>, <<_fblangref_security_user_createoralter,CREATE OR ALTER USER>>, <<_fblangref_security_user_drop,DROP USER>>. 

[[_fblangref_security_user_alter]]
=== ALTER USER

.Назначение:
Изменение учётной записи пользователя Firebird.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

ALTER {USER username | CURRENT USER}
{ 
  [SET]
  [PASSWORD 'password']
  [FIRSTNAME 'firstname']
  [MIDDLENAME 'middlename']
  [LASTNAME 'lastname']
  [ACTIVE | INACTIVE]
}
[USING PLUGIN pluginname] 
[{GRANT | REVOKE} ADMIN ROLE]
[TAGS (<tag> | DROP tagname [, <tag> | DROP tagname ...] )]
  
<tag> ::= tagname = 'string value'
----



.Параметры оператора ALTER USER
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``username``
|

Имя пользователя.

|[replaceable]``password``
|

Пароль пользователя.
Чувствительно к регистру.

|[replaceable]``firstname``
|

Вспомогательная информация: имя пользователя.
Максимальная длина 32 символа.

|[replaceable]``middlename``
|

Вспомогательная информация: "второе имя" (отчество, "имя отца") пользователя.
Максимальная длина 32 символа.

|[replaceable]``lastname``
|

Вспомогательная информация: фамилия пользователя.
Максимальная длина 32 символа.

|[replaceable]``pluginname``
|

Имя плагина управления пользователями, в котором был создан данный пользователь.

|[replaceable]``tagname``
|

Имя пользовательского атрибута.
Максимальная длина 63 символа.
Имя атрибута должно подчиняться правилам наименования SQL идентификаторов.

|[replaceable]``string value``
|

Значение пользовательского атрибута.
Максимальная длина 255 символов.
|===

Оператор ALTER USER изменяет данные учётной записи пользователя.
В операторе ALTER USER должен присутствовать хотя бы одно из необязательных предложений.
(((ALTER USER,PASSWORD)))
(((ALTER USER,MIDDLENAME)))

Необязательное предложение PASSWORD задаёт новый пароль пользователя.
Необязательные предложения FIRSTNAME, MIDDLENAME и LASTNAME позволяют изменить дополнительные атрибуты пользователя, такие как имя пользователя (имя человека), отчество и фамилия соответственно.
(((ALTER USER,INACTIVE)))

Атрибут INACTIVE позволяет сделать учётную запись неактивной.
Это удобно когда необходимо временно отключить учётную запись без её удаления.
Атрибут ACTIVE позволяет вернуть неактивную учётную запись в активное состояние.
Данная возможность доступна только при использовании Srp в качестве менеджера пользователей.
(((ALTER USER,TAGS)))

Необязательное предложение TAGS позволяет задать, изменить или удалить пользовательские атрибуты.
Если в списке атрибутов, атрибута с заданным именем не было, то он будет добавлен, иначе его значение будет изменено.
Атрибуты не указанные в списке не будут изменены.
Для удаления пользовательского атрибута перед его именем в списке атрибутов необходимо указать ключевое слово DROP.
Данная возможность доступна только при использовании Srp в качестве менеджера пользователей.

Предложение GRANT ADMIN ROLE предоставляет указанному пользователю привилегии роли RDB$ADMIN в текущей базе данных безопасности.
Это позволяет указанному пользователю управлять учётными записями пользователей, но не даёт ему специальных полномочий в обычных базах данных.
(((ALTER USER,REVOKE ADMIN ROLE)))

Предложение REVOKE ADMIN ROLE отбирает у указанного пользователя привилегии роли RDB$ADMIN в текущей базе данных безопасности.
Это запрещает указанному пользователю управлять учётными записями пользователей.

Необязательное предложение USING PLUGIN позволяет явно указывать какой плагин управления пользователями будет использован.
По умолчанию используется тот плагин, который был указан первым в списке параметра [parameter]``UserManager`` в файле конфигурации [path]_firebird.conf_.
Допустимыми являются только значения, перечисленные в параметре [parameter]``UserManager``.

.Важно:
[IMPORTANT]
====
Учтите что одноименные пользователи, созданные с помощью разных плагинов управления пользователями -- это разные пользователи.
Поэтому пользователя созданного с помощью одного плагина управления пользователями можно удалить или изменить, указав только тот же самый плагин. 
====

Если требуется изменить свою учётную запись, то вместо указания имени текущего пользователя можно использовать предложение CURRENT USER.

Модифицировать чужую учётную запись могут:

* SYSDBA и другие пользователи являющиеся администраторами в базе данных безопасности (с ролью RDB$ADMIN);
* Пользователи вошедшие с ролью или получившие её привилегии (роль назначена по умолчанию), которой назначена системная привилегия USER_MANAGEMENT.

Свои собственные учётные записи могут изменять любые пользователи, однако это не относится к опциям GRANT/REVOKE ADMIN ROLE и атрибуту ACTIVE/INACTIVE для изменения которых необходимы административные привилегии.

.Примеры:


.Изменение пользователя и выдача ему привилегии управленияпользователями.
[example]

[source,sql]
----
 
ALTER USER bobby PASSWORD '67-UiT_G8'
GRANT ADMIN ROLE;
----

.Изменение пароля пользователя, созданного с помощью плагинауправления пользователями Legacy_UserManager.
[example]

[source,sql]
----
 
ALTER USER godzilla PASSWORD 'robot12'
USING PLUGIN Legacy_UserManager;
----

.Изменение дополнительных атрибутов своей учётной записи.
[example]

[source,sql]
----
 
ALTER CURRENT USER
FIRSTNAME 'No_Jack'
LASTNAME 'Kennedy';
----

.Отключение пользователя.
[example]

[source,sql]
----
 
ALTER USER dan INACTIVE;
----

.Отбор привилегии управления пользователями у пользователя.
[example]

[source,sql]
----
 
ALTER USER dumbbell
REVOKE ADMIN ROLE;
----

.Изменение пользовательских атрибутов своей учётной записи.
[example]

[source,sql]
----
 
ALTER CURRENT USER
TAGS (BIRTHYEAR = '1971', DROP CITY);
----
Атрибуту BIRTHDAY будет установлено новое значение, а атрибут CITY будет удалён. 

.См. также:
<<_fblangref_security_user_create,CREATE USER>>, <<_fblangref_security_user_createoralter,CREATE OR ALTER USER>>, <<_fblangref_security_user_drop,DROP USER>>. 

[[_fblangref_security_user_createoralter]]
=== CREATE OR ALTER USER
(((CREATE OR ALTER USER)))

.Назначение:
Создание или изменение учётной записи пользователя Firebird.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

CREATE OR ALTER USER username
{ 
  [SET]
  [PASSWORD 'password']
  [FIRSTNAME 'firstname']
  [MIDDLENAME 'middlename']
  [LASTNAME 'lastname']
  [ACTIVE | INACTIVE]  
}
[USING PLUGIN pluginname] 
[{GRANT | REVOKE} ADMIN ROLE]
[TAGS (<tag> | DROP tagname [, <tag> | DROP tagname ...] )]
  
<tag> ::= tagname = 'string value'
----



.Параметры оператора CREATE OR ALTER USER
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``username``
|

Имя пользователя.
Максимальная длина 63 символа.

|[replaceable]``password``
|

Пароль пользователя.
Чувствительно к регистру.

|[replaceable]``firstname``
|

Вспомогательная информация: имя пользователя.
Максимальная длина 32 символа.

|[replaceable]``middlename``
|

Вспомогательная информация: "второе имя" (отчество, "имя отца") пользователя.
Максимальная длина 32 символа.

|[replaceable]``lastname``
|

Вспомогательная информация: фамилия пользователя.
Максимальная длина 32 символа.

|[replaceable]``pluginname``
|

Имя плагина управления пользователями, в котором необходимо создать нового пользователя или в котором он был создан ранее.

|[replaceable]``tagname``
|

Имя пользовательского атрибута.
Максимальная длина 63 символа.
Имя атрибута должно подчиняться правилам наименования SQL идентификаторов.

|[replaceable]``string value``
|

Значение пользовательского атрибута.
Максимальная длина 255 символов.
|===

Оператор CREATE OR ALTER USER создаёт новую или изменяет учётную запись.
Если пользователя не существует, то он будет создан с использованием предложения CREATE USER.
Если он уже существует, то он будет изменён, при этом существующие привилегии сохраняются.

.Примеры:


.Создание или изменение пользователя.
[example]

[source,sql]
----
 
CREATE OR ALTER USER john PASSWORD 'fYe_3Ksw'
FIRSTNAME 'John'
LASTNAME 'Doe'
INACTIVE;
----

.См. также:
<<_fblangref_security_user_create,CREATE USER>>, <<_fblangref_security_user_alter,ALTER USER>>. 

[[_fblangref_security_user_drop]]
=== DROP USER
(((DROP USER)))

.Назначение:
Удаление учётной записи пользователя Firebird.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

DROP USER username
[USING PLUGIN pluginname];
----



.Параметры оператора DROP USER
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``username``
|

Имя пользователя.

|[replaceable]``pluginname``
|

Имя плагина управления пользователями, в котором был создан данный пользователь.
|===

Оператор DROP USER удаляет учётную запись пользователя Firebird.
(((DROP USER,USING PLUGIN)))

Необязательное предложение USING PLUGIN позволяет явно указывать какой плагин управления пользователями будет использован.
По умолчанию используется тот плагин, который был указан первым в списке параметра [parameter]``UserManager`` в файле конфигурации [path]_firebird.conf_.
Допустимыми являются только значения, перечисленные в параметре [parameter]``UserManager``.

[IMPORTANT]
====
Учтите что одноименные пользователи, созданные с помощью разных плагинов управления пользователями -- это разные пользователи.
Поэтому пользователя созданного с помощью одного плагина управления пользователями можно удалить или изменить, указав только тот же самый плагин.
====

Удалить учётную запись могут:

* SYSDBA и другие пользователи являющиеся администраторами в базе данных безопасности (с ролью RDB$ADMIN);
* Пользователи вошедшие с ролью или получившие её привилегии (роль назначена по умолчанию), которой назначена системная привилегия USER_MANAGEMENT.


.Примеры:


.Удаление пользователя.
[example]

[source,sql]
----
 
DROP USER bobby;
----

.Удаление пользователя, созданного с помощью плагина управленияпользователями Legacy_UserManager.
[example]

[source,sql]
----
 
DROP USER Godzilla USING PLUGIN Legacy_UserManager;
----

.См. также:
<<_fblangref_security_user_create,CREATE USER>>, <<_fblangref_security_user_alter,ALTER USER>>. 

[[_fblangref_security_user_recreate]]
=== RECREATE USER

.Назначение:
Создание новой учётной записи пользователя Firebird или пересоздание существующей.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----

RECREATE USER username PASSWORD 'password'
{
  [FIRSTNAME 'firstname']
  [MIDDLENAME 'middlename']
  [LASTNAME 'lastname']
  [ACTIVE | INACTIVE]
}
[USING PLUGIN pluginname]   
[GRANT ADMIN ROLE]
[TAGS (<tag> [, <tag> [, <tag> ...]] )]

<tag> ::= tagname = 'string value'
----



.Параметры оператора RECREATE USER
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``username``
|

Имя пользователя.
Максимальная длина 63 символов.

|[replaceable]``password``
|

Пароль пользователя.
Чувствительно к регистру.

|[replaceable]``firstname``
|

Вспомогательная информация: имя пользователя.
Максимальная длина 32 символа.

|[replaceable]``middlename``
|

Вспомогательная информация: "второе имя" (отчество, "имя отца") пользователя.
Максимальная длина 32 символа.

|[replaceable]``lastname``
|

Вспомогательная информация: фамилия пользователя.
Максимальная длина 32 символа.

|[replaceable]``pluginname``
|

Имя плагина управления пользователями, в котором необходимо создать нового пользователя.

|[replaceable]``tagname``
|

Имя пользовательского атрибута.
Максимальная длина 63 символа.
Имя атрибута должно подчиняться правилам наименования SQL идентификаторов.

|[replaceable]``string value``
|

Значение пользовательского атрибута.
Максимальная длина 255 символов.
|===

Оператор `RECREATE USER` создаёт нового или пересоздаёт существующего пользователя.
Если пользователь с таким именем уже существует, то оператор `RECREATE TABLE` удалить его и создаст нового.
Существующие привилегии при этом будут сохранены.

.Примеры:


.Создание или пересоздание пользователя.
[example]

[source,sql]
----
 
RECREATE USER john PASSWORD 'fYe_3Ksw'
FIRSTNAME 'John'
LASTNAME 'Doe'
INACTIVE;
----

.См. также:
<<_fblangref_security_user_create,CREATE USER>>, <<_fblangref_security_user_drop,DROP USER>>. 

[[_fblangref_security_user_list]]
=== Получение списка пользователей

Для получения списка пользователей и их атрибутов вы можете воспользоваться псевдо таблицами `SEC$USERS` и ``SEC$USER_ATTRIBUTES``.

.Отображение списка пользователей и их атрибутов
[example]

[source,sql]
----
 
SELECT CAST(U.SEC$USER_NAME AS CHAR(20)) AS LOGIN,
    CAST(A.SEC$KEY AS CHAR(10)) AS TAG,
    CAST(A.SEC$VALUE AS CHAR(20)) AS "VALUE",
    U.SEC$PLUGIN AS "PLUGIN"
FROM SEC$USERS U LEFT JOIN SEC$USER_ATTRIBUTES A
    ON U.SEC$USER_NAME = A.SEC$USER_NAME
   AND U.SEC$PLUGIN = A.SEC$PLUGIN;
----
----

   LOGIN                TAG        VALUE                PLUGIN
   ==================== ========== ==================== ==========================
   SYSDBA               <null>     <null>               Srp
   ALEX                 B          x                    Srp
   ALEX                 C          sample               Srp
   SYSDBA               <null>     <null>               Legacy_UserManager
----

.Подробное описание псевдо таблиц безопасности смотри в:
<<_fblangref_sectables_users,SEC$USERS>>, <<_fblangref_sectables_user_attributes,SEC$USER_ATTRIBUTES>>. 

[[_fblangref_security_roles]]
== Роли
(((ROLE)))

*Роль* (role) -- объект базы данных, представляющий набор привилегий.
Роли реализуют концепцию управления безопасностью на групповом уровне.
Множество привилегий предоставляется роли, а затем роль может быть предоставлена или отозвана у одного или нескольких пользователей. 

Пользователь, которому предоставлена роль, должен указать её при входе, для того чтобы получить её привилегии, или же эта роль должна быть грантована с использованием ключевого слова DEFAULT.
Любые другие привилегии, предоставленные пользователю, не будут затронуты при его входе в систему с указанной ролью.
Вход в систему с несколькими ролями не поддерживается, однако вы можете права нескольких ролей назначенных по умолчанию.
Вы можете изменить текущую роль с помощью оператора <<_fblangref_session_role,SET
                ROLE>>.

Роли могут быть грантованы другие роли.
При входе с этой ролью пользователь автоматически получит права всех ролей выданных с использованием ключевого слова DEFAULT.

[[_fblangref_security_roles_managment]]
=== Операторы управления ролями

В данном разделе рассматриваются вопросы создания и удаления ролей.

[[_fblangref_security_roles_create]]
==== CREATE ROLE
(((CREATE ROLE)))

.Назначение:
Создание новой роли.

.Доступно в:
DSQL, ESQL.

.Синтаксис:

[source]
----

CREATE ROLE rolename [SET SYSTEM PRIVILEGES TO <privileges_list>]    

<privileges_list> ::= <privilege> [, <privilege> [, <privilege> ...]]
----



.Параметры оператора CREATE ROLE
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``rolename``
|

Имя роли.
Максимальная длина 63 символа.

|[replaceable]``privilege``
|

Системная привилегия.
|===

Оператор CREATE ROLE создаёт новую роль.
Имя роли должно быть уникальным среди имён ролей.

[WARNING]
====
Желательно также чтобы имя роли было уникальным не только среди имён ролей, но и среди имён пользователей.
Если вы создадите роль с тем же именем существующего пользователя, то такой пользователь не сможет подключиться к базе данных. 
====
(((CREATE ROLE,SET SYSTEM PRIVILEGES TO)))

Предложение `SET SYSTEM PRIVILEGES TO` позволяет создать роль с системными привилегиями.
Системные привилегии это части привилегий администратора.
Таким образом, через делегирование роли с системными привилегиями пользователю можно передавать ему часть прав администратора БД.

[NOTE]
====
Системные привилегии позволяют производить очень тонкую настройку, поэтому иногда вам нужно будет выдать более 1 системной привилегии для выполнения какой-либо задачи.
Например, необходимо выдать IGNORE_DB_TRIGGERS совместно с USE_GSTAT_UTILITY, потому что [app]``gstat`` должен игнорировать триггера на события БД. 
====



.Системные привилегии
[cols="1,1", frame="all", options="header"]
|===
| Привилегия
| Описание

|USER_MANAGEMENT
|

Управление пользователями.

|READ_RAW_PAGES
|

Чтение страниц в сыром формате используя Attachment::getInfo()

|CREATE_USER_TYPES
|

Создание, изменение и удаление не системных записей в таблице RDB$USER_TYPES.

|USE_NBACKUP_UTILITY
|

Использование [app]``nbackup`` для создания резервных копий.

|CHANGE_SHUTDOWN_MODE
|

Закрытие базы данных (shutdown) и возвращаение её в online.

|TRACE_ANY_ATTACHMENT
|

Трассировка чужих пользовательских сессий.

|MONITOR_ANY_ATTACHMENT
|

Мониторинг (MON$ таблицы) чужих пользовательских сессий.

|ACCESS_SHUTDOWN_DATABASE
|

Доступ к базе данных в режиме shutdown.

|CREATE_DATABASE
|

Создание новой базы данных (хранится в базе данных пользователей security.db).

|DROP_DATABASE
|

Удаление текущей БД.

|USE_GBAK_UTILITY
|

Использование утилиты или сервиса [app]``gbak``.

|USE_GSTAT_UTILITY
|

Использование утилиты или сервиса [app]``gstat``.

|USE_GFIX_UTILITY
|

Использование утилиты или сервиса [app]``gfix``.

|IGNORE_DB_TRIGGERS
|

Разрешает игнорировать триггеры на события БД.

|CHANGE_HEADER_SETTINGS
|

Изменение параметров на заголовочной странице БД.

|SELECT_ANY_OBJECT_IN_DATABASE
|

Выполнение оператора SELECT из всех селективных объектов (таблиц, представлений, хранимых процедур выбора).

|ACCESS_ANY_OBJECT_IN_DATABASE
|

Доступ (любым способом) к любому объекту БД.

|MODIFY_ANY_OBJECT_IN_DATABASE
|

Изменение любого объекта БД.

|CHANGE_MAPPING_RULES
|

Изменение правил отображения при аутентификации.

|USE_GRANTED_BY_CLAUSE
|

Использование GRANTED BY в операторах GRANT и REVOKE.

|GRANT_REVOKE_ON_ANY_OBJECT
|

Выполнение операторов GRANT и REVOKE для любого объекта БД.

|GRANT_REVOKE_ANY_DDL_RIGHT
|

Выполнение операторов GRANT и REVOKE для выдачи DDL привилегий.

|CREATE_PRIVILEGED_ROLES
|

Создание привилегированных ролей (с использование SET SYSTEM PRIVILEGES).

|GET_DBCRYPT_KEY_NAME
|

Получение имени ключа шифрования.

|MODIFY_EXT_CONN_POOL
|

Управление пулом внешних соединений.

|REPLICATE_INTO_DATABASE
|

Использование API репликации для загрузки наборов изменений в базу данных..
|===

Для проверки имеет ли текущее подключение заданную системную привилегию можно воспользоваться встроенной функцией <<_fblangref_scalarfuncs_system_privelege,RDB$SYSTEM_PRIVILEGE>>.

Выполнить оператор `CREATE ROLE` могут: 

* <<_fblangref_security_administrators,Администраторы>>
* Пользователи с привилегией ``CREATE ROLE``. 


.Примеры:


.Создание роли.
[example]

[source,sql]
----
 
CREATE ROLE SELLERS;
----

.Создание роли с системными привилегиями.
[example]

[source,sql]
----
 
CREATE ROLE SYS_UTILS 
SET SYSTEM PRIVILEGES TO USE_GBAK_UTILITY, USE_GSTAT_UTILITY, IGNORE_DB_TRIGGERS;
----

.См. также:
<<_fblangref_security_roles_drop,DROP ROLE>>, <<_fblangref_security_priv_grant,GRANT>>, <<_fblangref_security_priv_revoke,REVOKE>>, <<_fblangref_session_role_setrole,SET ROLE>>, <<_fblangref_scalarfuncs_system_privelege,RDB$SYSTEM_PRIVILEGE>>. 

[[_fblangref_security_roles_alter]]
==== ALTER ROLE

.Назначение:
Изменение системных привилегий роли.

.Доступно в:
DSQL, ESQL.

.Синтаксис:

[source]
----

ALTER ROLE rolename 
{
    SET SYSTEM PRIVILEGES TO <privileges_list>
  | DROP SYSTEM PRIVILEGES   
}  
                      

<privileges_list> ::= <privilege> [, <privilege> [, <privilege> ...]]
----
Только для роли RDB$ADMIN 
[source]
----


ALTER ROLE RDB$ADMIN {SET | DROP} AUTO ADMIN MAPPING
----



.Параметры оператора ALTER ROLE
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``rolename``
|

Имя роли.

|[replaceable]``privilege``
|

Системная привилегия.
|===

Оператор ALTER ROLE изменяет список системных привилегий роли или удаляет их.
При использовании предложения SET SYSTEM PRIVILEGES TO к роли добавляются системные привилегии из списка.
Для очистки списка системных привилегий установленных предыдущим оператором используйте оператор ALTER ROLE с предложением DROP SYSTEM PRIVILEGES. 

Оператор ALTER ROLE RDB$ADMIN для включения и отключения возможности администраторам Windows автоматически получать привилегии <<_fblangref_security_administrators,администраторов>> при входе.

Эта возможность существует только для одной роли, а именно системной роли RDB$ADMIN, которая существует в любой базе данных с ODS 11.2 и выше.
Подробности см.
в <<_fblangref_security_autoadminmapping,AUTO ADMIN MAPPING>>.
В настоящее время является устаревшим и поддерживается для обратной совместимости, вместо него рекомендуется использовать операторы <<_fblangref_security_mapping,{CREATE | ALTER | DROP} MAPPING>>.

[[_fblangref_security_roles_drop]]
==== DROP ROLE

.Назначение:
Удаление существующей роли.

.Доступно в:
DSQL, ESQL.

.Синтаксис:

[source]
----

DROP ROLE rolename;
----



.Параметры оператора DROP ROLE
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``rolename``
|

Имя роли.
|===

Оператор DROP ROLE удаляет существующую роль.
При удалении роли все привилегии, предоставленные этой роли, отменяются.

Выполнить оператор `DROP ROLE` могут: 

* <<_fblangref_security_administrators,Администраторы>>
* Владелец роли; 
* Пользователи с привилегией ``ALTER ANY ROLE``. 


.Примеры:


.Удаление роли.
[example]

[source,sql]
----
 
DROP ROLE SELLERS;
----

.См. также:
<<_fblangref_security_roles_create,CREATE ROLE>>, <<_fblangref_security_priv_grant,GRANT>>, <<_fblangref_security_priv_revoke,REVOKE>>. 

[[_fblangref_security_priv]]
== SQL привилегии

Вторым уровень модели обеспечения безопасности Firebird являются SQL привилегии.
После успешного входа в систему (первый уровень), авторизованный пользователь получает доступ к серверу и ко всем базам данных этого сервера, но это не означает, что он имеет доступ к любым объектам в любой базе данных.
После создания объекта, только пользователь создавший объект (его владелец) и администраторы имеют доступ к нему.
Пользователю необходимы привилегии на каждый объект, к которому он должен получить доступ.
Как правило, привилегии должны быть предоставлены явно пользователю владельцем объекта или <<_fblangref_security_administrators,администратором>> базы данных.

Привилегия включает тип DML доступа (SELECT, INSERT, UPDATE, DELETE, EXECUTE и REFERENCES), имя объекта базы данных для которого предоставляется привилегия (таблица, представление, процедура или роль) и имя объекта которому предоставляется привилегия (пользователь, процедура, триггер, роль). Существуют различные способы для предоставления нескольких типов доступа на один объект базы данных сразу нескольким пользователям в одном операторе GRANT.
Привилегии могут быть отозваны с помощью оператора REVOKE.

Все привилегии по доступу к объектам базы данных хранятся в самой базе, и не могут быть применены к любой другой базе данных. 

[[_fblangref_security_owner]]
=== Владелец объекта базы данных

Пользователь, создавший объект базы данных, становится его владельцем.
Только владелец объекта и пользователи с правами <<_fblangref_security_administrators,администратора>> в базе данных могут изменить или удалить объект базы данных.
Владелец базы данных, то есть пользователь, который создал её, имеет все права на объекты, которые были созданы другими пользователями.

Администраторы или владелец объекта могут выдавать привилегии другим пользователям, в том числе и привилегии на право выдачи привилегий другим пользователям.
Собственно сам процесс раздачи и отзыва привилегий на уровне SQL реализуется двумя операторами: <<_fblangref_security_priv_grant,GRANT>>, <<_fblangref_security_priv_revoke,REVOKE>>.

[[_fblangref_security_priv_grant]]
=== GRANT
(((GRANT)))

.Назначение:
Предоставление привилегий или назначение ролей.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----
                    
<grant_stmt> ::= <grant_priv_stmt> | <grant_roles_stmt>

<grant_priv_stmt> ::= 
  GRANT <privileges> 
  TO {
      <object_list> 
    | PUBLIC 
    | <user_list> [WITH GRANT OPTION] 
    | SYSTEM PRIVILEGE <sys_privileges_list>
  } [{GRANTED BY | AS} [USER] grantor] 
  
<grant_roles_stmt> ::= 
  GRANT [DEFAULT] <role_granted> 
  TO { PUBLIC | <role_grantee_list> [WITH ADMIN OPTION] } 
  [{GRANTED BY | AS} [USER] grantor]

<privileges> ::= 
    <table_privileges>
  | <execute_privileges>
  | <usage_privileges>
  | <ddl_privileges>    
  | <ddl_db_privileges>           

<table_privileges> ::= 
  { ALL [PRIVILEGES] | <table_privileges_list> } 
  ON [TABLE] {table_name | view_name} 

<table_privilege_list> ::= {     
    SELECT 
  | DELETE 
  | INSERT 
  | UPDATE [(col [,col ...])] 
  | REFERENCES [(col [,col ...])]   
} [, <table_privilege_list> ...]    

<execute_privileges> ::= EXECUTE ON {
    PROCEDURE proc_name
  | FUNCTION func_name
  | PACKAGE package_name
}     

<usage_privileges> ::= USAGE ON {
    EXCEPTION exception_name 
  | {GENERATOR | SEQUENCE} generator_name 
}      

<ddl_privileges> ::= 
    {ALL [PRIVILEGES] | <ddl_privelege> [,<ddl_privelege> ...]} <object_type>

<ddl_privelege> ::= {CREATE | ALTER ANY | DROP ANY}

<ddl_db_privileges> ::= 
    {ALL [PRIVILEGES] | <ddl_db_priv> [,<ddl_db_priv> ...]} DATABASE

<ddl_db_priv> ::= {CREATE | ALTER | DROP}  
  
<object_type> ::= {
    CHARACTER SET 
  | COLLATION 
  | DOMAIN 
  | EXCEPTION 
  | FILTER 
  | FUNCTION 
  | GENERATOR 
  | PACKAGE 
  | PROCEDURE 
  | ROLE 
  | SEQUENCE 
  | TABLE 
  | VIEW
}  

<sys_privileges_list> ::= <sys_privilege> [, <sys_privilege> [, <sys_privilege> ...]] 

<object_list> ::= {     
    PROCEDURE proc_name 
  | FUNCTION func_name
  | PACKAGE package_name
  | TRIGGER trig_name 
  | VIEW view_name } [, <object_list> ...]

<user_list> ::= { 
    [USER] username 
  | [ROLE] rolename 
  | GROUP Unix_group 
  | Unix_user } [, <user_list> ...] 

<role_granted> ::= rolename [, rolename ...]

<role_grantee_list> ::= <role_grantee_item> [, <role_grantee_item> ...]      

<role_grantee_item> ::= [USER] username | [ROLE] rolename
----



.Параметры оператора GRANT
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``table_name``
|

Имя таблицы, к которой должно быть применена привилегия. 

|[replaceable]``view_name``
|

Имя представления, к которому должно быть применена привилегия или которому будут выданы привилегии. 

|[replaceable]``col``
|

Столбец таблицы, к которому должна быть применена привилегия. 

|[replaceable]``proc_name``
|

Имя хранимой процедуры, для которой должна быть выдана привилегия EXECUTE или которой будут даны привилегии. 

|[replaceable]``func_name``
|

Имя хранимой функции (или UDF), для которой должна быть выдана привилегия EXECUTE или которой будут даны привилегии. 

|[replaceable]``package_name``
|

Имя пакета, для которого должна быть выдана привилегия EXECUTE или которому будут даны привилегии. 

|[replaceable]``exception_name``
|

Имя исключения, для которого должна быть выдана привилегия USAGE.

|[replaceable]``generator_name``
|

Имя генератора (последовательности), для которого должна быть выдана привилегия USAGE.

|[replaceable]``object_type``
|

Тип объекта метаданных.

|[replaceable]``object_list``
|

Список объектов метаданных, которым будут даны привилегии.

|[replaceable]``trig_name``
|

Имя триггера, которому будут даны привилегии.

|[replaceable]``user_list``
|

Список пользователей/ролей, которым будут выданы привилегии.

|[replaceable]``username``
|

Имя пользователя, для которого выдаются привилегии или которому назначается роль. 

|[replaceable]``rolename``
|

Имя роли.

|[replaceable]``Unix_group``
|

Имя группы пользователей в операционных системах семейства UNIX.
Только в Firebird Embedded.

|[replaceable]``Unix_user``
|

Имя пользователя в операционной системе семейства UNIX.
Только в Firebird Embedded.

|[replaceable]``sys_privilege``
|Системная привилегия.

|[replaceable]``role_granted``
|

Список ролей, которые будут назначены. 

|[replaceable]``role_grantee_list``
|

Список пользователей, которым будут назначены роли.

|[replaceable]``grantor``
|

Пользователь от имени, которого предоставляются привилегии. 
|===

Оператор GRANT предоставляет одну или несколько привилегий для объектов базы данных пользователям, ролям, хранимым процедурам, функциям, пакетам, триггерам и представлениям. 

Авторизованный пользователь не имеет никаких привилегий до тех пор, пока какие либо права не будут предоставлены ему явно.
При создании объекта только его создатель и SYSDBA имеет привилегии на него и может назначать привилегии другим пользователям, ролям или объектам.

Для различных типов объектов метаданных существует различный набор привилегий.
Эти привилегии будут описаны далее отдельно для каждого из типов объектов метаданных.

[[_fblangref_security_priv_grant_to_clause]]
==== Предложение TO

В предложении TO указывается список пользователей, ролей и объектов базы данных (процедур, функций, пакетов, триггеров и представлений) для которых будут выданы перечисленные привилегии.
Необязательные предложения USER и ROLE позволяют уточнить, кому именно выдаётся привилегия.
Если ключевое слово USER или ROLE не указано, то сервер проверяет, существует ли роль с данным именем, если таковой не существует, то привилегии назначаются пользователю.
Существование пользователя, которому выдаются права, не проверяются при выполнении оператора GRANT.
Если привилегия выдаётся объекту базы данных, то необходимо обязательно указывать тип объекта.

.Рекомендация
[TIP]
====
Несмотря на то, что ключевые слова USER и ROLE не обязательные, желательно использовать их, чтобы избежать путаницы. 
====

[[_fblangref_security_priv_grant_public_user]]
==== Пользователь PUBLIC

В SQL существует специальный пользователь PUBLIC, представляющий всех пользователей.
Если какая-то операция разрешена пользователю PUBLIC, значит, любой аутентифицированный пользователь может выполнить эту операцию над указанным объектом.

[IMPORTANT]
====
Если привилегии назначены пользователю PUBLIC, то и отозваны они должны быть у пользователя PUBLIC.
====

[[_fblangref_security_priv_grant_grant_option]]
==== WITH GRANT OPTION
(((GRANT,WITH GRANT OPTION)))

Необязательное предложение WITH GRANT OPTION позволяет пользователям, указанным в списке пользователей, передавать другим пользователям привилегии указанные в списке привилегий.

[[_fblangref_security_priv_grant_granted_by]]
==== GRANTED BY

При предоставлении прав в базе данных в качестве лица, предоставившего эти права, обычно записывается текущий пользователь.
Используя предложение GRANTED BY можно предоставлять права от имени другого пользователя.
При использовании оператора REVOKE после GRANTED BY права будут удалены только в том случае, если они были зарегистрированы от удаляющего пользователя.
Для облегчения миграции из некоторых других реляционных СУБД нестандартное предложение AS поддерживается как синоним оператора GRANTED BY.

Предложение GRANTED BY может использовать: 

* Владелец базы данных;
* SYSDBA;
* Любой пользователь, имеющий права на роль RDB$ADMIN и указавший её при соединении с базой данных;
* При использовании флага AUTO ADMIN MAPPING -- любой администратор операционной системы Windows (при условии использования сервером доверенной авторизации -- trusted authentication), даже без указания роли.

Даже владелец роли не может использовать GRANTED BY, если он не находится в вышеупомянутом списке.

[[_fblangref_security_priv_grant_table]]
==== Табличные привилегии
(((GRANT,SELECT)))
(((GRANT,UPDATE)))
(((GRANT,REFERENCES)))

Для таблиц и представлений в отличие от других объектов метаданных возможно использовании сразу нескольких привилегий.



.Список привилегий для таблиц
[cols="1,1", frame="all", options="header"]
|===
| Привилегия
| Описание

|SELECT
|

Разрешает выборку данных из таблицы или представления. 

|INSERT
|

Разрешает добавлять записи в таблицу или представление. 

|UPDATE
|

Разрешает изменять записи в таблице или представлении.
Можно указать ограничения, чтобы можно было изменять только указанные столбцы. 

|DELETE
|

Разрешает удалять записи из таблицы или представления. 

|REFERENCES
|

Разрешает ссылаться на указанные столбцы внешним ключом.
Необходимо указать для столбцов, на которых построен первичный ключ таблицы, если на неё есть ссылка внешним ключом другой таблицы. 

|ALL
|

Объединяет привилегии SELECT, INSERT, UPDATE, DELETE и REFERENCES. 
|===

.Примеры:


.Назначение привилегий для таблиц
[example]

[source,sql]
----

-- Привилегии SELECT, INSERT пользователю ALEX                            
GRANT SELECT, INSERT ON TABLE SALES 
TO USER ALEX;

-- Привилегия SELECT ролям MANAGER, ENGINEER и пользователю IVAN
GRANT SELECT ON TABLE CUSTOMER 
TO ROLE MANAGER, ROLE ENGINEER, USER IVAN;

-- Все привилегии для роли ADMINISTRATOR 
-- с возможностью передачи своих полномочий
GRANT ALL ON TABLE CUSTOMER 
TO ROLE ADMINISTRATOR WITH GRANT OPTION;

-- Привилегии SELECT и REFRENCE для столбца NAME для всех пользователей
GRANT SELECT, REFERENCES (NAME) ON TABLE COUNTRY 
TO PUBLIC;

-- Выдача привилегии SELECT для пользователя IVAN от имени пользователя ALEX 
GRANT SELECT ON TABLE EMPLOYEE 
TO USER IVAN GRANTED BY ALEX;

-- Привилегия UPDATE для столбцов FIRST_NAME, LAST_NAME
GRANT UPDATE (FIRST_NAME, LAST_NAME) ON TABLE EMPLOYEE 
TO USER IVAN;

-- Привилегия INSERT для хранимой процедуры ADD_EMP_PROJ
GRANT INSERT ON EMPLOYEE_PROJECT 
TO PROCEDURE ADD_EMP_PROJ;
----

[[_fblangref_security_priv_grant_execute]]
==== Привилегия EXECUTE
(((GRANT,EXECUTE)))

Привилегия EXECUTE (выполнение) применима к хранимым процедурам, хранимым функциям, пакетам и унаследованным внешним функциям (UDF), определяемых как DECLARE EXTERNAL FUNCTION.

Для хранимых процедур привилегия EXECUTE позволяет не только выполнять хранимые процедуры, но и делать выборку данных из селективных процедур (с помощью оператора SELECT).

.Замечание:
[NOTE]
====
Привилегия может быть назначена только для всего пакета, а не для отдельных его подпрограмм.
====

.Примеры:


.Назначение привилегии EXECUTE
[example]

[source,sql]
----

-- Привилегия EXECUTE на хранимую процедуру                             
GRANT EXECUTE ON PROCEDURE ADD_EMP_PROJ 
TO ROLE MANAGER;

-- Привилегия EXECUTE на хранимую функцию 
GRANT EXECUTE ON FUNCTION GET_BEGIN_DATE TO ROLE MANAGER;

-- Привилегия EXECUTE на пакет
GRANT EXECUTE ON PACKAGE APP_VAR TO PUBLIC;

-- Привилегия EXECUTE на функцию выданная пакету
GRANT EXECUTE ON FUNCTION GET_BEGIN_DATE
TO PACKAGE APP_VAR;
----

[[_fblangref_security_priv_grant_usage]]
==== Привилегия USAGE

Для использования объектов метаданных, отличных от таблиц, представлений, хранимых процедур и функций, триггеров и пакетов, в пользовательских запросах необходимо предоставить пользователю привилегию USAGE для этих объектов.
Поскольку в Firebird хранимые процедуры и функции, триггеры и подпрограммы пакетов выполняются с привилегиями вызывающего пользователя, то при использовании таких объектов метаданных в них, может потребоваться назначить привилегию USAGE и для них. 

.Замечание:
[NOTE]
====
В Firebird 3 привилегия USAGE проверяется только для исключений (exception) и генераторов/последовательностей (в gen_id([replaceable]``gen_name``, 1) или next value for [replaceable]``gen_name``). Привилегии для других объектов метаданных могут быть включены в следующих релизах, если покажется целесообразным. 
====

.Замечание:
[NOTE]
====
Привилегия USAGE даёт права только на приращения генераторов (последовательностей) с помощью функции GEN_ID или конструкции NEXT VALUE FOR.
Оператор SET GENERATOR является аналогом оператора ALTER SEQUENCE ... RESTART WITH, которые относятся к DDL операторам.
По умолчанию права на такие операции имеет только владелец генератора (последовательности). Права на установку начального значения любого генератора (последовательности) можно предоставить с помощью GRANT ALTER ANY SEQUENCE, что не рекомендуется для обычных пользователей. 
====

.Примеры:


.Назначение привилегии USAGE
[example]

[source,sql]
----

-- Привилегия USAGE на последовательность выданная роли                            
GRANT USAGE ON SEQUENCE GEN_AGE TO ROLE MANAGER;

-- Привилегия USAGE на последовательность выданная триггеру   
GRANT USAGE ON SEQUENCE GEN_AGE TO TRIGGER TR_AGE_BI;

-- Привилегия USAGE на исключение выданная пакету
GRANT USAGE ON EXCEPTION E_ACCESS_DENIED
TO PACKAGE PKG_BILL;
----

[[_fblangref_security_priv_grant_ddl]]
==== DDL привилегии

По умолчанию создавать новые объекты метаданных могут только <<_fblangref_security_administrators,Администраторы>>, а изменять и удалять -- администраторы и владельцы этих объектов.
Выдача привилегий на создание, изменение или удаление объектов конкретного типа позволяет расширить этот список.
(((GRANT,CREATE)))
(((GRANT,DROP ANY)))



.Список DDL привилегий
[cols="1,1", frame="all", options="header"]
|===
| Привилегия
| Описание

|CREATE
|

Разрешает создание объекта указанного типа метаданных. 

|ALTER ANY
|

Разрешает изменение любого объекта указанного типа метаданных. 

|DROP ANY
|

Разрешает удаление любого объекта указанного типа метаданных. 

|ALL
|

Объединяет привилегии CREATE, ALTER и DROP на указанный тип объекта. 
|===

.Примечание:
[NOTE]
====
Метаданные триггеров и индексов наследуют привилегии таблиц, которые владеют ими.
====

.Примеры:


.Назначение привилегий на изменение метаданных
[example]

[source,sql]
----

-- Разрешение пользователю Joe создавать таблицы                            
GRANT CREATE TABLE TO Joe;

-- Разрешение пользователю Joe изменять любые процедуры
GRANT ALTER ANY PROCEDURE TO Joe;
----

[[_fblangref_security_priv_grant_ddl_database]]
===== DDL привилегии на базу данных
(((GRANT,ALTER DATABASE)))

Оператор назначения привилегий на создание, удаление и изменение базы данных имеет несколько отличную форму от оператора назначения DDL привилегий на другие объекты метаданных.



.Список DDL привилегий на базу данных
[cols="1,1", frame="all", options="header"]
|===
| Привилегия
| Описание

|CREATE
|

Разрешает создание базы данных. 

|ALTER
|

Разрешает изменение текущей базы данных. 

|DROP
|

Разрешает удаление текущей базы данных. 

|ALL
|

Объединяет привилегии ALTER и DROP на базу данных. 
|===

Привилегия CREATE DATABASE является особым видом привилегий, поскольку она сохраняется в базе данных безопасности.
Список пользователей имеющих привилегию CREATE DATABASE можно посмотреть в виртуальной таблице SEC$DB_CREATORS.
Привилегию на создание новой базы данных могут выдавать только <<_fblangref_security_administrators,Администраторы>> в базе данных безопасности.

Привилегии ALTER DATABASE и DROP DATABASE относятся только к текущей базе данных, тогда как DDL привилегии ALTER ANY и DROP ANY на другие объекты метаданных относятся ко всем объектам указанного типа внутри текущей базы данных.
Привилегии на изменение и удаление текущей базы данных могут выдавать только <<_fblangref_security_administrators,Администраторы>>.

.Примеры:


[example]

[source,sql]
----

-- Разрешение пользователю Superuser создавать базы данных                            
GRANT CREATE DATABASE TO USER Superuser;

-- Разрешение пользователю Joe выполнять оператор ALTER DATABASE 
-- для текущей базы данных
GRANT ALTER DATABASE TO USER Joe;

-- Разрешение пользователю Fedor удалять текущую базу данных
GRANT DROP DATABASE TO USER Fedor;
----

[[_fblangref_security_priv_grant_sys_priv]]
==== Выдача прав системным привилегиям
(((GRANT,SYSTEM PRIVILEGE)))

Благодаря поддержки системных привилегий в ядре, становится очень удобно предоставлять некоторые дополнительные привилегии пользователям уже имеющим какую-то системную привилегию.
Для этих целей существует возможность использовать в качестве грантополучателя одну или несколько системных привилегий.

.Пример:


[example]
Следующий оператор назначит все привилегии на представление PLG$SRP_VIEW, используемое в плагине управления пользователями SRP, системной привилегии USER_MANAGEMENT. 
[source,sql]
----

GRANT ALL ON PLG$SRP_VIEW TO SYSTEM PRIVILEGE USER_MANAGEMENT
----

Описание системных привилегий вы можете посмотреть в <<_fblangref_security_roles_create,CREATE ROLE>>

[[_fblangref_security_priv_grant_role]]
==== Назначение ролей

.Синтаксис:

[source]
----
   
<grant_roles_stmt> ::= 
  GRANT [DEFAULT] <role_granted> 
  TO { PUBLIC | <role_grantee_list> [WITH ADMIN OPTION] } 
  [{GRANTED BY | AS} [USER] grantor] 
                        
<role_granted> ::= rolename [, rolename ...]  
                        
<role_grantee_list> ::= <role_grantee_item> [, <role_grantee_item> ...]      

<role_grantee_item> ::= [USER] username | [ROLE] rolename
----

Оператор `GRANT` может быть использован для назначения ролей для списка пользователей или ролей.
В этом случае после предложения GRANT следует список ролей, которые будут назначены списку пользователей или ролей, указанному после предложения TO. 

Если используется ключевое слово ``DEFAULT``, то роль (роли) будет использоваться пользователем или ролью каждый раз, даже если она не была указана явно.
При подключении пользователь получит привилегии всех ролей, которые были назначены пользователю с использованием ключевого слова ``DEFAULT``.
Если пользователь укажет свою роль при подключении, то получит привилегии этой роли (если она была ему назначена) и привилегии всех ролей назначенных ему с использованием ключевого слова ``DEFAULT``.
(((GRANT,ROLE,WITH ADMIN OPTION)))

Необязательное предложение `WITH ADMIN OPTION` позволяет пользователям, указанным в списке пользователей, передавать свои роли другому пользователю или роли.
Полномочия роли могут быть переданы кумулятивно, только если каждая роль в последовательности ролей назначена с использованием ``WITH ADMIN OPTION``.

.Примеры:


.Назначение ролей для пользователей
[example]

[source,sql]
----

-- Назначение ролей DIRECTOR и MANAGER пользователю IVAN                            
GRANT DIRECTOR, MANAGER TO USER IVAN;

-- Назначение роли ADMIN пользователю ALEX 
-- с возможностью назначить эту другим пользователям
GRANT MANAGER TO USER ALEX WITH ADMIN OPTION;

-- Назначение роли MANAGER пользователю JOHN
-- Привилегии роли будут автоматически назначаться пользователю
-- каждый раз при входе. В этом случае роль выступает в качестве группы.
GRANT DEFAULT MANAGER TO USER JOHN;

-- Теперь при входе пользователь JOHN автоматически получит привилегии
-- ролей MANAGER (см. предыдущий оператор) и DIRECTOR
GRANT DEFAULT DIRECTOR TO USER JOHN;
----

.Назначение ролей другим ролям
[example]

[source,sql]
----

-- Назначение роли MANAGER для роли DIRECTOR 
-- с возможностью передачи роли MANAGER другим пользователям или ролям
GRANT MANAGER TO ROLE DIRECTOR WITH ADMIN OPTION;

-- Назначение роли ACCOUNTANT роли DIRECTOR
-- при входе в систему с ролью DIRECTOR полномочия роли ACCOUNTANT
-- будут также получены
GRANT DEFAULT ACCOUNTANT TO ROLE DIRECTOR;
     
-- Пользователь PETROV при входе автоматически получает
-- полномочия роли DIRECTOR. Эти полномочия будут включать также
-- полномочия роли ACCOUNTANT. Для получения полномочий роли MANAGER
-- необходимо указать эту роль при входе в систему или позже с 
-- помощью оператора SET ROLE          
GRANT DEFAULT ROLE DIRECTOR TO USER PETROV;
----

.См. также:
<<_fblangref_security_priv_revoke,REVOKE>>. 

[[_fblangref_security_priv_revoke]]
=== REVOKE

.Назначение:
Отмена привилегий или отбор ролей.

.Доступно в:
DSQL.

.Синтаксис:

[source]
----
                    
<revoke_stmt> ::= 
    <revoke_priv_stmt> 
  | <revoke_role_stmt> 
  | <revoke_all_stmt>

<revoke_priv_stmt> ::= 
  REVOKE [GRANT OPTION FOR] <privileges> 
  FROM {
      <object_list> 
    | PUBLIC | 
    | <user_list> 
    | SYSTEM PRIVILEGE <sys_privileges_list> } 
  [{GRANTED BY | AS} [USER] grantor] 

<revoke_role_stmt> ::= 
  REVOKE [ADMIN OPTION FOR] [DEFAULT] <role_granted> 
  FROM {PUBLIC | <role_grantee_list> } 
  [{GRANTED BY | AS} [USER] grantor] 

<revoke_all_stmt> ::= 
  REVOKE ALL ON ALL FROM <user_list>
  [{GRANTED BY | AS} [USER] grantor] 

<privileges> ::= 
    <table_privileges>
  | <execute_privileges>
  | <usage_privileges>
  | <ddl_privileges>  
  | <ddl_db_privileges>            

<table_privileges> ::= 
  { ALL [PRIVILEGES] | <table_privileges_list> } 
  ON [TABLE] {table_name | view_name} 

<table_privilege_list> ::= {     
    SELECT 
  | DELETE 
  | INSERT 
  | UPDATE [(col [,col ...])] 
  | REFERENCES [(col [,col ...])]   
} [, <table_privilege_list> ...]    

<execute_privileges> ::= EXECUTE ON {
    PROCEDURE proc_name
  | FUNCTION func_name
  | PACKAGE package_name
}     

<usage_privileges> ::= USAGE ON {
    EXCEPTION exception_name 
  | {GENERATOR | SEQUENCE} generator_name
}      


<ddl_privileges> ::= 
    {ALL [PRIVILEGES] | <ddl_privelege> [,<ddl_privelege> ...]} <object_type>

<ddl_privelege> ::= CREATE | ALTER ANY | DROP ANY

  
<ddl_db_privileges> ::= 
    {ALL [PRIVILEGES] | <ddl_db_priv> [,<ddl_db_priv> ...]} DATABASE

<ddl_db_priv> ::= CREATE | ALTER | DROP  
  
<object_type> ::= 
    CHARACTER SET 
  | COLLATION 
  | DOMAIN 
  | EXCEPTION 
  | FILTER 
  | FUNCTION 
  | GENERATOR 
  | PACKAGE 
  | PROCEDURE 
  | ROLE 
  | SEQUENCE 
  | TABLE 
  | VIEW
  

<object_list> ::= {     
    PROCEDURE proc_name 
  | FUNCTION func_name
  | PACKAGE package_name
  | TRIGGER trig_name 
  | VIEW view_name } [, <object_list> ...]

<sys_privileges_list> ::= <sys_privilege> [, <sys_privilege> [, <sys_privilege> ...]] 

<user_list> ::= { 
    [USER] username 
  | [ROLE] rolename 
  | GROUP Unix_group 
  | Unix_user } [, <user_list> ...] 

<role_granted> ::= rolename [, rolename ...]

<role_grantee_list> ::= [USER] username [, [USER] username ...]
----



.Параметры оператора REVOKE
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``table_name``
|

Имя таблицы, у которой должна быть отозвана привилегия. 

|[replaceable]``view_name``
|

Имя представления, к которому должно быть применена привилегия или которого будет отозваны привилегии. 

|[replaceable]``col``
|

Столбец таблицы, у которого должна быть отозвана привилегия. 

|[replaceable]``proc_name``
|

Имя хранимой процедуры, для которой должна быть отозвана привилегия EXECUTE или у которой должны быть отозваны привилегии. 

|[replaceable]``func_name``
|

Имя хранимой функции (или UDF), для которой должна быть отозвана привилегия EXECUTE или у которой должны быть отозваны привилегии. 

|[replaceable]``package_name``
|

Имя пакета, для которого должна быть отозвана привилегия EXECUTE или у которого должны быть отозваны привилегии. 

|[replaceable]``exception_name``
|

Имя исключения, для которого должна быть отозвана привилегия USAGE.

|[replaceable]``generator_name``
|

Имя генератора (последовательности), для которого должна быть отозвана привилегия USAGE.

|[replaceable]``object_type``
|

Тип объекта метаданных.

|[replaceable]``object_list``
|

Список объектов метаданных, у которых будут отозваны привилегии.

|[replaceable]``trig_name``
|

Имя триггера, у которого будут отозваны привилегии.

|[replaceable]``sys_privilege``
|Системная привилегия.

|[replaceable]``user_list``
|

Список пользователей/ролей, у которых будут отозваны привилегии.

|[replaceable]``username``
|

Имя пользователя, для которого отзываются привилегии или у которого отбирается роль. 

|[replaceable]``rolename``
|

Имя роли.

|[replaceable]``Unix_group``
|

Имя группы пользователей в операционных системах семейства UNIX.
Только в Firebird Embedded.

|[replaceable]``Unix_user``
|

Имя пользователя в операционной системе семейства UNIX.
Только в Firebird Embedded.

|[replaceable]``role_granted``
|

Список ролей, которые будут отобраны. 

|[replaceable]``role_grantee_list``
|

Список пользователей, у которых будут отобраны роли.

|[replaceable]``grantor``
|

Пользователь от имени, которого отзываются привилегии. 
|===

Оператор REVOKE отменяет привилегии для пользователей, ролей, хранимых процедур, хранимых функций, пакетов, триггеров и представлений выданные оператором GRANT.
Подробное описание различных типов привилегий см.
в <<_fblangref_security_priv_grant,GRANT>>. 

[[_fblangref_security_priv_revoke_from_clause]]
==== Предложение FROM

В предложении FROM указывается список пользователей, ролей и объектов базы данных (процедур, функций, пакетов, триггеров и представлений) у которых будут отняты перечисленные привилегии.
Необязательные предложения USER и ROLE позволяют уточнить, у кого именно выдаётся привилегия.
Если ключевое слово USER или ROLE не указано, то сервер проверяет, существует ли роль с данным именем, если таковой не существует, то привилегии отбираются у пользователя.

.Рекомендация
[TIP]
====
Несмотря на то, что ключевые слова USER и ROLE не обязательные, желательно использовать их, чтобы избежать путаницы. 
====

Существование пользователя, у которого отбираются права, не проверяются при выполнении оператора REVOKE.
Если привилегия отбирается у объекта базы данных, то необходимо обязательно указывать тип объекта.

[IMPORTANT]
====
Если привилегии были назначены специальному пользователю PUBLIC, то отменять привилегии необходимо для пользователя PUBLIC.
Специальный пользователь PUBLIC используется, когда необходимо предоставить привилегии сразу всем пользователям.
Однако не следует рассматривать PUBLIC как группу пользователей.
====

.Примеры:


.Отзыв привилегий на таблицу
[example]

[source,sql]
----

-- отзыв привилегий SELECT, INSERT у таблицы                        
REVOKE SELECT, INSERT ON TABLE SALES FROM USER ALEX

-- отзыв привилегии SELECT у ролей MANAGER и ENGINEER и пользователя IVAN
REVOKE SELECT ON TABLE CUSTOMER 
FROM ROLE MANAGER, ROLE ENGINEER, USER IVAN;

-- отзыв привилегий SELECT и REFERENCES у пользователя PUBLIC
REVOKE SELECT, REFERENCES (NAME) ON TABLE COUNTRY 
FROM PUBLIC;

-- отзыв привилегии UPDATE для столбцов FIRST_NAME, LAST_NAME 
REVOKE UPDATE (FIRST_NAME, LAST_NAME) ON TABLE EMPLOYEE 
FROM USER IVAN;

-- отзыв привилегии INSERT у хранимой процедуры ADD_EMP_PROJ
REVOKE INSERT ON EMPLOYEE_PROJECT 
FROM PROCEDURE ADD_EMP_PROJ;
----

.Отзыв привилегии EXECUTE
[example]

[source,sql]
----

-- отзыв привилегии EXECUTE на процедуру                        
REVOKE EXECUTE ON PROCEDURE ADD_EMP_PROJ 
FROM USER IVAN;
       
-- отзыв привилегии EXECUTE на пакет
REVOKE EXECUTE ON PACKAGE DATE_UTILS
FROM USER ALEX;
----

.Отзыв привилегии USAGE
[example]

[source,sql]
----

-- Отзыв привилегии USAGE на последовательность выданной роли                            
REVOKE USAGE ON SEQUENCE GEN_AGE FROM ROLE MANAGER;

-- Отзыв привилегии USAGE на последовательность выданной триггеру   
REVOKE USAGE ON SEQUENCE GEN_AGE FROM TRIGGER TR_AGE_BI;

-- Отзыв привилегии USAGE на исключение выданной пакету
REVOKE USAGE ON EXCEPTION E_ACCESS_DENIED
FROM PACKAGE PKG_BILL;
----

.Отзыв привилегий на изменение метаданных
[example]

[source,sql]
----

-- Отзыв у пользователя Joe привилегии на создание таблиц                            
REVOKE CREATE TABLE FROM Joe;

-- Отзыв у пользователя Joe привилегии на изменение любой процедуры
REVOKE ALTER ANY PROCEDURE FROM Joe;

-- Отзыв привилегии пользователю на создание базы данных 
-- у пользователя Superuser                             
REVOKE CREATE DATABASE FROM USER Superuser;
----

.Отзыв привилегий у системной привилегии
[example]

[source,sql]
----

-- Отзыв у системной привилегии USER_MANAGEMENT всех прав 
-- на представление PLG$SRP_VIEW                            
REVOKE ALL ON PLG$SRP_VIEW FROM SYSTEM PRIVILEGE USER_MANAGEMENT;
----

[[_fblangref_security_priv_revoke_grant_option]]
==== GRANT OPTION FOR

Необязательное предложение GRANT OPTION FOR отменяет для соответствующего пользователя или роли право предоставления другим пользователям или ролям привилегии к таблицам, представлениям, триггерам, хранимым процедурам.

.Примеры:


.Отзыв привилегий с использованием GRANT OPTION FOR
[example]

[source,sql]
----

-- отмена возможности передавать любую из привилегии на таблицу
-- другим пользователям или ролям у роли ADMINISTRATOR
REVOKE GRANT OPTION FOR ALL ON TABLE CUSTOMER 
FROM ROLE ADMINISTRATOR;

-- отзыв привилегии EXECUTE на функцию
-- и лишение права передавать эту привилегию 
-- другим пользователям и ролям
REVOKE GRANT OPTION FOR
EXECUTE ON FUNCTION GET_BEGIN_DATE
FROM ROLE MANAGER;
----

[[_fblangref_security_priv_revoke_roles]]
==== Отмена назначенных ролей
(((REVOKE,ROLE)))

Другое назначение оператора REVOKE в отзыве назначенных пользователям или ролям ролей оператором GRANT.
В этом случае после предложения REVOKE следует список ролей, которые будут отозваны у списка пользователей или ролей, указанных после предложения FROM. 

Необязательное предложение ADMIN OPTION FOR отменяет ранее предоставленную административную опцию (право на передачу предоставленной пользователю роли другим) из грантополучателей, не отменяя прав на роль.
В одном операторе могут быть обработаны несколько ролей и/или грантополучателей.

.Примеры:


.Отзыв ролей
[example]

[source,sql]
----

-- Отзыв ролей DIRECTOR, MANAGER у пользователя IVAN                        
REVOKE DIRECTOR, MANAGER FROM USER IVAN;


-- Отзыв умолчательной роли MANAGER у пользователя FEDOR                        
REVOKE DEFAULT MANAGER FROM USER FEDOR;

-- Отзыв роли MANAGER и права назначать её другим пользователям
REVOKE ADMIN OPTION FOR MANAGER FROM USER ALEX;
----

[[_fblangref_security_priv_revoke_granted_by]]
==== GRANTED BY
(((REVOKE,GRANTED BY)))

При предоставлении прав в базе данных в качестве лица, предоставившего эти права, обычно записывается текущий пользователь.
Используя предложение GRANTED BY можно предоставлять права от имени другого пользователя.
При использовании оператора REVOKE после GRANTED BY права будут удалены только в том случае, если они были зарегистрированы от удаляющего пользователя.
Для облегчения миграции из некоторых других реляционных СУБД нестандартное предложение AS поддерживается как синоним оператора GRANTED BY. 

Предложение GRANTED BY может использовать: 

* Владелец базы данных;
* SYSDBA;
* Любой пользователь, имеющий права на роль RDB$ADMIN и указавший её при соединении с базой данных;
* При использовании флага AUTO ADMIN MAPPING -- любой администратор операционной системы Windows (при условии использования сервером доверенной авторизации -- trusted authentication), даже без указания роли.

Даже владелец роли не может использовать GRANTED BY, если он не находится в вышеупомянутом списке.

.Примеры:


.Отзыв привилегий на таблицу с использованием GRANTED BY
[example]

[source,sql]
----

-- отзыв привилегии SELECT у пользователя IVAN,
-- которая была выдана пользователем ALEX
REVOKE SELECT ON TABLE EMPLOYEE 
FROM USER IVAN GRANTED BY ALEX;
----

[[_fblangref_security_priv_revoke_all_on_all]]
==== REVOKE ALL ON ALL

Если после ключевого слова REVOKE указано предложение ALL ON ALL, то это позволяет отменить все привилегии (включая роли) на всех объектах от одного или более пользователей и/или ролей.
Это быстрый способ "очистить" (отобрать) права, когда пользователю должен быть заблокирован доступ к базе данных.

.Примечания:
[NOTE]
====


* Когда оператор REVOKE ALL ON ALL вызывается привилегированным пользователем (владельцем базы данных, SYSDBA или любым пользователем, у которого CURRENT_ROLE -- RDB$ADMIN), удаляются все права независимо от того, кто их предоставил. В противном случае удаляются только права, предоставленные текущим пользователем;
* Не поддерживается предложение GRANTED BY;
* Этот оператор не удаляет флаг пользователя, давшего права на хранимые процедуры, триггеры или представлений (права на такие объекты конечно удаляются).

====

.Примеры:


.Отзыв всех привилегий и ролей у пользователя
[example]

[source,sql]
----

REVOKE ALL ON ALL FROM IVAN;
----
После выполнения этой команды у пользователя IVAN нет вообще никаких прав. 

.См. также:
<<_fblangref_security_priv_grant,GRANT>>. 

[[_fblangref_security_sql_security]]
=== Привилегии выполнения SQL кода
(((SQL SECURITY)))

Все объекты метаданных содержащие DML или PSQL код могут выполнятся в одном из следующих режимов:

* С привилегиями вызывающего пользователя (привилегии CURRENT_USER);
* С привилегиями определяющего пользователя (владельца объекта метаданных).

Исторически сложилось, что все PSQL модули по умолчанию выполняются с привилегиями вызывающего пользователя.
Начиная с Firebird 4.0 появилась возможность указывать объектам метаданных с какими привилегиями они будут выполняться: вызывающего или определяющего пользователя.
Для этого используется предложение ``SQL
                    SECURITY``, которое можно указать для таблицы, триггера, процедуры, функции или пакета.
Если выбрана опция INVOKER, то объект метаданных будет выполняться с привилегиями вызывающего пользователя.
Если выбрана опция DEFINER, то объект метаданных будет выполняться с привилегиями определяющего пользователя (владельца). Эти привилегии будут дополнены привилегиями выданные самому PSQL модулю с помощью оператора GRANT.

Привилегии выполнения, с которым по умолчанию создаётся любой PSQL модуль можно изменить с помощью оператора 
[source]
----

ALTER DATABASE SET DEFAULT SQL SECURITY {DEFINER | INVOKER}
----
Для сохранения обратной совместимости по умолчанию используется опция INVOKER. 

.Замечания:
[NOTE]
====


* Представления (VIEWs) всегда выполняются с привилегиями определяющего пользователя (владельца);
* По умолчанию триггеры наследуют привилегии выполнения которые были указаны у таблицы. Привилегии выполнения могут быть переопределены в самом триггере;
* Процедуры и функции пакета всегда наследуют привилегии выполнения указанный при определении пакета. Привилегии выполнения не могут быть переопределены в самих процедурах и функция пакета;
* Анонимные PSQL блоки (EXECUTE BLOCK) всегда выполняются с правами вызывающего пользователя.

====

В хранимых процедурах, функциях и триггерах вы можете проверить эффективного в настоящий момент пользователя, т.е.
пользователя с привилегиями которого выполняется текущий модуль, с помощью системной контекстной переменной EFFECTIVE_USER из пространства имён SYSTEM. 
[source,sql]
----

select RDB$GET_CONTEXT('SYSTEM', 'EFFECTIVE_USER') from RDB$DATABASE;
----

[NOTE]
====
Один и тот же объект может вызываться в разных контекстах безопасности и требовать различных привилегий.
Например у нас есть:

* хранимая процедура INV с SECURITY INVOKER, которая вставляет записи в таблицу T;
* хранимая процедура DEF с SQL SECURITY DEFINER, которая определена пользователем SYSDBA.

Если пользователь U вызывает процедуру INV, то для доступа к таблице T потребуется привилегия INSERT выданная пользователю U (и конечно привилегия EXECUTE для INV). В этом случае U является эффективным пользователем (EFFECTIVE_USER) во время выполнения INV.

Если пользователь U вызывает процедуру DEF, то для доступа к таблице T потребуется привилегия INSERT выданная пользователю SYSDBA (и EXECUTE на DEF для пользователя U). В этом случае SYSDBA является эффективным пользователем (EFFECTIVE_USER) во время выполнения DEF.
Если внутри DEF вызывается процедура INV, то эффективным пользователем по время выполнения INV будет так же SYSDBA.
====

[[_fblangref_security_priv_context_examples]]
==== Примеры

.Создание таблицы с привилегиями определяющего пользователя
====
В данном случае пользователю JOE достаточно только привилегии SELECT на таблицу t.
Если бы таблица была создана с привилегиями вызывающего пользователя (INVOKER), то ещё потребовалось бы выдать привилегию EXECUTE для таблицы на функцию f.


[source,sql]
----

SET TERM ^;

CREATE FUNCTION f() RETURNS INT
AS
BEGIN
  RETURN 3;
END^

SET TERM ;^

CREATE TABLE t (
  i INTEGER, 
  c COMPUTED BY (i + f())
)
SQL SECURITY DEFINER;

INSERT INTO t VALUES (2);

GRANT SELECT ON TABLE t TO USER joe;

COMMIT;

CONNECT 'inet://localhost:test' USER joe PASSWORD 'pas';

SELECT * FROM t;
----
====

.Создание процедуры с привилегиями определяющего пользователя
====
В данном случае пользователю JOE достаточно только привилегии EXECUTE на процедуру p.
Если бы процедура была создана с привилегиями вызывающего пользователя (опция INVOKER), то ещё потребовалось бы выдать привилегию INSERT для процедуры p на таблицу t.


[source,sql]
----

CREATE TABLE t (i INTEGER);

SET TERM ^;

CREATE PROCEDURE p (i INTEGER)
SQL SECURITY DEFINER
AS
BEGIN
  INSERT INTO t VALUES (:i);
END^

SET TERM ;^

GRANT EXECUTE ON PROCEDURE p TO USER joe;

COMMIT;

CONNECT 'inet://localhost:test' USER joe PASSWORD 'pas';

EXECUTE PROCEDURE p(1);
----
====

.Создание функции с привилегиями определяющего пользователя
====
В данном случае пользователю JOE достаточно только привилегии EXECUTE на функцию f.
Если бы функция была создана с привилегиями вызывающего пользователя (опция INVOKER), то ещё потребовалось бы выдать привилегию SELECT для функции f на таблицу t.


[source,sql]
----

CREATE TABLE t (i INTEGER PRIMARY KEY, j INTEGER);

INSERT INTO t(i, j) VALUES(1, 2);
INSERT INTO t(i, j) VALUES(2, 5);

COMMIT;

SET TERM ^;

CREATE FUNCTION f (i INTEGER)
SQL SECURITY DEFINER
AS
  DECLARE j INTEGER DEFAULT NULL;
BEGIN
  SELECT j
  FROM t
  WHERE i = :i
  INTO j;
  
  RETURN COALESCE(j, 0);
END^

SET TERM ;^

GRANT EXECUTE ON FUNCTION f TO USER joe;

COMMIT;

CONNECT 'inet://localhost:test' USER joe PASSWORD 'pas';

SELECT f(1) AS j FROM RDB$DATABASE;
----
====

.Создание триггера с привилегиями определяющего пользователя
====
В данном случае пользователю JOE достаточно только привилегии INSERT на на таблицу tr.
Если бы триггер была создан с привилегиями вызывающего пользователя (опция INVOKER), то ещё потребовалось бы выдать привилегию INSERT для триггера tr_ins на таблицу t.


[source,sql]
----

CREATE TABLE tr (i INTEGER);
CREATE TABLE t (i INTEGER);

SET TERM ^;

CREATE TRIGGER tr_ins FOR tr AFTER INSERT
SQL SECURITY DEFINER
AS
BEGIN
  INSERT INTO t(i) VALUES(NEW.i);
END^

SET TERM ;^

GRANT INSERT ON TABLE tr TO USER joe;

COMMIT;

CONNECT 'inet://localhost:test' USER joe PASSWORD 'pas';

INSERT INTO tr(i) VALUES(2);

COMMIT;
----

Тот же самый результат можно получить указав SQL SECURITY DEFINER для таблицы tr. 
[source,sql]
----

CREATE TABLE tr (i INTEGER) SQL SECURITY DEFINER;
CREATE TABLE t (i INTEGER);

SET TERM ^;

CREATE TRIGGER tr_ins FOR tr AFTER INSERT
AS
BEGIN
  INSERT INTO t(i) VALUES(NEW.i);
END^

SET TERM ;^

GRANT INSERT ON TABLE tr TO USER joe;

COMMIT;

CONNECT 'inet://localhost:test' USER joe PASSWORD 'pas';

INSERT INTO tr(i) VALUES(2);

COMMIT;
----
====

.Удаление привилегий выполнения у триггера
[example]
Если триггеру явно установлена опция SQL SECURITY, то для того чтобы наследовать привилегии выполнения у таблицы, необходимо выполнить следующий оператор. 
[source,sql]
----

ALTER TRIGGER tr_ins DROP SQL SECURITY;
----

.Создание пакета с привилегиями определяющего пользователя
====
В данном случае пользователю JOE достаточно только привилегии EXECUTE на пакет pk.
Если бы пакет была создана с привилегиями вызывающего пользователя (опция INVOKER), то ещё потребовалось бы выдать привилегию INSERT для пакета pk на таблицу t.


[source,sql]
----

CREATE TABLE t (i INTEGER);

SET TERM ^;

CREATE PACKAGE pk
SQL SECURITY DEFINER
AS
BEGIN
  FUNCTION f(i INTEGER) RETURNS INT;
END^

CREATE PACKAGE BODY pk
AS
BEGIN
  FUNCTION f(i INTEGER) RETURNS INT
  AS
  BEGIN
    INSERT INTO t VALUES (:i);
    RETURN i + 1;
  END
END^

SET TERM ;^

GRANT EXECUTE ON PACKAGE pk TO USER joe;

COMMIT;

CONNECT 'inet://localhost:test' USER joe PASSWORD 'pas';

SELECT pk.f(3) FROM rdb$database;
----
====

.Изменение привилегий выполнения по умолчанию
====
После выполнения данного оператора PSQL модули по умолчанию будут создаваться с опцией SQL SECURITY DEFINER


[source,sql]
----

ALTER DATABASE SET DEFAULT SQL SECURITY DEFINER;
----
====

[[_fblangref_security_crypt]]
== Шифрование базы данных

В Firebird существует возможность зашифровать данные хранимые в базе данных.
Не весь файл базы данных шифруется: только страницы данных, индексов и blob. 

Для того чтобы сделать шифрование базы данных возможным необходимо получить или написать плагин шифрования базы данных.

[NOTE]
====
Пример плагина шифрования в examples/dbcrypt не производит реального шифрования, это просто пример того, как можно написать этот плагин.
====

Основная проблема с шифрованием базы данных состоит в том, как хранить секретный ключ.
Firebird предоставляет помощника для передачи этого ключа от клиента, но это вовсе не означает, что хранение ключей на клиенте является лучшим способом: это не более чем одна возможных альтернатив.
Хранение ключей на том же диске что и база данных является очень плохим вариантом. 

Для эффективного разделения шифрования и доступа к ключу, плагин шифрования базы данных разделён на две части: само шифрование и держатель секретного ключа.
Это может быть эффективным подходом, когда вы хотите использовать некоторый хороший алгоритм шифрования, но у вас есть собственный секретный способ хранение ключей.

После того как вы определитесь с плагином и ключом, вы можете включить процесс шифрования.

.Синтаксис:

[source]
----

ALTER DATABASE ENCRYPT WITH plugin_name [KEY key_name]
----



.Параметры оператора ALTER DATABASE ENCRYPT
[cols="1,1", frame="all", options="header"]
|===
| Параметр
| Описание

|[replaceable]``plugin_name``
|

Имя плагина шифрования.

|[replaceable]``key_name``
|

Имя ключа шифрования.
|===

Шифрование начинается сразу после этого оператора и будет выполняться в фоновом режиме.
Нормальная работа с базами данных не нарушается во время шифрования.

[TIP]
====
Процесс шифрования может быть проконтролирован с помощью поля MON$CRYPT_PAGE в псевдо-таблице MON$DATABASE или смотреть страницу заголовка базы данных с помощью __gstat -e__.

_gstat –h_ также будет предоставлять ограниченную информацию о состоянии шифрования.

Например, следующий запрос 
[source,sql]
----

select MON$CRYPT_PAGE * 100 / MON$PAGES from MON$DATABASE
----
будет отображать процент завершения процесса шифрования. 
====

Необязательное предложение KEY позволяет передать имя ключа для плагина шифрования.
Что делать с этим именем ключа решает плагин.

Для дешифрования базы данных выполните: 
[source,sql]
----

ALTER DATABASE DECRYPT
----

Для Linux пример плагина с именем _libDbCrypt_example.so_ можно найти в поддиректории __/plugins/__.

ifdef::backend-docbook[]
[index]
== Index
// Generated automatically by the DocBook toolchain.
endif::backend-docbook[]