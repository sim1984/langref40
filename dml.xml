<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="dml" xml:lang="ru">
    <info>
        <title>Операторы DML</title>
    </info>

    <section xml:id="dml-select">
        <info>
            <title>SELECT</title>
            <keywordset>
                <keyword>SELECT</keyword>
            </keywordset>
        </info>

        <indexterm><primary>SELECT</primary></indexterm>

        <formalpara>
            <title>Назначение:</title>

            <para>Выборка данных.</para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL, ESQL, PSQL.</para>
        </formalpara>
        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
[WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]]   
SELECT 
  [FIRST <replaceable>m</replaceable>] [SKIP <replaceable>n</replaceable>] 
  [DISTINCT | ALL] <replaceable>&lt;columns&gt;</replaceable>   
FROM 
  <replaceable>source</replaceable> [[AS] <replaceable>alias</replaceable>] 
  [<replaceable>&lt;joins&gt;</replaceable>]   
[WHERE <replaceable>&lt;condition&gt;</replaceable>]   
[GROUP BY <replaceable>&lt;grouping-list&gt;</replaceable>   
[HAVING <replaceable>&lt;aggregate-condition&gt;</replaceable>]]   
[WINDOW <replaceable>&lt;window definition&gt;</replaceable> [, <replaceable>&lt;window definition&gt;</replaceable>] ...]
[PLAN <replaceable>&lt;plan-expr&gt;</replaceable>]   
[UNION [DISTINCT | ALL] <replaceable>&lt;other-select&gt;</replaceable>]   
[ORDER BY <replaceable>&lt;ordering-list&gt;</replaceable>] 
[   {ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]} 
  | {[OFFSET <replaceable>n</replaceable> {ROW | ROWS}] 
     [FETCH {FIRST | NEXT} [<replaceable>m</replaceable>] {ROW | ROWS} ONLY]}
]   
[FOR UPDATE [OF <replaceable>&lt;columns&gt;</replaceable>]]   
[WITH LOCK]   
[INTO <replaceable>&lt;variables&gt;</replaceable>]                    
                       
<replaceable>&lt;variables&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]         
            </programlisting></para>
        </formalpara>

        <bridgehead renderas="sect4">Описание</bridgehead>

        <para>Оператор (команда) SELECT извлекает данные из базы данных и передаёт их в приложение
            или в вызывающую SQL команду. Данные возвращаются в виде набора строк (которых может
            быть 0 или больше), каждая строка содержит один или более столбцов или полей.
            Совокупность возвращаемых строк является результирующим набором данных команды.</para>
        <para>Следующие части команды SELECT являются обязательными:<itemizedlist spacing="compact">
                <listitem>
                    <para>Ключевое слово SELECT, за которым следует список полей. Эта часть
                        определяет, что запрашивается из базы данных;</para>
                </listitem>
                <listitem>
                    <para>Ключевое слово FROM, за которым следует объект выборки (например,
                        таблица). Эта часть сообщает серверу, где следует искать запрашиваемые
                        данные.</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>В простейшей форме SELECT извлекает ряд полей из единственной таблицы, например:
            <programlisting language="sql">
SELECT id, name, address
FROM contacts            
        </programlisting>
        </para>
        <para>Или, для того чтобы извлечь все поля таблицы:
            <programlisting language="sql">
SELECT * FROM contacts                
            </programlisting>
        </para>
        <para>На практике команда SELECT обычно выполняется с выражением WHERE, которое ограничивает
            возвращаемый набор данных. Также, полученный набор данных обычно сортируется с помощью
            выражения ORDER BY, дополнительно ограничивается (с целью организации постраничного
            просмотра данных) выражениями FIRST ... SKIP, OFFSET ... FETCH или ROWS. </para>
        <para>Список полей может содержать различные типы выражений вместо имён полей, а источник
            необязательно должен быть таблицей или представлением, он так же может быть производной
            таблицей (derived table), общим табличным выражением (CTE) или селективной хранимой
            процедурой. </para>
        <para>Несколько источников данных могут быть соединены с помощью выражения JOIN, и несколько
            результирующих наборов данных могут быть скомбинированы с использованием выражения
            UNION.</para>
        <para>В следующих секциях мы подробно рассмотрим все выражения для команды SELECT и их
            использование.</para>
        <section xml:id="dml-select-first_skip">
            <info>
                <title>FIRST, SKIP</title>
                <keywordset>
                    <keyword>FIRST</keyword>
                    <keyword>SKIP</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>FIRST</secondary>
            </indexterm>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>SKIP</secondary>
            </indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Получение части строк из упорядоченного набора.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting>
SELECT [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>] 
FROM ... 
... 

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable> ::=  
    <replaceable>integer literal</replaceable> 
  | <replaceable>query parameter</replaceable>
  | (<replaceable>integer-expression</replaceable>)                            
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложений FIRST и SKIP</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>integer literal</replaceable></entry>
                                <entry>
                                    <para>Целочисленный литерал.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>query parameter</replaceable></entry>
                                <entry>
                                    <para>Параметр запроса. ? — в DSQL и
                                            :<replaceable>paramname</replaceable> — в PSQL.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>integer-expression</replaceable></entry>
                                <entry>
                                    <para>Выражение, возвращающее целочисленное значение.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <important>
                <para>FIRST и SKIP используются только в Firebird, они не включены в стандарт SQL.
                    Рекомендуется использовать OFFSET, FETCH везде, где это возможно. </para>
            </important>

            <bridgehead renderas="sect4">Описание</bridgehead>

            <para>Выражение FIRST <replaceable>&lt;m&gt;</replaceable> ограничивает результирующий
                набор данным указанным числом записей. </para>
            <para>Выражение SKIP <replaceable>&lt;n&gt;</replaceable> пропускает указанное число
                записей перед выдачей результирующего набора данных.</para>
            <para>Когда эти выражения используются совместно, например FIRST
                    <replaceable>m</replaceable> SKIP <replaceable>n</replaceable>, то в результате
                    <replaceable>n</replaceable> записей будет пропущено и, из оставшихся,
                    <replaceable>m</replaceable> записей будет возвращено в результирующем наборе
                данных.</para>
            <para>FIRST и SKIP являются необязательными выражениями.</para>
            <section xml:id="dml-select-first_skip01">
                <title>Особенности использования</title>
                <para><itemizedlist spacing="compact">
                        <listitem>
                            <para>Разрешается использовать SKIP 0 – в этом случае 0 записей будет
                                пропущено; </para>
                        </listitem>
                        <listitem>
                            <para>В случае использования FIRST 0 будет возвращён пустой набор
                                записей;</para>
                        </listitem>
                        <listitem>
                            <para>Отрицательные значения FIRST и SKIP вызовут ошибку; </para>
                        </listitem>
                        <listitem>
                            <para>Если указанное в SKIP значение превышает размер результирующего
                                набора данных, то вернётся пустой набор данных;</para>
                        </listitem>
                        <listitem>
                            <para>Если число записей в наборе данных (или остаток после применения
                                SKIP) меньше, чем заданное в FIRST значение, то соответственно
                                меньшее количество записей будет возвращено;</para>
                        </listitem>
                        <listitem>
                            <para>Любой аргумент FIRST или SKIP, который не является целым числом
                                или параметром SQL должен был заключён в круглые скобки. Это,
                                означает, что в случае использования вложенной команды SELECT в
                                качестве параметра для FIRST или SKIP, он должен быть вложен в две
                                пары скобок.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
            <simplesect xml:id="dml-select-first_skip-ex">
                <title>Примеры</title>
                <informalexample>
                    <para>Следующий запрос вернёт первые 10 имён из таблицы PEOPLE (имена также
                        будут отсортированы, см. ниже раздел <link linkend="dml-select-orderby"
                            >ORDER BY</link>):
                        <programlisting language="sql">
SELECT FIRST 10 id, name 
FROM People
ORDER BY name ASC                    
                </programlisting>
                        Следующий запрос вернёт все записи из таблицы PEOPLE, за исключением первых
                        10 имён:
                        <programlisting language="sql">
SELECT SKIP 10 id, name 
FROM People
ORDER BY name ASC                        
                    </programlisting>
                        А этот запрос вернёт последние 10 записей (обратите внимание на двойные
                        скобки):
                        <programlisting language="sql">
SELECT SKIP ((SELECT COUNT(*) - 10 FROM People))
  id, name 
FROM People
ORDER BY name ASC
                    </programlisting>
                        Этот запрос вернёт строки 81-100 из таблицы PEOPLE:
                        <programlisting language="sql">
SELECT FIRST 20 SKIP 80 id, name 
FROM People
ORDER BY name ASC                        
                    </programlisting>
                    </para>
                </informalexample>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="dml-select-fetch_offset">FETCH, OFFSET</link>, <link
                            linkend="dml-select-rows">ROWS</link>. </para>

                </formalpara>
            </simplesect>
        </section>

        <section xml:id="dml-select-fieldlist">
            <info>
                <title>Список полей SELECT</title>
                <keywordset>
                    <keyword>DISTINCT</keyword>
                    <keyword>ALL</keyword>
                </keywordset>
            </info>
            <para>Список полей содержит одно или более выражений, разделённых запятыми. Результатом
                каждого выражения является значение соответствующего поля в наборе данных команды
                SELECT. Исключением является выражение <literal>*</literal>
                    (<quote>звёздочка</quote>), которое возвращает все поля отношения.</para>
            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting>
SELECT   [...] 
[DISTINCT | ALL] <replaceable>&lt;output-column&gt;</replaceable> [, <replaceable>&lt;output-column&gt;</replaceable> ...]   
[...]
FROM ...

<replaceable>&lt;output-column&gt;</replaceable> ::= 
    [<replaceable>qualifier</replaceable>.]* 
  | <replaceable>&lt;value-expression&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] [[AS] <replaceable>alias</replaceable>]  

<replaceable>&lt;value-expression&gt;</replaceable> ::= 
    [<replaceable>qualifier</replaceable>.]<replaceable>table-column</replaceable> 
  | [<replaceable>qualifier</replaceable>.]<replaceable>view-column</replaceable>
  | [<replaceable>qualifier</replaceable>.]<replaceable>selectable-SP-outparm</replaceable> 
  | <replaceable>constant</replaceable> 
  | NULL          
  | <replaceable>context-variable</replaceable> 
  | <replaceable>function-call</replaceable>
  | <replaceable>single-value-subselect</replaceable> 
  | <replaceable>CASE-construct</replaceable>
  | <replaceable>other-single-value-expr</replaceable>                                    
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры списка полей оператора SELECT</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>qualifier</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы (представления) или псевдоним таблицы
                                        (представления, хранимой процедуры, производной
                                        таблицы).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Существующее имя сортировки (только для столбцов
                                        символьных типов).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>alias</replaceable></entry>
                                <entry>
                                    <para>Псевдоним поля.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>table-column</replaceable></entry>
                                <entry>
                                    <para>Столбец таблицы.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>view-column</replaceable></entry>
                                <entry>
                                    <para>Столбец представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>selectable-SP-outparm</replaceable></entry>
                                <entry>
                                    <para>Выходной параметр селективной хранимой процедуры.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>constant</replaceable></entry>
                                <entry>
                                    <para>Константа.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>context-variable</replaceable></entry>
                                <entry>
                                    <para>Контекстная переменная.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>function-call</replaceable></entry>
                                <entry>
                                    <para>Вызов скалярной, агрегатной или оконной функции.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>single-value-subselect</replaceable></entry>
                                <entry>
                                    <para>Подзапрос, возвращающий единственное скалярное значение
                                        (сингелтон).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>CASE-construct</replaceable></entry>
                                <entry>
                                    <para>Конструкция CASE.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>other-single-value-expr</replaceable></entry>
                                <entry>
                                    <para>Любое другое выражение, возвращающее единственное значение
                                        типа данных Firebird или NULL.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <bridgehead renderas="sect4">Описание</bridgehead>

            <para>Хорошим тоном является указание полного имени поля вместе с именем алиаса или
                таблицы/представления/хранимой процедуры, к которой это поле принадлежит. </para>
            <para>Указание полного имени становится <emphasis role="bold">обязательным</emphasis> в
                случае, если поле с одним и тем же именем находится в более чем одной таблице,
                участвующей в объединении.</para>
            <important>
                <title>Обратите внимание</title>
                <para>Алиасы (псевдонимы) заменяют оригинальное имя таблицы/ представления/ хранимой
                    процедуры: как только определён алиас для соответствующего отношения,
                    использовать оригинальное имя нельзя.</para>
            </important>

            <para>В начало списка полей могут быть добавлены ключевые слова DISTINCT или ALL:<itemizedlist>
                    <listitem>
                        <para>DISTINCT удаляет дубликаты строк: то есть, если две или более записей
                            содержат одинаковые значения во всех соответствующих полях, только одна
                            из этих строк будет включена в результирующий набор данных.  </para>
                    </listitem>
                    <listitem>
                        <para>ALL включает все строки в результирующий набор данных. ALL включено по
                            умолчанию и поэтому редко используется: явное указание поддерживается
                            для совместимости со стандартом SQL. </para>
                    </listitem>
                </itemizedlist></para>

            <para>Выражение COLLATE не изменяет содержимое поля, однако, если указать COLLATE для
                определённого поля, то это может изменить чувствительность к регистру символов или к
                акцентам (accent sensitivity), что, в свою очередь, может повлиять на: <itemizedlist
                    spacing="compact">
                    <listitem>
                        <para>Порядок сортировки, в случае если это поле указано в выражении ORDER
                            BY;</para>
                    </listitem>
                    <listitem>
                        <para>Группировку, в случае если это поле указано в выражении GROUP
                            BY;</para>
                    </listitem>
                    <listitem>
                        <para>Количество возвращаемых строк, если используется DISTINCT.</para>
                    </listitem>
                </itemizedlist></para>
            <simplesect>
                <title>Примеры операторов SELECT с различными типами полей</title>
                <para>Простой SELECT использующий только имена полей:
                    <programlisting language="sql">
SELECT cust_id, cust_name, phone
FROM customers
WHERE city = 'London'                        
                    </programlisting>
                </para>
                <para>Запрос с конкатенацией и вызовом функции в списке полей:
                    <programlisting language="sql">
SELECT 
  'Mr./Mrs. ' || lastname, 
  street, 
  zip, 
  upper(city)
FROM contacts
WHERE date_last_purchase(id) = current_date                        
                    </programlisting>
                </para>
                <para> Запрос с двумя подзапросами:
                    <programlisting language="sql">
SELECT 
  p.fullname,
  (SELECT name FROM classes c 
   WHERE c.id = p.class) AS class,
  (SELECT name FROM mentors m 
   WHERE m.id = p.mentor) AS mentor
FROM pupils p                        
                    </programlisting>
                </para>
                <para>Следующий запрос делает то же самое, что и предыдущий, только с использованием
                    соединения таблиц (JOIN) вместо подзапросов:
                    <programlisting language="sql">
SELECT 
  p.fullname,
  c.name AS class,
  m.name AS mentor
FROM pupils p
  JOIN classes c ON c.id = p.class
  JOIN mentors m ON m.id = p.mentor                        
                    </programlisting>
                </para>
                <para>Этот запрос использует конструкцию CASE для определения корректного обращения,
                    например, при рассылке сообщений конкретному человеку:
                    <programlisting language="sql">
SELECT 
  CASE upper(sex)
    WHEN 'F' THEN 'Mrs.'
    WHEN 'M' THEN 'Mr.'
    ELSE ''
  END AS title,
  lastname,
  address
FROM employees                        
                    </programlisting>
                </para>
                <para>Запрос с использованием оконной функции. Выводит сотрудников отранжированных
                    по заработной плате.
                    <programlisting language="sql">
SELECT
    id,
    salary,
    name,
    DENSE_RANK() OVER(ORDER BY salary) AS EMP_RANK
FROM employees
ORDER BY salary;                       
                    </programlisting>
                </para>
                <para>Запрос к хранимой процедуре:
                    <programlisting language="sql">
SELECT * 
FROM interesting_transactions(2010, 3, 'S')
ORDER BY amount                        
                    </programlisting>
                </para>
                <para>Выборка полей производной таблицы. Производная таблица – это заключённый в
                    скобки оператор SELECT, результат которого используется в запросе уровнем выше,
                    как будто является обычной таблицей или представлением.
                    <programlisting language="sql">
SELECT 
  fieldcount,
  COUNT(relation) AS num_tables
FROM 
  (SELECT 
     r.rdb$relation_name AS relation,
     COUNT(*) AS fieldcount
   FROM rdb$relations r
     JOIN rdb$relation_fields rf
       ON rf.rdb$relation_name = r.rdb$relation_name
   GROUP BY relation)
GROUP BY fieldcount                        
                    </programlisting>
                </para>
                <para> Запрос к контекстной переменной (CURRENT_TIME):
                    <programlisting language="sql">
SELECT current_time FROM rdb$database                        
                    </programlisting>
                </para>
                <para>Для тех, кто не знаком с RDB$DATABASE: это системная таблица, которая всегда
                    существует во всех базах данных Firebird и всегда содержит только одну строку.
                    И, хотя эта таблица не была создана специально для этой цели, стало
                    распространённой практикой среди разработчиков Firebird выполнять запросы к этой
                    таблице в случае, если нужно выполнить запрос, не привязанный ни к какой
                    таблице, в котором результат получается из выражений, указанных в списке полей
                    оператора SELECT. Например:
                    <programlisting language="sql">
SELECT 
  power(12, 2) AS twelve_squared, 
  power(12, 3) AS twelve_cubed 
FROM rdb$database                        
                    </programlisting>
                </para>
                <para> И, наконец, пример запроса к самой таблице RDB$DATABASE, с помощью которого
                    можно получить кодировку по умолчанию данной БД:
                    <programlisting language="sql">
SELECT rdb$character_set_name FROM rdb$database
                    </programlisting>
                </para>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="internalfunc-func">Скалярные функции</link>, <link
                            linkend="internalfunc-agg">Агрегатные функции</link>, <link
                            linkend="internalfunc-window">Оконные (аналитические) функции</link>,
                            <link linkend="internalfunc-contextvar">Контекстные переменные</link>,
                            <link linkend="common-expr-cond-case">CASE</link>, <link
                            linkend="common-subquery">Подзапросы</link>. </para>

                </formalpara>
            </simplesect>
        </section>
        <section xml:id="dml-select-from">
            <info>
                <title>FROM</title>
                <keywordset>
                    <keyword>FROM</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>FROM</secondary>
            </indexterm>
            <para>Выражение FROM определяет источники, из которых будут отобраны данные. В
                простейшей форме, это может быть единственная таблица или представление. Однако
                источниками также могут быть хранимая процедура, производная таблица или общее
                табличное выражение (CTE). Различные виды источников могут комбинироваться с
                использованием разнообразных видов соединений (JOIN).</para>
            <para>Этот раздел посвящён запрос из единственного источника. Соединения рассматриваются
                в следующем разделе.</para>
            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting>
SELECT 
... 
FROM <replaceable>&lt;source&gt;</replaceable>   
[<replaceable>&lt;joins&gt;</replaceable>] 
[...]       

<replaceable>&lt;source&gt;</replaceable> ::= {      
    <replaceable>table</replaceable> 
  | <replaceable>view</replaceable>  
  | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)] 
  | <replaceable>&lt;derived-table&gt;</replaceable>
  | <replaceable>&lt;lateral-derived-table&gt;</replaceable> 
  | <replaceable>&lt;common-table-expression&gt;</replaceable> 
} [[AS] <replaceable>alias</replaceable>]       

<replaceable>&lt;derived-table&gt;</replaceable> ::= (<replaceable>select-statement</replaceable>) [[AS] <replaceable>alias</replaceable>] [(<replaceable>&lt;column-aliases&gt;</replaceable>)] 

<replaceable>&lt;lateral-derived-table&gt;</replaceable> ::= LATERAL <replaceable>&lt;derived-table&gt;</replaceable>      

<replaceable>&lt;common-table-expression&gt;</replaceable> ::= WITH [RECURSIVE]      
  <replaceable>&lt;cte-def&gt;</replaceable> [, <replaceable>&lt;cte-def&gt;</replaceable> ...] 
  <replaceable>select-statement</replaceable>       

<replaceable>&lt;cte-def&gt;</replaceable> ::= <replaceable>name</replaceable> [(<replaceable>&lt;column-aliases&gt;</replaceable>)] AS (<replaceable>select-statement</replaceable>)       

<replaceable>&lt;column-aliases&gt;</replaceable> ::= <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]                                
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложения FROM</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>table</replaceable></entry>
                                <entry>
                                    <para>Таблица.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>view</replaceable></entry>
                                <entry>
                                    <para>Представление.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>selectable-stored-procedure</replaceable></entry>
                                <entry>
                                    <para>Селективная хранимая процедура.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>args</replaceable></entry>
                                <entry>
                                    <para>Аргументы селективной хранимой процедуры.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>derived-table</replaceable></entry>
                                <entry>
                                    <para>Производная таблица.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>lateral-derived-table</replaceable></entry>
                                <entry>Производная таблица с горизонтальной связью.</entry>
                            </row>
                            <row>
                                <entry><replaceable>cte-def</replaceable></entry>
                                <entry>
                                    <para>Общее табличное выражение (CTE).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select-statement</replaceable></entry>
                                <entry>
                                    <para>Произвольный SELECT запрос.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>column-alias</replaceable></entry>
                                <entry>
                                    <para>Алиас столбца CTE или производной таблицы.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>name</replaceable></entry>
                                <entry>
                                    <para>Имя CTE.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>alias</replaceable></entry>
                                <entry>
                                    <para>Псевдоним (алиас) для одного из источников данных
                                        (таблицы, представления, процедуры, CTE, производной
                                        таблицы).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <section xml:id="dml-select-from-tableorview">
                <info>
                    <title>Выборка из таблицы или представления</title>
                </info>
                <para>При выборке из таблицы или представления предложение FROM не требует ничего
                    кроме его имени. Псевдоним (алиас) может быть полезен или даже необходим при
                    использовании подзапросов, которые соотнесены с главным запросом (обычно
                    подзапросы являются коррелированными).</para>

                <bridgehead renderas="sect4">Примеры</bridgehead>

                <para>
                    <programlisting language="sql">
SELECT id, name, sex, age 
FROM actors
WHERE state = 'Ohio'

SELECT * 
FROM birds
WHERE type = 'flightless'
ORDER BY family, genus, species

SELECT 
  firstname,
  middlename,
  lastname,
  date_of_birth,
  (SELECT name FROM schools s WHERE p.school = s.id) schoolname
FROM pupils p
WHERE year_started = 2012
ORDER BY schoolname, date_of_birth                    
                </programlisting>
                </para>
                <important>
                    <para> Если вы дадите таблице или представлению псевдоним (алиас), то вы должны
                        везде использовать этот псевдоним, а не имя таблицы, при обращении к именам
                        столбцов. </para>
                    <para>Корректное использование:
                        <programlisting language="sql">
SELECT PEARS
FROM FRUIT
 
SELECT FRUIT.PEARS 
FROM FRUIT
 
SELECT PEARS 
FROM FRUIT F
 
SELECT F.PEARS
FROM FRUIT F                        
                    </programlisting>
                    </para>
                    <para>Некорректное использование:
                        <programlisting language="sql">
SELECT FRUIT.PEARS
FROM FRUIT F                        
                    </programlisting>
                    </para>
                </important>
            </section>

            <section xml:id="dml-select-from-sp">
                <title>Выборка из селективной хранимой процедуры</title>
                <para>Селективная хранимая процедура (т.е. с возможностью выборки) должна
                    удовлетворять следующим условиям:<itemizedlist spacing="compact">
                        <listitem>
                            <para>Содержать, по крайней мере, один выходной параметр;</para>
                        </listitem>
                        <listitem>
                            <para>Использовать ключевое слово SUSPEND таким образом, чтобы
                                вызывающий запрос могу выбирать выходные строки одну за другой,
                                также как выбираются строки таблицы или представления.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Выходные параметры селективной хранимой процедуры с точки зрения команды
                    SELECT соответствуют полям обычной таблицы.</para>
                <para>Выборка из хранимой процедуры без входных параметров осуществляется точно так
                    же, как обычная выборка из таблицы:
                    <programlisting language="sql">
SELECT * 
FROM suspicious_transactions
WHERE assignee = 'Dmitrii'                    
                </programlisting>
                </para>
                <para>Если хранимая процедура требует входные параметры, то они должны быть указаны
                    в скобках после имени процедуры:
                    <programlisting language="sql">
SELECT name, az, alt 
FROM visible_stars('Brugge', current_date, '22:30')
WHERE alt >= 20
ORDER BY az, alt                        
                    </programlisting>
                </para>
                <para>Значения для опциональных параметров (то есть, параметров, для которых
                    определены значения по умолчанию) могут быть указаны или опущены. </para>
                <para><emphasis role="italic">Однако если параметры задаются частично, то
                        пропущенные параметры должны быть в конце перечисления внутри
                        скобок.</emphasis></para>
                <para>Если предположить, что процедура visible_stars из предыдущего примера имеет
                    два опциональных параметра spectral_class (varchar(12)) и min_magn
                    (numeric(3,1)), то следующие команды будут корректными:
                    <programlisting language="sql">
SELECT name, az, alt 
FROM visible_stars('Brugge', current_date, '22:30')
 
SELECT name, az, alt 
FROM visible_stars('Brugge', current_date, '22:30', 4.0)                        
                    </programlisting>
                </para>
                <para>А вот этот запрос не будет корректным:
                    <programlisting language="sql">
SELECT name, az, alt 
FROM visible_stars('Brugge', current_date, 4.0)                        
                    </programlisting>
                </para>
                <para>Алиас для селективной хранимой процедуры указывается после списка параметров:
                    <programlisting language="sql">
SELECT 
  number,
  (SELECT name FROM contestants c 
   WHERE c.number = gw.number)
FROM get_winners('#34517', 'AMS') gw                        
                    </programlisting>
                </para>
                <para>Если вы указываете поле (выходной параметр) с полным именем процедуры, не
                    включайте в это имя список параметров процедуры:
                    <programlisting language="sql">
SELECT number,
  (SELECT name FROM contestants c 
   WHERE c.number = get_winners.number)
FROM get_winners('#34517', 'AMS')                        
                    </programlisting>
                </para>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="psql-procedure">Хранимые процедуры</link>, <link
                            linkend="ddl-procedure-create">CREATE PROCEDURE</link>. </para>

                </formalpara>
            </section>

            <section xml:id="dml-select-from-devired_table">

                <title>Выборка из производной таблицы (derived table)</title>

                <para>Производная таблица — это корректная команда SELECT, заключённая в круглые
                    скобки, опционально обозначенная псевдонимом таблицы и псевдонимами полей. </para>

                <formalpara>
                    <title>Синтаксис:</title>

                    <para>
                        <programlisting>
<replaceable>&lt;derived table</replaceable>&gt; ::= (<replaceable>select-query</replaceable>) [[AS] <replaceable>derived-table-alias</replaceable>] [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]       

<replaceable>&lt;derived-column-aliases&gt;</replaceable> := <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]

<replaceable>&lt;lateral-derived-table&gt;</replaceable> ::= LATERAL <replaceable>&lt;derived-table&gt;</replaceable>                                    
                    </programlisting>
                    </para>
                </formalpara>

                <para>Возвращаемый набор данных такого оператора представляет собой виртуальную
                    таблицу, к которой можно составлять запросы, так как будто это обычная таблица. </para>
                <para>Производная таблица в запросе ниже выводит список имён таблиц в базе данных и
                    количество столбцов в них. Запрос к производной таблице выводит количество
                    полей, и количество таблиц с таким количеством полей.
                    <programlisting language="sql">
SELECT
  FIELDCOUNT,
  COUNT(RELATION) AS NUM_TABLES
FROM (SELECT
        R.RDB$RELATION_NAME RELATION,
        COUNT(*) AS FIELDCOUNT
      FROM RDB$RELATIONS R 
        JOIN RDB$RELATION_FIELDS RF 
          ON RF.RDB$RELATION_NAME = R.RDB$RELATION_NAME
      GROUP BY RELATION)
GROUP BY FIELDCOUNT                        
                    </programlisting>
                </para>
                <para>Тривиальный пример, демонстрирующий использование псевдонима производной
                    таблицы и списка псевдонимов столбцов (оба опциональные):
                    <programlisting language="sql">
SELECT
  DBINFO.DESCR, DBINFO.DEF_CHARSET
FROM (SELECT *
      FROM RDB$DATABASE) DBINFO (DESCR, REL_ID, SEC_CLASS, DEF_CHARSET)                        
                    </programlisting>
                </para>
                <note>
                    <title>Примечания:</title>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para>Производные таблицы могут быть вложенными;</para>
                            </listitem>
                            <listitem>
                                <para>Производные таблицы могут быть объединениями и использоваться
                                    в объединениях. Они могут содержать агрегатные функции,
                                    подзапросы и соединения, и сами по себе могут быть использованы
                                    в агрегатных функциях, подзапросах и соединениях. Они также
                                    могут быть хранимыми процедурами или запросами из них. Они могут
                                    иметь предложения WHERE, ORDER BY и GROUP BY, указания FIRST,
                                    SKIP или ROWS и т.д.;</para>
                            </listitem>
                            <listitem>
                                <para>Каждый столбец в производной таблице должен иметь имя. Если
                                    этого нет по своей природе (например, потому что это —
                                    константа), то надо в обычном порядке присвоить псевдоним или
                                    добавить список псевдонимов столбцов в спецификации производной
                                    таблицы;</para>
                            </listitem>
                            <listitem>
                                <para>Список псевдонимов столбцов опциональный, но если он
                                    присутствует, то должен быть полным (т.е. он должен содержать
                                    псевдоним для каждого столбца производной таблицы);</para>
                            </listitem>
                            <listitem>
                                <para>Оптимизатор может обрабатывать производные таблицы очень
                                    эффективно. Однако если производная таблица включена во
                                    внутреннее соединение и содержит подзапрос, то никакой порядок
                                    соединения не может быть использован оптимизатором;</para>
                            </listitem>
                            <listitem>
                                <para>Ключевое слово LATERAL позволяет производной таблице ссылаться
                                    на поля из ранее перечисленных таблиц в текущем
                                        <replaceable>&lt;table reference list&gt;</replaceable>.
                                    Подробнее смотрите в разделе <link
                                        xmlns:xlink="http://www.w3.org/1999/xlink"
                                        xlink:href="#dml-select-joins-lateral">Соединение с LATERAL
                                        производными таблицами</link>.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </note>
                <para>Приведём пример того, как использование производных таблиц может упростить
                    решение некоторой задачи. </para>
                <para>Предположим, что у нас есть таблица COEFFS, которая содержит коэффициенты для
                    ряда квадратных уравнений, которые мы собираемся решить. Она может быть
                    определена примерно так: <programlisting language="sql"><![CDATA[
CREATE TABLE coeffs (
  a DOUBLE PRECISION NOT NULL,
  b DOUBLE PRECISION NOT NULL,
  c DOUBLE PRECISION NOT NULL,
  CONSTRAINT chk_a_not_zero CHECK (a <> 0)
)                        
]]></programlisting>
                </para>
                <para>В зависимости от значений коэффициентов a, b и c, каждое уравнение может иметь
                    ноль, одно или два решения. Мы можем найти эти решения с помощью одноуровневого
                    запроса к таблице COEFFS, однако код такого запроса будет громоздким, а
                    некоторые значения (такие, как дискриминанты) будут вычисляться несколько раз в
                    каждой строке.</para>
                <para>Если использовать производную таблицу, то запрос можно сделать гораздо более
                    элегантным:
                    <programlisting language="sql">
SELECT
  IIF (D >= 0, (-b - sqrt(D)) / denom, NULL) AS sol_1,
  IIF (D > 0, (-b + sqrt(D)) / denom, NULL) AS sol_2
FROM
  (SELECT b, b*b - 4*a*c, 2*a FROM coeffs) (b, D, denom)                   
                    </programlisting></para>
                <para>Если мы захотим показывать коэффициенты рядом с решениями уравнений, то мы
                    можем модифицировать запрос следующим образом:
                    <programlisting language="sql">
SELECT
  a, b, c,
  IIF (D >= 0, (-b - sqrt(D)) / denom, NULL) sol_1,
  IIF (D > 0, (-b + sqrt(D)) / denom, NULL) sol_2
FROM
  (SELECT a, b, c, b*b - 4*a*c AS D, 2*a AS denom
   FROM coeffs)                        
                    </programlisting></para>
                <para>Обратите внимание, что в первом запросе мы назначили алиасы для всех полей
                    производной таблицы в виде списка после таблицы, а во втором, по мере
                    необходимости, добавляем алиасы внутри запроса производной таблицы. Оба этих
                    метода корректны, так как при правильном применении гарантируют, что каждое поле
                    производной таблицы имеет уникальное имя.</para>
                <note>
                    <para>На самом деле все столбцы, вычисляемые в производной таблице, будут
                        перевычислены столько раз, сколько раз они указываются в основном запросе.
                        Это важно может привести к неожиданным результатам при использовании
                        недетерминированных функций. Следующий пример показывает сказанное:
                        <programlisting language="sql">                           
SELECT
    UUID_TO_CHAR(X) AS C1,
    UUID_TO_CHAR(X) AS C2,
    UUID_TO_CHAR(X) AS C3
FROM (SELECT GEN_UUID() AS X
      FROM RDB$DATABASE) T;
                        </programlisting>
                        результатом этого запроса будет
                        <screen>
C1                              80AAECED-65CD-4C2F-90AB-5D548C3C7279
C2                              C1214CD3-423C-406D-B5BD-95BF432ED3E3
C3                              EB176C10-F754-4689-8B84-64B666381154                       
                        </screen>
                    </para>
                    <para>Для материализации результата функции GEN_UUID вы можете воспользоваться
                        следующим способом:
                        <programlisting language="sql">                            
SELECT
    UUID_TO_CHAR(X) AS C1,
    UUID_TO_CHAR(X) AS C2,
    UUID_TO_CHAR(X) AS C3
FROM (SELECT GEN_UUID() AS X
      FROM RDB$DATABASE
      UNION ALL
      SELECT NULL FROM RDB$DATABASE WHERE 1=0) T;
                        </programlisting>
                        результатом этого запроса будет
                        <screen>
C1                              80AAECED-65CD-4C2F-90AB-5D548C3C7279
C2                              80AAECED-65CD-4C2F-90AB-5D548C3C7279
C3                              80AAECED-65CD-4C2F-90AB-5D548C3C7279                       
                        </screen>
                        или завернуть функцию GEN_UUID в подзапрос
                        <programlisting language="sql">                          
SELECT
    UUID_TO_CHAR(X) AS C1,
    UUID_TO_CHAR(X) AS C2,
    UUID_TO_CHAR(X) AS C3
FROM (SELECT
          (SELECT GEN_UUID() FROM RDB$DATABASE) AS X
      FROM RDB$DATABASE) T;
                        </programlisting>
                    </para>
                    <para>Эта особенность текущей реализации и она может быть изменена в следующих
                        версиях сервера.</para>
                </note>
            </section>
            <section xml:id="dml-select-from-cte">

                <title>Выборка из общих табличных выражений (CTE)</title>

                <para>Общие табличные выражения являются более сложной и более мощной вариацией
                    производных таблиц. CTE состоят из преамбулы, начинающейся с ключевого слова
                    WITH, которая определяет одно или более общих табличных выражений (каждое из
                    которых может иметь список алиасов полей). Основной запрос, который следует за
                    преамбулой, может обращаться к CTE так, как будто обычные таблицы. CTE доступны
                    любой части запроса ниже точки своего объявления. </para>
                <para>Подробно CTE описываются в разделе <link linkend="dml-select-cte">Общие
                        табличные выражения CTE (WITH ... AS ... SELECT)</link>, а здесь приведены
                    лишь некоторые примеры использования.</para>
                <para>Следующий запрос представляет наш пример с производной таблицей в варианте для
                    общих табличных выражений: <programlisting language="sql"><![CDATA[
WITH vars (b, D, denom) AS (
  SELECT b, b*b - 4*a*c, 2*a 
  FROM coeffs
)
SELECT
  IIF (D >= 0, (-b - sqrt(D)) / denom, NULL) AS sol_1,
  IIF (D > 0, (-b + sqrt(D)) / denom, NULL) AS sol_2
FROM vars                        
]]></programlisting>
                </para>
                <para>Это не слишком большое улучшение по сравнению с вариантом с производными
                    таблицами (за исключением того, что вычисления проводятся до основного запроса).
                    Мы можем ещё улучшить запрос, исключив двойное вычисление sqrt(D) для каждой
                    строки: <programlisting language="sql"><![CDATA[
WITH vars (b, D, denom) AS (
  SELECT b, b*b - 4*a*c, 2*a 
  FROM coeffs
),
vars2 (b, D, denom, sqrtD) AS (
  SELECT 
    b, D, denom, 
    IIF (D >= 0, sqrt(D), NULL) 
  FROM vars
)
SELECT
  IIF (D >= 0, (-b - sqrtD) / denom, NULL) AS sol_1,
  IIF (D > 0, (-b + sqrtD) / denom, NULL) AS sol_2
FROM vars2                        
]]></programlisting>
                </para>
                <para>Текст запроса выглядит более сложным, но он стал более эффективным
                    (предполагая, что исполнение функции SQRT занимает больше времени, чем передача
                    значений переменных b, d и denom через дополнительное CTE).</para>
                <note>
                    <para>На самом деле все столбцы, вычисляемые в CTE, будут перевычислены столько
                        раз, сколько раз они указываются в основном запросе. Это важно может
                        привести к неожиданным результатам при использовании недетерминированных
                        функций. Следующий пример показывает сказанное:
                        <programlisting language="sql">
WITH T(X)
AS (SELECT GEN_UUID()
    FROM RDB$DATABASE)
SELECT
    UUID_TO_CHAR(X) as c1,
    UUID_TO_CHAR(X) as c2,
    UUID_TO_CHAR(X) as c3
FROM T
                        </programlisting>
                        результатом этого запроса будет
                        <screen>
C1                              80AAECED-65CD-4C2F-90AB-5D548C3C7279
C2                              C1214CD3-423C-406D-B5BD-95BF432ED3E3
C3                              EB176C10-F754-4689-8B84-64B666381154                       
                        </screen>
                    </para>
                    <para>Для материализации результата функции GEN_UUID вы можете воспользоваться
                        следующим способом:
                        <programlisting language="sql">
WITH T(X)
AS (SELECT GEN_UUID()
    FROM RDB$DATABASE
    UNION ALL
    SELECT NULL FROM RDB$DATABASE WHERE 1=0)
SELECT
    UUID_TO_CHAR(X) as c1,
    UUID_TO_CHAR(X) as c2,
    UUID_TO_CHAR(X) as c3
FROM T;
                        </programlisting>
                        результатом этого запроса будет
                        <screen>
C1                              80AAECED-65CD-4C2F-90AB-5D548C3C7279
C2                              80AAECED-65CD-4C2F-90AB-5D548C3C7279
C3                              80AAECED-65CD-4C2F-90AB-5D548C3C7279                       
                        </screen>
                        или завернуть функцию GEN_UUID в подзапрос
                        <programlisting language="sql">                          
WITH T(X)
AS (SELECT (SELECT GEN_UUID() FROM RDB$DATABASE)
    FROM RDB$DATABASE)
SELECT
    UUID_TO_CHAR(X) as c1,
    UUID_TO_CHAR(X) as c2,
    UUID_TO_CHAR(X) as c3
FROM T;
                        </programlisting>
                    </para>
                    <para>Эта особенность текущей реализации и она может быть изменена в следующих
                        версиях сервера.</para>
                </note>
                <para>Конечно, мы могли бы добиться такого результата и с помощью производных
                    таблиц, но это потребовало бы вложить запросы один в другой.</para>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="dml-select-cte">Общие табличные выражения CTE (WITH ... AS
                            ... SELECT)</link>. </para>

                </formalpara>
            </section>
        </section>

        <section xml:id="dml-select-joins">
            <info>
                <title>Соединения (JOINS)</title>
                <keywordset>
                    <keyword>JOIN</keyword>
                    <keyword>INNER</keyword>
                    <keyword>OUTER</keyword>
                    <keyword>LEFT</keyword>
                    <keyword>RIGHT</keyword>
                    <keyword>FULL</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>JOIN</secondary>
            </indexterm>
            <para>Соединения объединяют данные из двух источников в один набор данных. Соединение
                данных осуществляется для каждой строки и обычно включает в себя проверку условия
                соединения (join condition) для того, чтобы определить, какие строки должны быть
                объединены и оказаться в результирующем наборе данных.</para>
            <para>Результат соединения также может быть соединён с другим набором данных с помощью
                следующего соединения.</para>
            <para>Существует несколько типов (INNER, OUTER) и классов (квалифицированные,
                натуральные, и др.) соединений, каждый из которых имеет свой синтаксис и
                правила.</para>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT
...
FROM <replaceable>&lt;source&gt;</replaceable>
[<replaceable>&lt;joins&gt;</replaceable>]
[...] 

<replaceable>&lt;source&gt;</replaceable> ::= {   
    <replaceable>table</replaceable> 
  | <replaceable>view</replaceable>  
  | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)] 
  | <replaceable>derived-table</replaceable>
  | <replaceable>lateral-derived-table</replaceable>
  | <replaceable>common-table-expression</replaceable> 
} [[AS] <replaceable>alias</replaceable>] 

<replaceable>&lt;joins&gt;</replaceable> ::= <replaceable>&lt;join&gt;</replaceable> [<replaceable>&lt;join&gt;</replaceable> ...] 

<replaceable>&lt;join&gt;</replaceable> ::= 
    [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>           
  | NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> 
  | {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable> 

<replaceable>&lt;join-type&gt;</replaceable> ::= INNER | {LEFT | RIGHT | FULL} [OUTER] 

<replaceable>&lt;join-condition&gt;</replaceable> ::= ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)

                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложения JOIN</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>table</replaceable></entry>
                                <entry>
                                    <para>Таблица.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>view</replaceable></entry>
                                <entry>
                                    <para>Представление.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>selectable-stored-procedure</replaceable></entry>
                                <entry>
                                    <para>Селективная хранимая процедура.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>args</replaceable></entry>
                                <entry>
                                    <para>Аргументы селективной хранимой процедуры.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>derived-table</replaceable></entry>
                                <entry>
                                    <para>Производная таблица.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>common-table-expression</replaceable></entry>
                                <entry>
                                    <para>Общее табличное выражение (CTE).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>alias</replaceable></entry>
                                <entry>
                                    <para>Псевдоним (алиас) для одного из источников данных
                                        (таблицы, представления, процедуры, CTE, производной
                                        таблицы).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>condition</replaceable></entry>
                                <entry>
                                    <para>Условие соединения.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>column-list</replaceable></entry>
                                <entry>
                                    <para>Список столбцов по которым происходит
                                        эквисоединение.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <section xml:id="dml-select-joins-inner_and_outer">
                <title>Внутренние (INNER) и внешние (OUTER) соединения</title>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>JOIN</secondary>
                    <tertiary>INNER JOIN</tertiary>
                </indexterm>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>JOIN</secondary>
                    <tertiary>LEFT [OUTER] JOIN</tertiary>
                </indexterm>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>JOIN</secondary>
                    <tertiary>RIGHGT [OUTER] JOIN</tertiary>
                </indexterm>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>JOIN</secondary>
                    <tertiary>FULL [OUTER] JOIN</tertiary>
                </indexterm>
                <para>Соединение всегда соединяет строки из двух наборов данных (которые обычно
                    называются <quote>левый</quote> и <quote>правый</quote>). По умолчанию, только
                    строки, которые удовлетворяет условию соединения (те, которым соответствует хотя
                    бы одна строка из другого набора строк согласно применяемому условию) попадают в
                    результирующий набор данных. Такой тип соединения (который является типом по
                    умолчанию) называется внутренним (INNER JOIN).</para>
                <para>Предположим, у нас есть 2 таблицы:</para>
                <para>Таблица А: <informaltable frame="all">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                            <thead>
                                <row>
                                    <entry>ID</entry>
                                    <entry>S</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>87</entry>
                                    <entry>Just some text</entry>
                                </row>
                                <row>
                                    <entry>35</entry>
                                    <entry>Silence</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable></para>
                <para>Таблица B: <informaltable frame="all">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                            <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                            <thead>
                                <row>
                                    <entry>CODE</entry>
                                    <entry>X</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>-23</entry>
                                    <entry>56.7735</entry>
                                </row>
                                <row>
                                    <entry>87</entry>
                                    <entry>416.0</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable></para>
                <para>Если мы соединим эти таблицы с помощью вот такого запроса:
                    <programlisting language="sql">
SELECT *
FROM A
JOIN B ON A.id = B.code                        
                    </programlisting>
                    то результат будет:<informaltable frame="all">
                        <tgroup cols="4">
                            <colspec colname="c1" colnum="1" colwidth="0.5*"/>
                            <colspec colname="c2" colnum="2" colwidth="0.5*"/>
                            <colspec colname="c3" colnum="3" colwidth="0.5*"/>
                            <colspec colname="c4" colnum="4" colwidth="0.5*"/>
                            <thead>
                                <row>
                                    <entry>ID</entry>
                                    <entry>S</entry>
                                    <entry>CODE</entry>
                                    <entry>X</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>87</entry>
                                    <entry>Just some text</entry>
                                    <entry>87</entry>
                                    <entry>416.0</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para>То есть, первая строка таблицы А была соединена со второй строкой таблицы B,
                    потому что вместе они удовлетворяют условию соединения &quot;A.id =
                    B.code&quot;. Другие строки не имеют соответствия и поэтому не включаются в
                    соединение. Помните, что умолчанию соединение всегда внутреннее (INNER).</para>
                <para>Мы можем сделать это явным, указав тип соединения:
                    <programlisting language="sql">
SELECT *
FROM A
INNER JOIN B ON A.id = B.code                        
                    </programlisting>
                    но обычно слово INNER опускается. </para>
                <para>Разумеется, возможны случаи, когда строке в левом наборе данных соответствует
                    несколько строк в правом наборе данных (или наоборот).</para>
                <para>В таких случаях все комбинации включаются в результирующих набор данных, и мы
                    можем получить результат вроде этого:<informaltable frame="all">
                        <tgroup cols="4">
                            <colspec colname="c1" colnum="1" colwidth="0.5*"/>
                            <colspec colname="c2" colnum="2" colwidth="0.5*"/>
                            <colspec colname="c3" colnum="3" colwidth="0.5*"/>
                            <colspec colname="c4" colnum="4" colwidth="0.5*"/>
                            <thead>
                                <row>
                                    <entry>ID</entry>
                                    <entry>S</entry>
                                    <entry>CODE</entry>
                                    <entry>X</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>87</entry>
                                    <entry>Just some text</entry>
                                    <entry>87</entry>
                                    <entry>416.0</entry>
                                </row>
                                <row>
                                    <entry>87</entry>
                                    <entry>Just some text</entry>
                                    <entry>87</entry>
                                    <entry>-1.0</entry>
                                </row>
                                <row>
                                    <entry>-23</entry>
                                    <entry>Don't know</entry>
                                    <entry>-23</entry>
                                    <entry>56.7735</entry>
                                </row>
                                <row>
                                    <entry>-23</entry>
                                    <entry>Still don't know</entry>
                                    <entry>-23</entry>
                                    <entry>56.7735</entry>
                                </row>
                                <row>
                                    <entry>-23</entry>
                                    <entry>I give up</entry>
                                    <entry>-23</entry>
                                    <entry>56.7735</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para>Иногда необходимо включить в результат все записи из левого или правого набора
                    данных, вне зависимости от того, есть ли для них соответствующая запись в парном
                    наборе данных. В этом случае необходимо использовать внешние соединения. </para>
                <para>Внешнее левое соединение (LEFT OUTER) включает все записи из левого набора
                    данных, и те записи из правого набора, которые удовлетворяют условию
                    соединения.</para>
                <para>Внешнее правое соединение (RIGHT OUTER) включает все записи из правого набора
                    данных и те записи из левого набора данных, которые удовлетворяют условию
                    соединения.</para>
                <para>Полное внешнее соединение (FULL OUTER) включает все записи из обоих наборов
                    данных.</para>
                <para>Во всех внешних соединениях, &quot;дыры&quot; (то есть поля набора данных, в
                    которых нет соответствующей записи) заполняются NULL.</para>
                <para>Для обозначения внешнего соединения используются ключевые слова LEFT, RIGHT
                    или FULL с необязательным ключевым словом OUTER.</para>
                <para>Рассмотрим различные внешние соединения на примере запросов с указанными выше
                    таблицами A и B:
                    <programlisting language="sql">
SELECT *
FROM A
LEFT OUTER JOIN B ON A.id = B.code                        
                    </programlisting>
                    то же самое <programlisting language="sql">
SELECT *
FROM A
LEFT JOIN B ON A.id = B.code                        
                    </programlisting>
                    <informaltable frame="all">
                        <tgroup cols="4">
                            <colspec colname="c1" colnum="1" colwidth="0.5*"/>
                            <colspec colname="c2" colnum="2" colwidth="0.5*"/>
                            <colspec colname="c3" colnum="3" colwidth="0.5*"/>
                            <colspec colname="c4" colnum="4" colwidth="0.5*"/>
                            <thead>
                                <row>
                                    <entry>ID</entry>
                                    <entry>S</entry>
                                    <entry>CODE</entry>
                                    <entry>X</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>87</entry>
                                    <entry>Just some text</entry>
                                    <entry>87</entry>
                                    <entry>416.0</entry>
                                </row>
                                <row>
                                    <entry>235</entry>
                                    <entry>Silence</entry>
                                    <entry>&lt;null></entry>
                                    <entry>&lt;null></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <programlisting language="sql">
SELECT *
FROM A
RIGHT OUTER JOIN B ON A.id = B.code                        
                    </programlisting>
                    то же самое <programlisting language="sql">
SELECT *
FROM A
RIGHT JOIN B ON A.id = B.code                        
                    </programlisting>
                    <informaltable frame="all">
                        <tgroup cols="4">
                            <colspec colname="c1" colnum="1" colwidth="0.5*"/>
                            <colspec colname="c2" colnum="2" colwidth="0.5*"/>
                            <colspec colname="c3" colnum="3" colwidth="0.5*"/>
                            <colspec colname="c4" colnum="4" colwidth="0.5*"/>
                            <thead>
                                <row>
                                    <entry>ID</entry>
                                    <entry>S</entry>
                                    <entry>CODE</entry>
                                    <entry>X</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>&lt;null></entry>
                                    <entry>&lt;null></entry>
                                    <entry>-23</entry>
                                    <entry>56.7735</entry>
                                </row>
                                <row>
                                    <entry>87</entry>
                                    <entry>Just some text</entry>
                                    <entry>87</entry>
                                    <entry>416.0</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                    <programlisting language="sql">
SELECT *
FROM A
FULL OUTER JOIN B ON A.id = B.code                        
                    </programlisting>
                    то же самое <programlisting language="sql">
SELECT *
FROM A
FULL JOIN B ON A.id = B.code                        
                    </programlisting>
                    <informaltable frame="all">
                        <tgroup cols="4">
                            <colspec colname="c1" colnum="1" colwidth="0.5*"/>
                            <colspec colname="c2" colnum="2" colwidth="0.5*"/>
                            <colspec colname="c3" colnum="3" colwidth="0.5*"/>
                            <colspec colname="c4" colnum="4" colwidth="0.5*"/>
                            <thead>
                                <row>
                                    <entry>ID</entry>
                                    <entry>S</entry>
                                    <entry>CODE</entry>
                                    <entry>X</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>&lt;null></entry>
                                    <entry>&lt;null></entry>
                                    <entry>-23</entry>
                                    <entry>56.7735</entry>
                                </row>
                                <row>
                                    <entry>87</entry>
                                    <entry>Just some text</entry>
                                    <entry>87</entry>
                                    <entry>416.0</entry>
                                </row>
                                <row>
                                    <entry>235</entry>
                                    <entry>Silence</entry>
                                    <entry>&lt;null></entry>
                                    <entry>&lt;null></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </section>
            <section xml:id="dml-select-joins-qualified">
                <title>Обычные соединения</title>
                <para>Явный синтаксис соединения требует указания условия соединения записей. Это
                    условие указывается явно в предложении ON или неявно при помощи предложения
                    USING. </para>
                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting> 
<replaceable>&lt;qualified-join&gt;</replaceable> ::= [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>       

<replaceable>&lt;join-type&gt;</replaceable> ::= INNER | {LEFT | RIGHT | FULL} [OUTER]       

<replaceable>&lt;join-condition&gt;</replaceable> ::= ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)    
                    </programlisting>
                    </para>
                </formalpara>
                <section xml:id="dml-select-joins-qualified-explicit_cond">
                    <info>
                        <title>Соединения с явными условиями</title>
                        <keywordset>
                            <keyword>ON</keyword>
                        </keywordset>
                    </info>
                    <para>В синтаксисе явного соединения есть предложение ON, с условием соединения,
                        в котором может быть указано любое логическое выражение, но, как правило,
                        оно содержит условие сравнения между двумя участвующими источниками. </para>
                    <para>Довольно часто, это условие — проверка на равенство (или ряд проверок на
                        равенство объединённых оператором AND) использующая оператор "=". Такие
                        соединения называются эквисоединениями. (Примеры в главе Внутренние (INNER)
                        и внешние (OUTER) соединения были эквисоединениями).</para>
                    <para>Примеры соединений с явными условиями:
                        <programlisting language="sql">
/*
 * Выборка всех заказчиков из города Детройт, которые
 * сделали покупку.
 */
SELECT * 
FROM customers c
JOIN sales s ON s.cust_id = c.id
WHERE c.city = 'Detroit'
 
/* 
 * Тоже самое, но включает в выборку заказчиков, которые 
 * не совершали покупки.
 */
SELECT * 
FROM customers c
LEFT JOIN sales s ON s.cust_id = c.id
WHERE c.city = 'Detroit'
 
/* 
 * Для каждого мужчины выбрать женщин, которые выше него.
 * Мужчины, для которых такой женщины не существуют, 
 * не будут выключены в выборку. 
 */
SELECT 
    m.fullname AS man, 
    f.fullname AS woman
FROM males m
JOIN females f ON f.height > m.height
 
/* 
 * Выборка всех учеников, их класса и наставника.
 * Ученики без наставника буду включены в выборку.
 * Ученики без класса не будут включены в выборку. 
 */
SELECT 
    p.firstname, 
    p.middlename, 
    p.lastname,
    c.name, 
    m.name
FROM pupils p
JOIN classes c ON c.id = p.class
LEFT JOIN mentors m ON m.id = p.mentor                    
                </programlisting>
                    </para>
                </section>
                <section xml:id="dml-select-joins-qualified-named_columns">
                    <info>
                        <title>Соединения именованными столбцами</title>
                        <keywordset>
                            <keyword>USING</keyword>
                        </keywordset>
                    </info>

                    <para>Эквисоединения часто сравнивают столбцы, которые имеют одно и то же имя в
                        обеих таблицах. Для таких соединений мы можем использовать второй тип явных
                        соединений, называемый соединением именованными столбцами (Named Columns
                        Joins). Соединение именованными столбцами осуществляются с помощью
                        предложения USING, в котором перечисляются только имена столбцов.</para>
                    <note>
                        <para> Соединения именованными столбцами доступны только в диалекте 3.
                        </para>
                    </note>
                    <para> Таким образом, следующий пример:
                        <programlisting language="sql">
SELECT * 
FROM flotsam f
  JOIN jetsam j 
    ON f.sea = j.sea AND f.ship = j.ship
                    </programlisting>
                        можно переписать так:
                        <programlisting language="sql">
SELECT * 
FROM flotsam
JOIN jetsam USING (sea, ship)
                    </programlisting>
                        что значительно короче. Результирующий набор несколько отличается, по
                        крайней мере, при использовании "SELECT *":<itemizedlist spacing="compact">
                            <listitem>
                                <para>Результат соединения с явным условием соединения в предложении
                                    ON будет содержать каждый из столбцов SEA и SHIP дважды: один
                                    раз для таблицы FLOTSAM и один раз для таблицы JETSAM. Очевидно,
                                    что они будут иметь они и те же значения;</para>
                            </listitem>
                            <listitem>
                                <para>Результат соединения именованными столбцами, с помощью
                                    предложения USING, будет содержать эти столбцы один раз.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>Если вы хотите получить в результате соединения именованными столбцами все
                        столбцы, перепишите запрос следующим образом:
                        <programlisting language="sql">
SELECT f.*, j.*
FROM flotsam f
JOIN jetsam j USING (sea, ship)
                    </programlisting>
                    </para>
                    <para>Для внешних (OUTER) соединений именованными столбцами, существуют
                        дополнительные нюансы, при использовании "SELECT *" или неполного имени
                        столбца. Если столбец строки из одного источника не имеет совпадений со
                        столбцом строки из другого источника, но все равно должен быть включён
                        результат из-за инструкций LEFT, RIGHT или FULL, то объединяемый столбец
                        получит не NULL значение. Это достаточно справедливо, но теперь вы не можете
                        сказать из какого набора левого, правого или обоих пришло это значение. Это
                        особенно обманывает, когда значения пришли из правой части набора данных,
                        потому что "*" всегда отображает для комбинированных столбцов значения из
                        левой части набора данных, даже если используется RIGHT соединение. </para>
                    <para>Является ли это проблемой, зависит от ситуации. Если это так, используйте
                        "f.*, j.*" подход, продемонстрированный выше, где f и j имена или алиасы
                        двух источников. Или лучше вообще избегать "*" в серьёзных запросах и
                        перечислять все имена столбцов для соединяемых множеств. Такой подход имеет
                        дополнительное преимущество, заставляя вас думать, о том какие данные вы
                        хотите получить и откуда.</para>
                    <para>Вся ответственность за совместимость типов столбцов между соединяемыми
                        источниками, имена которых перечислены в предложении USING, лежит на вас. 
                        Если типы совместимы, но не равны, то Firebird преобразует их в тип с более
                        широким диапазоном значений перед сравнением. Кроме того, это будет типом
                        данных объединённого столбца, который появится в результирующем наборе, если
                        используются "SELECT *" или неполное имя столбца. Полные имена столбцов
                        всегда будут сохранять свой первоначальный тип данных.</para>
                    <tip>
                        <para>Если при соединении именованными столбцами вы используете столбцы
                            соединения в условии отбора WHERE, то всегда используйте уточнённые
                            имена столбцов. В противном случае индекс по этому столбцу не будет
                            задействован.
                            <programlisting language="sql">
SELECT 1 FROM t1 a JOIN t2 b USING(x) WHERE x = 0;
PLAN JOIN (A NATURAL, B INDEX (RDB$2))
                    </programlisting>
                            однако
                            <programlisting language="sql">
SELECT 1 FROM t1 a JOIN t2 b USING(x) WHERE a.x = 0; -- или 'b.x'
PLAN JOIN (A INDEX (RDB$1), B INDEX (RDB$2))

SELECT 1 FROM t1 a JOIN t2 b USING(x) WHERE b.x = 0;
PLAN JOIN (A INDEX (RDB$1), B INDEX (RDB$2))
                    </programlisting>
                            Дело в том, неуточнённый столбец в данном случае неявно заменяется на
                                <command>COALESCE(a.x, b.x)</command>. Этот хитрый трюк применяется
                            для устранения неоднозначности имён столбцов, но он же мешает применению
                            индекса. </para>
                    </tip>
                </section>
            </section>
            <section xml:id="dml-select-joins-natural">
                <info>
                    <title>Естественные соединения (Natural Joins)</title>
                    <keywordset>
                        <keyword>NATURAL</keyword>
                    </keywordset>
                </info>

                <para>Взяв за основу соединения именованными столбцами, следующим шагом будет
                    естественное соединение, которое выполняет эквисоединение по всем одноименным
                    столбцам правой и левой таблицы. Типы данных этих столбцов должны быть
                    совместимыми.</para>
                <note>
                    <para> Естественные соединения доступны только в диалекте 3. </para>
                </note>
                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
<replaceable>&lt;natural-join&gt;</replaceable> ::= NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>       

<replaceable>&lt;join-type&gt;</replaceable> ::= INNER | {LEFT | RIGHT | FULL} [OUTER]    
                    </programlisting>
                    </para>
                </formalpara>
                <para>Даны две таблицы:
                    <programlisting language="sql">
CREATE TABLE TA (
    a BIGINT,
    s VARCHAR(12),
    ins_date DATE
);
 
CREATE TABLE TB (
    a BIGINT,
    descr VARCHAR(12),
    x FLOAT,
    ins_date DATE
);   
                    </programlisting>
                </para>
                <para>Естественное соединение таблиц TA и TB будет происходить по столбцам a и
                    ins_date и два следующих оператора дадут один и тот же результат:
                    <programlisting language="sql">
SELECT * 
FROM TA
NATURAL JOIN TB;
 
SELECT * 
FROM TA
JOIN TB USING (a, ins_date);
                    </programlisting>
                </para>
                <para>Как и все соединения, естественные соединения являются внутренними
                    соединениями по умолчанию, но вы можете превратить их во внешние соединения,
                    указав LEFT, RIGHT или FULL перед ключевым словом JOIN.</para>
                <important>
                    <title>Внимание</title>
                    <para>Если в двух исходных таблицах не будут найдены одноименные столбцы, то
                        будет выполнен CROSS JOIN.</para>
                </important>
            </section>
            <section xml:id="dml-select-joins-implicit">
                <title>Неявные соединения</title>
                <para>В стандарте SQL-89 таблицы, участвующие в соединении, задаются списком с
                    разделяющими запятыми в предложении FROM. Условия соединения задаются в
                    предложении WHERE среди других условий поиска. Такие соединения называются
                    неявными. </para>
                <para>Синтаксис неявного соединения может осуществлять только внутренние
                    соединения.</para>
                <para>Пример неявного соединения:
                    <programlisting language="sql">
/*
 * Выборка всех заказчиков из города Детройт, которые
 * сделали покупку.
 */
SELECT * 
FROM customers c, sales s
WHERE s.cust_id = c.id AND c.city = 'Detroit'                        
                    </programlisting>
                </para>
                <important>
                    <para>В настоящее время синтаксис неявных соединений не рекомендуется к
                        использованию.</para>
                </important>
            </section>
            <section xml:id="dml-select-joins-implicit-mix">
                <title>Смешивание явного и неявного соединения</title>
                <para>Смешивание явных и неявных соединений не рекомендуется, но позволяется.
                    Некоторые виды смешивания запрещены в Firebird.</para>
                <para>Например, такой запрос вызовет ошибку "Column does not belong to referenced
                    table"
                    <programlisting language="sql">
SELECT *
FROM
TA, TB
JOIN TC ON TA.COL1 = TC.COL1
WHERE TA.COL2 = TB.COL2                       
                    </programlisting>
                    Это происходит потому, что явный JOIN не может видеть таблицу TA. Однако
                    следующий запрос будет выполнен без ошибок, поскольку изоляция не нарушена.
                    <programlisting language="sql">
SELECT *
FROM
TA, TB
JOIN TC ON TB.COL1 = TC.COL1
WHERE TA.COL2 = TB.COL2                     
                    </programlisting>
                </para>
            </section>
            <section xml:id="dml-select-joins-cross">
                <info>
                    <title>Перекрёстное соединение (CROSS JOIN)</title>
                    <keywordset>
                        <keyword>CROSS JOIN</keyword>
                    </keywordset>
                </info>

                <para>Перекрёстное соединение или декартово произведение. Каждая строка левой
                    таблицы соединяется с каждой строкой правой таблицы.</para>

                <formalpara>
                    <title>Синтаксис:</title>
                    <para>
                        <programlisting>
<replaceable>&lt;cross-join&gt;</replaceable> ::= {CROSS JOIN | , } <replaceable>&lt;source&gt;</replaceable>       
                    </programlisting>
                    </para>
                </formalpara>
                <para>Обратите внимание, что синтаксис с использованием запятой является устаревшим.
                    Он поддерживается только для поддержания работоспособности унаследованного
                    программного кода и может быть удалён в будущих версиях. </para>
                <para>Перекрёстное соединение двух наборов эквивалентно их соединению по условию
                    тавтологии (условие, которое всегда верно).</para>
                <para>Следующие два запроса дадут один и тот же результат:
                    <programlisting language="sql">
SELECT * 
FROM TA
CROSS JOIN TB;
 
SELECT * 
FROM TA
JOIN TB ON 1 = 1;
                    </programlisting>
                </para>

                <para>Перекрёстные соединения являются внутренними соединениями, потому что они
                    отбирают строки, для которых есть соответствие — так уж случилось, что каждая
                    строка соответствует! Внешнее перекрёстное соединение, если бы оно существовало,
                    ничего не добавило бы к результату, потому что внешние соединения добавляют
                    записи, по которым нет соответствия, а они не существуют в перекрёстном
                    соединении. </para>

                <para>Перекрёстные соединения редко полезны, кроме случаев, когда вы хотите получить
                    список всех возможных комбинаций двух или более переменных. Предположим, вы
                    продаёте продукт, который поставляется в различных размерах, различных цветов и
                    из различных материалов. Если для каждой переменной значения перечислены в
                    собственной таблице, то этот запрос будет возвращать все комбинации:
                    <programlisting language="sql">
SELECT 
    m.name, 
    s.size, 
    c.name
FROM materials m
CROSS JOIN sizes s
CROSS JOIN colors c
                    </programlisting>
                </para>
            </section>

            <section xml:id="dml-select-joins-ambiguous">
                <title>Неоднозначные имена полей в соединениях</title>
                <para>Firebird отвергает неполные имена полей в запросе, если эти имена полей
                    существуют в более чем одном наборе данных, участвующих в объединении. Это также
                    верно для внутренних эквисоединений, в которых имена полей фигурируют в
                    предложении ON:
                    <programlisting language="sql">
SELECT a, b, c
FROM TA
JOIN TB ON TA.a = TB.a
                    </programlisting>
                </para>
                <para>Существует одно исключение из этого правила: соединения по именованным
                    столбцам и естественные соединения, которые используют неполное имя поля в
                    процессе подбора, могут использоваться законно. Это же относится и к одноименным
                    объединяемым столбцам. Для соединений по именованным столбцам эти столбцы должны
                    быть перечислены в предложении USING. Для естественных соединений это столбцы,
                    имена которых присутствуют в обеих таблицах. Но снова замечу, что, особенно во
                    внешних соединениях, плоское имя  colname является не всегда тем же самым что
                    left.colname или right.colname. Типы данных могут отличаться, и один из полных
                    столбцов может иметь значение NULL, в то время как другой нет. В этом случае
                    значение в объединённом, неполном столбце может замаскировать тот факт, что одно
                    из исходных значений отсутствует.  </para>
            </section>
            <section xml:id="dml-select-joins-sp">
                <title>Соединения с хранимыми процедурами</title>

                <para>Если соединение происходит с хранимой процедурой, которая не коррелирована с
                    другими потоками данных через входные параметры, то нет никаких особенностей. </para>
                <para>В противном случае, есть одна особенность: потоки, используемые во входных
                    параметрах, должны быть описаны раньше соединения с хранимой процедурой:
                    <programlisting language="sql">
SELECT *
FROM MY_TAB
JOIN MY_PROC(MY_TAB.F) ON 1 = 1
                    </programlisting>
                    Запрос же написанный следующим образом вызовет ошибку
                    <programlisting language="sql">
SELECT *
FROM MY_PROC(MY_TAB.F)
JOIN MY_TAB ON 1 = 1
                    </programlisting>
                </para>
            </section>
            <section xml:id="dml-select-joins-lateral">
                <info>
                    <title>Соединения с LATERAL производными таблицами</title>
                    <keywordset>
                        <keyword>LATERAL</keyword>
                    </keywordset>
                </info>
                <indexterm>
                    <primary>LATERAL</primary>
                </indexterm>

                <para>Если перед производной таблицей указать ключевое слово LATERAL, то это
                    позволит ссылаться в них на столбцы предшествующих элементов из списка FROM. Без
                    LATERAL каждый подзапрос выполняется независимо и поэтому не может обращаться к
                    другим элементам FROM.</para>

                <para>Элемент LATERAL может находиться на верхнем уровне списка FROM или в дереве
                    JOIN. В последнем случае он может также ссылаться на любые элементы в левой
                    части JOIN, справа от которого он находится.</para>

                <para>Когда элемент FROM содержит ссылки LATERAL, то запрос выполняется следующим
                    образом: сначала вычисляется значения всех столбцов о которых зависит
                    производная таблица с ключевым словом LATERAL, затем вычисляется сама
                    производная таблица с LATERAL для каждой полученной записи. Результирующие
                    строки полученные из производной таблицы c LATERAL соединяются со строками из
                    которых они получены.</para>

                <para>В качестве соединений допускается следующие CROSS JOIN и LEFT OUTER JOIN.
                    Внутреннее соединение также допустимо, но не рекомендуется, поскольку могут
                    возникнуть проблемы при вычислении условия соединения потоков.</para>

                <para>В качестве примера выведем результаты лошадей и их последние промеры. Если у
                    лошади нет ни одного промера, то она не будет выведена:
                    <programlisting language="sql">
SELECT
    HORSE.NAME,
    M.BYDATE,
    M.HEIGHT_HORSE,
    M.LENGTH_HORSE
FROM HORSE
CROSS JOIN LATERAL(SELECT
                       *
                   FROM MEASURE
                   WHERE MEASURE.CODE_HORSE = HORSE.CODE_HORSE
                   ORDER BY MEASURE.BYDATE DESC
                   FETCH FIRST ROW ONLY) M                    
                </programlisting>
                    другой вариант написание этого запроса
                    <programlisting language="sql">
SELECT
    HORSE.NAME,
    M.BYDATE,
    M.HEIGHT_HORSE,
    M.LENGTH_HORSE
FROM HORSE,
     LATERAL(SELECT
                       *
                   FROM MEASURE
                   WHERE MEASURE.CODE_HORSE = HORSE.CODE_HORSE
                   ORDER BY MEASURE.BYDATE DESC
                   FETCH FIRST ROW ONLY) M                    
                </programlisting>
                </para>
                <para>Если необходимо выводить лошадей, не зависимо есть ли у них хотя бы один
                    промер, то необходимо заменить CROSS JOIN на LEFT JOIN:
                    <programlisting language="sql">
SELECT
    HORSE.NAME,
    M.BYDATE,
    M.HEIGHT_HORSE,
    M.LENGTH_HORSE
FROM HORSE
LEFT JOIN LATERAL(SELECT
                       *
                   FROM MEASURE
                   WHERE MEASURE.CODE_HORSE = HORSE.CODE_HORSE
                   ORDER BY MEASURE.BYDATE DESC
                   FETCH FIRST ROW ONLY) M ON TRUE                    
                </programlisting>
                </para>
            </section>
        </section>
        <section xml:id="dml-select-where">
            <info>
                <title>WHERE</title>
                <keywordset>
                    <keyword>WHERE</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>WHERE</secondary>
            </indexterm>

            <para>Предложение WHERE предназначено для ограничения количества возвращаемых строк,
                теми которые нас интересуют. Условие после ключевого слова WHERE может быть простым,
                как проверка "AMOUNT = 3", так и сложным, запутанным выражением, содержащим
                подзапросы, предикаты, вызовы функций, математические и логические операторы,
                контекстные переменные и многое другое. </para>
            <para>Условие в предложении WHERE часто называют условием поиска, выражением поиска или
                просто поиск.</para>
            <para>В DSQL и ESQL, выражение поиска могут содержать параметры. Это полезно, если
                запрос должен быть повторен несколько раз с разными значениями входных параметров. В
                строке SQL запроса, передаваемого на сервер, вопросительные знаки используются как
                заполнители для параметров. Их называют позиционными параметрами, потому что они не
                могут сказать ничего кроме как о позиции в строке. Библиотеки доступа часто
                поддерживают именованные параметры в виде :<replaceable>id</replaceable>,
                    :<replaceable>amount</replaceable>, :<replaceable>a</replaceable> и т.д. Это
                более удобно для пользователя, библиотека заботится о трансляции именованных
                параметров в позиционные параметры, прежде чем передать запрос на сервер.</para>
            <para>Условие поиска может также содержать локальные (PSQL) или хост (ESQL) имена
                переменных, предваряемых двоеточием.</para>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT ... 
FROM ... 
[...] 
WHERE <replaceable>&lt;search-condition&gt;</replaceable> 
[...]    
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложения WHERE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>search-condition</replaceable></entry>
                                <entry>
                                    <para>Логическое выражение возвращающее TRUE, FALSE и возможно
                                        UNKNOWN (NULL).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Только те строки, для которых условие поиска истинно будут включены в
                результирующий набор. Будьте осторожны с возможными получаемыми значениями NULL:
                если вы отрицаете выражение, дающее NULL с помощью NOT, то результат такого
                выражения все равно будет NULL и строка не пройдёт. Это демонстрируется в одном из
                ниже приведённых примеров.</para>
            <bridgehead renderas="sect4">Примеры</bridgehead>
            <para>
                <programlisting language="sql"><![CDATA[
SELECT genus, species 
FROM mammals
WHERE family = 'Felidae'
ORDER BY genus;
 
SELECT * 
FROM persons
WHERE birthyear IN (1880, 1881)
   OR birthyear BETWEEN 1891 AND 1898;
 
SELECT name, street, borough, phone
FROM schools s
WHERE EXISTS (SELECT * FROM pupils p WHERE p.school = s.id)
ORDER BY borough, street;
 
SELECT * 
FROM employees
WHERE salary >= 10000 AND position <> 'Manager';
 
SELECT name 
FROM wrestlers
WHERE region = 'Europe'
  AND weight > ALL (SELECT weight FROM shot_putters
                    WHERE region = 'Africa');
 
SELECT id, name 
FROM players
WHERE team_id = (SELECT id FROM teams 
                 WHERE name = 'Buffaloes');
 
SELECT SUM (population) 
FROM towns
WHERE name LIKE '%dam'
  AND province CONTAINING 'land';
 
SELECT pass 
FROM usertable
WHERE username = current_user;                      
]]></programlisting>
            </para>
            <para>Следующий пример показывает, что может быть, если условие поиска вычисляется как
                NULL.</para>
            <para>Предположим у вас есть таблица, в которой находятся несколько детских имён и
                количество шариков, которыми они обладают. </para>
            <para>
                <informaltable frame="all">
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="0.5*"/>
                        <colspec colname="c2" colnum="2" colwidth="0.5*"/>
                        <thead>
                            <row>
                                <entry>CHILD</entry>
                                <entry>MARBLES</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Anita</entry>
                                <entry>23</entry>
                            </row>
                            <row>
                                <entry>Bob E. </entry>
                                <entry>12</entry>
                            </row>
                            <row>
                                <entry>Chris </entry>
                                <entry>&lt;null&gt;</entry>
                            </row>
                            <row>
                                <entry>Deirdre </entry>
                                <entry>1</entry>
                            </row>
                            <row>
                                <entry>Eve </entry>
                                <entry>17</entry>
                            </row>
                            <row>
                                <entry>Fritz </entry>
                                <entry>0</entry>
                            </row>
                            <row>
                                <entry>Gerry </entry>
                                <entry>21</entry>
                            </row>
                            <row>
                                <entry>Hadassah </entry>
                                <entry>&lt;null></entry>
                            </row>
                            <row>
                                <entry>Isaac </entry>
                                <entry>6</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>Первое, обратите внимание на разницу между NULL и 0. Известно, что Fritz не имеет
                шариков вовсе, однако неизвестно количество шариков у Chris и Hadassah.</para>
            <para> Теперь, если ввести этот SQL оператор:
                <programlisting language="sql">
SELECT LIST(child) FROM marbletable WHERE marbles &gt; 10
                    </programlisting>
                вы получите имена Anita, Bob E., Eve и Gerry. Все эти дети имеют более чем 10
                шариков. </para>
            <para>Если вы отрицаете выражение:
                <programlisting language="sql">
SELECT LIST(child) FROM marbletable WHERE NOT marbles &gt; 10
                    </programlisting>
                запрос вернёт Deirdre, Fritz и Isaac. Chris и Hadassah не будут включены в выборку,
                так как не известно 10 у них шариков или меньше. Если вы измените последний запрос
                так:
                <programlisting language="sql">
SELECT LIST(child) FROM  marbletable WHERE marbles &lt;= 100
                    </programlisting>
                результат будет тем же самым, поскольку выражение NULL &lt;= 10 даёт UNKNOWN. Это не
                то же самое что TRUE, поэтому Chris и Hadassah не отображены. Если вы хотите что бы
                в списке были перечислены все "бедные" дети, то измените запрос следующим образом:
                <programlisting language="sql">
SELECT LIST(child) 
FROM marbletable 
WHERE marbles &lt;= 10 OR marbles IS NULL
                    </programlisting>
            </para>
            <para>Теперь условие поиска становится истинным для Chris и Hadassah, потому что условие
                "marbles is null" возвращает TRUE в этом случае. Фактически, условие поиска не может
                быть NULL ни для одного из них.</para>
            <para>Наконец, следующие два примера SELECT запросов с параметрами в условии поиска. Как
                определяются параметры запроса и возможно ли это, зависит от приложения. Обратите
                внимание, что запросы подобные этим не могут быть выполнены немедленно, они должны
                быть предварительно подготовлены. После того как параметризированный запрос был
                подготовлен, пользователь (или вызывающий код) может подставить значения параметров
                и выполнить его многократно, подставляя перед каждым вызовом новые значения
                параметров. Как вводятся значения параметров, и проходят ли они предобработку
                зависит от приложения. В GUI средах пользователь, как правило, вводит значения
                параметров через одно и более текстовых полей, и щелкает на кнопку "Execute", "Run"
                или "Refresh".
                <programlisting language="sql">
SELECT name, address, phone 
FROM stores
WHERE city = ? AND class = ?
 
SELECT * 
FROM pants
WHERE model = :model AND size = :size AND color = :col
                    </programlisting>
            </para>
            <para>Последний запрос не может быть передан непосредственно к движку сервера,
                приложение должно преобразовать его в другой формат, отображая именованные параметры
                на позиционные параметры.</para>
        </section>
        <section xml:id="dml-select-groupby">
            <info>
                <title>GROUP BY</title>
                <keywordset>
                    <keyword>GROUP BY</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>GROUP BY</secondary>
            </indexterm>

            <para>Предложение GROUP BY соединяет записи, имеющие одинаковую комбинацию значений
                полей, указанных в его списке, в одну запись. Агрегатные функции в списке выбора
                применяются к каждой группе индивидуально, а не для всего набора в целом.</para>
            <para>Если список выборки содержит только агрегатные столбцы или столбцы, значения
                которых не зависит от отдельных строк основного множества, то предложение GROUP BY
                необязательно. Когда предложение GROUP BY опущено, результирующее множество будет
                состоять из одной строки (при условии, что хотя бы один агрегатный столбец
                присутствует). </para>
            <para>Если в списке выборки содержатся как агрегатные столбцы, так и столбцы, чьи
                значения зависит от выбираемых строк, то предложение GROUP BY становится
                обязательным.</para>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT ... 
FROM ... 
GROUP BY <replaceable>&lt;grouping-item&gt;</replaceable> [, <replaceable>&lt;grouping-item&gt;</replaceable> ...] 
[HAVING <replaceable>&lt;grouped-row-condition&gt;</replaceable>] ...       

<replaceable>&lt;grouping-item&gt;</replaceable> ::= <replaceable>&lt;non-aggr-select-item&gt;</replaceable> | <replaceable>&lt;non-aggr-expression&gt;</replaceable>   

<replaceable>&lt;non-aggr-select-item&gt;</replaceable> ::= <replaceable>column-copy</replaceable> | <replaceable>column-alias</replaceable> | <replaceable>column-position</replaceable>    
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложения GROUP BY</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>non-aggr-expression</replaceable></entry>
                                <entry>
                                    <para>Любое не агрегатное выражение, которое не включено в
                                        список выборки, т.е. невыбираемые столбцы из набора
                                        источника или выражения, которые не зависит от набора данных
                                        вообще. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>column-copy</replaceable></entry>
                                <entry>
                                    <para>Дословная копия выражения из списка выбора, не содержащего
                                        агрегатной функции. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>column-alias</replaceable></entry>
                                <entry>
                                    <para>Псевдоним выражения (столбца) из списка выбора, не
                                        содержащего агрегатной функции. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>column-position</replaceable></entry>
                                <entry>
                                    <para>Номер позиции выражения (столбца) из списка выбора, не
                                        содержащего агрегатной функции. </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Общее правило гласит, что каждый не агрегированный столбец в SELECT списке, должен
                быть так же включён в GROUP BY список. Вы можете это сделать тремя способами:
                    <orderedlist spacing="compact">
                    <listitem>
                        <para>Копировать выражение дословно из списка выбора, например "class" или
                            "'D:' || upper(doccode)";</para>
                    </listitem>
                    <listitem>
                        <para>Указать псевдоним, если он существует; </para>
                    </listitem>
                    <listitem>
                        <para>Задать положение столбца в виде целого числа, которое находится в
                            диапазоне от 1 до количества столбцов в списке SELECT. Целые значения,
                            полученные из выражений, параметров или просто инварианты будут
                            использоваться в качестве таковых в группировке. Они не будут иметь
                            никакого эффекта, поскольку их значение одинаково для каждой строки.
                        </para>
                    </listitem>
                </orderedlist></para>
            <important>
                <para>Если вы группируете по позиции столбца или алиасу, то выражение
                    соответствующее этой позиции (алиасу) будет скопировано из списка выборки
                    SELECT. Это касается и подзапросов, таким образом, подзапрос будет выполняться,
                    по крайней мере, два раза.</para>
            </important>
            <para> В дополнении к требуемым элементам, список группировки так же может содержать:
                    <itemizedlist spacing="compact">
                    <listitem>
                        <para>Столбцы исходной таблицы, которые не включены в список выборки SELECT,
                            или неагрегатные выражения, основанные на таких столбцах. Добавление
                            таких столбцов может дополнительно разбить группы. Но так как эти
                            столбцы не в списке выборки SELECT, вы не можете сказать, какому
                            значению столбца соответствует значение агрегированной строки. Таким
                            образом, если вы заинтересованы в этой информации, вы так же должны
                            включить этот столбец или выражение в список выборки SELECT, что
                            возвращает вас к правилу "каждый не агрегированный столбце в списке
                            выборки SELECT должен быть включён в список группировки GROUP
                            BY";</para>
                    </listitem>
                    <listitem>
                        <para>Выражения, которые не зависят от данных из основного набора, т.е.
                            константы, контекстные переменные, некоррелированные подзапросы,
                            возвращающие единственное значение и т.д. Это упоминается только для
                            полноты картины, т.к. добавление этих элементов является абсолютно
                            бессмысленным, поскольку они не повлияют на группировку вообще.
                            "Безвредные, но бесполезные" элементы так же могут фигурировать в списке
                            выбора SELECT без их копирования в список группировки GROUP BY.</para>
                    </listitem>
                </itemizedlist></para>

            <bridgehead renderas="sect4">Примеры</bridgehead>

            <para>Когда в списке выбора SELECT содержатся только агрегатные столбцы, предложение
                GROUP BY необязательно:
                <programlisting language="sql">
SELECT COUNT(*), AVG(age) 
FROM students
WHERE sex = 'M'
                    </programlisting>
            </para>
            <para>Этот запрос вернёт одну строку с указанием количества студентов мужского пола и их
                средний возраст. Добавление выражения, которое не зависит от строк таблицы STUDENTS,
                ничего не меняет:
                <programlisting language="sql">
SELECT COUNT(*), AVG(age), current_date 
FROM students
WHERE sex = 'M'
                    </programlisting>
            </para>
            <para> Теперь строка результата будет иметь дополнительный столбец, отображающий текущую
                дату, но кроме этого, ничего фундаментального не изменилось. Группировка по-прежнему
                не требуется. </para>
            <para>Тем не менее, в обоих приведённых выше примерах это разрешено. Это совершенно
                справедливо и для запроса:
                <programlisting language="sql">
SELECT COUNT(*), AVG(age) 
FROM students
WHERE sex = 'M'
GROUP BY class
                    </programlisting>
                и вернёт результат для каждого класса, в котором есть мальчики, перечисляя
                количество мальчиков и их средний возраст в этой конкретном классе. Если вы также
                оставите поле CURRENT_DATE, то это значение будет повторяться на каждой строке, что
                не интересно. </para>
            <para> Этот запрос имеет существенный недостаток, хотя он даёт вам информацию о
                различных классах, но не говорит вам, какая строка к какому классу относится. Для
                того чтобы получить эту дополнительную часть информации, не агрегатный столбец CLASS
                должен быть добавлен в список выборки SELECT:
                <programlisting language="sql">
SELECT class, COUNT(*), AVG(age) 
FROM students
WHERE sex = 'M'
GROUP BY class
                    </programlisting>
            </para>
            <para>Теперь у нас есть полезный запрос. Обратите внимание, что добавление столбца CLASS
                делает предложение GROUP BY обязательным. Мы не можем удалить это предложение, так
                же мы не можем удалить столбец CLASS из списка столбцов.</para>
            <para> Результат последнего запроса будет выглядеть примерно так: <informaltable
                    frame="all">
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="0.7*"/>
                        <colspec colname="c2" colnum="2" colwidth="0.7*"/>
                        <colspec colname="c3" colnum="3" colwidth="0.7*"/>
                        <thead>
                            <row>
                                <entry>CLASS</entry>
                                <entry>COUNT</entry>
                                <entry>AVG</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>2A</entry>
                                <entry>12</entry>
                                <entry>13.5</entry>
                            </row>
                            <row>
                                <entry>2B </entry>
                                <entry>9 </entry>
                                <entry>13.9 </entry>
                            </row>
                            <row>
                                <entry>3A </entry>
                                <entry>11 </entry>
                                <entry>14.6 </entry>
                            </row>
                            <row>
                                <entry>3B </entry>
                                <entry>12 </entry>
                                <entry>14.4 </entry>
                            </row>
                            <row>
                                <entry>...</entry>
                                <entry>...</entry>
                                <entry>...</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>Заголовки "COUNT" и "AVG" не очень информативны. В простейшем случае вы можете
                обойти это, но лучше, если мы дадим им значимые имена с помощью псевдонимов:
                <programlisting language="sql">
SELECT 
    class,
    COUNT(*) AS num_boys,
    AVG(age) AS boys_avg_age
FROM students
WHERE sex = 'M'
GROUP BY class
                    </programlisting>
            </para>
            <para>Как вы помните из формального синтаксиса списка столбцов, ключевое слово AS не
                является обязательным. </para>
            <para>Добавление большего не агрегированных (или точнее строчно зависимых) столбцов
                требуется добавления их в предложения GROUP BY тоже. Например, вы хотите видеть
                вышеуказанную информацию о девочках то же, и хотите видеть разницу между интернатами
                и студентами дневного отделения: <programlisting language="sql">
SELECT 
    class,
    sex,
    boarding_type,
    COUNT(*) AS anumber,
    AVG(age) AS avg_age
FROM students
GROUP BY class, sex, boarding_type
                    </programlisting>
                <informaltable frame="all">
                    <tgroup cols="5">
                        <colspec colname="c1" colnum="1" colwidth="0.3*"/>
                        <colspec colname="c2" colnum="2" colwidth="0.2*"/>
                        <colspec colname="c3" colnum="3" colwidth="0.7*"/>
                        <colspec colname="c4" colnum="4" colwidth="0.5*"/>
                        <colspec colname="c5" colnum="5" colwidth="0.3*"/>
                        <thead>
                            <row>
                                <entry>CLASS</entry>
                                <entry>SEX</entry>
                                <entry>BOARDING_TYPE</entry>
                                <entry>ANUMBER</entry>
                                <entry>AVG_AGE</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>2A</entry>
                                <entry>F</entry>
                                <entry>BOARDING</entry>
                                <entry>9</entry>
                                <entry>13.3</entry>
                            </row>
                            <row>
                                <entry>2A </entry>
                                <entry> F </entry>
                                <entry>DAY </entry>
                                <entry>6 </entry>
                                <entry>13.5 </entry>
                            </row>
                            <row>
                                <entry>2A </entry>
                                <entry>M</entry>
                                <entry>BOARDING</entry>
                                <entry>7</entry>
                                <entry>13.6 </entry>
                            </row>
                            <row>
                                <entry>2A </entry>
                                <entry>M</entry>
                                <entry>DAY</entry>
                                <entry>5</entry>
                                <entry>13.4 </entry>
                            </row>
                            <row>
                                <entry>2B </entry>
                                <entry>F</entry>
                                <entry>BOARDING</entry>
                                <entry>11</entry>
                                <entry>13.7 </entry>
                            </row>
                            <row>
                                <entry>2B </entry>
                                <entry>F</entry>
                                <entry>DAY</entry>
                                <entry>5</entry>
                                <entry>13.7 </entry>
                            </row>
                            <row>
                                <entry>2B </entry>
                                <entry>M</entry>
                                <entry>BOARDING</entry>
                                <entry>6</entry>
                                <entry>13.8 </entry>
                            </row>
                            <row>
                                <entry>...</entry>
                                <entry>...</entry>
                                <entry>...</entry>
                                <entry>...</entry>
                                <entry>...</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>Каждая строка в результирующем наборе соответствует одной конкретной комбинации
                переменных CLASS, SEX и BOARDING_TYPE. Агрегированные результаты — количество и
                средний возраст — приведены для каждой из конкретизированной группы отдельно. В
                результате запроса вы не можете увидеть обобщённые результаты для мальчиков отдельно
                или для студентов дневного отделения отдельно. Таким образом, вы должны найти
                компромисс. Чем больше вы добавляете неагрегатных столбцов, тем больше вы
                конкретизируете группы, и тем больше вы упускаете общую картину из виду. Конечно, вы
                все ещё можете получить "большие" агрегаты, с помощью отдельных запросов.</para>
            <section xml:id="dml-select-having">
                <info>
                    <title>HAVING</title>
                    <keywordset>
                        <keyword>HAVING</keyword>
                    </keywordset>
                </info>

                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>HAVING</secondary>
                </indexterm>

                <para>Так же, как и предложение WHERE ограничивает строки в наборе данных, теми
                    которые удовлетворяют условию поиска, с той разницей, что предложение HAVING
                    накладывает ограничения на агрегированные строки сгруппированного набора.
                    Предложение HAVING не является обязательным и может быть использовано только в
                    сочетании с предложением GROUP BY.</para>
                <para>Условие(я) в предложении HAVING может ссылаться на:<itemizedlist
                        spacing="compact">
                        <listitem>
                            <para>Любой агрегированный столбец в списке выбора SELECT. Это наиболее
                                широко используемый случай;</para>
                        </listitem>
                        <listitem>
                            <para>Любое агрегированное выражение, которое не находится в списке
                                выбора SELECT, но разрешено в контексте запроса. Иногда это
                                полезно;</para>
                        </listitem>
                        <listitem>
                            <para>Любой столбец в списке GROUP BY. Однако более эффективно
                                фильтровать не агрегированные данные на более ранней стадии в
                                предложении WHERE;</para>
                        </listitem>
                        <listitem>
                            <para>Любое выражение, значение которого не зависит от содержимого
                                набора данных (например, константа или контекстная переменная). Это
                                допустимо, но совершенно бессмысленно, потому что такое условие, не
                                имеющее никакого отношения к самому набору данных, либо подавит весь
                                набор, либо оставит его не тронутым.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Предложение HAVING не может содержать:<itemizedlist spacing="compact">
                        <listitem>
                            <para>Не агрегированные выражения столбца, которые не находятся в списке
                                GROUP BY;</para>
                        </listitem>
                        <listitem>
                            <para>Позицию столбца. Целое число в предложении HAVING – просто целое
                                число;</para>
                        </listitem>
                        <listitem>
                            <para>Псевдонимы столбца – даже, если они появляются в предложении GROUP
                                BY.</para>
                        </listitem>
                    </itemizedlist></para>

                <bridgehead renderas="sect4">Примеры</bridgehead>
                <para>Перестроим наши ранние примеры. Мы можем использовать предложение HAVING для
                    исключения малых групп студентов:
                    <programlisting language="sql">
SELECT 
    class,
    COUNT(*) AS num_boys,
    AVG(age) AS boys_avg_age
FROM students
WHERE sex = 'M'
GROUP BY class
HAVING COUNT(*) >= 5                    
                </programlisting>
                </para>
                <para>Выберем только группы, которые имеют минимальный разброс по возрасту 1,2 года:
                    <programlisting language="sql">
SELECT 
    class,
    COUNT(*) AS num_boys,
    AVG(age) AS boys_avg_age
FROM students
WHERE sex = 'M'
GROUP BY class
HAVING MAX(age) - MIN(age) > 1.2                    
                </programlisting>
                </para>
                <para>Обратите внимание, что если вас действительно интересует эта информация, то
                    неплохо бы включить в список выбора min(age) и max(age) или выражение max(age) –
                    min(age).</para>
                <para>Следующий запрос отбирает только учеников 3 класса:
                    <programlisting language="sql">
SELECT 
    class,
    COUNT(*) AS num_boys,
    AVG(age) AS boys_avg_age
FROM students
WHERE sex = 'M'
GROUP BY class
HAVING class STARTING WITH '3'                   
                </programlisting>
                </para>
                <para>Однако гораздо лучше переместить это условие в предложение WHERE:
                    <programlisting language="sql">
SELECT 
    class,
    COUNT(*) AS num_boys,
    AVG(age) AS boys_avg_age
FROM students
WHERE sex = 'M' AND class STARTING WITH '3'
GROUP BY class                   
                </programlisting>
                </para>
            </section>
        </section>
        <section xml:id="dml-select-window">
            <info>
                <title>WINDOW</title>
                <keywordset>
                    <keyword>WINDOW</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>WINDOW</secondary>
            </indexterm>

            <para>Предложение WINDOW предназначено для задания именованных окон, которые
                используются <link linkend="internalfunc-window">оконными функциями</link>.
                Поскольку выражение окна может быть довольно сложным и использоваться многократно
                такая функциональность бывает полезной.</para>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
<replaceable>&lt;query spec&gt;</replaceable> ::=
  SELECT
    [<replaceable>&lt;first clause&gt;</replaceable>] [<replaceable>&lt;skip clause&gt;</replaceable>]
    [<replaceable>&lt;distinct clause&gt;</replaceable>]
    <replaceable>&lt;select list&gt;</replaceable>
    <replaceable>&lt;from clause&gt;</replaceable>
    [<replaceable>&lt;where clause&gt;</replaceable>]
    [<replaceable>&lt;group clause&gt;</replaceable>]
    [<replaceable>&lt;having clause&gt;</replaceable>]
    [<replaceable>&lt;named windows clause&gt;</replaceable>]
    [<replaceable>&lt;order clause&gt;</replaceable>]
    [<replaceable>&lt;rows clause&gt;</replaceable>]
    [<replaceable>&lt;offset clause&gt;</replaceable>] [<replaceable>&lt;limit clause&gt;</replaceable>]
    [<replaceable>&lt;plan clause&gt;</replaceable>]

<replaceable>&lt;named windows clause&gt;</replaceable> ::=
  WINDOW <replaceable>&lt;window definition&gt;</replaceable> [, <replaceable>&lt;window definition&gt;</replaceable>] ...

<replaceable>&lt;window definition&gt;</replaceable> ::=
  <replaceable>&lt;window name&gt;</replaceable> AS <replaceable>&lt;window specification&gt;</replaceable> 
                    
<replaceable>&lt;window specification&gt;</replaceable> ::= 
   ([<replaceable>&lt;window name&gt;</replaceable>] [<replaceable>&lt;window partition&gt;</replaceable>] [<replaceable>&lt;window order&gt;</replaceable>] [<replaceable>&lt;window frame&gt;</replaceable>])  
 
                  
<replaceable>&lt;window partition&gt;</replaceable> ::= PARTITION BY <replaceable>&lt;expr&gt;</replaceable> [, <replaceable>&lt;expr&gt;</replaceable> ...]

<replaceable>&lt;window order&gt;</replaceable> ::= 
  ORDER BY <replaceable>&lt;expr&gt;</replaceable> [<replaceable>&lt;direction&gt;</replaceable>] [<replaceable>&lt;nulls placement&gt;</replaceable>]  
        [, <replaceable>&lt;expr&gt;</replaceable> [<replaceable>&lt;direction&gt;</replaceable>] [<replaceable>&lt;nulls placement&gt;</replaceable>] ...]

<replaceable>&lt;direction&gt;</replaceable> ::= {ASC | DESC} 

<replaceable>&lt;nulls placement&gt;</replaceable> ::= NULLS {FIRST | LAST} 
                
<replaceable>&lt;window frame&gt;</replaceable> ::= 
  {ROWS | RANGE} <replaceable>&lt;window frame extent&gt;</replaceable>                

<replaceable>&lt;window frame extent&gt;</replaceable> ::= 
  <replaceable>&lt;window frame preceding&gt;</replaceable> | <replaceable>&lt;window frame between&gt;</replaceable> 

<replaceable>&lt;window frame preceding&gt;</replaceable> ::= 
  UNBOUNDED PRECEDING | <replaceable>&lt;expr&gt;</replaceable> PRECEDING | CURRENT ROW 

<replaceable>&lt;window frame between&gt;</replaceable> ::= 
  BETWEEN { UNBOUNDED PRECEDING | <replaceable>&lt;expr&gt;</replaceable> PRECEDING | <replaceable>&lt;expr&gt;</replaceable> FOLLOWING | CURRENT ROW } 
      AND { UNBOUNDED FOLLOWING | <replaceable>&lt;expr&gt;</replaceable> PRECEDING | <replaceable>&lt;expr&gt;</replaceable> FOLLOWING | CURRENT ROW }                    
                
                </programlisting></para>
            </formalpara>

            <para>Имя окна может быть использовано в предложении OVER для ссылки на определение
                окна, кроме того оно может быть использовано в качестве базового окна для другого
                именованного или встроенного (в предложении OVER) окна. Окна с рамкой (с
                предложениями RANGE и ROWS) не могут быть использованы в качестве базового окна (но
                могут быть использованы в предложении OVER <replaceable>&lt;window
                    name&gt;</replaceable>). Окно, которое использует ссылку на базовое окно, не
                может иметь предложение PARTITION BY и не может переопределять сортировку с помощью
                предложения ORDER BY.</para>

            <formalpara>
                <title>Пример:</title>

                <para>
                    <example>
                        <title>Использование именованных окон</title>
                        <para>
                            <programlisting language="sql">
SELECT
    id,
    department,
    salary,
    count(*) OVER w1,
    first_value(salary) OVER w2,
    last_value(salary) OVER w2,
    sum(salary) over (w2 ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) AS s
FROM employee
WINDOW w1 AS (PARTITION BY department),
       w2 AS (w1 ORDER BY salary)
ORDER BY department, salary;
                                </programlisting>
                        </para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="internalfunc-window">Оконные (аналитические) функции</link>.
                </para>
            </formalpara>
        </section>
        <section xml:id="dml-select-plan">
            <info>
                <title>PLAN</title>
                <keywordset>
                    <keyword>PLAN</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>PLAN</secondary>
            </indexterm>

            <para>Предложение PLAN позволяет пользователю указать свой план выполнения запроса,
                который перекрывает тот план, который оптимизатор сгенерировал автоматически.</para>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
PLAN <replaceable>&lt;plan-expr&gt;</replaceable> 

<replaceable>&lt;plan-expr&gt;</replaceable> ::= 
    (<replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])               
  | <replaceable>&lt;sorted-item&gt;</replaceable>               
  | <replaceable>&lt;joined-item&gt;</replaceable>               
  | <replaceable>&lt;merged-item&gt;</replaceable> 
  | <replaceable>&lt;hash-item&gt;</replaceable>

<replaceable>&lt;sorted-item&gt;</replaceable> ::= SORT (<replaceable>&lt;plan-item&gt;</replaceable>) 

<replaceable>&lt;joined-item&gt;</replaceable> ::= JOIN (<replaceable>&lt;plan-item&gt;</replaceable>, <replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...]) 

<replaceable>&lt;merged-item&gt;</replaceable> ::= 
  [SORT] MERGE (<replaceable>&lt;sorted-item&gt;</replaceable>, <replaceable>&lt;sorted-item&gt;</replaceable> [, <replaceable>&lt;sorted-item&gt;</replaceable> ...]) 

<replaceable>&lt;hash-item&gt;</replaceable> ::= HASH (<replaceable>&lt;plan-item&gt;</replaceable>, <replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...]) 

<replaceable>&lt;plan-item&gt;</replaceable> ::= &lt;basic-item&gt; | &lt;plan-expr&gt;  

<replaceable>&lt;basic-item&gt;</replaceable> ::= <replaceable>&lt;relation&gt;</replaceable> {
    NATURAL                
  | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)                
  | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]
} 

<replaceable>&lt;relation&gt;</replaceable> ::= <replaceable>table</replaceable> | <replaceable>view</replaceable> [<replaceable>table</replaceable>]  

<replaceable>&lt;indexlist&gt;</replaceable> ::= <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложения PLAN</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>table</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы или её алиас.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>view</replaceable></entry>
                                <entry>
                                    <para>Имя представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>index</replaceable></entry>
                                <entry>
                                    <para>Имя индекса.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Каждый раз, когда пользователь отправляет запрос ядру Firebird, оптимизатор
                вычисляет стратегию извлечения данных. Большинство клиентов Firebird имеют
                возможность отобразить пользователю план извлечения данных. В собственном
                инструменте <application>isql</application> это делается с помощью команды SET PLAN
                ON. Если вы хотите только изучить план запроса без его выполнения, то вам необходимо
                ввести команду SET PLANONLY ON, после чего будут извлекаться планы запросов без их
                выполнения. Для возврата <application>isql</application> в режим выполнения запросов
                введите команду SET PLANONLY OFF.</para>
            <note>
                <para>Более подробный план можно получить при включении расширенного плана. В
                        <application>isql</application> это делается с помощью команды SET EXPLAIN
                    ON. Этот план выводит более подробную информацию о методах доступа используемых
                    оптимизатором, однако его нельзя включить в запрос. Описание расширенного плана
                    выходит за рамки данного руководства.</para>
            </note>
            <para>В большинстве случаев, вы можете доверять тому, что Firebird выберет наиболее
                оптимальный план запроса. Однако если ваши запросы очень сложны и вам кажется, что
                они выполняются не эффективно, вам необходимо посмотреть план запроса и подумать
                можете ли вы улучшить его. </para>
            <simplesect>
                <title>Простые планы</title>
                <para>Простейшие планы состоят только из имени таблицы и следующим за ним метода
                    извлечения. Например, для неотсортированной выборки из единственной таблицы без
                    предложения WHERE:
                    <programlisting language="sql">
SELECT * FROM students
PLAN (students NATURAL)           
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Table "STUDENTS" Full Scan                    
                </screen>
                </para>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>PLAN</secondary>
                    <tertiary>INDEX</tertiary>
                </indexterm>
                <para>Если есть предложение WHERE вы можете указать индекс, который будет
                    использоваться при нахождении совпадений:
                    <programlisting language="sql">
SELECT * 
FROM students
WHERE class = '3C'
PLAN (students INDEX (ix_stud_class))         
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Filter
      -> Table "STUDENTS" Access By ID
          -> Bitmap
              -> Index "IX_STUD_CLASS" Range Scan (full match)                   
                </screen>
                </para>
                <para>Директива INDEX может использоваться также для условий соединения (которые
                    будут обсуждаться чуть позже). Она содержит список индексов, разделённых
                    запятыми.</para>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>PLAN</secondary>
                    <tertiary>ORDER</tertiary>
                </indexterm>
                <para>Директива ORDER определяет индекс, который используется при сортировке набора
                    данных, если присутствуют предложения ORDER BY или GROUP BY:
                    <programlisting language="sql">
SELECT * 
FROM students
PLAN (students ORDER pk_students)
ORDER BY id           
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Table "STUDENTS" Access By ID
      -> Index "PK_STUDENTS" Full Scan                  
                </screen>
                </para>
                <para>Инструкции ORDER и INDEX могут быть объединены:
                    <programlisting language="sql">
SELECT * 
FROM students
WHERE class >= '3'
PLAN (students ORDER pk_students INDEX (ix_stud_class))
ORDER BY id           
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Filter
      -> Table "STUDENTS" Access By ID
          -> Index "PK_STUDENTS" Full Scan
              -> Bitmap
                  -> Index "IX_STUD_CLASS" Range Scan (lower bound: 1/1)                  
                </screen>
                </para>
                <para>В инструкциях ORDER и INDEX разрешено указывать один и тот же индекс:
                    <programlisting language="sql">
SELECT * 
FROM students
WHERE class >= '3'
PLAN (students ORDER ix_stud_class INDEX (ix_stud_class))
ORDER BY class         
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Filter
      -> Table "STUDENTS" Access By ID
          -> Index "IX_STUD_CLASS" Range Scan (lower bound: 1/1)
              -> Bitmap
                  -> Index "IX_STUD_CLASS" Range Scan (lower bound: 1/1)                 
                </screen>
                </para>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>PLAN</secondary>
                    <tertiary>SORT</tertiary>
                </indexterm>
                <para>Для сортировки наборов данных, когда невозможно использовать индекс (или вы
                    хотите подавить его использование), уберите инструкцию ORDER и предварите
                    выражение плана инструкцией SORT:
                    <programlisting language="sql">
SELECT * 
FROM students
PLAN SORT (students NATURAL)
ORDER BY name        
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Sort (record length: 128, key length: 56)
      -> Table "STUDENTS" Full Scan                
                </screen>
                </para>
                <para>Или когда индекс используется для поиска:
                    <programlisting language="sql">
SELECT * 
FROM students
WHERE class >= '3'
PLAN SORT (students INDEX (ix_stud_class))
ORDER BY name        
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Sort (record length: 136, key length: 56)
      -> Filter
          -> Table "STUDENTS" Access By ID
              -> Bitmap
                  -> Index "IX_STUD_CLASS" Range Scan (lower bound: 1/1)             
                </screen>
                </para>
                <para>Обратите внимание, что инструкция SORT, в отличие от ORDER, находится за
                    пределами скобок. Это отражает тот факт, что строки данных извлекаются
                    неотсортированными и сортируются впоследствии. </para>
                <para>При выборке из представления указывается само представление и участвующее в
                    нем таблица. Например, если у вас есть представление FRESHMEN, которое выбирает
                    только студентов первокурсников:
                    <programlisting language="sql">
SELECT * 
FROM freshmen
PLAN (freshmen students NATURAL)      
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Table "STUDENTS" as "FRESHMEN" Full Scan            
                </screen>
                </para>
                <para>Или, например:
                    <programlisting language="sql">
SELECT * 
FROM freshmen
WHERE id > 10
PLAN SORT (freshmen students INDEX (pk_students))
ORDER BY name DESC     
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Sort (record length: 144, key length: 24)
      -> Filter
          -> Table "STUDENTS" as "FRESHMEN" Access By ID
              -> Bitmap
                  -> Index "PK_STUDENTS" Range Scan (lower bound: 1/1)            
                </screen>
                </para>
                <para>Обратите внимание: если вы назначили псевдоним таблице или представлению, то в
                    предложении PLAN необходимо использовать псевдоним, а не оригинальное
                    имя.</para>
            </simplesect>
            <simplesect>
                <title>Составные планы</title>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>PLAN</secondary>
                    <tertiary>JOIN</tertiary>
                </indexterm>
                <para>Если вы делаете соединение, то вы можете указать индекс, который будет
                    использоваться для сопоставления. Кроме того, вы должны использовать директиву
                    JOIN для двух потоков в плане:
                    <programlisting language="sql">
SELECT s.id, s.name, s.class, c.mentor
FROM students s
JOIN classes c ON c.name = s.class
PLAN JOIN (s NATURAL, c INDEX (pk_classes))   
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  ->  Nested Loop Join (inner)
      -> Table "STUDENTS" as "S" Full Scan
      -> Filter
          -> Table "CLASSES" as "C" Access By ID
              -> Bitmap
                  -> Index "PK_CLASSES" Unique Scan            
                </screen>
                </para>
                <para>То же самое соединение, отсортированное по индексированному столбцу:
                    <programlisting language="sql">
SELECT s.id, s.name, s.class, c.mentor
FROM students s
JOIN classes c ON c.name = s.class
PLAN JOIN (s ORDER pk_students, c INDEX (pk_classes))
ORDER BY s.id   
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  ->  Nested Loop Join (inner)
      -> Table "STUDENTS" as "S" Access By ID
          -> Index "PK_STUDENTS" Full Scan
      -> Filter
          -> Table "CLASSES" as "C" Access By ID
              -> Bitmap
                  -> Index "PK_CLASSES" Unique Scan            
                </screen>
                </para>
                <para>И соединение, отсортированное не по индексированному столбцу:
                    <programlisting language="sql">
SELECT s.id, s.name, s.class, c.mentor
FROM students s
JOIN classes c ON c.name = s.class
PLAN SORT (JOIN (S NATURAL, c INDEX (pk_classes))))
ORDER BY s.name  
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Sort (record length: 152, key length: 12)
      ->  Nested Loop Join (inner)
          -> Table "STUDENTS" as "S" Full Scan
          -> Filter
              -> Table "CLASSES" as "C" Access By ID
                  -> Bitmap
                      -> Index "PK_CLASSES" Unique Scan           
                </screen>
                </para>
                <para>Соединение с добавленным условием поиска:
                    <programlisting language="sql">
SELECT s.id, s.name, s.class, c.mentor
FROM students s
JOIN classes c ON c.name = s.class
WHERE s.class &lt;= '2'
PLAN SORT (JOIN (s INDEX (fk_student_class), c INDEX (pk_classes)))
ORDER BY s.name 
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Sort (record length: 152, key length: 12)
     ->  Nested Loop Join (inner)
         -> Filter
            -> Table "STUDENTS" as "S" Access By ID
               -> Bitmap
                  -> Index "FK_STUDENT_CLASS" Range Scan (lower bound: 1/1)
         -> Filter
            -> Table "CLASSES" as "C" Access By ID
               -> Bitmap
                  -> Index "PK_CLASSES" Unique Scan          
                </screen>
                </para>
                <para>То же самое, но используется левое внешнее соединение:
                    <programlisting language="sql">
SELECT s.id, s.name, s.class, c.mentor
FROM classes c
LEFT JOIN students s ON c.name = s.class
WHERE s.class &lt;= '2'
PLAN SORT (JOIN (c NATURAL, s INDEX (fk_student_class)))
ORDER BY s.name 
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
  -> Sort (record length: 192, key length: 56)
      -> Filter
         ->  Nested Loop Join (outer)
             -> Table "CLASSES" as "C" Full Scan
             -> Filter
                -> Table "STUDENTS" as "S" Access By ID
                   -> Bitmap
                      -> Index "FK_STUDENT_CLASS" Range Scan (full match)         
                </screen>
                </para>
                <para>Если нет доступных индексов для условия соединения (или вы не хотите его
                    использовать), то возможно соединение потоков с помощью метода HASH или
                    MERGE.</para>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>PLAN</secondary>
                    <tertiary>HASH</tertiary>
                </indexterm>
                <para>Для соединения методом HASH в плане вместо директивы JOIN используется
                    директива HASH. В этом случае меньший (ведомый) поток целиком вычитывается во
                    внутренний буфер. В процессе чтения к каждому ключу связи применяется
                    хеш-функция и пара <emphasis role="italic">{хеш, указатель в буфере}</emphasis>
                    записывается в хеш-таблицу. После чего читается ведущий поток и его ключ связи
                    апробируется в
                    хеш-таблице.<programlisting language="sql">
SELECT * 
FROM students s
JOIN classes c ON c.cookie = s.cookie
PLAN HASH (c NATURAL, s NATURAL)                    
                </programlisting>
                    План в EXPLAIN форме:
                    <screen>
Select Expression
    -> Filter
        -> Hash Join (inner)
            -> Table "STUDENTS" as "S" Full Scan
            -> Record Buffer (record length: 145)
                -> Table "CLASSES" as "C" Full Scan        
                </screen>
                </para>
                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>PLAN</secondary>
                    <tertiary>MERGE</tertiary>
                </indexterm>
                <para>При выполнении соединения методом MERGE план должен сначала отсортировать оба
                    потока по соединяемым столбцам и затем произвести слияние. Это достигается с
                    помощью директив SORT (которую вы уже встречали) и MERGE используемую вместо
                    JOIN.
                    <programlisting language="sql">
SELECT * 
FROM students s
JOIN classes c ON c.cookie = s.cookie
PLAN MERGE (SORT (c NATURAL), SORT (s NATURAL)) 
                </programlisting>
                </para>
                <para>Добавление предложения ORDER BY означает, что результат слияния также должен
                    быть отсортирован:
                    <programlisting language="sql">
SELECT * 
FROM students s
JOIN classes c ON c.cookie = s.cookie
PLAN SORT (MERGE (SORT (c NATURAL), SORT (s NATURAL)))
ORDER BY c.name, s.id
                </programlisting>
                </para>
                <para>И наконец, мы добавляем условие поиска на двух индексированных столбцах
                    таблицы STUDENTS:
                    <programlisting language="sql">
SELECT * 
FROM students s
JOIN classes c ON c.cookie = s.cookie
WHERE s.id &lt; 10 AND s.class &lt;= '2'
PLAN SORT (MERGE (SORT (c NATURAL),
                  SORT (s INDEX (pk_students, fk_student_class))))
ORDER BY c.name, s.id
                </programlisting>
                </para>
                <para>Как следует из формального определения синтаксиса, JOIN и MERGE могут
                    объединять в плане более двух потоков. Кроме того, каждое выражение плана может
                    использоваться в качестве элемента в охватывающем плане. Это означает, что планы
                    некоторых сложных запросов могут иметь различные уровни вложенности. </para>
                <para>Наконец, вместо MERGE вы можете писать SORT MERGE. Поскольку это не имеет
                    абсолютно никакого значения и может создать путаницу с &quot;настоящей&quot;
                    директивой SORT (которая действительно имеет значение), то вероятно лучше
                    придерживаться простой директивы MERGE.</para>
                <para>Помимо плана для основного запроса вы можете указать план для каждого
                    подзапроса. Например, следующий запрос с указанием планов будет абсолютно
                    правильным.</para>
                <para>
                    <programlisting language="sql">
SELECT *
FROM COLOR
WHERE EXISTS(
             SELECT *
             FROM HORSE
             WHERE HORSE.CODE_COLOR = COLOR.CODE_COLOR
             PLAN (HORSE INDEX (FK_HORSE_COLOR)))
PLAN(COLOR NATURAL) 
                </programlisting>
                </para>
            </simplesect>
        </section>
        <section xml:id="dml-select-union">
            <info>
                <title>UNION</title>
                <keywordset>
                    <keyword>UNION</keyword>
                    <keyword>UNION ALL</keyword>
                    <keyword>UNION DISTINCT</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>UNION</secondary>
            </indexterm>

            <para>Предложение UNION объединяет два и более набора данных, тем самым увеличивая общее
                количество строк, но не столбцов. Наборы данных, принимающие участие в UNION, должны
                иметь одинаковое количество столбцов. Однако столбцы в соответствующих позициях не
                обязаны иметь один и тот же тип данных, они могут быть абсолютно не
                связанными. </para>
            <para>По умолчанию, объединение подавляет дубликаты строк. UNION ALL отображает все
                строки, включая дубликаты. Необязательное ключевое слово DISTINCT делает поведение
                по умолчанию явным.</para>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
<replaceable>&lt;union&gt;</replaceable> ::= 
  <replaceable>&lt;individual-select&gt;</replaceable>    
  UNION [DISTINCT | ALL]               
  <replaceable>&lt;individual-select&gt;</replaceable>               
  [UNION [DISTINCT | ALL]               
  <replaceable>&lt;individual-select&gt;</replaceable>  
  [...]               
  [<replaceable>&lt;union-wide-clauses&gt;</replaceable>]           

<replaceable>&lt;individual-select&gt;</replaceable> ::= 
  SELECT                          
  [FIRST <replaceable>m</replaceable>] [SKIP <replaceable>n</replaceable>]                          
  [DISTINCT | ALL] <replaceable>&lt;columns&gt;</replaceable>                          
  FROM <replaceable>source</replaceable> [[AS] <replaceable>alias</replaceable>]                          
  [<replaceable>&lt;joins&gt;</replaceable>]                          
  [WHERE <replaceable>&lt;condition&gt;</replaceable>]                          
  [GROUP BY <replaceable>&lt;grouping-list&gt;</replaceable>                          
  [HAVING <replaceable>&lt;aggregate-condition&gt;</replaceable>]]                          
  [PLAN <replaceable>&lt;plan-expr&gt;</replaceable>]       

<replaceable>&lt;union-wide-clauses&gt;</replaceable> ::= 
  [ORDER BY <replaceable>&lt;ordering-list&gt;</replaceable>] 
  [ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]] 
  [FOR UPDATE [OF <replaceable>&lt;forupdate-columns&gt;</replaceable>]] 
  [WITH LOCK]                           
  [INTO <replaceable>&lt;PSQL-varlist&gt;</replaceable>]    
                    </programlisting>
                </para>
            </formalpara>
            <para>Объединения получают имена столбцов из первого запроса на выборку. Если вы хотите
                дать псевдонимы объединяемым столбцам, то делайте это для списка столбцов в самом
                верхнем запросе на выборку. Псевдонимы в других участвующих в объединении выборках
                разрешены, и могут быть даже полезными, но они не будут распространяться на уровне
                объединения. </para>
            <para>Если объединение имеет предложение ORDER BY, то единственно возможными элементами
                сортировки являются целочисленные литералы, указывающие на позиции столбцов,
                необязательно сопровождаемые ASC/DESC и/или NULLS FIRST/LAST директивами. Это так же
                означает, что вы не можете упорядочить объединение ничем, что не является столбцом
                объединения. (Однако вы можете завернуть его в производную таблицу, которая даст вам
                все обычные параметры сортировки.) </para>
            <para>Объединения позволены в подзапросах любого вида и могут самостоятельно содержать
                подзапросы. Они также могут содержать соединения (joins), и могут принимать участие
                в соединениях, если завёрнуты в производную таблицу. </para>

            <bridgehead renderas="sect4">Примеры</bridgehead>

            <para>Этот запрос представляет информацию из различных музыкальных коллекций в одном
                наборе данных с помощью объединений:
                <programlisting language="sql">
SELECT id, title, artist, len, 'CD' AS medium
FROM cds
UNION
SELECT id, title, artist, len, 'LP'
FROM records
UNION
SELECT id, title, artist, len, 'MC'
FROM cassettes
ORDER BY 3, 2 -- artist, title                  
              </programlisting>
            </para>
            <para>Если id, title, artist и length – единственные поля во всех участвующих таблицах,
                то запрос может быть записан так:
                <programlisting language="sql">
SELECT c.*, 'CD' AS medium
FROM cds c
UNION
SELECT r.*, 'LP'
FROM records r
UNION
SELECT c.*, 'MC'
FROM cassettes c
ORDER BY 3, 2 -- artist, title                
              </programlisting>
            </para>
            <para>Квалификация "звёзд" необходима здесь, потому что они не являются единственным
                элементом в списке столбцов. Заметьте, что псевдонимы "c" в первой и третьей выборке
                не кусают друг друга. Они не имеют контекста объединения, а лишь применяются к
                отдельным запросам на выборку.</para>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>UNION</secondary>
                <tertiary>ALL</tertiary>
            </indexterm>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>UNION</secondary>
                <tertiary>DISTINCT</tertiary>
            </indexterm>
            <para>Следующий запрос получает имена и телефонные номера переводчиков и корректоров. Те
                переводчики, которые также работают корректорами, будут отображены только один раз в
                результирующем наборе, если номера их телефонов одинаковые в обеих таблицах. Тот же
                результат может быть получен без ключевого слова DISTINCT. Если вместо ключевого
                слова DISTINCT, будет указано ключевое слово ALL, эти люди будут отображены дважды.
                <programlisting language="sql">
SELECT name, phone 
FROM translators
UNION DISTINCT
SELECT name, telephone 
FROM proofreaders              
              </programlisting>
            </para>
            <para>Пример использования UNION в подзапросе:
                <programlisting language="sql">
SELECT name, phone, hourly_rate 
FROM clowns
WHERE hourly_rate &lt; ALL
  (SELECT hourly_rate FROM jugglers
   UNION
   SELECT hourly_rate FROM acrobats)
ORDER BY hourly_rate            
              </programlisting>
            </para>
        </section>
        <section xml:id="dml-select-orderby">
            <info>
                <title>ORDER BY</title>
                <keywordset>
                    <keyword>ORDER BY</keyword>
                    <keyword>ASC</keyword>
                    <keyword>ASCENDING</keyword>
                    <keyword>DESC</keyword>
                    <keyword>DESCENDING</keyword>
                    <keyword>NULLS FIRST</keyword>
                    <keyword>NULLS LAST</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>ORDER BY</secondary>
            </indexterm>
            <para>Результат выборки данных при выполнении оператора SELECT по умолчанию никак не
                упорядочивается (хотя довольно часто происходит упорядочение в хронологическом
                порядке помещёния строк в таблицу операторами INSERT). Предложение ORDER BY
                позволяет задать необходимый порядок при выборке данных.</para>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT ... FROM ...
...
ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]
 
<replaceable>&lt;ordering-item&gt;</replaceable> ::= 
  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
  [COLLATE <replaceable>collation-name</replaceable>]
  [ASC[ENDING] | DESC[ENDING]]
  [NULLS {FIRST | LAST}]
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложения ORDER BY</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>col-name</replaceable></entry>
                                <entry>
                                    <para>Полное имя столбца.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>col-alias</replaceable></entry>
                                <entry>
                                    <para>Алиас (псевдоним) столбца.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>col-position</replaceable></entry>
                                <entry>
                                    <para>Позиция столбца.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>expression</replaceable></entry>
                                <entry>
                                    <para>Произвольное выражение.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation-name</replaceable></entry>
                                <entry>
                                    <para>Имя сопоставления (порядка сортировки).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>В предложении через запятую перечисляются столбцы, по которым нужно упорядочить
                результирующий набор данных. Можно задавать имя столбца, псевдоним, присвоенный
                столбцу в списке выбора при помощи ключевого слова AS, или порядковый номер столбца
                в списке выбора. В одном предложении можно для разных столбцов смешивать форму
                записи. Например, один столбец в списке сортировки может быть задан своим именем, а
                другой порядковым номером.</para>
            <important>
                <para>Если вы сортируете по позиции столбца или его алиасу, то выражение
                    соответствующее этой позиции (алиасу) будет скопировано из списка выборки
                    SELECT. Это касается и подзапросов, таким образом, подзапрос будет выполняться,
                    по крайней мере, два раза.</para>
            </important>
            <note>
                <para>В случае сортировки по номеру столбца для запроса вида "SELECT *" сервер
                    раскрывает звёздочку (*) для определения сортируемых столбцов. Однако
                    использование данной особенности в ваших запросах является плохой
                    практикой.</para>
            </note>
            <section xml:id="dml-select-orderby-direction">
                <title>Направление сортировки</title>
                <para>Ключевое слово ASCENDING задаёт упорядочение по возрастанию значений.
                    Допустимо сокращение ASC. Применяется по умолчанию. </para>
                <para>Ключевое слово DESCENDING задаёт упорядочение по убыванию значений. Допустимо
                    сокращение DESC.</para>
                <para>В одном предложении упорядочение по одному столбцу может идти по возрастанию
                    значений, а по другому — по убыванию.</para>
            </section>
            <section xml:id="dml-select-orderby-collation">
                <title>Порядок сравнения</title>
                <para>Ключевое слово COLLATE позволяет задать порядок сортировки строкового столбца,
                    если нужен порядок, отличный от того, который был установлен для этого столбца
                    (явно при описании столбца или по умолчанию, принятому для соответствующего
                    набора символов). </para>
            </section>
            <section xml:id="dml-select-orderby-nulls">
                <title>Расположение NULL</title>
                <para>Ключевое слово NULLS определяет, где в отсортированном наборе данных будут
                    находиться значения NULL соответствующего столбца – в начале выборки (FIRST) или
                    в конце (LAST). По умолчанию принимается NULLS FIRST.</para>
            </section>
            <section xml:id="dml-select-orderby-union">
                <title>Сортировка частей UNION</title>
                <para>Части выборок SELECT, участвующих в объединении UNION, не могут быть
                    отсортированы с использованием предложения ORDER BY. Однако вы можете достичь
                    желаемого результата с использованием производных таблиц или общих табличных
                    выражений. Предложение ORDER BY, записанное последним в объединении, будет
                    применено ко всей выборке в целом, а не к последней его части. Для объединений, 
                    единственно возможными элементами сортировки являются целочисленные литералы,
                    указывающие на позиции столбцов, необязательно сопровождаемые ASC / DESC и/или
                    NULLS FIRST / LAST директивами. </para>
            </section>
            <simplesect xml:id="dml-select-orderby-examples">
                <title>Примеры</title>
                <para>В описанном ниже запросе выборка будет отсортирована по возрастанию по
                    столбцам RDB$CHARACTER_SET_ID, RDB$COLLATION_ID таблицы DB$COLLATIONS:
                    <programlisting language="sql">
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY RDB$CHARACTER_SET_ID, RDB$COLLATION_ID                
            </programlisting>
                </para>
                <para>То же самое, но сортировка производится по псевдонимам столбцов:
                    <programlisting language="sql">
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY CHARSET_ID, COLL_ID              
            </programlisting>
                </para>
                <para> В следующем запросе производится сортировка, по номерам столбцов:
                    <programlisting language="sql">
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY 1, 2             
            </programlisting>
                </para>
                <para> Как было выше сказано, такая сортировка тоже допустима, но не рекомендуется:
                    <programlisting language="sql">
SELECT *
FROM RDB$COLLATIONS
ORDER BY 3, 2            
            </programlisting>
                </para>
                <para>В данном запросе сортировка происходит по второму столбцу таблицы BOOKS:
                    <programlisting language="sql">
SELECT
    BOOKS.*,
    FILMS.DIRECTOR
FROM BOOKS, FILMS
ORDER BY 2           
            </programlisting>
                </para>
                <warning>
                    <para>Обратите внимание на то, что выражения, результатом вычисления которых
                        должны быть целые неотрицательные числа, будут интерпретироваться как номер
                        столбца и вызовут исключение, если они не будут в диапазоне от 1 до числа
                        столбцов.</para>
                    <para>Пример:
                        <programlisting language="sql">
SELECT
  X, Y, NOTE
FROM PAIRS
ORDER BY X+Y DESC          
            </programlisting>
                    </para>
                    <para>Примечания:<itemizedlist spacing="compact">
                            <listitem>
                                <para>Число, возвращаемое функцией или процедурой из UDF или
                                    хранимой процедуры, непредсказуемо, независимо от того,
                                    определена сортировка самим выражением или номером
                                    столбца;</para>
                            </listitem>
                            <listitem>
                                <para>Только неотрицательные целые числа интерпретируются как номер
                                    столбца. Целое число, полученное однократным вычислением
                                    выражения или заменой параметра, запоминается как целочисленная
                                    постоянная величина, так как это значение одинаково для всех
                                    строк.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </warning>
                <para>Сортировка по убыванию значений столбца PROCESS_TIME с размещёнием значений
                    NULL в начале выборки:
                    <programlisting language="sql">
SELECT *
FROM MSG
ORDER BY PROCESS_TIME DESC NULLS FIRST         
            </programlisting>
                </para>
                <para>Сортировка выборки полученной объединением выборок из двух запросов. Выборка
                    сортируется по убыванию значений второго столбца с размещёнием NULL значений в
                    конце списка и возрастанием значений первого столбца с размещёнием NULL значений
                    в начале списка.
                    <programlisting language="sql">
SELECT
  DOC_NUMBER, DOC_DATE
FROM PAYORDER
UNION ALL
SELECT
  DOC_NUMBER, DOC_DATE
FROM BUDGORDER
ORDER BY 2 DESC NULLS LAST, 1 ASC NULLS FIRST      
            </programlisting>
                </para>
            </simplesect>
        </section>
        <section xml:id="dml-select-rows">
            <info>
                <title>ROWS</title>
                <keywordset>
                    <keyword>ROWS</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>ROWS</secondary>
            </indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Получение части строк из упорядоченного набора.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT
...
FROM ...
...
ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложения ROWS</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>m</replaceable>,
                                    <replaceable>n</replaceable></entry>
                                <entry>
                                    <para>Любые целочисленные выражения.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Предложение ROWS было введено для совместимости с Interbase 6.5 и выше.</para>
            <para>В отличие от FIRST и SKIP, выражение ROWS принимает все типы целочисленных
                (integer) выражений в качестве аргумента – без скобок! Конечно, скобки могут
                требоваться для правильных вычислений внутри выражения, и вложенный запрос также
                должен быть обернут в скобки. </para>
            <important>
                <itemizedlist>
                    <listitem>
                        <para>Нумерация записей в наборе данных начинается с 1.</para>
                    </listitem>
                    <listitem>
                        <para>И FIRST/SKIP, и ROWS могут быть использованы без выражения ORDER BY,
                            хотя это редко имеет смысл, за исключением случая, когда необходимо
                            быстро взглянуть на данные таблицы – получаемые строки при этом будут
                            чаще всего в случайном порядке. В этом случае запрос вроде "SELECT *
                            FROM TABLE1 ROWS 20" вернёт 20 первых записей, а не целую таблицу
                            (которая может очень большой).</para>
                    </listitem>
                </itemizedlist>
            </important>
            <para>Вызов ROWS <replaceable>m</replaceable> приведёт к возвращению первых
                    <replaceable>m</replaceable> записей из набора данных. </para>
            <section xml:id="dml-select-rows-1">
                <title>Особенности при использовании ROWS с одним аргументом</title>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>Если <replaceable>m</replaceable> больше общего числа записей в
                                возвращаемом наборе данных, то будет возвращён весь набор данных;
                            </para>
                        </listitem>
                        <listitem>
                            <para>Если <replaceable>m</replaceable> = 0, то будет возвращён пустой
                                набор данных;</para>
                        </listitem>
                        <listitem>
                            <para>Если <replaceable>m</replaceable> &lt; 0, выдаётся ошибка.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>В случае указания ROWS <replaceable>m</replaceable> TO
                        <replaceable>n</replaceable>, то будут возвращены записи с
                        <replaceable>m</replaceable> по <replaceable>n</replaceable> из набора
                    данных. </para>
            </section>
            <section xml:id="dml-select-rows-2">
                <title>Особенности при использовании ROWS с двумя аргументами</title>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Если <replaceable>m</replaceable> больше общего количества строк в
                                наборе данных и <replaceable>n</replaceable> >=
                                    <replaceable>m</replaceable>, то будет возвращён пустой набор
                                данных;</para>
                        </listitem>
                        <listitem>
                            <para>Если число <replaceable>m</replaceable> не превышает общего
                                количества строк в наборе данных, а <replaceable>n</replaceable>
                                превышает, то выборка ограничивается строками, начиная с
                                    <replaceable>m</replaceable> до конца набора данных;</para>
                        </listitem>
                        <listitem>
                            <para>Если <replaceable>m</replaceable> &lt; 1 и
                                    <replaceable>n</replaceable> &lt; 1, то оператор SELECT выдаст
                                ошибку;</para>
                        </listitem>
                        <listitem>
                            <para>Если <replaceable>n</replaceable> = <replaceable>m</replaceable>
                                -1, то будет возвращён пустой набор данных;</para>
                        </listitem>
                        <listitem>
                            <para>Если <replaceable>n</replaceable> &lt;
                                    <replaceable>m</replaceable> -1, то оператор SELECT выдаст
                                ошибку.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
            <section xml:id="dml-select-rows-replace">
                <title>Замена FIRST..SKIP</title>
                <para>В сущности, ROWS заменяет собой нестандартные выражения FIRST и SKIP, за
                    исключением единственного случая, когда указывается только SKIP, т.е. когда
                    возвращается весь набор данных за исключением пропуска указанного числа записей
                    с начала. </para>
                <para>Для того, что реализовать такое поведение с помощью ROWS, необходимо указать
                    второй аргумент, заведомо больший, чем размер возвращаемого набора данных. Или
                    запросить число записей в возвращаемом наборе через подзапрос. </para>
            </section>
            <section xml:id="dml-select-rows-mix">
                <title>Совместное использование FIRST..SKIP и ROWS</title>
                <para>Нельзя использовать ROWS вместе с FIRST/SKIP в одном и том же операторе
                    SELECT, но можно использовать разный синтаксис в разных подзапросах.</para>
            </section>
            <section xml:id="dml-select-rows-union">
                <title>Использование ROWS в UNION</title>
                <para>При использовании ROWS с выражением UNION, он будет применяться к
                    объединённому набору данных, и должен быть помещён после последнего  SELECT. </para>
                <para>При необходимости ограничить возвращаемые наборы данных одного или нескольких
                    операторов SELECT внутри UNION, можно воспользоваться следующими
                        вариантами:<orderedlist spacing="compact">
                        <listitem>
                            <para>Использовать FIRST/SKIP в этих операторах SELECT. Необходимо
                                помнить, что нельзя локально использовать выражение ORDER BY в
                                SELECT внутри UNION – только глобально, ко всему суммарному набору
                                данных; </para>
                        </listitem>
                        <listitem>
                            <para>Преобразовать SELECT в производные таблицы с выражениями ROWS.
                            </para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section xml:id="dml-select-rows-examples">
                <title>Примеры</title>
                <para>Ниже приведены примеры, ранее использованные для демонстрации
                    FIRST/SKIP.</para>
                <para>Следующий запрос вернёт первые 10 имён из таблицы PEOPLE (имена также будут
                    отсортированы, см. <link linkend="dml-select-orderby">ORDER BY</link>).
                    <programlisting language="sql">
SELECT id, name 
FROM People
ORDER BY name ASC
ROWS 1 TO 10
                    </programlisting>
                    или его эквивалент
                    <programlisting language="sql">
SELECT id, name 
FROM People
ORDER BY name ASC
ROWS 10
                    </programlisting>
                </para>
                <para>Следующий запрос вернёт все записи из таблицы PEOPLE, за исключением первых 10
                    имён:
                    <programlisting language="sql">
SELECT id, name 
FROM People
ORDER BY name ASC
ROWS 11 TO (SELECT COUNT(*) FROM People)
                    </programlisting>
                </para>
                <para> А этот запрос вернёт последние 10 записей (обратите внимание на скобки):
                    <programlisting language="sql">
SELECT id, name 
FROM People
ORDER BY name ASC
ROWS (SELECT COUNT(*) - 9 FROM People)
TO (SELECT COUNT(*) FROM People)
                    </programlisting>
                </para>
                <para>Этот запрос вернёт строки 81-100 из таблицы PEOPLE:
                    <programlisting language="sql">
SELECT id, name 
FROM People
ORDER BY name ASC
ROWS 81 TO 100
                    </programlisting>
                </para>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="dml-select-fetch_offset">FETCH, OFFSET</link>, <link
                            linkend="dml-select-first_skip">FIRST, SKIP</link>. </para>

                </formalpara>
            </section>
        </section>
        <section xml:id="dml-select-fetch_offset">
            <info>
                <title>FETCH, OFFSET</title>

                <keywordset>
                    <keyword>FETCH FIRST</keyword>
                    <keyword>FETCH NEXT</keyword>
                    <keyword>OFFSET</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>FETCH</secondary>
            </indexterm>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>OFFSET</secondary>
            </indexterm>
            <para>Предложения FETCH и OFFSET являются SQL:2008 совместимым эквивалентом предложениям
                FIRST/SKIP и альтернативой предложению ROWS. Предложение OFFSET указывает, какое
                количество строк необходимо пропустить. Предложение FETCH указывает, какое
                количество строк необходимо получить.</para>
            <para>Предложения OFFSET и FETCH могут применяться независимо уровня вложенности
                выражений запросов.</para>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT ...
FROM ...  
[...]
[ORDER BY <replaceable>&lt;expr_order_list&gt;</replaceable>]  
[OFFSET <replaceable>&lt;simple_value_expr&gt;</replaceable> {ROW | ROWS}]   
[FETCH {FIRST | NEXT} [<replaceable>&lt;simple_value_expr&gt;</replaceable>] {ROW | ROWS} ONLY]    
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры предложений OFFSET и FETCH</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>expr_order_list</replaceable></entry>
                                <entry>
                                    <para>Список выражений сортировки.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>simple_value_expr</replaceable></entry>
                                <entry>
                                    <para>Числовой литерал, SQL параметр (?) или PSQL параметр
                                        (:param).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Примечания: <itemizedlist spacing="compact">
                    <listitem>
                        <para>Firebird не поддерживает указание FETCH в процентах, определённое в
                            стандарте.</para>
                    </listitem>
                    <listitem>
                        <para>Firebird не поддерживает предложение FETCH с опцией WITH TIES, которая
                            определена в стандарте.</para>
                    </listitem>
                    <listitem>
                        <para>FIRST ... SKIP и ROWS являются нестандартными альтернативами.</para>
                    </listitem>
                    <listitem>
                        <para>Предложения OFFSET и/или FETCH не могут быть объединены с
                            предложениями ROWS или FIRST/SKIP в одном выражении запроса.</para>
                    </listitem>
                    <listitem>
                        <para>Выражения, ссылки на столбцы и т.д. недопустимы в любом из
                            предложений.</para>
                    </listitem>
                    <listitem>
                        <para>В отличие от предложения ROWS, предложения OFFSET и FETCH допустимы
                            только в операторе SELECT.</para>
                    </listitem>
                </itemizedlist></para>
            <para><emphasis>Примеры:</emphasis></para>
            <para>Следующий запрос возвращает все строки кроме первых 10, упорядоченных по столбцу
                COL1:
                <programlisting language="sql">
SELECT * 
FROM T1
ORDER BY COL1
OFFSET 10 ROWS                
            </programlisting>
            </para>
            <para>В этом примере возвращается первые 10 строк, упорядоченных по столбцу COL1:
                <programlisting language="sql">
SELECT * 
FROM T1
ORDER BY COL1
FETCH FIRST 10 ROWS ONLY                
            </programlisting>
            </para>
            <para>Использование предложений OFFSET и FETCH в производной таблице, результат которой
                ограничивается ещё раз во внешнем запросе.
                <programlisting language="sql">
SELECT * 
FROM (
  SELECT * 
  FROM T1
  ORDER BY COL1 DESC
  OFFSET 1 ROW
  FETCH NEXT 10 ROWS ONLY
) a
ORDER BY a.COL1
FETCH FIRST ROW ONLY                
            </programlisting>
            </para>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="dml-select-rows">ROWS</link>, <link
                        linkend="dml-select-first_skip">FIRST, SKIP</link>. </para>

            </formalpara>
        </section>

        <section xml:id="dml-select-for_update">
            <info>
                <title>FOR UPDATE [OF]</title>
            </info>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>FOR UPDATE</secondary>
            </indexterm>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT ... 
FROM <replaceable>single_table</replaceable> 
[WHERE ...] 
[FOR UPDATE [OF <replaceable>&lt;column-names&gt;</replaceable>]] 
                    </programlisting>
                </para>
            </formalpara>

            <para>Предложение FOR UPDATE не делает то, что от него ожидается. В настоящее время
                единственный эффект от его использования заключается лишь в отключении упреждающей
                выборки в буфер.</para>

            <tip>
                <para>Это, вероятно, изменится в будущем: план состоит в том, чтобы проверять
                    курсоры, отмеченные как FOR UPDATE, действительно ли они обновляемые, и
                    отклонять позиционированные обновления и удаления для курсоров, оцененных как
                    необновляемый. </para>
            </tip>

            <para>Предложение OF не делает ничего вообще.</para>
        </section>

        <section xml:id="dml-select-with_lock">
            <info>
                <title>WITH LOCK</title>
            </info>
            <indexterm>
                <primary>SELECT</primary>
                <secondary>WITH LOCK</secondary>
            </indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Пессимистическая блокировка.</para>
            </formalpara>
            <para>Опция WITH LOCK, обеспечивает возможность ограниченной явной пессимистической
                блокировки для осторожного использования в затронутых наборах строк:<itemizedlist
                    spacing="compact">
                    <listitem>
                        <para>крайне малой выборки (в идеале из одной строки) и</para>
                    </listitem>
                    <listitem>
                        <para>при контроле из приложения.</para>
                    </listitem>
                </itemizedlist></para>
            <caution>
                <title>Только для экспертов</title>

                <para>Пессимистическая блокировка редко требуется при работе с Firebird. Эту функцию
                    можно использовать только хорошо понимая её. </para>
                <para>Требуется хорошее знание различных уровней изоляции и других параметров
                    транзакций прежде чем использовать явную блокировку в вашем приложении. </para>
            </caution>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT ... 
FROM <replaceable>single_table</replaceable> 
[WHERE ...] 
[FOR UPDATE [OF <replaceable>&lt;column-names&gt;</replaceable>]] 
WITH LOCK    
                    </programlisting>
                </para>
            </formalpara>

            <para>При успешном выполнении предложения WITH LOCK будут заблокированы выбранные строки
                данных и таким образом запрещён доступ на их изменение в рамках других транзакций до
                момента завершения вашей транзакции.</para>

            <para>Предложение WITH LOCK доступно только для выборки данных (SELECT) из одной
                таблицы. Предложение WITH LOCK нельзя использовать: <itemizedlist spacing="compact">
                    <listitem>
                        <para>в подзапросах;</para>
                    </listitem>
                    <listitem>
                        <para>в запросах с объединением нескольких таблиц (JOIN);</para>
                    </listitem>
                    <listitem>
                        <para>с оператором DISTINCT, предложением GROUP BY и при использовании любых
                            агрегатных функций;</para>
                    </listitem>
                    <listitem>
                        <para>при работе с представлениями;</para>
                    </listitem>
                    <listitem>
                        <para>при выборке данных из селективных хранимых процедур;</para>
                    </listitem>
                    <listitem>
                        <para>при работе с внешними таблицами.</para>
                    </listitem>
                </itemizedlist></para>

            <para>Сервер, в свою очередь, для каждой записи, подпадающей под явную блокировку,
                возвращает версию записи, которая является в настоящее время подтверждённой
                (актуальной), независимо от состояния базы данных, когда был выполнен оператор
                выборки данных, или исключение при попытке обновления заблокированной записи.</para>

            <para>Ожидаемое поведение и сообщения о конфликте зависят от параметров транзакции,
                определённых в TPB (Transaction Parameters Block):<table frame="all">
                    <title>Влияние параметров TPB на явную блокировку</title>
                    <tgroup cols="2">
                        <colspec colname="tpbmode" colnum="1" colwidth="1.2*"/>
                        <colspec colname="behaviour" colnum="2" colwidth="2.8*"/>
                        <thead>
                            <row>
                                <entry>
                                    <emphasis role="bold">Режим TPB</emphasis>
                                </entry>
                                <entry>
                                    <emphasis role="bold">Поведение</emphasis>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>isc_tpb_consistency</entry>
                                <entry>Явные блокировки переопределяются неявными или явными
                                    блокировками табличного уровня и игнорируются.</entry>
                            </row>
                            <row>
                                <entry>
                                    <para>isc_tpb_concurrency</para>
                                    <para>+ isc_tpb_nowait</para>
                                </entry>
                                <entry>При подтверждении изменения записи в транзакции, стартовавшей
                                    после транзакции, запустившей явную блокировку, немедленно
                                    возникает исключение конфликта обновления.</entry>
                            </row>
                            <row>
                                <entry>
                                    <para>isc_tpb_concurrency</para>
                                    <para>+ isc_tpb_wait</para>
                                </entry>
                                <entry>
                                    <para>При подтверждении изменения записи в транзакции,
                                        стартовавшей после транзакции, запустившей явную блокировку,
                                        немедленно возникает исключение конфликта обновления.</para>
                                    <para>Если в активной транзакции идёт редактирование записи (с
                                        использованием явной блокировки или нормальной
                                        оптимистической блокировкой записи), то транзакция, делающая
                                        попытку явной блокировки, ожидает окончания транзакции
                                        блокирования и, после её завершения, снова пытается получить
                                        блокировку записи. Это означает, что при изменении версии
                                        записи и подтверждении транзакции с блокировкой возникает
                                        исключение конфликта обновления. </para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>isc_tpb_read_committed</para>
                                    <para>+ isc_tpb_nowait</para>
                                </entry>
                                <entry>Если есть активная транзакция, редактирующая запись (с
                                    использованием явной блокировки или нормальной оптимистической
                                    блокировкой записи), то сразу же возникает исключение конфликта
                                    обновления. </entry>
                            </row>
                            <row>
                                <entry>
                                    <para>isc_tpb_read_committed</para>
                                    <para>+ isc_tpb_wait</para>
                                </entry>
                                <entry>
                                    <para>Если в активной транзакции идёт редактирование записи (с
                                        использованием явной блокировки или нормальной
                                        оптимистической блокировкой записи), то транзакция, делающая
                                        попытку явной блокировки, ожидает окончания транзакции
                                        блокирования и, после её завершения, снова пытается получить
                                        блокировку записи.</para>
                                    <para>Для этого режима TPB никогда не возникает конфликта
                                        обновления.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table></para>

            <section xml:id="dml-select-with_lock-for_update">
                <title>Использование предложения FOR UPDATE</title>

                <para>Если предложение FOR UPDATE предшествует предложению WITH LOCK, то буферизация
                    выборки не используется. Таким образом, блокировка применяется к каждой строке,
                    одна за другой, по мере извлечения записей. Это делает возможным ситуацию, в
                    которой успешная блокировка данных <emphasis role="italic">перестаёт
                        работать</emphasis> при достижении в выборке строки, заблокированной другой
                    транзакцией.</para>

                <tip>
                    <para>Кроме того, некоторые компоненты доступа позволяют установить размер
                        буфера выборки и уменьшить его до 1 записи. Это позволяет вам заблокировать
                        и редактировать строку до выборки и блокировки следующей или обрабатывать
                        ошибки, не отменяя действий вашей транзакции.</para>
                </tip>

                <note>
                    <para>Опциональное предложение <quote>OF &lt;column-names&gt;</quote> не делает
                        ничего вообще.</para>
                </note>
            </section>

            <section xml:id="dml-select-with_lock-how_work">
                <title>Как сервер работает с WITH LOCK</title>

                <para>Попытка редактирования записи с помощью оператора UPDATE, заблокированной
                    другой транзакцией, приводит к вызову исключения конфликта обновления или
                    ожиданию завершения блокирующей транзакции – в зависимости от режима TPB.
                    Поведение сервера здесь такое же, как если бы эта запись уже была изменена
                    блокирующей транзакцией.</para>
                <para>Нет никаких специальных кодов gdscode, возвращаемых для конфликтов обновления,
                    связанных с пессимистической блокировкой.</para>
                <para>Сервер гарантирует, что все записи, возвращённые явным оператором блокировки,
                    фактически заблокированы и действительно соответствуют условиям поиска, заданным
                    в операторе WHERE, если эти условия не зависят ни от каких других таблиц, не
                    имеется операторов соединения, подзапросов и т.п. Это также гарантирует то, что
                    строки, не попадающие под условия поиска, не будут заблокированы. Это не даёт
                    гарантии, что нет строк, которые попадают под условия поиска, и не
                    заблокированы.</para>
                <note>
                    <para>Такая ситуация может возникнуть, если в другой, параллельной транзакции 
                        подтверждаются изменения в процессе выполнения текущего оператора
                        блокировки.</para>
                </note>
                <para>Сервер блокирует строки по мере их выборки. Это имеет важные последствия, если
                    вы блокируете сразу несколько строк. Многие методы доступа к базам данных
                    Firebird по умолчанию используют для выборки данных пакеты из нескольких сотен
                    строк (так называемый "буфер выборки"). Большинство компонентов доступа к данным
                    не выделяют строки, содержащиеся в последнем принятом пакете, и для которых
                    произошёл конфликт обновления. </para>
            </section>

            <section xml:id="dml-select-with_lock-caveats">
                <title>Предостережения при использовании WITH LOCK</title>

                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Откат неявной или явной точки сохранения отменяет блокировку
                                записей, которые изменялись в рамках её действий, но ожидающие
                                окончания блокировки транзакции при этом не уведомляются. Приложения
                                не должны зависеть от такого поведения, поскольку в будущем оно
                                может быть изменено; </para>
                        </listitem>
                        <listitem>
                            <para>Хотя явные блокировки могут использоваться для предотвращения
                                и/или обработки необычных ошибок конфликтов обновления, объем ошибок
                                обновления (deadlock) вырастет, если вы тщательно не разработаете
                                свою стратегию блокировки и не будете ей строго управлять; </para>
                        </listitem>
                        <listitem>
                            <para>Большинство приложений не требуют явной блокировки записей.
                                Основными целями явной блокировки являются: 1) предотвращение
                                дорогостоящей обработки ошибок конфликта обновления в сильно
                                загруженных приложениях и 2) для поддержания целостности объектов,
                                отображаемых из реляционной базы данных в кластеризируемой среде.
                                Если использование вами явной блокировки не подпадает под одну из
                                этих двух категорий, то это является неправильным способом решения
                                задач в Firebird; </para>
                        </listitem>
                        <listitem>
                            <para>Явная блокировка — это расширенная функция; не злоупотребляйте её
                                использованием! В то время как явная блокировка может быть очень
                                важной для веб-сайтов, обрабатывающих тысячи параллельных пишущих
                                транзакций или для систем типа ERP/CRM, работающих в крупных
                                корпорациях, большинство прикладных программ не требуют её
                                использования. </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>

            <simplesect>
                <title>Примеры использования явной блокировки</title>

                <orderedlist numeration="lowerroman">
                    <listitem>
                        <para>Одиночная:</para>
                        <programlisting language="sql">
SELECT * 
FROM DOCUMENT
WHERE DOCUMENT_ID=? WITH LOCK                            
                        </programlisting>
                    </listitem>
                    <listitem>
                        <para>Несколько строк с последовательной их обработкой с курсором
                            DSQL:</para>
                        <programlisting language="sql">
SELECT * 
FROM DOCUMENT 
WHERE PARENT_ID=?
FOR UPDATE WITH LOCK  
</programlisting>
                    </listitem>
                </orderedlist>
            </simplesect>
        </section>

        <section xml:id="dml-select-into">
            <title>INTO</title>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>INTO</secondary>
            </indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Передача результатов SELECT в переменные.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
SELECT [...] <replaceable>&lt;column-list&gt;</replaceable>   
FROM ...   
[...]   
[INTO <replaceable>&lt;variable-list&gt;</replaceable>]       

<replaceable>&lt;variable-list&gt;</replaceable> ::= [:]<replaceable>psqlvar</replaceable> [, [:]<replaceable>psqlvar</replaceable> ...]    
                    </programlisting>
                </para>
            </formalpara>

            <para>В PSQL (хранимых процедурах, триггерах и др.) результаты выборки команды SELECT
                могут быть построчно загружены в локальные переменные (число, порядок и типы
                локальных переменных должны соответствовать полям SELECT). Часто такая загрузка –
                единственный способ что-то сделать с возвращаемыми значениями. </para>

            <para>Простой оператор SELECT может быть использован в PSQL, только если он возвращает
                не более одной строки, то есть, если это запрос типа singleton (одиночка). Для
                запросов, возвращающих несколько строк, PSQL предлагает использовать оператор <link
                    linkend="psql-statements-forselect">FOR SELECT</link>.  </para>

            <important>
                <para>В случае, когда запрос не возвращает данных (ноль строк), значения переменных
                    в списке INTO <replaceable>&lt;variable-list&gt;</replaceable> не
                    изменяется.</para>
            </important>

            <para>Также, PSQL поддерживает оператор <link linkend="psql-statements-declare-cursor"
                    >DECLARE CURSOR</link>, который связывает именованный курсор с определенной
                командой SELECT — и этот курсор впоследствии может быть использован для навигации по
                возвращаемому набору данных.</para>
            <para>В PSQL выражение INTO должно появляться в самом конце команды SELECT.  </para>

            <important>
                <title>Обратите внимание.</title>
                <para>В PSQL двоеточие перед именами переменных является опциональным.</para>
            </important>

            <bridgehead renderas="sect4">Примеры</bridgehead>

            <para>В PSQL, можно присвоить значения min_amt, avg_amt и max_amt заранее объявленным
                переменным или выходным параметрам:
                <programlisting language="sql">
SELECT 
  MIN(amount), 
  AVG(CAST(amount AS float)), 
  MAX(amount)
FROM orders
WHERE artno = 372218
INTO min_amt, 
     avg_amt, 
     max_amt;                
            </programlisting>
            </para>
            <para>В данном запросе CAST служит для корректного вычисления среднего значения. Если не
                привести значение к float, то среднее значение будет обрезано до ближайшего целого
                значения.</para>
            <para> В триггере:
                <programlisting language="sql">
SELECT LIST(name, ', ')
FROM persons p
WHERE p.id IN (new.father, new.mother)
INTO new.parentnames;                
            </programlisting>
            </para>
        </section>
        <section xml:id="dml-select-cte">
            <info>
                <title>Общие табличные выражения CTE (&quot;WITH ... AS ... SELECT&quot;)</title>

                <keywordset>
                    <keyword>CTE</keyword>
                    <keyword>WITH</keyword>
                    <keyword>RECURSIVE</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>SELECT</primary>
                <secondary>WITH</secondary>
            </indexterm>

            <para>Общие табличные выражения (Common Table Expressions), сокращённо
                    <abbrev>CTE</abbrev>, описаны как виртуальные таблицы или представления,
                определённые в преамбуле основного запроса, которые участвуют в основном запросе.
                Основной запрос может ссылаться на любое CTE из определённых в преамбуле, как и при
                выборке данных из обычных таблиц или представлений. CTE могут быть рекурсивными,
                т.е. ссылающимися сами на себя, но не могут быть вложенными.</para>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>
<replaceable>&lt;cte-construct&gt;</replaceable> ::= 
  <replaceable>&lt;cte-defs&gt;</replaceable>                      
  <replaceable>&lt;main-query&gt;</replaceable>  

<replaceable>&lt;cte-defs&gt;</replaceable> ::= WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]       

<replaceable>&lt;cte&gt;</replaceable> ::= <replaceable>name</replaceable> [(<replaceable>&lt;column-list&gt;</replaceable>)] AS (<replaceable>&lt;cte-stmt&gt;</replaceable>)       

<replaceable>&lt;column-list&gt;</replaceable> ::= <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]    
                    </programlisting>
                </para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры CTE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>cte-stmt</replaceable></entry>
                                <entry>
                                    <para>Любой оператор SELECT или UNION.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>main-query</replaceable></entry>
                                <entry>
                                    <para>Основной оператор SELECT, который может ссылаться на любое
                                        CTE из найденных в преамбуле. </para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>name</replaceable></entry>
                                <entry>
                                    <para>Алиас табличного выражения.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>column-alias</replaceable></entry>
                                <entry>
                                    <para>Алиас столбца табличного выражения.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para><emphasis>Примеры:</emphasis></para>
            <example>
                <title>Запрос с использованием CTE</title>

                <para>
                    <programlisting language="sql">  
WITH DEPT_YEAR_BUDGET AS (
  SELECT
      FISCAL_YEAR,
      DEPT_NO,
      SUM(PROJECTED_BUDGET) BUDGET
  FROM PROJ_DEPT_BUDGET
  GROUP BY FISCAL_YEAR, DEPT_NO
)
SELECT
    D.DEPT_NO, 
    D.DEPARTMENT,
    DYB_2008.BUDGET BUDGET_08,
    DYB_2009.BUDGET AS BUDGET_09
FROM DEPARTMENT D
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2008
      ON D.DEPT_NO = DYB_2008.DEPT_NO AND
         DYB_2008.FISCAL_YEAR = 2008
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2009
      ON D.DEPT_NO = DYB_2009.DEPT_NO AND
         DYB_2009.FISCAL_YEAR = 2009
WHERE EXISTS (SELECT * 
              FROM PROJ_DEPT_BUDGET B
              WHERE D.DEPT_NO = B.DEPT_NO)
</programlisting>
                </para>
            </example>

            <bridgehead renderas="sect4">Примечания</bridgehead>

            <para><itemizedlist spacing="compact">
                    <listitem>
                        <para>Определение CTE может содержать любой правильный оператор SELECT, если
                            он не содержит преамбулы "WITH ..." (операторы WITH не могут быть
                            вложенными);</para>
                    </listitem>
                    <listitem>
                        <para>CTE могут использовать друг друга, но ссылки не должны иметь
                            циклов;</para>
                    </listitem>
                    <listitem>
                        <para>CTE могут быть использованы в любой части главного запроса или другого
                            табличного выражения и сколько угодно раз;</para>
                    </listitem>
                    <listitem>
                        <para>Основной запрос может ссылаться на CTE несколько раз, но с разными
                            алиасами;</para>
                    </listitem>
                    <listitem>
                        <para>CTE могут быть использованы в операторах INSERT, UPDATE и DELETE как
                            подзапросы;</para>
                    </listitem>
                    <listitem>
                        <para>Если объявленое CTE не использовано, то будет выдано предупреждение
                            "CTE <replaceable>&lt;cte&gt;</replaceable> is not used in query". В
                            более ранних версиях вместо прежупреждения выдавалась ошибка;</para>
                    </listitem>
                    <listitem>
                        <para>CTE могут быть использованы и в PSQL (FOR WITH ... SELECT ... INTO
                            ...):
                            <programlisting language="sql">
FOR 
  WITH MY_RIVERS AS (
      SELECT *
      FROM RIVERS
      WHERE OWNER = 'me')
  SELECT
      NAME, 
      LENGTH
  FROM MY_RIVERS
  INTO :RNAME, 
       :RLEN 
DO
BEGIN
  ...
END                        
                    </programlisting>
                        </para>
                    </listitem>
                </itemizedlist></para>
            <section xml:id="dml-select-cte-recursive">
                <title>Рекурсивные CTE</title>

                <indexterm>
                    <primary>SELECT</primary>
                    <secondary>WITH</secondary>
                    <tertiary>RECURSIVE</tertiary>
                </indexterm>

                <para>Рекурсивное (ссылающееся само на себя) CTE это ОБЪЕДИНЕНИЕ, у которого должен
                    быть, по крайней мере, один не рекурсивный элемент, к которому привязываются
                    остальные элементы объединения. Не рекурсивный элемент помещается в CTE первым.
                    Рекурсивные члены отделяются от не рекурсивных и друг от друга с помощью UNION
                    ALL. Объединение не рекурсивных элементов может быть любого типа.</para>
                <para>Рекурсивное CTE требует наличия ключевого слова RECURSIVE справа от WITH.
                    Каждый рекурсивный член объединения может сослаться на себя только один раз и
                    это должно быть сделано в предложении FROM. </para>
                <para>Главным преимуществом рекурсивных CTE является то, что они используют гораздо
                    меньше памяти и процессорного времени, чем эквивалентные рекурсивные хранимые
                    процедуры.</para>

                <bridgehead renderas="sect4">Выполнение рекурсивного CTE</bridgehead>

                <para>Выполнение рекурсивного CTE с точки зрения сервера Firebird можно описать
                    следующим образом: <itemizedlist spacing="compact">
                        <listitem>
                            <para>Сервер начинает выполнение с не рекурсивного члена;</para>
                        </listitem>
                        <listitem>
                            <para>Для каждой выбранной строки из нерекурсивного части выполняется
                                каждый рекурсивный член один за другим, используя текущие значения
                                из предыдущей итерации как параметры;</para>
                        </listitem>
                        <listitem>
                            <para>Если во время выполнения экземпляр рекурсивного элемента не выдаёт
                                строк, цикл выполнения переходит на предыдущий уровень и получает
                                следующую строку от внешнего для него набора данных.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>Важно отметить, что если СТЕ объявлена, то где-то ниже она обязательно должна
                    быть использована, иначе будет ошибка вида <quote>CTE "AAA" is not used in
                        query</quote>.</para>

                <bridgehead renderas="sect5">Примеры:</bridgehead>

                <example>
                    <title>Рекурсивное CTE</title>
                    <para>
                        <programlisting language="sql">
WITH RECURSIVE DEPT_YEAR_BUDGET AS (
  SELECT
      FISCAL_YEAR, 
      DEPT_NO,
      SUM(PROJECTED_BUDGET) BUDGET
  FROM PROJ_DEPT_BUDGET
  GROUP BY FISCAL_YEAR, DEPT_NO
),
DEPT_TREE AS (
  SELECT
      DEPT_NO, 
      HEAD_DEPT, 
      DEPARTMENT,
      CAST('' AS VARCHAR(255)) AS INDENT
  FROM DEPARTMENT
  WHERE HEAD_DEPT IS NULL
  UNION ALL
  SELECT
      D.DEPT_NO, 
      D.HEAD_DEPT, 
      D.DEPARTMENT,
      H.INDENT || ' '
  FROM DEPARTMENT D 
    JOIN DEPT_TREE H ON H.HEAD_DEPT = D.DEPT_NO
)
SELECT
    D.DEPT_NO, 
    D.INDENT || D.DEPARTMENT DEPARTMENT,
    DYB_2008.BUDGET AS BUDGET_08,
    DYB_2009.BUDGET AS BUDGET_09
FROM DEPT_TREE D
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2008 ON
      (D.DEPT_NO = DYB_2008.DEPT_NO) AND
      (DYB_2008.FISCAL_YEAR = 2008)
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2009 ON
      (D.DEPT_NO = DYB_2009.DEPT_NO) AND
      (DYB_2009.FISCAL_YEAR = 2009)                            
                        </programlisting>
                    </para>
                </example>
                <para>Следующий пример выводит родословную лошади. Основное отличие состоит в том,
                    что рекурсия идёт сразу по двум веткам дерева родословной.
                    <programlisting language="sql">
WITH RECURSIVE PEDIGREE (
    CODE_HORSE,
    CODE_FATHER,
    CODE_MOTHER,
    NAME,
    MARK,
    DEPTH)
AS (SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        CAST('' AS VARCHAR(80)),
        0
    FROM HORSE
    WHERE
        HORSE.CODE_HORSE = :CODE_HORSE
    UNION ALL
    SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        'F' || PEDIGREE.MARK,
        PEDIGREE.DEPTH + 1
    FROM HORSE
        JOIN PEDIGREE 
          ON HORSE.CODE_HORSE = PEDIGREE.CODE_FATHER
    WHERE 
        –- ограничение глубины рекурсии
        PEDIGREE.DEPTH &lt; :MAX_DEPTH 
    UNION ALL
    SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        'M' || PEDIGREE.MARK,
        PEDIGREE.DEPTH + 1
    FROM HORSE
        JOIN PEDIGREE 
          ON HORSE.CODE_HORSE = PEDIGREE.CODE_MOTHER
    WHERE 
        –- ограничение глубины рекурсии
        PEDIGREE.DEPTH &lt; :MAX_DEPTH
)
SELECT
    CODE_HORSE,
    NAME,
    MARK,
    DEPTH
FROM
    PEDIGREE                    
                </programlisting>
                </para>
                <formalpara>
                    <title>Примечания для рекурсивного CTE:</title>
                    <para><itemizedlist spacing="compact">
                            <listitem>
                                <para>В рекурсивных членах объединения не разрешается использовать
                                    агрегаты (DISTINCT, GROUP BY, HAVING) и агрегатные функции (SUM,
                                    COUNT, MAX и т.п.);</para>
                            </listitem>
                            <listitem>
                                <para>Рекурсивная ссылка не может быть участником внешнего
                                    объединения OUTER JOIN;</para>
                            </listitem>
                            <listitem>
                                <para>Максимальная глубина рекурсии составляет 1024;</para>
                            </listitem>
                            <listitem>
                                <para>Рекурсивный член не может быть представлен в виде производной
                                    таблицы.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="dml-insert">
        <info>
            <title>INSERT</title>
            <keywordset>
                <keyword>INSERT INTO</keyword>
                <keyword>DEFAULT VALUES</keyword>
                <keyword>VALUES</keyword>
                <keyword>RETURNING</keyword>
            </keywordset>
        </info>

        <indexterm><primary>INSERT</primary></indexterm>

        <formalpara>
            <title>Назначение:</title>

            <para>Вставка данных в таблицу.</para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL, ESQL, PSQL.</para>
        </formalpara>
        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
INSERT INTO <replaceable>target</replaceable>  
[OVERRIDE {SYSTEM | USER} VALUE]                  
{DEFAULT VALUES | [(<replaceable>&lt;column_list&gt;</replaceable>)] <replaceable>&lt;value_source&gt;</replaceable>}     
[RETURNING {<replaceable>&lt;returning_list&gt;</replaceable> | *} [INTO <replaceable>&lt;variables&gt;</replaceable>]]       

<replaceable>&lt;column_list&gt;</replaceable> ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]       

<replaceable>&lt;value_source&gt;</replaceable> ::= VALUES (<replaceable>&lt;value_list&gt;</replaceable>) | <replaceable>&lt;select_stmt&gt;</replaceable>       

<replaceable>&lt;value_list&gt;</replaceable> ::= {<replaceable>value</replaceable> | DEFAULT} [, {<replaceable>value</replaceable> | DEFAULT} ...]  

<replaceable>&lt;returning_list&gt;</replaceable> ::= 
  <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] [, <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] ...]      

<replaceable>&lt;variables&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]    
            </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора INSERT</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>target</replaceable></entry>
                            <entry>
                                <para>Имя таблицы или представления, в которую происходит вставка
                                    новой записи или записей.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>colname</replaceable></entry>
                            <entry>
                                <para>Столбец таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>value</replaceable></entry>
                            <entry>
                                <para>Выражение, значение которого используется для вставки в
                                    таблицу.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_value</replaceable></entry>
                            <entry>
                                <para>Выражение, возвращаемое в предложении RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним для выражения, возвращаемого в предложении
                                    RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>varname</replaceable></entry>
                            <entry>
                                <para>Имя PSQL переменной.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <para>Оператор INSERT добавляет строки в таблицу, или в одну или более таблиц представления.
            Если значения столбцов указаны в разделе VALUES, то будет вставлена одна строка.
            Значения столбцов также могут быть получены из оператора SELECT, в этом случае может
            быть вставлено от нуля и более строк. В случае DEFAULT VALUES, значения можно не
            указывать, и вставлена будет одна строка.</para>
        <note>
            <para><itemizedlist>
                    <listitem>
                        <para>Один столбец не может быть указан более одного раза в списке
                            столбцов;</para>
                    </listitem>
                    <listitem>
                        <para>При возвращении значений столбцов вставленной записи с помощью INTO в
                            контекстные переменные NEW.<replaceable>columnname</replaceable> в
                            триггерах не должен использоваться префикс двоеточия (":").</para>
                    </listitem>
                </itemizedlist></para>
        </note>
        <section xml:id="dml-insert-values">
            <title>INSERT ... VALUES</title>

            <indexterm>
                <primary>INSERT</primary>
                <secondary>VALUES</secondary>
            </indexterm>

            <para>В списке VALUES должны быть указаны значения для всех столбцов в списке столбцов в
                том же порядке и совместимые по типу. Если список столбцов отсутствует, то значения
                должны быть указаны для каждого столбца таблицы или представления (исключая
                вычисляемые столбцы).</para>

            <note>
                <para><link linkend="common-expr-string-constants-introducer">Вводный
                        синтаксис</link> даёт возможность определить набор символов для значений
                    строковых констант (литералов). Вводный синтаксис работаёт только с литералами
                    строк: он не может быть применён к строковым переменным, параметрам, ссылкам на
                    столбцы или значения, выражениям.</para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <informalexample>
                        <para><programlisting language="sql">
INSERT INTO cars (make, model, byyear)
VALUES ('Ford', 'T', 1908);

INSERT INTO cars
VALUES ('Ford', 'T', 1908, 'USA', 850);

-- обратите внимание на префикс '_' (introducer syntax)
INSERT INTO People
VALUES (_ISO8859_1 'Hans-Jörg Schäfer');             
            </programlisting></para>
                    </informalexample>
                </para>
            </formalpara>

            <section xml:id="dml-insert-values-default">
                <title>Ключевое слово DEFAULT</title>

                <indexterm>
                    <primary>INSERT</primary>
                    <secondary>DEFAULT</secondary>
                </indexterm>

                <para>В списке VALUES вместо значения столбца можно использовать ключевое слово
                    DEFAULT. В этом случае столбец получит значение по умолчанию, указанное при
                    определении целевой таблицы. Если значение по умолчанию для столбца отсутствует,
                    то столбец получит значение NULL.</para>

                <para>Если ключевое слово DEFAULT указано для столбца, определенного как GENERATED
                    BY DEFAULT AS IDENTITY, то столбец получит следующее значение идентификации, так
                    как будто этот столбец не был указан в запросе вовсе.</para>

                <formalpara>
                    <title>Примеры:</title>
                    <para>
                        <informalexample>
                            <para><programlisting language="sql">
CREATE TABLE cars (
  ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
  BYYEAR SMALLINT DEFAULT 1990 NOT NULL,
  NAME VARCHAR(45),
  CONSTRAINT pk_cars PRIMARY KEY (ID)
);                                
 
-- в столбец BYYEAR попадёт значение 1990 
INSERT INTO cars (byyear, name)
VALUES (DEFAULT, 'Ford Focus');
           
-- в столбец id попадёт значение 2, как будто мы не указывали значение для id
INSERT INTO cars (id, byyear, name)
VALUES (DEFAULT, 1996, 'Ford Mondeo');           
            </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="dml-insert-select">
            <title>INSERT ... SELECT</title>

            <indexterm>
                <primary>INSERT</primary>
                <secondary>SELECT</secondary>
            </indexterm>

            <para>В этом случае выходные столбцы оператора SELECT, должны предоставить значения для
                каждого целевого столбца в списке столбцов, в том же порядке и совместимого типа.
                Если список столбцов отсутствует, то значения должны быть предоставлены для каждого
                столбца таблицы или представления (исключая вычисляемые столбцы).</para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <informalexample>
                        <para><programlisting language="sql"><![CDATA[                    
INSERT INTO cars (make, model, byyear)
SELECT make, model, byyear 
FROM new_cars;

INSERT INTO cars
SELECT * 
FROM new_cars;

INSERT INTO Members (number, name)
SELECT number, name 
FROM NewMembers 
WHERE Accepted = 1
UNION ALL
SELECT number, name 
FROM SuspendedMembers 
WHERE Vindicated = 1

INSERT INTO numbers(num)
WITH RECURSIVE r(n) AS (
  SELECT 1 FROM rdb$database
  UNION ALL
  SELECT n+1 FROM r where n < 100
)
SELECT n FROM r
]]></programlisting></para>
                    </informalexample>
                </para>
            </formalpara>
            <para>Конечно, имена столбцов в таблице источнике не обязательно должны быть такими же,
                как и в таблице приёмнике.</para>
            <para>Любой тип оператора SELECT разрешён, пока его выходные столбцы точно соответствуют
                столбцам вставки по числу и типу. Типы не должны быть точно такими же, но они должны
                быть совместимыми по присваиванию.</para>
        </section>
        <section xml:id="dml-insert-defaultvalues">
            <title>INSERT ... DEFAULT VALUES</title>

            <indexterm>
                <primary>INSERT</primary>
                <secondary>DEFAULT VALUES</secondary>
            </indexterm>
            <para>Предложение DEFAULT VALUES позволяет вставлять записи без указания значений
                вообще, ни непосредственно (в предложении VALUES), ни из оператора SELECT. Это
                возможно, только если для каждого NOT NULL поля и полей, на которые наложены другие
                ограничения, или имеются допустимые объявленные значения по умолчанию, или эти
                значения устанавливаются в BEFORE INSERT триггере.</para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <informalexample>
                        <para><programlisting language="sql"><![CDATA[                    
INSERT INTO journal 
DEFAULT VALUES
RETURNING entry_id
]]></programlisting></para>
                    </informalexample>
                </para>
            </formalpara>
        </section>
        <section xml:id="dml-insert-overriding">
            <title>Директива OVERRIDING</title>

            <indexterm>
                <primary>INSERT</primary>
                <secondary>OVERRIDING</secondary>
            </indexterm>
            <para>Значения столбцов идентификации (GENERATED BY DEFAULT AS IDENTITY) могут быть
                переопределены в операторах INSERT, UPDATE OR INSERT, MERGE. Для этого просто
                достаточно указать значение столбца в списке значений. Однако для столбцов
                определённых как GENERATED ALWAYS это недопустимо. Директива OVERRIDING SYSTEM VALUE
                позволяет заменить сгенерированное системой значение на значение указанное
                пользователем. Директива OVERRIDING SYSTEM VALUE вызовет ошибку, если в таблице нет
                столбцов идентификации или если они определены как GENERATED BY DEFAULT AS
                IDENTITY.</para>
            <formalpara>
                <title>Пример:</title>
                <para>
                    <informalexample>
                        <para><programlisting language="sql"><![CDATA[                    
CREATE TABLE objects (
  id INT GENERATED ALWAYS AS IDENTITY, 
  name CHAR(50));
	
-- будет вставлено значение с кодом 11	
INSERT INTO objects (id, name) 
OVERRIDING SYSTEM VALUE 
VALUES (11, 'Laptop');
]]></programlisting></para>
                    </informalexample>
                </para>
            </formalpara>
            <para>Директива OVERRIDE USER VALUE выполняет обратную задачу, т.е. заменяет значение
                указанное пользователем на значение сгенерированное системой, если столбец
                идентификации определён как GENERATED BY DEFAULT AS IDENTITY. Директива OVERRIDING
                USER VALUE вызовет ошибку, если в таблице нет столбцов идентификации или если они
                определены как GENERATED ALWAYS AS IDENTITY.</para>
            <formalpara>
                <title>Пример:</title>
                <para>
                    <informalexample>
                        <para><programlisting language="sql"><![CDATA[                    
CREATE TABLE objects (
  id INT GENERATED BY DEFAULT AS IDENTITY, 
  name CHAR(50));
	
-- значение 12 будет проигнорировано	
INSERT INTO objects (id, name) 
OVERRIDING SYSTEM VALUE 
VALUES (12, 'Laptop');
]]></programlisting></para>
                    </informalexample>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="ddl-table-create-column-identity">Столбцы идентификации
                        (автоинкремент)</link>. </para>
            </formalpara>
        </section>
        <section xml:id="dml-insert-returning">
            <title>RETURNING</title>

            <indexterm>
                <primary>INSERT</primary>
                <secondary>RETURNING</secondary>
            </indexterm>
            <para>Оператор INSERT вставляющий только одну строку может включать необязательное
                предложение RETURNING для возврата значений из вставленной строки. Если предложение
                указано, то оно может содержать любые столбцы, указанные в операторе, или другие
                столбцы и выражения. Вместо списка столбцов вы можете указать звёздочку (*) для
                возврата всех значений столбцов таблицы. Возвращаемые значения содержат все
                изменения, произведённые в триггерах BEFORE.</para>
            <important>
                <para>В DSQL, оператор с RETURNING всегда возвращает только одну строку. Если
                    указано предложение RETURNING, и обнаружено более одной совпадающей строки,
                    выдаётся сообщение об ошибке. Это поведение может быть изменено в последующих
                    версиях Firebird.</para>
            </important>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование предложения RETURNING в операторе INSERT</title>
                        <para><programlisting language="sql"><![CDATA[                    
INSERT INTO Scholars (
  firstname, 
  lastname, 
  address, 
  phone, 
  email)
VALUES (
  'Henry', 
  'Higgins', 
  '27A Wimpole Street', 
  '3231212', 
  NULL)
RETURNING lastname, fullname, id;

INSERT INTO Dumbbells (first_name, last_name, iq)
SELECT fname, lname, iq 
FROM Friends 
ORDER BY iq ROWS 1
RETURNING id, first_name, iq 
INTO :id, :fname, :iq;
]]></programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>Замечания:</title>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Предложение RETURNING поддерживается только для INSERT .. VALUES и
                                одиночных INSERT .. SELECT.</para>
                        </listitem>
                        <listitem>
                            <para>В DSQL оператор с использованием RETURNING всегда возвращает ровно
                                одну строку. Если запись не была вставлена на самом деле, то все
                                поля в возвращаемой строке будут меть значения NULL. Это поведение
                                может быть изменено позже. В PSQL, если ни одна строка не вставлена,
                                то ничего не возвращается и все целевые переменные сохраняют свои
                                прежние значения.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </formalpara>
        </section>
        <simplesect>
            <title>Вставка столбцов BLOB</title>
            <para>Вставка в столбцы BLOB только возможна при следующих обстоятельствах:<orderedlist>
                    <listitem>
                        <para>Клиентское приложение вставляет BLOB посредством Firebird API. В этом
                            случае все зависит от приложения, и не рассматривается в этом
                            руководстве;</para>
                    </listitem>
                    <listitem>
                        <para>Длина строкового литерала не может превышать 32767 байт.</para>
                    </listitem>
                    <listitem>
                        <para>Если источником данных является столбец BLOB или выражение,
                            возвращающее BLOB.</para>
                    </listitem>
                </orderedlist>
            </para>
        </simplesect>
    </section>
    <section xml:id="dml-update">
        <info>
            <title>UPDATE</title>
            <keywordset>
                <keyword>UPDATE</keyword>
            </keywordset>
        </info>
        <indexterm><primary>UPDATE</primary></indexterm>
        <formalpara>
            <title>Назначение:</title>

            <para>Обновление данных в таблице.</para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL, ESQL, PSQL.</para>
        </formalpara>
        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
UPDATE <replaceable>target</replaceable> [[AS] <replaceable>alias</replaceable>]   
SET <replaceable>col</replaceable> = {<replaceable>newval</replaceable> | DEFAULT} [, <replaceable>col</replaceable> = {<replaceable>newval</replaceable> | DEFAULT} ...]   
[WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]   
[PLAN <replaceable>plan_items</replaceable>]   
[ORDER BY <replaceable>sort_items</replaceable>]   
[ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]]   
[RETURNING {<replaceable>&lt;returning_list&gt;</replaceable> | [{OLD. | NEW.}]*} [INTO <replaceable>&lt;variables&gt;</replaceable>]]  

<replaceable>&lt;returning_list&gt;</replaceable> ::= 
  <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] [, <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] ...]        

<replaceable>&lt;variables&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]         
            </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора UPDATE</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>target</replaceable></entry>
                            <entry>
                                <para>Имя таблицы или представления, в которой происходит обновление
                                    записей.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>col</replaceable></entry>
                            <entry>
                                <para>Столбец таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>newval</replaceable></entry>
                            <entry>
                                <para>Новые значения обновляемых столбцов в таблице
                                    (представлении).</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>search-conditions</replaceable></entry>
                            <entry>
                                <para>Условие поиска, ограничивающее набор обновляемых строк.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>cursorname</replaceable></entry>
                            <entry>
                                <para>Имя курсора, по которому позиционируется обновляемая
                                    запись.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>plan_items</replaceable></entry>
                            <entry>
                                <para>Предложение плана.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>sort_items</replaceable></entry>
                            <entry>
                                <para>Предложение сортировки.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>m</replaceable>,
                                <replaceable>n</replaceable></entry>
                            <entry>
                                <para>Целочисленные выражения для ограничения количества обновляемых
                                    строк.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_value</replaceable></entry>
                            <entry>
                                <para>Выражение, возвращаемое в предложении RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним для выражения, возвращаемого в предложении
                                    RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>varname</replaceable></entry>
                            <entry>
                                <para>Имя PSQL переменной.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <para>Изменяет значения в одной таблице или в большем количестве таблиц в
            представлении.</para>
        <para>Если вы назначаете псевдоним таблице или представлению, вы обязаны использовать
            псевдоним для уточнения столбцов таблицы.</para>
        <section xml:id="dml-update-set">
            <title>SET</title>

            <para>Изменяемые столбцы указываются в предложении SET. Столбцы и их значения
                перечисляются через запятую. Слева имя столбца, и справа значение или выражение. </para>
            <para>Разрешено использовать имена столбцов в выражениях справа. При этом использоваться
                будет всегда старое значение столбца, даже если присваивание этому столбцу уже
                произошло ранее в перечислении SET. Один столбец может быть использован только один
                раз в конструкции SET. </para>
            <formalpara>
                <title>Пример:</title>
                <para>
                    <informalexample>
                        <para> Данные в таблице TSET:
                            <screen>
A B
----
1 0
2 0                    
                </screen>
                            После выполнения оператора <programlisting language="sql">
update tset set a = 5, b = a                    
                </programlisting>
                            <screen>
A B
----
5 1
5 2                   
                </screen>
                            Обратите внимание, что старые значения (1 и 2) используются для
                            обновления столбца b, даже после того как столбцу a были назначено новое
                            значение (5). </para>
                    </informalexample>
                </para>
            </formalpara>

            <section xml:id="dml-update-set-default">
                <title>Ключевое слово DEFAULT</title>

                <indexterm>
                    <primary>UPDATE</primary>
                    <secondary>DEFAULT</secondary>
                </indexterm>

                <para>В предложении SET вместо значения столбца можно использовать ключевое слово
                    DEFAULT. В этом случае столбец получит значение по умолчанию, указанное при
                    определении целевой таблицы. Если значение по умолчанию для столбца отсутствует,
                    то столбец получит значение NULL.</para>


                <formalpara>
                    <title>Примеры:</title>
                    <para>
                        <informalexample>
                            <para><programlisting language="sql">
CREATE TABLE cars (
  ID INTEGER NOT NULL,
  BYYEAR SMALLINT DEFAULT 1990 NOT NULL,
  NAME VARCHAR(45),
  CONSTRAINT pk_cars PRIMARY KEY (ID)
);                                
 
INSERT INTO cars (1, byyear, name)
VALUES (1, 1985, 'Ford Focus');
           
-- столбцу BYYEAR будет присвоено значение 1990 
UPDATE cars
SET BYYEAR = DEFAULT
WHERE ID = 1;
            </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="dml-update-where">
            <info>
                <title>WHERE</title>
                <keywordset>
                    <keyword>UPDATE</keyword>
                    <keyword>WHERE</keyword>
                </keywordset>
            </info>

            <para>Предложение WHERE ограничивает набор обновляемых записей заданным условием, или –
                в PSQL – текущей строкой именованного курсора, если указано предложение WHERE
                CURRENT OF.</para>
            <note>
                <para>Предложение WHERE CURRENT OF используется только в PSQL, т.к. в DSQL нет
                    оператора DSQL для создания курсора. </para>
            </note>
            <para>Строковые литералы могут предваряться именем набора символов, для того чтобы
                Firebird понимал, как интерпретировать данные. </para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <informalexample>
                        <para>
                            <programlisting language="sql">
UPDATE addresses
SET city = 'Saint Petersburg', citycode = 'PET'
WHERE city = 'Leningrad';
                
UPDATE employees
SET salary = 2.5 * salary
WHERE title = 'CEO';
    

-- обратите внимание на префикс '_'            
UPDATE People
SET name = _ISO8859_1 'Hans-Jörg Schäfer' 
WHERE id = 53662;

UPDATE employee e
SET salary = salary * 1.05
WHERE EXISTS(
  SELECT *
  FROM employee_project ep
  WHERE e.emp_no = ep.emp_no);   
</programlisting>
                        </para>
                    </informalexample>
                </para>
            </formalpara>
        </section>
        <section xml:id="dml-update-plan">
            <title>PLAN</title>
            <indexterm>
                <primary>UPDATE</primary>
                <secondary>PLAN</secondary>
            </indexterm>
            <para>Предложение PLAN позволяет вручную указать план для оптимизатора.</para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <informalexample>
                        <para>
                            <programlisting language="sql">
UPDATE company c SET c.company_name = 
    ( SELECT k.contact_name 
      FROM contact k 
      WHERE k.id = c.contact_id
      PLAN (K INDEX (CONTACT_ID)))
WHERE c.company_name IS NULL OR c.company_name = ''
PLAN (C NATURAL)                                 
                            </programlisting>
                        </para>
                    </informalexample>
                </para>
            </formalpara>
        </section>
        <section xml:id="dml-update-orderby">
            <title>ORDER BY и ROWS</title>
            <para>Предложение ORDER BY позволяет задать порядок обновления записей. Это может иметь
                значение в некоторых случаях.</para>
            <para>Предложение ROWS имеет смысл только вместе с предложением ORDER BY. Однако его
                можно использовать отдельно.</para>
            <para>При одном аргументе <replaceable>m</replaceable>, ROWS ограничивает update первыми
                    <replaceable>m</replaceable> строками. Особенности: <itemizedlist
                    spacing="compact">
                    <listitem>
                        <para>Если <replaceable>m</replaceable> > количества обрабатываемых строк,
                            то обновляется весь набор строк;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>m</replaceable> = 0, ни одна строка не
                            обновляется;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>m</replaceable> &lt; 0, выдаётся ошибка.</para>
                    </listitem>
                </itemizedlist></para>
            <para>При двух аргументах <replaceable>m</replaceable> и <replaceable>n</replaceable>,
                ROWS ограничивает update до строк от <replaceable>m</replaceable> до
                    <replaceable>n</replaceable> включительно. Оба аргумента – целочисленные, и
                начинаются с 1. Особенности: <itemizedlist spacing="compact">
                    <listitem>
                        <para>Если <replaceable>m</replaceable> > количества обрабатываемых строк,
                            ни одна строка не обновляется;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>n</replaceable> больше количества строк, то
                            обновляются строки от <replaceable>m</replaceable> до конца
                            набора;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>m</replaceable> &lt; 1 или
                                <replaceable>n</replaceable> &lt; 1, выдаётся ошибка;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>n</replaceable> = <replaceable>m</replaceable> - 1,
                            ни одна строка не обновляется;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>n</replaceable> &lt; <replaceable>m</replaceable> -
                            1, выдаётся ошибка.</para>
                    </listitem>
                </itemizedlist></para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование предложения ROWS в операторе UPDATE</title>
                        <para>
                            <programlisting language="sql">
-- дать надбавку 20ти сотрудникам с наименьшей зарплатой 
UPDATE employees
SET salary = salary + 50
ORDER BY salary ASC
ROWS 20;
                </programlisting>
                        </para>
                    </example>
                </para>
            </formalpara>
        </section>

        <section xml:id="dml-update-returning">
            <title>RETURNING</title>
            <para>Оператор UPDATE, обновляющий максимум одну строку, может включать RETURNING для
                возврата значений из обновляемой строки. В RETURNING могут включаться любые строки,
                необязательно только те, которые обновляются.</para>
            <para>Возвращаемые значения содержат изменения, произведённые в триггерах BEFORE, но не
                в триггерах AFTER. <code>OLD.<replaceable>fieldname</replaceable></code> и
                        <code>NEW.<replaceable>fieldname</replaceable></code> могут быть
                использованы в качестве имён столбцов. Если <code>OLD.</code> или <code>NEW.</code>
                не указано, возвращаются новые значения столбцов (NEW.).</para>
            <para>Вместо списка столбцов вы можете указать звёздочку (*). В этом случае будут
                возвращены все значения столбцов таблицы. Звёздочку можно применять со
                спецификаторами NEW или OLD.</para>
            <note>
                <para>В DSQL оператор с RETURNING всегда возвращает только одну строку. Если записи
                    не были обновлены оператором, то возвращаемые значения содержат NULL. Это
                    поведение может быть изменено в последующих версиях Firebird.</para>
            </note>

            <section xml:id="dml-update-returning-into">
                <title>INTO</title>
                <para>Предложение INTO предназначено для передачи значений в локальные переменные.
                    Оно доступно только в PSQL. Если записи не было обновлены, ничего не
                    возвращается, и переменные, указанные в RETURING, сохранят свои прежние
                    значения.</para>
                <example>
                    <title>Использование предложения RETURNING в операторе UPDATE</title>
                    <para>
                        <programlisting language="sql">
UPDATE Scholars
SET first_name = 'Hugh', last_name = 'Pickering'
WHERE first_name = 'Henry' AND last_name = 'Higgins'
RETURNING id, old.last_name, new.last_name;
                </programlisting>
                    </para>
                </example>
                <example>
                    <title>Использование * в предложении RETURNING в операторе UPDATE</title>
                    <para>
                        <programlisting language="sql">
UPDATE Scholars
SET first_name = 'Hugh', last_name = 'Pickering'
WHERE first_name = 'Henry' AND last_name = 'Higgins'
RETURNING old.*;
                </programlisting>
                    </para>
                </example>
            </section>
        </section>
        <simplesect>
            <title>Обновление столбцов BLOB</title>
            <para>Обновление столбцов BLOB всегда полностью меняет их содержимое. Даже идентификатор
                BLOB (ID), который является ссылкой на данные BLOB и хранится в столбце, меняется.
                BLOB могут быть изменены, если:<orderedlist>
                    <listitem>
                        <para>Клиентское приложение меняет BLOB посредством Firebird API. В этом
                            случае все зависит от приложения, и не рассматривается в этом
                            руководстве;</para>
                    </listitem>
                    <listitem>
                        <para>Длина строкового литерала не может превышать 65535 байт;</para>
                    </listitem>
                    <listitem>
                        <para>Если источником данных является столбец BLOB или выражение,
                            возвращающее BLOB.</para>
                    </listitem>
                </orderedlist>
            </para>
        </simplesect>
    </section>

    <section xml:id="dml-upsert">
        <info>
            <title>UPDATE OR INSERT</title>
            <keywordset>
                <keyword>UPDATE OR INSERT</keyword>
            </keywordset>
        </info>

        <indexterm><primary>UPDATE OR INSERT</primary></indexterm>

        <formalpara>
            <title>Назначение:</title>

            <para>Добавление новой или обновление существующей записи в таблице.</para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL, PSQL.</para>
        </formalpara>

        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
UPDATE OR INSERT INTO <replaceable>target</replaceable> [(<replaceable>&lt;column_list&gt;</replaceable>)] 
VALUES (<replaceable>&lt;value_list&gt;</replaceable>)  
[MATCHING (<replaceable>&lt;column_list&gt;</replaceable>)]       
[RETURNING {<replaceable>&lt;returning_list&gt;</replaceable> | [{OLD. | NEW.}]*} [INTO <replaceable>&lt;variables&gt;</replaceable>]]       

<replaceable>&lt;column_list&gt;</replaceable> ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]       

<replaceable>&lt;value_list&gt;</replaceable> ::= {<replaceable>value</replaceable> | DEFAULT} [, {<replaceable>value</replaceable> | DEFAULT} ...] 

<replaceable>&lt;returning_list&gt;</replaceable> ::= 
  <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] [, <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] ...]       

<replaceable>&lt;variables&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]    
            </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора UPDATE OR INSERT</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>target</replaceable></entry>
                            <entry>
                                <para>Имя таблицы или представления, запись в которой будет
                                    обновлена или произойдет вставка новой записи.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>colname</replaceable></entry>
                            <entry>
                                <para>Столбец таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>value</replaceable></entry>
                            <entry>
                                <para>Выражение, значение которого используется для вставки или
                                    обновления таблицы.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_value</replaceable></entry>
                            <entry>
                                <para>Выражение, возвращаемое в предложении RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним для выражения, возвращаемого в предложении
                                    RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>varname</replaceable></entry>
                            <entry>
                                <para>Имя PSQL переменной.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <para>Оператор UPDATE OR INSERT вставляет или обновляет одну или более существующих записей.
            Производимое действие зависит от значений столбцов в предложении MATCHING (или, если оно
            не указано, то от значений столбцов первичного ключа — PK). Если найдены записи,
            совпадающие с указанными значениями, то они обновляются. Если нет, то вставляется новая
            запись. </para>
        <para>Совпадением считается полное совпадение значений столбцов MATCHING или PK. Совпадение
            проверяется с использованием IS NOT DISTINCT, поэтому NULL совпадает с NULL.</para>
        <note>
            <title>Ограничения</title>
            <para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>Если у таблицы нет первичного ключа, то указание MATCHING считается
                            обязательным;</para>
                    </listitem>
                    <listitem>
                        <para>В списке MATCHING, так же как и в списке столбцов update/insert,
                            каждый столбец может быть упомянут только один раз;</para>
                    </listitem>
                    <listitem>
                        <para>Предложение INTO доступно только в PSQL.</para>
                    </listitem>
                    <listitem>
                        <para>У столбцов, возвращаемых в контекстные переменные NEW в триггере,
                            перед именем не должно использоваться двоеточие.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </note>
        <section xml:id="dml-upsert-default">
            <title>Ключевое слово DEFAULT</title>

            <indexterm>
                <primary>UPDATE OR INSERT</primary>
                <secondary>DEFAULT</secondary>
            </indexterm>

            <para>В списке VALUES вместо значения столбца можно использовать ключевое слово DEFAULT.
                В этом случае столбец получит значение по умолчанию, указанное при определении
                целевой таблицы. Если значение по умолчанию для столбца отсутствует, то столбец
                получит значение NULL.</para>

            <note>
                <title>Ограничение</title>
                <para>Столбец для которого вместо значения использовано ключевое слово DEFAULT не
                    может быть использован предложении MATCHING.</para>
            </note>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <informalexample>
                        <para><programlisting language="sql">
CREATE TABLE cars (
  ID INTEGER GENERATED BY DEFAULT AS IDENTITY,
  BYYEAR SMALLINT DEFAULT 1990 NOT NULL,
  NAME VARCHAR(45),
  CONSTRAINT pk_cars PRIMARY KEY (ID)
);                                
 
-- в столбец BYYEAR попадёт значение 1990 
UPDATE OR INSERT INTO cars (byyear, name)
VALUES (DEFAULT, 'Ford Focus')
MATCHING (name);                 
            </programlisting></para>
                    </informalexample>
                </para>
            </formalpara>
        </section>
        <section xml:id="dml-tbl-upsert-returning">
            <title>RETURNING</title>
            <indexterm>
                <primary>UPDATE OR INSERT</primary>
                <secondary>RETURNING</secondary>
            </indexterm>
            <para>Предложение RETURNING может содержать любые столбцы, указанные в операторе, или
                другие столбцы и выражения. Возвращаемые значения содержат все изменения,
                произведённые в триггерах BEFORE, но не в триггерах AFTER.
                        <code>OLD.<replaceable>fieldname</replaceable></code> и
                        <code>NEW.<replaceable>fieldname</replaceable></code> могут быть
                использованы в качестве возвращаемых значений. Для обычных имён столбцов
                возвращаются новые значения.</para>
            <para>Вместо списка столбцов вы можете указать звёздочку (*). В этом случае будут
                возвращены все значения столбцов таблицы. Звёздочку можно применять со
                спецификаторами NEW или OLD.</para>
            <note>
                <para>В DSQL, оператор с RETURNING всегда возвращает только одну строку. Если
                    присутствует предложение RETURNING, и обнаружено более одной совпадающей строки,
                    выдаётся сообщение об ошибке. Это поведение может быть изменено в последующих
                    версиях Firebird.</para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>Использование оператора UPDATE OR INSERT <informalexample>
                        <para><programlisting language="sql">
UPDATE OR INSERT INTO Cows (Name, Number, Location)
VALUES ('Suzy Creamcheese', 3278823, 'Green Pastures')
MATCHING (Number)
RETURNING rec_id 
INTO :id;            
            </programlisting></para>
                    </informalexample>
                </para>
            </formalpara>
        </section>
    </section>
    <section xml:id="dml-delete">
        <info>
            <title>DELETE</title>
            <keywordset>
                <keyword>DELETE</keyword>
            </keywordset>
        </info>

        <indexterm><primary>DELETE</primary></indexterm>

        <formalpara>
            <title>Назначение:</title>

            <para>Удаление данных из таблицы.</para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL, ESQL, PSQL.</para>
        </formalpara>
        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
DELETE
FROM <replaceable>target</replaceable> [[AS] <replaceable>alias</replaceable>]
[WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
[PLAN <replaceable>plan_items</replaceable>]
[ORDER BY <replaceable>sort_items</replaceable>]
[ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]]
[RETURNING {<replaceable>&lt;returning_list&gt;</replaceable> | *} [INTO <replaceable>&lt;variables&gt;</replaceable>]]
 
<replaceable>&lt;returning_list&gt;</replaceable> ::= <replaceable>ret_value</replaceable> [[AS] <replaceable>alias_val</replaceable>] [, <replaceable>ret_value</replaceable> [[AS] <replaceable>alias_val</replaceable>] ...]

<replaceable>&lt;variables&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...] 
            </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора DELETE</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>target</replaceable></entry>
                            <entry>
                                <para>Имя таблицы или представления, из которой удаляются
                                    записи.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>search-conditions</replaceable></entry>
                            <entry>
                                <para>Условие поиска, ограничивающее набор удаляемых строк.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>cursorname</replaceable></entry>
                            <entry>
                                <para>Имя курсора, по которому позиционируется удаляемая
                                    запись.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>plan_items</replaceable></entry>
                            <entry>
                                <para>Предложение плана.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>sort_items</replaceable></entry>
                            <entry>
                                <para>Предложение сортировки.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>m</replaceable>,
                                <replaceable>n</replaceable></entry>
                            <entry>
                                <para>Целочисленные выражения для ограничения количества удаляемых
                                    строк.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_value</replaceable></entry>
                            <entry>
                                <para>Выражение, возвращаемое в предложении RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>alias_val</replaceable></entry>
                            <entry>
                                <para>Псевдоним для выражения, возвращаемого в предложении
                                    RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>varname</replaceable></entry>
                            <entry>
                                <para>Имя PSQL переменной.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <para>Оператор DELETE удаляет строки из таблицы или из одной и более таблиц представления. </para>
        <para>Если для таблицы указан псевдоним, то он должен использоваться для всех столбцов
            таблицы.</para>
        <section xml:id="dml-delete-where">
            <title>WHERE</title>
            <indexterm>
                <primary>DELETE</primary>
                <secondary>WHERE</secondary>
            </indexterm>
            <para>Условие в предложении WHERE ограничивает набор удаляемых строк. Удаляются только
                те строки, которые удовлетворяют условию поиска, или только текущей строке
                именованного курсора.</para>
            <para>Удаление с помощью WHERE CURRENT OF называется <emphasis role="italic"
                    >позиционированным удалением</emphasis> (positioned delete), потому что
                удаляется запись в текущей позиции. Удаление при помощи &quot;WHERE условие&quot;
                называется <emphasis role="italic">поисковым удалением</emphasis> (searched delete),
                поскольку Firebird ищет записи, соответствующие условию.</para>
            <note>
                <para>В чистом DSQL выражение WHERE CURRENT OF не имеет смысла, т.к. в DSQL нет
                    оператора для создания курсора. </para>
            </note>
            <para><emphasis>Примеры:</emphasis></para>
            <example>
                <title>Использование предложения WHERE в операторе DELETE</title>
                <para>
                    <programlisting language="sql"><![CDATA[
DELETE FROM People 
WHERE first_name <> 'Boris' AND last_name <> 'Johnson';
]]></programlisting>
                    <programlisting language="sql"><![CDATA[
DELETE FROM employee e
WHERE NOT EXISTS(
  SELECT *
  FROM employee_project ep
  WHERE e.emp_no = ep.emp_no);
]]></programlisting>
                    <programlisting language="sql"><![CDATA[
DELETE FROM Cities 
WHERE CURRENT OF Cur_Cities; -- только в PSQL
]]></programlisting>
                </para>
            </example>
        </section>
        <section xml:id="dml-delete-plan">
            <title>PLAN</title>
            <indexterm>
                <primary>DELETE</primary>
                <secondary>PLAN</secondary>
            </indexterm>
            <para>Предложение PLAN позволяет вручную указать план для оптимизатора.</para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <informalexample>
                        <para>
                            <programlisting language="sql"><![CDATA[
DELETE FROM Submissions
WHERE date_entered < '1-Jan-2002'
PLAN (Submissions INDEX ix_subm_date)
]]></programlisting>
                        </para>
                    </informalexample>
                </para>
            </formalpara>
        </section>
        <section xml:id="dml-delete-orderby">
            <title>ORDER BY и ROWS</title>
            <indexterm>
                <primary>DELETE</primary>
                <secondary>ORDER BY</secondary>
            </indexterm>
            <indexterm>
                <primary>DELETE</primary>
                <secondary>ROWS</secondary>
            </indexterm>
            <para>Предложение ORDER BY упорядочивает набор перед его удалением. Что может быть важно
                в некоторых случаях. </para>
            <para>Предложение ROWS позволяет ограничить количество удаляемых строк. Имеет смысл
                только в комбинации с предложением ORDER BY, но допустимо и без него.</para>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]                     
            </programlisting></para>
            </formalpara>
            <para>В качестве <replaceable>m</replaceable> и <replaceable>n</replaceable> могут
                выступать любые целочисленные выражения.</para>
            <para>При одном аргументе <replaceable>m</replaceable>, удаляются первые
                    <replaceable>m</replaceable> строк. Порядок строк без ORDER BY не определён
                (случаен).</para>
            <para>Замечания:<itemizedlist spacing="compact">
                    <listitem>
                        <para>Если <replaceable>m</replaceable> больше общего числа строк в наборе,
                            то весь набор удаляется;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>m</replaceable> = 0, то удаление не
                            происходит;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>m</replaceable> &lt; 0, то выдаётся сообщение об
                            ошибке.</para>
                    </listitem>
                </itemizedlist></para>
            <para>Если указаны аргументы <replaceable>m</replaceable> и
                <replaceable>n</replaceable>, удаление ограничено количеством строк от
                    <replaceable>m</replaceable> до <replaceable>n</replaceable>, включительно.
                Нумерация строк начинается с 1. </para>
            <para>Замечания по использованию двух аргументов:<itemizedlist spacing="compact">
                    <listitem>
                        <para> Если <replaceable>m</replaceable> &gt; общего числа строк в наборе,
                            ни одна строка не удаляется; </para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>m</replaceable> > 0 и &lt;= числа строк в наборе, а
                                <replaceable>n</replaceable> вне этих значений, то удаляются строки
                            от m до конца набора;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>m</replaceable> &lt; 1 или n &lt; 1, выдаётся
                            сообщение об ошибке;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>n</replaceable> = <replaceable>m</replaceable> – 1,
                            ни одна строка не удаляется;</para>
                    </listitem>
                    <listitem>
                        <para>Если <replaceable>n</replaceable> &lt; <replaceable>m</replaceable> –
                            1, выдаётся сообщение об ошибке.</para>
                    </listitem>
                </itemizedlist></para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <blockquote>
                        <para>Удаление самой старой покупки
                            <programlisting language="sql">DELETE FROM Purchases ORDER BY ByDate ROWS 1</programlisting>
                            Удаление заказов для 10 клиентов с самыми большими номерами
                            <programlisting language="sql">DELETE FROM Sales ORDER BY custno DESC ROWS 1 TO 10</programlisting>
                            Удаляет все записи из sales, поскольку не указано ROWS
                            <programlisting language="sql">DELETE FROM Sales ORDER BY custno DESC</programlisting>
                            Удаляет одну запись &quot;с конца&quot;, т.е. от Z…
                            <programlisting language="sql">DELETE FROM popgroups ORDER BY name DESC ROWS 1</programlisting>
                            Удаляет пять самых старых групп
                            <programlisting language="sql">DELETE FROM popgroups ORDER BY formed ROWS 5</programlisting>
                            Сортировка (ORDER BY) не указана, поэтому будут удалены 8 обнаруженных
                            записей, начиная с пятой.
                            <programlisting language="sql">DELETE FROM popgroups ROWS 5 TO 12</programlisting>
                        </para>
                    </blockquote>
                </para>
            </formalpara>
        </section>
        <section xml:id="dml-delete-returning">
            <title>RETURNING</title>
            <indexterm>
                <primary>DELETE</primary>
                <secondary>RETURNING</secondary>
            </indexterm>
            <para>Оператор DELETE, удаляющий не более одной строки, может содержать конструкцию
                RETURNING для возвращения значений удаляемой строки. В RETURNING могут быть указаны
                любые столбцы, не обязательно все, а также другие столбцы и выражения. Вместо списка
                столбцов может быть указана звёздочка (*), в этом случае будут возвращаены все
                столбцы удалённой записи.</para>
            <note>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>В DSQL, оператор с RETURNING всегда возвращает только одну строку.
                                Если записи не были удалены, то возвращаемые столбцы содержат NULL.
                                Это поведение может быть изменено в последующих версиях
                                Firebird;</para>
                        </listitem>
                        <listitem>
                            <para>В PSQL, если строка не была удалена, ничего не возвращается, и
                                целевые переменные сохраняют свои значения;</para>
                        </listitem>
                        <listitem>
                            <para>Предложение INTO доступно только в PSQL.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </note>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <programlisting language="sql">
DELETE FROM Scholars
WHERE first_name = 'Henry' AND last_name = 'Higgins'
RETURNING last_name, fullname, id
 
DELETE FROM Dumbbells
ORDER BY iq DESC
ROWS 1
RETURNING last_name, iq 
INTO :lname, :iq;
 
DELETE FRMO TempSales ts
WHERE ts.id = tempid
RETURNING ts.qty 
INTO new.qty;                     
                </programlisting>
                </para>
            </formalpara>
        </section>
    </section>
    <section xml:id="dml-merge">
        <info>
            <title>MERGE</title>
            <keywordset>
                <keyword>MERGE</keyword>
                <keyword>WHEN MATCHED</keyword>
                <keyword>WHEN NOT MATCHED</keyword>
            </keywordset>
        </info>
        <indexterm><primary>MERGE</primary></indexterm>
        <formalpara>
            <title>Назначение:</title>

            <para>Слияние записей источника в целевую таблицу (или обновляемое представление).
            </para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL, PSQL.</para>
        </formalpara>
        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
MERGE INTO <replaceable>target</replaceable> [[AS] <replaceable>target_alias</replaceable>]    
USING <replaceable>&lt;source&gt;</replaceable> [[AS] <replaceable>source_alias</replaceable>] 
ON <replaceable>&lt;join condition&gt;</replaceable>   
<replaceable>&lt;merge when&gt;</replaceable> [<replaceable>&lt;merge when&gt;</replaceable> ...]   
[RETURNING {<replaceable>&lt;returning_list&gt;</replaceable> | [{OLD. | NEW.}]* } [INTO <replaceable>&lt;variable_list&gt;</replaceable>]]       

<replaceable>&lt;merge when&gt;</replaceable> ::= <replaceable>&lt;merge when matched&gt;</replaceable> | <replaceable>&lt;merge when not matched&gt;</replaceable>       

<replaceable>&lt;merge when matched&gt;</replaceable> ::= 
  WHEN MATCHED [ AND <replaceable>&lt;condition&gt;</replaceable> ] 
  THEN { UPDATE SET <replaceable>&lt;assignment_list&gt;</replaceable> | DELETE }       

<replaceable>&lt;merge when not matched&gt;</replaceable> ::=   
  WHEN NOT MATCHED [ AND <replaceable>&lt;condition&gt;</replaceable> ] 
  THEN INSERT [ (<replaceable>&lt;column_list&gt;</replaceable>) ] 
  VALUES (<replaceable>&lt;value_list&gt;</replaceable>)       

<replaceable>&lt;assignment_list&gt;</replaceable> ::= 
  <replaceable>colname</replaceable> = {<replaceable>value</replaceable> | DEFAULT} [, <replaceable>colname</replaceable> = {<replaceable>value</replaceable> | DEFAULT} ...]       

<replaceable>&lt;column_list&gt;</replaceable> ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]       

<replaceable>&lt;value_list&gt;</replaceable> ::= {<replaceable>value</replaceable> | DEFAULT} [, {<replaceable>value</replaceable> | DEFAULT} ...]     

<replaceable>&lt;returning_list&gt;</replaceable> ::= 
  <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] [, <replaceable>ret_value</replaceable> [[AS] <replaceable>ret_alias</replaceable>] ...]    

<replaceable>&lt;variable_list&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]      
            </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора MERGE</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>target</replaceable></entry>
                            <entry>
                                <para>Целевая таблица или обновляемое представление.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>source</replaceable></entry>
                            <entry>
                                <para>Источник данных. Может быть таблицей, представлением, хранимой
                                    процедурой или производной таблицей.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>target_alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним целевой таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>source_alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним источника.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>join condition</replaceable></entry>
                            <entry>
                                <para>Условие соединения целевой таблицы и источника.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>condition</replaceable></entry>
                            <entry>
                                <para>Дополнительные условия проверки в предложениях WHEN MATCHED
                                    или WHEN NOT MATCHED.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>colname</replaceable></entry>
                            <entry>
                                <para>Столбец целевой таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>value</replaceable></entry>
                            <entry>
                                <para>Значение, присваиваемое столбцу целевой таблицы. Выражение,
                                    которое может содержать литералы, PSQL переменные, столбцы из
                                    источника.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_value</replaceable></entry>
                            <entry>
                                <para>Выражение, возвращаемое в предложении RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>ret_alias</replaceable></entry>
                            <entry>
                                <para>Псевдоним для выражения, возвращаемого в предложении
                                    RETURNING.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>varname</replaceable></entry>
                            <entry>
                                <para>Имя PSQL переменной.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <para>Оператор MERGE производит слияние записей источника в целевую таблицу (или обновляемое
            представление). Источником может быть таблица, представление, хранимой процедурой или
            производной таблицей. Каждая запись источника используется для обновления (предложение
            UPDATE) или удаления (предложение DELETE) одной или более записей цели, или вставки
            (предложение INSERT) записи в целевую таблицу, или ни для того, ни для другого. Условие
            обычно содержит сравнение столбцов в таблицах источника и цели.</para>

        <indexterm>
            <primary>MERGE</primary>
            <secondary>DEFAULT</secondary>
        </indexterm>

        <para>В списке VALUES предложения INSERT и списке SET предложения UPDATE вместо значения
            столбца можно использовать ключевое слово DEFAULT. В этом случае столбец получит
            значение по умолчанию, указанное при определении целевой таблицы. Если значение по
            умолчанию для столбца отсутствует, то столбец получит значение NULL.</para>


        <indexterm>
            <primary>MERGE</primary>
            <secondary>WHEN MATCHED</secondary>
        </indexterm>
        <indexterm>
            <primary>MERGE</primary>
            <secondary>WHEN NOT MATCHED</secondary>
        </indexterm>
        <para>Допускается указывать несколько предложений WHEN MATCHED и WHEN NOT MATCHED.</para>
        <para>Предложения WHEN проверяются в указанном порядке. Если условие в предложении WHEN не
            выполняется, то мы пропускаем его и переходим к следующему предложению. Так будет
            происходить до тех пор, пока условие для одного из предложений WHEN не будет выполнено.
            В этом случае выполняется действие, связанное с предложением WHEN, и осуществляется
            переход на следующую строку источника. Для каждой строки источника выполняется только
            одно действие.</para>
        <note>
            <para>WHEN NOT MATCHED оценивается с точки зрения источника, т.е. таблицы или набора
                данных указанного в предложения USING. Так сделано потому, что если запись источника
                не имеет совпадения с записью цели, то выполняется INSERT. Разумеется, если запись
                цели не соответствует записи в источнике, то никакие действия не
                производятся.</para>
            <para>На данный момент переменная ROW_COUNT возвращает значение 1, даже если было
                модифицировано или вставлено более 1 записи. См. <link
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="http://tracker.firebirdsql.org/browse/CORE-4400"
                >CORE-4400</link>.</para>
        </note>
        <warning>
            <para>Если условие WHEN MATCHED присутствует, и несколько записей совпадают с записями в
                целевой таблице, UPDATE выполнится для всех совпадающих записей источника, и каждое
                последующее обновление перезапишет предыдущее. Это нестандартное поведение: стандарт
                SQL-2003 требует, чтобы в этой ситуации выдавалось исключение (ошибка). </para>
        </warning>
        <formalpara>
            <title>Примеры:</title>
            <para>
                <informalexample>
                    <para>
                        <programlisting language="sql"><![CDATA[
MERGE INTO books b
USING purchases p
ON p.title = b.title AND p.booktype = 'bk'
WHEN MATCHED THEN
  UPDATE SET b.descr = b.descr || '; ' || p.descr
WHEN NOT MATCHED THEN
  INSERT (title, descr, bought) 
  VALUES (p.title, p.descr, p.bought);
 
-- с использованием производной таблицы 
MERGE INTO customers c
USING (SELECT * FROM customers_delta WHERE id > 10) cd
ON (c.id = cd.id)
WHEN MATCHED THEN 
  UPDATE SET name = cd.name
WHEN NOT MATCHED THEN 
  INSERT (id, name) VALUES (cd.id, cd.name);

-- совместно с рекурсивным CTE
MERGE INTO numbers
USING (
  WITH RECURSIVE r(n) AS (
    SELECT 1 FROM rdb$database
    UNION ALL
    SELECT n+1 FROM r WHERE n < 200
  )
  SELECT n FROM r
) t
ON numbers.num = t.n
WHEN NOT MATCHED THEN
  INSERT(num) VALUES(t.n);
  
-- с использованием предложения DELETE
MERGE INTO SALARY_HISTORY
USING (
  SELECT EMP_NO
  FROM EMPLOYEE
  WHERE DEPT_NO = 120) EMP
ON SALARY_HISTORY.EMP_NO = EMP.EMP_NO
WHEN MATCHED THEN DELETE
]]>                    
                </programlisting>
                    </para>
                </informalexample>
                <informalexample>
                    <para>В следующем примере происходит ежедневное обновление таблицы
                        PRODUCT_IVENTORY на основе заказов, обработанных в таблице SALES_ORDER_LINE.
                        Если количество заказов на продукт таково, что уровень запасов продукта
                        опускается до нуля или становится ещё ниже, то строка этого продукта
                        удаляется из таблицы PRODUCT_IVENTORY. <programlisting language="sql"><![CDATA[
MERGE INTO PRODUCT_IVENTORY AS TARGET
USING (
  SELECT
    SL.ID_PRODUCT,
    SUM(SL.QUANTITY)
  FROM SALES_ORDER_LINE SL
    JOIN SALES_ORDER S ON S.ID = SL.ID_SALES_ORDER
  WHERE S.BYDATE = CURRENT_DATE
  GROUP BY 1
) AS SRC(ID_PRODUCT, QUANTITY)
ON TARGET.ID_PRODUCT = SRC.ID_PRODUCT
WHEN MATCHED AND TARGET.QUANTITY - SRC.QUANTITY <= 0 THEN
  DELETE
WHEN MATCHED THEN
  UPDATE SET
    TARGET.QUANTITY = TARGET.QUANTITY - SRC.QUANTITY,
    TARGET.BYDATE = CURRENT_DATE
]]>                    
                </programlisting>
                    </para>
                </informalexample>
            </para>
        </formalpara>
        <formalpara>
            <title>См. также:</title>

            <para>
                <link linkend="dml-select">SELECT</link>, <link linkend="dml-insert">INSERT</link>,
                    <link linkend="dml-update">UPDATE</link>, <link linkend="dml-delete"
                    >DELETE</link>. </para>
        </formalpara>
        <simplesect>
            <title>RETURNING</title>
            <indexterm>
                <primary>MERGE</primary>
                <secondary>RETURNING</secondary>
            </indexterm>
            <para>Оператор MERGE, затрагивающий не более одной строки, может содержать конструкцию
                RETURNING для возвращения значений добавленной, модифицируемой или удаляемой строки.
                В RETURNING могут быть указаны любые столбцы из целевой таблицы (обновляемого
                представления), не обязательно все, а также другие столбцы и выражения.</para>
            <para>Возвращаемые значения содержат изменения, произведённые в триггерах BEFORE.</para>
            <para>Имена столбцов могут быть уточнены с помощью префиксов NEW и OLD для определения,
                какое именно значение вы хотите столбца вы хотите получить до модификации или
                после.</para>
            <para>Вместо списка столбцов может быть указана звёздочка (*), в этом случае будут
                возвращены все столбцы целевой таблицы. Префиксы NEW и OLD могут быть сипользованы
                совместно с звёздочкой.</para>
            <para>Для предложений WHEN MATCHED UPDATE и MERGE WHEN NOT MATCHED неуточнённые имена
                столбцов или уточнённые именами таблиц или их псевдонимами понимаются как столбцы с
                префиксом NEW, для предложений MERGE WHEN MATCHED DELETE —с префиксом OLD.</para>
            <example>
                <title>Использование оператора MERGE с предложением RETURNING</title>
                <para>Немного модифицируем наш предыдущий пример, чтобы он затрагивал только одну
                    строку, и добавим в него инструкцию RETURNING возвращающего старое и новое
                    количество товара и разницу между этими значениями. <programlisting language="sql"><![CDATA[
MERGE INTO PRODUCT_IVENTORY AS TARGET
USING (
  SELECT
    SL.ID_PRODUCT,
    SUM(SL.QUANTITY)
  FROM SALES_ORDER_LINE SL
    JOIN SALES_ORDER S ON S.ID = SL.ID_SALES_ORDER
  WHERE S.BYDATE = CURRENT_DATE
    AND SL.ID_PRODUCT = :ID_PRODUCT
  GROUP BY 1
) AS SRC(ID_PRODUCT, QUANTITY)
ON TARGET.ID_PRODUCT = SRC.ID_PRODUCT
WHEN MATCHED AND TARGET.QUANTITY - SRC.QUANTITY <= 0 THEN
  DELETE
WHEN MATCHED THEN
  UPDATE SET
    TARGET.QUANTITY = TARGET.QUANTITY - SRC.QUANTITY,
    TARGET.BYDATE = CURRENT_DATE
RETURNING OLD.QUANTITY, NEW.QUANTITY, SRC.QUANTITY
INTO :OLD_QUANTITY, :NEW_QUANTITY, :DIFF_QUANTITY
]]>                    
                </programlisting>
                </para>
            </example>
        </simplesect>
    </section>
    <section xml:id="dml-execproc">
        <info>
            <title>EXECUTE PROCEDURE</title>
            <keywordset>
                <keyword>EXECUTE PROCEDURE</keyword>
            </keywordset>
        </info>
        <indexterm><primary>EXECUTE PROCEDURE</primary></indexterm>
        <formalpara>
            <title>Назначение:</title>

            <para>Выполнение хранимой процедуры.</para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL, ESQL, PSQL.</para>
        </formalpara>
        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
EXECUTE PROCEDURE <replaceable>procname</replaceable>
    [<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...]] 
  | ([<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...]])
[RETURNING_VALUES <replaceable>&lt;outvar&gt;</replaceable> [, <replaceable>&lt;outvar&gt;</replaceable> ...]]
 
<replaceable>&lt;outvar&gt;</replaceable> ::= [:]<replaceable>varname</replaceable>                      
            </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора EXECUTE PROCEDURE</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>procname</replaceable></entry>
                            <entry>
                                <para>Имя хранимой процедуры.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>inparam</replaceable></entry>
                            <entry>
                                <para>Выражение совместимое по типу с входным параметром хранимой
                                    процедуры.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>varname</replaceable></entry>
                            <entry>
                                <para>PSQL переменная, в которую возвращается значение выходного
                                    параметра процедуры.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <para>Оператор EXECUTE PROCEDURE выполняет хранимую процедуру, получая список из одного или
            нескольких входных параметров, если они определены, и возвращает однострочный набор
            значений, если он определён.</para>
        <section xml:id="dml-execproc-executable">
            <title>"Выполняемые" хранимые процедуры</title>
            <para>Оператор EXECUTE PROCEDURE является наиболее часто используемым стилем вызова
                хранимой процедуры, которая написана для модификации некоторых данных, код которой
                не содержит оператора SUSPEND. Такие хранимые процедуры могут возвратить набор
                данных, состоящий не более чем из одной строки. Этот набор может быть передан в
                переменные другой (вызывающей) процедуры с помощью предложения RETURNING_VALUES.
                Клиентские интерфейсы, как правило, имеют обертку API, которые могут извлекать
                выходные значения в однострочный буфер при вызове процедуры через EXECUTE PROCEDURE
                в DSQL.</para>
            <para>При вызове с помощью EXECUTE PROCEDURE процедур другого типа (селективных
                процедур) будет возвращена только первая запись из результирующего набора, несмотря
                на то, что эта процедура скорее всего должна возвращать многострочный результат.
                "Селективные" хранимые процедуры должны вызываться с помощью оператора SELECT, в
                этом случае они ведут себя как виртуальные таблицы.</para>
            <note>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>В PSQL И DSQL входными параметрами могут быть любые совместимые по
                                типу выражения;</para>
                        </listitem>
                        <listitem>
                            <para>Несмотря на то, что скобки для отделения списка передаваемых
                                параметров необязательны после имени хранимой процедуры, желательно
                                их использовать;</para>
                        </listitem>
                        <listitem>
                            <para>В DSQL приложениях, использующих Firebird API или иную обёртку,
                                вызов процедуры через EXECUTE PROCEDURE не требует указания
                                предложения RETURNING_VALUES для получения выходных значений в
                                однострочный буфер.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </note>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <blockquote>
                        <para>В PSQL (с опциональными двоеточиями): <programlisting language="sql">
<![CDATA[                
EXECUTE PROCEDURE MakeFullName(:First_Name, :Middle_Name, :Last_Name)
RETURNING_VALUES :FullName;
]]>                
            </programlisting>
                        </para>
                        <para>В утилите командной строки <application>isql</application> (с
                            литералами в качестве параметров): <programlisting language="sql">
<![CDATA[                
EXECUTE PROCEDURE MakeFullName
  'J', 'Edgar', 'Hoover';
]]>                
            </programlisting>
                        </para>
                        <para>С выражениями в качестве параметров: <programlisting language="sql">
<![CDATA[                
EXECUTE PROCEDURE MakeFullName
   ('Mr./Mrs. ' || First_Name, Middle_Name, upper(Last_Name))
RETURNING_VALUES FullName;
]]>                
            </programlisting>
                        </para>
                    </blockquote>
                </para>
            </formalpara>
        </section>
    </section>
    <section xml:id="dml-execblock">
        <info>
            <title>EXECUTE BLOCK</title>
            <keywordset>
                <keyword>EXECUTE BLOCK</keyword>
            </keywordset>
        </info>

        <indexterm><primary>EXECUTE BLOCK</primary></indexterm>

        <formalpara>
            <title>Назначение:</title>

            <para>Выполнение анонимного PSQL блока.</para>
        </formalpara>

        <formalpara>
            <title>Доступно в:</title>

            <para>DSQL.</para>
        </formalpara>
        <formalpara>
            <title>Синтаксис:</title>

            <para><programlisting>
EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)] [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]   
AS   
  [<replaceable>&lt;declarations&gt;</replaceable>]   
BEGIN   
  [<replaceable>&lt;PSQL statements&gt;</replaceable>]   
END       

<replaceable>&lt;inparams&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable> ]       

<replaceable>&lt;outparams&gt;</replaceable> ::= <replaceable>&lt;param_decl&gt;</replaceable> [, <replaceable>&lt;outparams&gt;</replaceable>]       

<replaceable>&lt;param_decl&gt;</replaceable> ::= <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]    
  
<replaceable>&lt;type&gt;</replaceable> ::= 
    <replaceable>&lt;datatype&gt;</replaceable>             
  | [TYPE OF] <replaceable>domain</replaceable>             
  | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>  

<replaceable>&lt;datatype&gt;</replaceable> ::= 
    {SMALLINT | INT[EGER] | BIGINT} 
  | BOOLEAN 
  | {FLOAT | DOUBLE PRECISION} 
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])] 
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)] 
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}] 
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])] 
                
                
<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>                 
                       </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора EXECUTE BLOCK</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>param_decl</replaceable></entry>
                            <entry>
                                <para>Описание входного или выходного параметра.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>declarations</replaceable></entry>
                            <entry>
                                <para>Секция объявления локальных переменных, именованных курсоров,
                                    подпроцедур и подфункций.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>declare_var</replaceable></entry>
                            <entry>
                                <para>Объявление локальной переменной. </para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>declare_cursor</replaceable></entry>
                            <entry>
                                <para>Объявление именованного курсора. </para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>subfunc_decl</replaceable></entry>
                            <entry>
                                <para>Объявление подпрограммы – функции.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>subproc_decl</replaceable></entry>
                            <entry>
                                <para>Объявление подпрограммы – процедуры. </para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>subfunc_impl</replaceable></entry>
                            <entry>
                                <para>Реализация подпрограммы – функции.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>subproc_impl</replaceable></entry>
                            <entry>
                                <para>Реализация подпрограммы – процедуры. </para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>paramname</replaceable></entry>
                            <entry>
                                <para>Имя входного или выходного параметра процедуры. Может
                                    содержать до 63 символов. Имя параметра должно быть уникальным
                                    среди входных и  выходных параметров процедуры, а также её
                                    локальных переменных. </para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>datatype</replaceable></entry>
                            <entry>
                                <para>Тип данных SQL.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>collation</replaceable></entry>
                            <entry>
                                <para>Порядок сортировки.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>domain</replaceable></entry>
                            <entry>
                                <para>Домен.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>rel</replaceable></entry>
                            <entry>
                                <para>Имя таблицы или представления. </para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>col</replaceable></entry>
                            <entry>
                                <para>Имя столбца таблицы или представления.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>precision</replaceable></entry>
                            <entry>
                                <para>Точность. От 1 до 38.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>scale</replaceable></entry>
                            <entry>
                                <para>Масштаб. От 0 до 38, должно быть меньше или равно
                                        <replaceable>precision</replaceable>.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>size</replaceable></entry>
                            <entry>
                                <para>Максимальный размер строки в символах.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>charset</replaceable></entry>
                            <entry>
                                <para>Набор символов. </para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>subtype_num</replaceable></entry>
                            <entry>
                                <para>Номер подтипа BLOB.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>subtype_name</replaceable></entry>
                            <entry>
                                <para>Мнемоника подтипа BLOB.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>seqlen</replaceable></entry>
                            <entry>
                                <para>Размер сегмента, не может превышать 65535. </para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <para>Выполняет блок PSQL кода, так как будто это хранимая процедура, возможно с входными и
            выходными параметрами и локальными переменными. Это позволяет пользователю выполнять
            &quot;на лету&quot; PSQL в контексте DSQL.</para>
        <formalpara>
            <title>Примеры:</title>
            <para>
                <blockquote>
                    <para>Этот пример вводит цифры от 0 до 127 и соответствующие им ASCII символов в
                        таблицу ASCIITABLE: <programlisting language="sql">
<![CDATA[                
EXECUTE BLOCK
AS
  DECLARE i INT = 0;
BEGIN
  WHILE (i < 128) DO
  BEGIN
    INSERT INTO AsciiTable VALUES (:i, ascii_char(:i));
    i = i + 1;
  END
END
]]>                
            </programlisting></para>
                </blockquote>
                <blockquote>
                    <para>Следующий пример вычисляет среднее геометрическое двух чисел и возвращает
                        его пользователю: <programlisting language="sql">
<![CDATA[                
EXECUTE BLOCK (
  x DOUBLE PRECISION = ?, 
  y DOUBLE PRECISION = ?)
RETURNS (gmean DOUBLE PRECISION)
AS
BEGIN
  gmean = sqrt(x*y);
  SUSPEND;
END
]]>                
            </programlisting>
                    </para>
                    <para> Поскольку этот блок имеет входные параметры, он должен быть
                        предварительно подготовлен. После чего можно установить параметры и
                        выполнить блок. Как это будет сделано, и вообще возможно ли это сделать,
                        зависит от клиентского программного обеспечения. Смотрите примечания ниже.
                    </para>
                </blockquote>
                <blockquote>
                    <para>Наш последний пример принимает два целочисленных значений, smallest и
                        largest. Для всех чисел в диапазоне smallest..largest, блок выводит само
                        число, его квадрат, куб и четвертую степень. <programlisting language="sql">
<![CDATA[                
EXECUTE BLOCK (smallest INT = ?, largest INT = ?)
RETURNS (
  number INT, 
  square BIGINT, 
  cube BIGINT, 
  fourth BIGINT)
AS
BEGIN
  number = smallest;
  WHILE (number <= largest) DO
  BEGIN
    square = number * number;
    cube = number * square;
    fourth = number * cube;
    SUSPEND;
    number = number + 1;
  END
END
]]>                
            </programlisting>
                    </para>
                    <para>Опять же, как вы можете установить значения параметров, зависит от
                        программного обеспечения клиента.</para>
                </blockquote></para>
        </formalpara>
        <formalpara>
            <title>См. также:</title>

            <para>
                <link linkend="psql-statements">Операторы языка PSQL</link>. </para>
        </formalpara>
        <section xml:id="dml-execblock-inoutparams">
            <title>Входные и выходные параметры</title>

            <para>Выполнение блока без входных параметров должно быть возможным с любым клиентом
                Firebird, который позволяет пользователю вводить свои собственные DSQL операторы.
                Если есть входные параметры, все становится сложнее: эти параметры должны получить
                свои значения после подготовки оператора, но перед его выполнением. Это требует
                специальных возможностей, которыми располагает не каждое клиентское приложение
                (Например, <application>isql</application> такой возможности не предлагает). </para>
            <para>Сервер принимает только вопросительные знаки (&quot;?&quot;) в качестве
                заполнителей для входных значений, а не &quot;:<replaceable>а</replaceable>&quot;,
                    &quot;:<replaceable>MyParam</replaceable>&quot; и т.д., или литеральные
                значения. Клиентское программное обеспечение может поддерживать форму
                    &quot;:<replaceable>ххх</replaceable>&quot;, в этом случае будет произведена
                предварительная обработка запроса перед отправкой его на сервер.</para>
            <para>Если блок имеет выходные параметры, вы должны использовать SUSPEND, иначе ничего
                не будет возвращено. </para>
            <para>Выходные данные всегда возвращаются в виде набора данных, так же как и в случае с
                оператором SELECT. Вы не можете использовать RETURNING_VALUES или выполнить блок,
                вернув значения в некоторые переменные, используя INTO, даже если возвращается всего
                одна строка. </para>
            <para>Для получения дополнительной информации о параметрах и объявлениях переменных,
                [TYPE OF] <replaceable>domain</replaceable>, TYPE OF COLUMN и т.д. обратитесь к
                главе <link linkend="psql-statements-declare-var">DECLARE VARIABLE</link>.</para>
        </section>
        <section xml:id="dml-execblock-term">
            <title>Терминатор оператора</title>

            <para>Некоторые редакторы SQL-операторов — в частности утилита
                    <application>isql</application>, которая идёт в комплекте с Firebird, и возможно
                некоторые сторонние редакторы — используют внутреннее соглашение, которое требует,
                чтобы все операторы были завершены с точкой с запятой.</para>
            <para>Это создает конфликт с синтаксисом PSQL при кодировании в этих средах. Если вы не
                знакомы с этой проблемой и ее решением, пожалуйста, изучать детали в главе PSQL в
                разделе, озаглавленном <link linkend="psql-setterm">Изменение терминатора в
                        <application>isql</application></link>.</para>

        </section>
    </section>
</chapter>
