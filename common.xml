<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="common" xml:lang="ru">
    <info>
        <title>Общие элементы языка</title>
    </info>

    <para>В этой главе рассматриваются элементы, которые являются общими для всех реализаций языка
        SQL — выражения, которые используются для извлечения и работают на утверждениях о данных, и
        предикатов, которые проверяют истинность этих утверждений.</para>

    <section xml:id="common-expr">
        <info>
            <title>Выражения</title>
        </info>

        <para>Выражения SQL представляют формальные методы для вычисления, преобразования и
            сравнения значений. Выражения SQL могут включать в себя столбцы таблиц, переменные,
            константы, литералы, различные операторы и предикаты, а так же другие выражения. Полный
            список допустимых символов (tokens) в выражениях описан ниже.</para>
        <para>
            <table xml:id="common-tbl-elem" frame="all">
                <?dbfo keep-together='auto'?>
                <title>Описание элементов языка</title>
                <tgroup cols="2">
                    <colspec colname="colElem" colnum="1" colwidth="2*" align="left"/>
                    <colspec colname="colDesc" colnum="2" colwidth="5*" align="justify"/>
                    <thead>
                        <row valign="middle">
                            <entry align="center">Элемент</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>Имя столбца</entry>
                            <entry>Идентификаторы столбцов из указанных таблиц, используемые в
                                вычислениях, или сравнениях, или в качестве условия поиска. Столбец
                                типа массив не может быть элементом выражения, если только он не
                                проверяется на IS [NOT] NULL.</entry>
                        </row>
                        <row>
                            <entry>Элементы массива</entry>
                            <entry>В выражении может содержаться ссылка на элемент массива, т.е.
                                    <replaceable>&lt;array_name&gt;[s]</replaceable>, где
                                    <replaceable>s</replaceable> — индекс элемента в массиве
                                    <replaceable>&lt;array_name&gt;</replaceable>.</entry>
                        </row>
                        <row>
                            <entry>Арифметические операторы</entry>
                            <entry>Символы +, -, *, / используемые для вычисления значений.</entry>
                        </row>
                        <row>
                            <entry>Оператор конкатенации</entry>
                            <entry>Оператор || используется для соединения символьных строк.
                            </entry>
                        </row>
                        <row>
                            <entry>Логические операторы</entry>
                            <entry>Зарезервированные слова NOT, AND и OR используются при
                                комбинировании простых условий поиска для создания сложных
                                утверждений.</entry>
                        </row>
                        <row>
                            <entry>Операторы сравнения</entry>
                            <entry>Символы =, &lt;&gt;, !=, ~=, ^=, &lt;, &lt;=, &gt;, &gt;=, !&lt;,
                                ~&lt;, ^&lt;, !&gt;, ~&gt; и ^&gt;.</entry>
                        </row>
                        <row>
                            <entry>Предикаты сравнения</entry>
                            <entry>LIKE, STARTING WITH, CONTAINING, SIMILAR TO, BETWEEN, IS [NOT]
                                NULL и  IS [NOT] DISTINCT FROM</entry>
                        </row>
                        <row>
                            <entry>Предикаты существования</entry>
                            <entry>Предикаты, используемые для проверки существования значений в
                                наборе. Предикат IN может быть использован как с наборами констант,
                                так и со скалярными подзапросами. Предикаты EXISTS, SINGULAR, ALL
                                ANY, SOME могут быть использованы только с подзапросами.</entry>
                        </row>
                        <row>
                            <entry>Константы</entry>
                            <entry>Числа, заключённые в апострофы строковые литералы, логические
                                значения TRUE, FALSE и UNKNOWN, псевдозначение NULL.</entry>
                        </row>
                        <row>
                            <entry>Литералы дат</entry>
                            <entry>Выражения, подобные строковым литералам, заключённые в
                                апострофах, которые могут быть интерпретированы как значения даты,
                                времени или даты-времени. Литералами дат могут быть строки из
                                символов и чисел, такие как '25.12.2016 15:30:35', которые могут
                                быть преобразованы в дату, время или дату с временем.</entry>
                        </row>
                        <row>
                            <entry>Контекстные переменные</entry>
                            <entry>Встроенные <link linkend="internalfunc-contextvar">контекстные
                                    переменные</link>.</entry>
                        </row>
                        <row>
                            <entry>Локальные переменные</entry>
                            <entry>Локальные переменные, входные или выходные параметры PSQL модулей
                                (хранимых процедур, триггеров, анонимных блоков PSQL). </entry>
                        </row>
                        <row>
                            <entry>Позиционные параметры</entry>
                            <entry>В DSQL в качестве параметров запроса могут быть использованы
                                только позиционные параметры. Позиционные параметры представляют
                                собой знаки вопроса (?) внутри DSQL оператора. Доступ к таким
                                параметрам осуществляется по его номеру (позиции в запросе
                                относительно предыдущего позиционного параметра) поэтому они
                                называются позиционными. Обычно компоненты доступа позволяют
                                работать с именованными параметрами, которые они сами
                                преобразовывают в позиционные.</entry>
                        </row>
                        <row>
                            <entry>Подзапросы</entry>
                            <entry>Оператор SELECT заключённый в круглые скобки, который возвращает
                                одно единственное (скалярное) значение или множество значений (при
                                использовании в предикатах существования).</entry>
                        </row>
                        <row>
                            <entry>Идентификаторы функций</entry>
                            <entry>Идентификаторы встроенных или внешних функций в функциональных
                                выражениях.</entry>
                        </row>
                        <row>
                            <entry>Приведения типа</entry>
                            <entry>
                                <para>Выражение явного преобразования одного типа данных в другой
                                    <programlisting>
CAST(<replaceable>&lt;value&gt;</replaceable> AS <replaceable>&lt;datatype&gt;</replaceable>) 
                                </programlisting>
                                    или сокращённое (для даты/времени) преобразование типа
                                    <programlisting>
<replaceable>&lt;datatype&gt;</replaceable> <replaceable>&lt;value&gt;</replaceable>
                                     </programlisting>
                                    например <function>DATE '25.12.2016'</function>
                                </para>
                            </entry>
                        </row>
                        <row>
                            <entry>Условные выражения</entry>
                            <entry>Выражение CASE и встроенные функции COALESCE, NULLIF.</entry>
                        </row>
                        <row>
                            <entry>Круглые скобки</entry>
                            <entry>Пара скобок ( ... ) используются для группировки выражений.
                                Операции внутри скобок выполняются перед операциями вне скобок. При
                                использовании вложенных скобок, сначала вычисляются значения самых
                                внутренних выражений, а затем вычисления перемещаются наверх по
                                уровням вложенности. </entry>
                        </row>
                        <row>
                            <entry>Предложение COLLATE</entry>
                            <entry>Предложение применяется к типам CHAR и VARCHAR, чтобы в указанной
                                кодировке установить параметры сортировки, используемые при
                                сравнении.</entry>
                        </row>
                        <row>
                            <entry><database>NEXT VALUE FOR</database>
                                <replaceable>sequence</replaceable></entry>
                            <entry>Конструкция NEXT VALUE FOR позволяет получить следующее значение
                                последовательности, то же самое делает встроенная функция GEN_ID().
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>
        <section xml:id="common-expr-constants">
            <info>
                <title>Константы</title>
            </info>
            <para>Константа это значение, подставляемое непосредственно в SQL оператор, которое не
                получено из выражения, параметра, ссылки на столбец или переменной. Константой может
                быть строка или число.</para>

            <section xml:id="common-expr-string-constants">
                <title>Строковые константы (литералы)</title>
                <para>Строковая константа это последовательность символов, заключенных между парой
                    апострофов (<quote>одинарных кавычек</quote>). Максимальная длина строковой
                    константы составляет 65535 байт; максимальная количество символов будет
                    определяться количеством байт, используемых для кодирования каждого
                    символа.</para>
                <note>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para>Двойные кавычки <emphasis>не должны</emphasis> (допускаются 1
                                    диалектом) использоваться для квотирования строк. В SQL они
                                    предусмотрены для других целей.</para>
                            </listitem>
                            <listitem>
                                <para>Если литерал апострофа требуется в строковой константе, то он
                                    может быть <quote>экранирован</quote> другим предшествующим
                                    апострофом. Например,
                                    <programlisting> 
'Mother O''Reilly's home-made hooch'
</programlisting>
                                </para>
                            </listitem>
                            <listitem>
                                <para>Необходимо быть осторожным с длиной строки, если значение
                                    должно быть записано в столбец типа
                                    <database>VARCHAR</database>. Максимальная длина строки для типа
                                        <database>VARCHAR</database> составляет 32765 байт (32767
                                    для типа CHAR). Если значение должно быть записано в столбец
                                    типа <database>BLOB</database>, то максимальная длина строкового
                                    литерала составляет 65535 байт.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>Предполагается, что набор символов строковой константы совпадает с набором
                        символов столбца предназначенного для её сохранения. </para>
                </note>
                <section xml:id="common-expr-string-constants-hexstrings">
                    <title>Строковые константы в шестнадцатеричной нотации</title>
                    <para>Начиная с Firebird 2.5 строковые константы могут быть записаны в
                        шестнадцатеричной нотации, так называемые <quote>двоичные строки</quote>.
                        Каждая пара шестнадцатеричных цифр определяет один байт в строке. Строки
                        введённые таким образом будут иметь кодировку OCTETS по умолчанию, но <link
                            linkend="common-expr-string-constants-introducer">вводный синтаксис
                            (introducer syntax)</link> может быть использован для принудительной
                        интерпретации строки в другом наборе символов. </para>
                    <formalpara>
                        <title>Синтаксис:</title>
                        <para>
                            <programlisting>  
{x|X}'<replaceable>&lt;hexstring&gt;</replaceable>'

<replaceable>&lt;hexstring&gt;</replaceable> ::= an even number of <replaceable>&lt;hexdigit&gt;</replaceable>
                                
<replaceable>&lt;hexdigit&gt;</replaceable> ::= 0..9 | A..F | a..f                                
</programlisting>
                        </para>
                    </formalpara>
                    <formalpara>
                        <title>Примеры:</title>
                        <para>
                            <informalexample>
                                <para><programlisting language="sql">
SELECT x'4E657276656E' FROM rdb$database
-- returns 4E657276656E, a 6-byte 'binary' string

SELECT _ascii x'4E657276656E' FROM rdb$database
-- returns 'Nerven' (same string, now interpreted as ASCII text)

SELECT _iso8859_1 x'53E46765' FROM rdb$database
-- returns 'Säge' (4 chars, 4 bytes)

SELECT _utf8 x'53C3A46765' FROM rdb$database
-- returns 'Säge' (4 chars, 5 bytes)            
            </programlisting></para>
                            </informalexample>
                        </para>
                    </formalpara>
                    <note>
                        <para> Как будут отображены двоичные строки зависит от интерфейса клиента.
                            Например, утилита <application>isql</application> использует заглавные
                            буквы A-F, в то время как <application>FlameRobin</application> буквы в
                            нижнем регистре. Другие могут использовать другие правила
                            конвертирования, например отображать пробелы между парами байт: '4E 65
                            72 76 65 6E'. </para>
                        <para> Шестнадцатеричная нотация позволяет вставить любой байт (включая 00)
                            в любой позиции в строке. </para>
                    </note>
                </section>
                <section xml:id="common-expr-string-constants-introducer">
                    <title>Вводный синтаксис для строковых литералов</title>
                    <para>При необходимости, строковому литералу может предшествовать имя набор
                        символов, который начинается с префикса подчеркивания <quote>_</quote>. Это
                        известно как вводный синтаксис (Introducer syntax). Его цель заключается в
                        информировании Firebird о том, как интерпретировать и хранить входящую
                        строку.</para>
                    <formalpara>
                        <title>Примеры:</title>
                        <para>
                            <informalexample>
                                <para><programlisting language="sql">
-- обратите внимание на префикс '_'
INSERT INTO People
VALUES (_ISO8859_1 'Hans-Jörg Schäfer');             
            </programlisting></para>
                            </informalexample>
                        </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="common-expr-number-constants">
                <title>Числовые константы</title>
                <para>Числовая константа — это любое правильное число в одной из поддерживаемых
                    нотаций: <itemizedlist>
                        <listitem>
                            <para>В SQL, для чисел в стандартной десятичной записи, десятичная точка
                                всегда представлена символом точки и тысячи не разделены. Включение
                                запятых, пробелов, и т.д. вызовет ошибки.</para>
                        </listitem>
                        <listitem>
                            <para>Экспоненциальная запись, например число 0.0000234 может быть
                                записано как <literal>2.34e-5</literal>.</para>
                        </listitem>
                        <listitem>
                            <para>Шестнадцатеричная запись (см. ниже) чисел поддерживается начиная с
                                Firebird 2.5.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <section xml:id="common-expr-number-constants-hex">
                    <title>Шестнадцатеричная нотация чисел</title>
                    <para>Начиная с Firebird 2.5 целочисленные значения могут быть записаны в
                        шестнадцатеричной системе счисления. Числа состоящие из 1-8
                        шестнадцатеричных цифр будут интерпретированы как INTEGER, состоящие из 9-16
                        цифр — как BIGINT. </para>
                    <formalpara>
                        <title>Синтаксис:</title>
                        <para>
                            <programlisting>  
{x|X}<replaceable>&lt;hexdigits&gt;</replaceable>

<replaceable>&lt;hexdigits&gt;</replaceable> ::= 1-16 of <replaceable>&lt;hexdigit&gt;</replaceable>
                                
<replaceable>&lt;hexdigit&gt;</replaceable> ::= 0..9 | A..F | a..f                                
</programlisting>
                        </para>
                    </formalpara>
                    <formalpara>
                        <title>Примеры:</title>
                        <para>
                            <informalexample>
                                <para><programlisting language="sql">
SELECT 0x6FAA0D3 FROM rdb$database -- returns 117088467
SELECT 0x4F9 FROM rdb$database -- returns 1273
SELECT 0x6E44F9A8 FROM rdb$database -- returns 1850014120
SELECT 0x9E44F9A8 FROM rdb$database -- returns -1639646808 (an INTEGER)
SELECT 0x09E44F9A8 FROM rdb$database -- returns 2655320488 (a BIGINT)
SELECT 0x28ED678A4C987 FROM rdb$database -- returns 720001751632263
SELECT 0xFFFFFFFFFFFFFFFF FROM rdb$database -- returns -1            
            </programlisting></para>
                            </informalexample>
                        </para>
                    </formalpara>
                </section>
                <section xml:id="common-expr-number-constants-hex-valrange">
                    <title>Диапазон значений шестнадцатеричных чисел</title>
                    <para><itemizedlist>
                            <listitem>
                                <para>Шестнадцатеричные числа в диапазоне 0 .. 7FFF FFFF являются
                                    положительными INTEGER числа со значениями 0 .. 2147483647. Для
                                    того, чтобы интерпретировать константу как BIGINT число
                                    необходимо дописать необходимо количества нулей слева. Это
                                    изменит тип, но не значение. </para>
                            </listitem>
                            <listitem>
                                <para>Числа в диапазоне 8000 0000 .. FFFF FFFF требуют особого
                                    внимания: <itemizedlist>
                                        <listitem>
                                            <para>При записи восемью шестнадцатеричный числами,
                                                такие как 0x9E44F9A8, интерпретируется как 32-битное
                                                целое. Поскольку крайний левый (знаковый) бит
                                                установлен, то такие числа будут находится в
                                                отрицательном диапазоне -2147483648 .. -1. </para>
                                        </listitem>
                                        <listitem>
                                            <para>Числа предварённые одним или несколькими нулями,
                                                такие как 0x09E44F9A8, будут интерпретированы как
                                                64-разрядный BIGINT в диапазоне значений 0000 0000
                                                8000 0000 .. 0000 0000 FFFF FFFF. В этом случае
                                                знаковый бит не установлен, поэтому они отображаются
                                                в положительном диапазоне 2147483648 .. 4294967295
                                                десятичных чисел.</para>
                                            <para>Таким образом, только в этом диапазоне числа,
                                                предварённые совершенно незначимым нулём, имеют
                                                кардинально разные значения. Это необходимо
                                                знать.</para>
                                        </listitem>
                                    </itemizedlist></para>
                            </listitem>
                            <listitem>
                                <para>Шестнадцатеричные числа в диапазоне 1 0000 0000 .. 7FFF FFFF
                                    FFFF FFFF являются положительными BIGINT числами.</para>
                            </listitem>
                            <listitem>
                                <para>Шестнадцатеричные числа в диапазоне 8000 0000 0000 0000 ..
                                    FFFF FFFF FFFF FFFF являются отрицательными BIGINT
                                    числами.</para>
                            </listitem>
                            <listitem>
                                <para>Числа с типом SMALLINT не могут быть записаны в
                                    шестнадцатеричном виде, строго говоря, так как даже 0x1
                                    оценивается как INTEGER. Тем не менее, если вы записываете
                                    положительное целое число в пределах 16-разрядного диапазона от
                                    0x0000 (десятичный ноль) до 0x7FFF (десятичное 32767), то оно
                                    будет преобразовано в SMALLINT прозрачно.</para>
                                <para>Вы можете записать отрицательное SMALLINT число в
                                    шестнадцатеричном виде используя 4-байтное шестнадцатеричное
                                    число в диапазоне от 0xFFFF8000 (десятичное -32768) до
                                    0xFFFFFFFF (десятичное -1).</para>
                            </listitem>
                        </itemizedlist></para>
                </section>
            </section>
        </section>
        <section xml:id="common-expr-operators">
            <info>
                <title>Операторы SQL</title>
            </info>
            <para>SQL операторы включают в себя операторы для сравнения, вычисления, оценки и
                конкатенации значений.</para>
            <section xml:id="common-expr-operators-prioritet">
                <info>
                    <title>Приоритет операторов</title>
                </info>
                <para>Приоритет определяет порядок, в котором операторы и получаемые с помощью них
                    значения вычисляются в выражении. </para>
                <para>Все операторы разбиты на 4 типа. Каждый тип оператора имеет свой приоритет.
                    Чем выше приоритет типа оператора, тем раньше он будет вычислен. Внутри одного
                    типа операторы имеют собственный приоритет, который также определяет порядок их
                    вычисления в выражении. Операторы с одинаковым приоритетом вычисляются слева
                    направо. Для изменения порядка вычислений операции могут быть сгруппированы с
                    помощью круглых скобок. </para>
                <para>
                    <table xml:id="common-tbl-operpreced" frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Приоритеты типов операторов</title>
                        <tgroup cols="3">
                            <colspec colname="c1" colnum="1" colwidth="1*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="1*" align="center"/>
                            <colspec colname="c3" colnum="3" colwidth="3*" align="justify"/>
                            <thead>
                                <row valign="middle">
                                    <entry align="center">Тип оператора</entry>
                                    <entry align="center">Приоритет</entry>
                                    <entry align="center">Пояснение</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row valign="middle">
                                    <entry>Конкатенация</entry>
                                    <entry>1</entry>
                                    <entry>Строки объединяются до выполнения любых других операций.
                                    </entry>
                                </row>
                                <row valign="middle">
                                    <entry>Арифметический</entry>
                                    <entry>2</entry>
                                    <entry>Арифметические операции выполняются после конкатенации
                                        строк, но перед выполнением операторов сравнения и
                                        логических операций.</entry>
                                </row>
                                <row valign="middle">
                                    <entry>Сравнение</entry>
                                    <entry>3</entry>
                                    <entry>Операции сравнения вычисляются после конкатенации строк и
                                        выполнения арифметических операций, но до логических
                                        операций.</entry>
                                </row>
                                <row valign="middle">
                                    <entry>Логический</entry>
                                    <entry>4</entry>
                                    <entry>Логические операторы выполняются после всех других типов
                                        операторов.</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
            </section>
            <section xml:id="common-expr-operators-concat">
                <info>
                    <title>Оператор конкатенации</title>
                </info>
                <para>Оператор конкатенации <command>||</command> соединяет две символьные строки и создаёт одну
                    строку. Символьные стоки могут быть константами или значениями, полученными из
                    столбцов или других выражений. </para>

                <formalpara>
                    <title>Пример:</title>
                    <para>
                        <informalexample>
                            <para><programlisting language="sql"> 
SELECT LAST_NAME || ', ' || FIRST_NAME AS FULL_NAME
FROM EMPLOYEE                   
                </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
            </section>
            <section xml:id="common-expr-operators-arith">
                <info>
                    <title>Арифметические операторы</title>
                </info>
                <para>
                    <table xml:id="common-tbl-arithpreced" frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Приоритет арифметических операторов</title>
                        <tgroup cols="3">
                            <colspec colname="c1" colnum="1" colwidth="1*" align="center"/>
                            <colspec colname="c2" colnum="2" colwidth="2*" align="center"/>
                            <colspec colname="c3" colnum="3" colwidth="1*" align="center"/>
                            <thead>
                                <row valign="middle">
                                    <entry align="center">Оператор</entry>
                                    <entry align="center">Назначение</entry>
                                    <entry align="center">Приоритет</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row valign="middle">
                                    <entry><command>+</command></entry>
                                    <entry>Унарный плюс</entry>
                                    <entry>1</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>-</command></entry>
                                    <entry>Унарный минус</entry>
                                    <entry>1</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>*</command></entry>
                                    <entry>Умножение</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>/</command></entry>
                                    <entry>Деление</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>+</command></entry>
                                    <entry>Сложение</entry>
                                    <entry>3</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>-</command></entry>
                                    <entry>Вычитание</entry>
                                    <entry>3</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <formalpara>
                    <title>Пример:</title>
                    <para>
                        <informalexample>
                            <para><programlisting language="sql"> 
UPDATE T
SET A = 4 + 1/(B-C)*D                  
                </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
            </section>
            <section xml:id="common-expr-operators-comp">
                <info>
                    <title>Операторы сравнения</title>
                </info>
                <para>
                    <table xml:id="common-tbl-compar" frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Операторы сравнения</title>
                        <tgroup cols="3">
                            <colspec colname="c1" colnum="1" colwidth="1*" align="center"/>
                            <colspec colname="c2" colnum="2" colwidth="2*" align="center"/>
                            <colspec colname="c3" colnum="3" colwidth="2*" align="center"/>
                            <thead>
                                <row valign="middle">
                                    <entry align="center">Оператор</entry>
                                    <entry align="center">Назначение</entry>
                                    <entry align="center">Приоритет</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row valign="middle">
                                    <entry><command>IS</command></entry>
                                    <entry>Проверяет, что выражение в левой части является псевдо
                                        значением NULL или соответствует логическому значению в
                                        правой части.</entry>
                                    <entry>1</entry>
                                </row>                                
                                <row valign="middle">
                                    <entry><command>=</command></entry>
                                    <entry>Равно, идентично</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>&lt;&gt;, !=, ~=, ^=</command></entry>
                                    <entry>Не равно</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>&gt;</command></entry>
                                    <entry>Больше</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>&lt;</command></entry>
                                    <entry>Меньше</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>&gt;=</command></entry>
                                    <entry>Больше или равно</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>&lt;=</command></entry>
                                    <entry>Меньше или равно</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>!&gt;, ~&gt;, ^&gt;</command></entry>
                                    <entry>Не больше</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>!&lt;, ~&lt;, ^&lt;</command></entry>
                                    <entry>Не меньше</entry>
                                    <entry>2</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
                <para>В эту же группу входят предикаты сравнения <link
                        linkend="common-predicats-othercompare-distinct">IS DISTINCT FROM</link>,
                        <link linkend="common-predicats-othercompare-between">BETWEEN</link>, <link
                        linkend="common-predicats-existence-in">IN</link>, <link
                        linkend="common-predicats-othercompare-like">LIKE</link>, <link
                        linkend="common-predicats-othercompare-containing">CONTAINING</link>, <link
                        linkend="common-predicats-othercompare-starting">SIMILAR TO</link> и другие. </para>
                <formalpara>
                    <title>Пример:</title>
                    <para>
                        <informalexample>
                            <para><programlisting language="sql"> 
IF (SALARY &gt; 1400) THEN   
...
                </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="common-predicats-othercompare">Другие предикаты
                            сравнения</link>. </para>

                </formalpara>
            </section>
            <section xml:id="common-expr-operators-logic">
                <info>
                    <title>Логические операторы</title>
                    <keywordset>
                        <keyword>NOT</keyword>
                        <keyword>AND</keyword>
                        <keyword>OR</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>NOT</primary></indexterm>
                <indexterm><primary>AND</primary></indexterm>
                <indexterm><primary>OR</primary></indexterm>
                <para>
                    <table xml:id="common-tbl-logical" frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Приоритет логических операторов</title>
                        <tgroup cols="3">
                            <colspec colname="c1" colnum="1" colwidth="1*" align="center"/>
                            <colspec colname="c2" colnum="2" colwidth="2*" align="justify"/>
                            <colspec colname="c3" colnum="3" colwidth="1*" align="center"/>
                            <thead>
                                <row valign="middle">
                                    <entry align="center">Оператор</entry>
                                    <entry align="center">Назначение</entry>
                                    <entry align="center">Приоритет</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row valign="middle">
                                    <entry><command>NOT</command></entry>
                                    <entry>Отрицание условия поиска.</entry>
                                    <entry>1</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>AND</command></entry>
                                    <entry>Объединяет два предиката и более, каждый из которых
                                        должен быть истинным, чтобы истинным был и весь
                                        предикат.</entry>
                                    <entry>2</entry>
                                </row>
                                <row valign="middle">
                                    <entry><command>OR</command></entry>
                                    <entry>Объединяет два предиката и более, из которых должен быть
                                        истинным хотя бы один предикат, чтобы истинным был и весь
                                        предикат.</entry>
                                    <entry>3</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>
                <formalpara>
                    <title>Пример:</title>
                    <para>
                        <informalexample>
                            <para><programlisting language="sql"> 
IF (A &gt; B OR (A &gt; C AND A &gt; D) AND NOT (C = D)) THEN
...
                </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
            </section>
        </section>
        
        <section xml:id="icommon-expr-attimezone">
            <info>
                <title>AT</title>
                <keywordset>
                    <keyword>AT</keyword>
                </keywordset>
            </info>
            <indexterm><primary>AT</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>
                
                <para>DSQL, PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para>
                    <programlisting>                                                           
<replaceable>&lt;expr&gt;</replaceable> AT {TIME ZONE <replaceable>&lt;time zone string&gt;</replaceable> | LOCAL}                       
                        
<replaceable>&lt;time zone string&gt;</replaceable> ::=
    '<replaceable>&lt;time zone&gt;</replaceable>'                            
                            
<replaceable>&lt;time zone&gt;</replaceable> ::=
    <replaceable>&lt;time zone region&gt;</replaceable> |
    [+/-] <replaceable>&lt;hour displacement&gt;</replaceable> [: <replaceable>&lt;minute displacement&gt;</replaceable>]                         
                        </programlisting>
                </para>
            </formalpara>
            
            <para>Преобразует время или временную метку в указанный часовой пояс. Если
                используется ключевое слово LOCAL, то преобразование происходит в часовой пояс
                сессии.</para>
            
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование функции AT</title>
                        <para><programlisting language="sql">
select time '12:00 GMT' at time zone '-03'
  from rdb$database;

select current_timestamp at time zone 'America/Sao_Paulo'
  from rdb$database;

select timestamp '2018-01-01 12:00 GMT' at local
  from rdb$database;
                </programlisting>
                        </para>
                    </example>
                </para>
            </formalpara>
        </section>        
        
        <section xml:id="common-expr-nextvalue">
            <info>
                <title>NEXT VALUE FOR</title>
                <keywordset>
                    <keyword>NEXT VALUE FOR</keyword>
                </keywordset>
            </info>
            <indexterm><primary>NEXT VALUE FOR</primary></indexterm>
            <formalpara>
                <title>Доступно в:</title>

                <para>DSQL, PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>
                <para><programlisting>
NEXT VALUE FOR <replaceable>sequence-name</replaceable>
                </programlisting></para>
            </formalpara>

            <para>Возвращает следующее значение в последовательности (SEQUENCE). SEQUENCE является
                SQL совместимым термином генератора в InterBase и Firebird. Оператор NEXT VALUE FOR
                полностью эквивалентен функции GEN_ID (seq, n) и является рекомендуемым синтаксисом. </para>

            <formalpara>
                <title>Пример:</title>
                <para>
                    <informalexample>
                        <para><programlisting language="sql"> 
NEW.CUST_ID = NEXT VALUE FOR CUSTSEQ;
                </programlisting>
                        </para>
                    </informalexample>
                </para>
            </formalpara>
            <note>
                <para>NEXT VALUE FOR не поддерживает значение приращения, отличное от того, что было
                    указано при создании последовательности в предложении INCREMENT [BY]. Если
                    требуется другое значение шага, то используйте старую функцию GEN_ID.</para>
            </note>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="ddl-sequence">SEQUENCE (GENERATOR)</link>, <link
                        linkend="internalfunc-func-gen-gen_id">GEN_ID</link>. </para>
            </formalpara>
        </section>
        <section xml:id="common-expr-cond">
            <info>
                <title>Условные выражения</title>
            </info>
            <para>Условное выражение — это выражение, которое возвращает различные значения в
                зависимости от истинности некоторого условия или условий. В данном разделе описано
                лишь одно условное выражение CASE. Остальные условные выражения являются
                производными встроенными функциями и описаны в разделе <link
                    linkend="internalfunc-func">Скалярные функции</link>.</para>
            <section xml:id="common-expr-cond-case">
                <info>
                    <title>CASE</title>
                    <keywordset>
                        <keyword>CASE</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>CASE</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, ESQL.</para>
                </formalpara>

                <para>Оператор CASE возвращает только одно значение из нескольких возможных. Есть
                    два синтаксических варианта: </para>
                <para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>Простой CASE, сравнимый с Pascal case или C switch;</para>
                        </listitem>
                        <listitem>
                            <para>Поисковый CASE, который работает как серия операторов <command>if
                                    ... else if ... else if</command>.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <simplesect xml:id="common-expr-cond-case-simple">
                    <title>Простой CASE</title>
                    <formalpara>
                        <title>Синтаксис:</title>

                        <para><programlisting>
CASE <replaceable>&lt;test-expr&gt;</replaceable>
  WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable>
  [WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable> ...]
  [ELSE <replaceable>&lt;defaultresult&gt;</replaceable>]
END
                </programlisting></para>
                    </formalpara>
                    <para>При использовании этого варианта
                            <replaceable>&lt;test-expr&gt;</replaceable> сравнивается с
                            <replaceable>&lt;expr&gt;</replaceable> 1,
                            <replaceable>&lt;expr&gt;</replaceable> 2 и т.д. до тех пор, пока не
                        будет найдено совпадение, и тогда возвращается соответствующий результат.
                        Если совпадений не найдено, то возвращается
                            <replaceable>defaultresult</replaceable> из ветви ELSE. Если нет
                        совпадений, и ветвь ELSE отсутствует, возвращается значение NULL.</para>
                    <para>Совпадение эквивалентно оператору <quote><command>=</command></quote>,
                        т.е. если <replaceable>&lt;test-expr&gt;</replaceable> имеет значение NULL,
                        то он не соответствует ни одному из <replaceable>&lt;expr&gt;</replaceable>,
                        даже тем, которые имеют значение NULL.</para>
                    <para>Результаты не обязательно должны быть литеральными значениями, они также
                        могут быть именами полей, переменными, сложными выражениями или NULL. </para>

                    <formalpara>
                        <title>Пример:</title>
                        <para>
                            <informalexample>
                                <para><programlisting language="sql"> 
SELECT
  NAME,
  AGE,
  CASE UPPER(SEX)
    WHEN 'M' THEN 'Male'
    WHEN 'F' THEN 'Female'
    ELSE 'Unknown'
  END AS SEXNAME,
  RELIGION
FROM PEOPLE
                </programlisting></para>
                            </informalexample>
                        </para>
                    </formalpara>
                    <para>Сокращённый вид простого оператора CASE используется в функции <link
                            linkend="internalfunc-func-case-decode">DECODE</link>. </para>
                </simplesect>
                <simplesect xml:id="common-expr-cond-case-search">
                    <title>Поисковый CASE</title>
                    <formalpara>
                        <title>Синтаксис:</title>

                        <para><programlisting>
CASE
  WHEN <replaceable>&lt;bool_expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable>
  [WHEN <replaceable>&lt;bool_expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable> …]
  [ELSE <replaceable>&lt;defaultresult&gt;</replaceable>]
END
                </programlisting></para>
                    </formalpara>
                    <para>Здесь <replaceable>&lt;bool_expr&gt;</replaceable> выражение, которое даёт
                        тройной логический результат: TRUE, FALSE или NULL. Первое выражение,
                        возвращающее TRUE, определяет результат. Если нет выражений, возвращающих
                        TRUE, то в качестве результата берётся
                            <replaceable>defaultresult</replaceable> из ветви ELSE. Если нет
                        выражений, возвращающих TRUE, и ветвь ELSE отсутствует, результатом будет
                        NULL.</para>
                    <para>Как и в простом операторе CASE, результаты не обязаны быть литеральными
                        значениями: они могут быть полями или именами переменных, сложными
                        выражениями, или NULL.</para>

                    <formalpara>
                        <title>Пример:</title>
                        <para>
                            <informalexample>
                                <para><programlisting language="sql"> 
CANVOTE = CASE
  WHEN AGE &gt;= 18 THEN 'Yes'
  WHEN AGE &lt; 18 THEN 'No'
  ELSE 'Unsure'
END;
                </programlisting></para>
                            </informalexample>
                        </para>
                    </formalpara>
                </simplesect>
            </section>
        </section>
        <section xml:id="common-expr-null">
            <info>
                <title>NULL в выражениях</title>
                <keywordset>
                    <keyword>NULL</keyword>
                </keywordset>
            </info>
            <indexterm><primary>NULL</primary></indexterm>
            <para>В SQL NULL не является значением — это состояние, указывающее, что значение
                элемента неизвестно или не существует. Это не ноль, не пустота, не <quote>пустая
                    строка</quote>, и оно не ведёт себя как какое-то из этих значений. </para>
            <para>При использовании NULL в числовых, строковых выражениях или в выражениях,
                содержащих дату/время, в результате вы всегда получите NULL. При использовании NULL
                в логических (булевых) выражениях результат будет зависеть от типа операции и других
                вовлечённых значений. При сравнении значения с NULL результат будет неопределённым
                (UNKNOWN). </para>
            <important>
                <para>Неопределённый логический результат (UNKNOWN) тоже представлен
                    псевдо-значением NULL. </para>
            </important>
            <section xml:id="common-expr-null-expr">
                <info>
                    <title>Выражения возвращающие NULL</title>
                </info>
                <para>Выражения в этом списке всегда возвратят NULL:
                    <literallayout class="monospaced">
1 + 2 + 3 + NULL
'Home ' || 'sweet ' || NULL
MyField = NULL
MyField &lt;&gt; NULL
NULL = NULL
not (NULL)
          </literallayout>
                    Если вам трудно понять, почему, вспомните, что NULL — значит
                        <quote>неизвестно</quote>.</para>
            </section>
            <section xml:id="common-expr-null-logicexpr" status="Переписать">
                <info>
                    <title>NULL в логических выражениях</title>
                </info>
                <para>Мы уже рассмотрели, что not (NULL) даёт в результате NULL. Для операторов and
                    (логическое И) и or (логическое ИЛИ) взаимодействие несколько сложнее:
                    <literallayout class="monospaced">
NULL or false = NULL
NULL or true = true
NULL or NULL = NULL
NULL and false = false
NULL and true = NULL
NULL and NULL = NULL
          </literallayout>
                </para>

                <formalpara>
                    <title>Примеры:</title>
                    <para>
                        <informalexample>
                            <para><programlisting language="sql"> 
  (1 = NULL) OR (1 &lt;&gt; 1) -- возвратит NULL   
  (1 = NULL) OR (1 = 1) -- возвратит TRUE   
  (1 = NULL) OR (1 = NULL) -- возвратит NULL   
  (1 = NULL) AND (1 &lt;&gt; 1) -- возвратит FALSE   
  (1 = NULL) AND (1 = 1) -- возвратит NULL   
  (1 = NULL) AND (1 = NULL) -- возвратит NULL    
                </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
            </section>
        </section>
    </section>
    <section xml:id="common-subquery">
        <title>Подзапросы</title>

        <para> Подзапрос — это специальный вид выражения, которое фактически является запросом
            SELECT к другой таблице, включённый в спецификацию основного запроса. Подзапросы пишутся
            как обычные SELECT запросы, но должны быть заключены в круглые скобки. Выражения
            подзапроса используется следующими способами: </para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>Для задания выходного столбца в списке выбора SELECT;</para>
            </listitem>
            <listitem>
                <para>Для получения значений или условий для предикатов поиска (предложения WHERE,
                    HAVING).</para>
            </listitem>
        </itemizedlist>
        <section xml:id="common-subquery-corr">
            <title>Коррелированные подзапросы</title>
            <para>Подзапрос может быть коррелированным (соотнесённым). Запрос называется
                соотнесённым, когда оба, и внутренний, и внешний, запросы взаимозависимы. Это
                означает, что для обработки каждой записи внутреннего запроса, должна быть получена
                также запись внешнего запроса, т.е. внутренний запрос всецело зависит от внешнего. </para>
            <formalpara>
                <title>Пример коррелированного подзапроса:</title>

                <para>
                    <informalexample>
                        <para>
                            <programlisting language="sql"> 
SELECT *
FROM Customers C
WHERE EXISTS
      (SELECT *
       FROM Orders O
       WHERE C.cnum = O.cnum
         AND O.adate = DATE '10.03.1990');
  
                </programlisting>
                        </para>
                    </informalexample>
                </para>
            </formalpara>
            <para> При использовании подзапросов для получения значений выходного столбца в списке
                выбора SELECT, подзапрос должен возвращать скалярный результат. </para>
        </section>
        <section xml:id="common-subquery-scalar">
            <title>Подзапросы возвращающие скалярный результат (Singletons)</title>
            <para><emphasis>Подзапросы</emphasis>, используемые в предикатах поиска, кроме
                предикатов существования и количественных предикатов, должны возвращать скалярный
                результат, то есть не более чем один столбец из одной отобранной строки или одно
                агрегированное значение, в противном случае, произойдёт ошибка времени выполнения
                    (<quote>Multiple rows in a singleton select...</quote>).</para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Подзапрос в качестве выходного столбца в списке выбора</title>

                        <para>
                            <programlisting language="sql">  
SELECT
    e.first_name,
    e.last_name,
    (SELECT
         sh.new_salary
     FROM
         salary_history sh
     WHERE
         sh.emp_no = e.emp_no
     ORDER BY sh.change_date DESC ROWS 1) AS last_salary
FROM
    employee e       
</programlisting>
                        </para>
                    </example>
                    <example>
                        <title>Подзапрос в предложении WHERE для получения значения максимальной
                            зарплаты сотрудника и фильтрации по нему</title>

                        <para>
                            <programlisting language="sql">  
SELECT
    e.first_name,
    e.last_name,
    e.salary
FROM
    employee e
WHERE
    e.salary = (SELECT
                    MAX(ie.salary)
                FROM
                    employee ie)       
</programlisting>
                        </para>
                    </example>
                </para>
            </formalpara>
        </section>
    </section>
    <section xml:id="common-predicats">
        <info>
            <title>Предикаты</title>
        </info>

        <para>Предикат — это простое выражение, утверждающее некоторый факт. Предикат может быть
            истинным (TRUE), ложным (FALSE) и неопределённым (UNKNOWN). В SQL ложный и
            неопределённый результаты трактуются как ложь. </para>
        <para>В SQL предикаты проверяют в ограничении CHECK, предложении WHERE, выражении CASE,
            условии соединения во фразе ON для предложений JOIN, а также в предложении HAVING. В
            PSQL операторы управления потоком выполнения проверяют предикаты в предложениях IF,
            WHILE и WHEN.</para>
        <section xml:id="common-predicats-assetions">
            <title>Утверждения</title>
            <para>Проверяемые условия не всегда являются простыми предикатами. Они могут быть
                группой предикатов, каждый из которых при вычислении делает вклад в вычислении общей
                истинности. Такие сложные условия называются утверждениями. Утверждения могут
                состоять из одного или нескольких предикатов, связанных логическими операторами AND,
                OR и NOT. </para>
            <para>Каждый из предикатов может содержать вложенные предикаты. Результат вычисления
                истинности утверждения получается в результате вычисления всех предикатов по
                направлению от внутренних к внешним. Каждый <quote>уровень</quote> вычисляется в
                порядке приоритета, до тех пор, пока невозможно будет получить окончательное
                утверждение.</para>
        </section>
        <section xml:id="common-predicats-compare">
            <title>Предикаты сравнения</title>

            <para>Предикат сравнения представляет собой два выражения, соединяемых оператором
                сравнения. Имеется шесть традиционных операторов сравнения:
                <literallayout>
<command>=</command>, <command>&gt;</command>, <command>&lt;</command>, <command>&gt;=</command>, <command>&lt;=</command>, <command>&lt;&gt;</command>
        </literallayout>
                (Полный список операторов сравнения см. <link linkend="common-expr-operators-comp"
                    >Операторы сравнения</link>).</para>
            <para>Если в одной из частей (левой или правой) предиката сравнения встречается NULL, то
                значение предиката будет неопределённым (UNKNOWN). </para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <informalexample>
                        <para>Получить информацию о компьютерах, имеющих частоту процессора не менее
                            500 МГц и цену ниже $800</para>
                        <para>
                            <programlisting language="sql">  
SELECT * 
FROM Pc 
WHERE speed &gt;= 500 AND price &lt; 800;      
</programlisting>
                        </para>
                    </informalexample>
                    <informalexample>
                        <para>Получить информацию обо всех принтерах, которые являются матричными и
                            стоят меньше $300</para>
                        <para>
                            <programlisting language="sql">  
SELECT * 
FROM Printer 
WHERE type = 'matrix' AND price &lt; 300;    
</programlisting>
                        </para>
                    </informalexample>
                    <informalexample>
                        <para>Следующий запрос не вернёт ни одной записи, поскольку сравнение
                            происходит с псевдо-значением NULL, даже если существуют принтеры с
                            неуказанным типом.</para>
                        <para>
                            <programlisting language="sql">  
SELECT * 
FROM Printer 
WHERE type = NULL AND price &lt; 300;  
</programlisting>
                        </para>
                    </informalexample>
                </para>
            </formalpara>
			<note>
                <title>Замечание о сравнении строк</title>
                <para>При сравнении на равенство полей типов <database>CHAR</database> и
                        <database>VARCHAR</database> завершающий пробелы игнорируются во всех
                    случаях.</para>
            </note>
        </section>
        <section xml:id="common-predicats-othercompare">
            <title>Другие предикаты сравнения</title>
            <para>Другие предикаты сравнения состоят из ключевых слов.</para>
            <section xml:id="common-predicats-othercompare-between">
                <info>
                    <title>BETWEEN</title>
                    <keywordset>
                        <keyword>BETWEEN</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>BETWEEN</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL, ESQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting> 
<replaceable>&lt;value&gt;</replaceable> [NOT] BETWEEN <replaceable>&lt;value_1&gt;</replaceable> AND <replaceable>&lt;value_2&gt;</replaceable>                                      
                </programlisting></para>
                </formalpara>

                <para>Оператор BETWEEN проверяет, попадает (или не попадает при использовании NOT)
                    ли значение во включающий диапазон значений.</para>
                <para>Оператор BETWEEN использует два аргумента совместимых типов. В отличие от
                    некоторых других СУБД в Firebird оператор BETWEEN не является симметричным.
                    Меньшее значение должно быть первым аргументом, иначе предикат BETWEEN всегда
                    будет ложным. Поиск является включающим. Таким образом, предикат BETWEEN можно
                    переписать следующим образом:
                    <programlisting> 
<replaceable>&lt;value&gt;</replaceable> &gt;= <replaceable>&lt;value_1&gt;</replaceable> AND <replaceable>&lt;value&gt;</replaceable> &lt;= <replaceable>&lt;value_2&gt;</replaceable>                               
</programlisting>
                </para>
                <para>При использовании предиката BETWEEN в поисковых условиях DML запросов,
                    оптимизатор Firebird может использовать индекс по искомому столбцу, если таковой
                    доступен.</para>
                <informalexample>
                    <para>
                        <programlisting language="sql">  
SELECT *
FROM EMPLOYEE
WHERE HIRE_DATE BETWEEN date '01.01.1992' AND CURRENT_DATE
</programlisting>
                    </para>
                </informalexample>
            </section>
            <section xml:id="common-predicats-othercompare-like">
                <info>
                    <title>LIKE</title>
                    <keywordset>
                        <keyword>LIKE</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>LIKE</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL, ESQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
<replaceable>&lt;match value&gt;</replaceable> [NOT] LIKE <replaceable>&lt;pattern&gt;</replaceable>
  [ESCAPE <replaceable>&lt;escape character&gt;</replaceable>]                                   
                </programlisting></para>
                </formalpara>
                <para>
                    <table frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Параметры предиката LIKE</title>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>match value</replaceable></entry>
                                    <entry>
                                        <para>Выражение символьного типа.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>pattern</replaceable></entry>
                                    <entry>
                                        <para>Шаблон поиска.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>escape character</replaceable></entry>
                                    <entry>
                                        <para>Символ экранирования.</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Предикат LIKE сравнивает выражение символьного типа с шаблоном, определённым
                    во втором выражении. Сравнение с шаблоном является чувствительным к регистру (за
                    исключением случаев, когда само поле определено с сортировкой (COLLATION)
                    нечувствительной к регистру). </para>
                <para>При использовании оператора LIKE во внимание принимаются все символы
                    строки-шаблона. Это касается так же начальных и конечных пробелов. Если операция
                    сравнения в запросе должна вернуть все строки, содержащие строки LIKE 'абв ' (с
                    символом пробела на конце), то строка, содержащая 'абв' (без пробела), не будет
                    возвращена.</para>
                <section xml:id="common-predicats-othercompare-like-wilcards">
                    <title>Трафаретные символы</title>
                    <para>В шаблоне, разрешается использование двух трафаретных символов: </para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>символ процента (%) заменяет последовательность любых символов
                                (число символов в последовательности может быть от 0 и более) в
                                проверяемом значении;</para>
                        </listitem>
                        <listitem>
                            <para>символ подчёркивания (_), который можно применять вместо любого
                                единичного символа в проверяемом значении.</para>
                        </listitem>
                    </itemizedlist>
                    <para>Если проверяемое значение соответствует образцу с учётом трафаретных
                        символов, то предикат истинен.</para>
                </section>
                <section xml:id="common-predicats-othercompare-like-escape">
                    <info>
                        <title>Использование управляющего символа в предложении ESCAPE</title>
                        <keywordset>
                            <keyword>ESCAPE</keyword>
                        </keywordset>
                    </info>
                    <indexterm>
                        <primary>LIKE</primary>
                        <secondary>ESCAPE</secondary>
                    </indexterm>
                    <para>Если искомая строка содержит трафаретный символ, то следует задать
                        управляющий символ в предложении ESCAPE. Этот управляющий символ должен
                        использоваться в образце перед трафаретным символом, сообщая о том, что
                        последний следует трактовать как обычный символ.</para>
                    <informalexample>
                        <para>Найти номера отделов, названия которых начинаются со слова
                                <quote>Software</quote>:</para>
                        <para>
                            <programlisting language="sql">  
SELECT DEPT_NO
FROM DEPT
WHERE DEPT_NAME LIKE 'Software%';
</programlisting>
                        </para>
                        <para>В данном запросе может быть использован индекс, если он построен на
                            поле DEPT_NAME.</para>
                    </informalexample>
                    <note>
                        <title>Оптимизация LIKE</title>
                        <para>В общем случае предикат LIKE не использует индекс. Однако если
                            предикат принимает вид LIKE 'строка%', то он будет преобразован в
                            предикат STARTING WITH, который будет использовать индекс. Если вам
                            необходимо выполнить поиск с начала строки, то вместо предиката LIKE
                            рекомендуется использовать предикат <link
                                linkend="common-predicats-othercompare-starting">STARTING
                                WITH</link>.</para>
                    </note>
                    <informalexample>
                        <para>Поиск сотрудников, имена которых состоят из 5 букв, начинающихся с
                            букв <quote>Sm</quote> и заканчивающихся на <quote>th</quote>. В данном
                            случае предикат будет истинен для имен <quote>Smith</quote> и
                                <quote>Smyth</quote>. </para>
                        <para>
                            <programlisting language="sql">  
SELECT
    first_name
FROM
    employee
WHERE first_name LIKE 'Sm_th'
</programlisting>
                        </para>
                    </informalexample>
                    <informalexample>
                        <para>Поиск всех заказчиков, в адресе которых содержится строка
                                <quote>Ростов</quote>.</para>
                        <para>
                            <programlisting language="sql">  
SELECT *
FROM CUSTOMER
WHERE ADDRESS LIKE '%Ростов%'
</programlisting>
                        </para>
                    </informalexample>
                    <tip>
                        <para>Если вам необходимо выполнить поиск внутри строки, то вместо предиката
                            LIKE рекомендуется использовать предикат <link
                                linkend="common-predicats-othercompare-containing"
                            >CONTAINING</link>.</para>
                    </tip>
                    <informalexample>
                        <para>Поиск таблиц, содержащих в имени знак подчёркивания. В данном случае в
                            качестве управляющего символа задан символ <quote>#</quote>.</para>
                        <para>
                            <programlisting language="sql">  
SELECT
  RDB$RELATION_NAME
FROM RDB$RELATIONS
WHERE RDB$RELATION_NAME LIKE '%#_%' ESCAPE '#'
</programlisting>
                        </para>
                    </informalexample>
                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="common-predicats-othercompare-starting">STARTING
                                WITH</link>, <link
                                linkend="common-predicats-othercompare-containing"
                            >CONTAINING</link>, <link
                                linkend="common-predicats-othercompare-similar">SIMILAR TO</link>.
                        </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="common-predicats-othercompare-starting">
                <info>
                    <title>STARTING WITH</title>
                    <keywordset>
                        <keyword>STARTING WITH</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>STARTING WITH</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL, ESQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
<replaceable>&lt;value&gt;</replaceable> [NOT] STARTING WITH <replaceable>&lt;value&gt;</replaceable>                                       
                </programlisting></para>
                </formalpara>

                <para>Оператор STARTING WITH ищет строку или тип, подобный строке, которая
                    начинается с символов в его аргументе. Поиск STARTING WITH чувствителен к
                    регистру. </para>
                <para>При использовании предиката STARTING WITH в поисковых условиях DML запросов,
                    оптимизатор Firebird может использовать индекс по искомому столбцу, если он
                    определён. </para>
                <informalexample>
                    <para>Поиск сотрудников, фамилия которых начинается с <quote>Jo</quote>.</para>
                    <para>
                        <programlisting language="sql">  
SELECT LAST_NAME, FIRST_NAME
FROM EMPLOYEE
WHERE LAST_NAME STARTING WITH 'Jo'
</programlisting>
                    </para>
                </informalexample>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="common-predicats-othercompare-like">LIKE</link>. </para>
                </formalpara>
            </section>
            <section xml:id="common-predicats-othercompare-containing">
                <info>
                    <title>CONTAINING</title>
                    <keywordset>
                        <keyword>CONTAINING</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>CONTAINING</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL, ESQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
<replaceable>&lt;value&gt;</replaceable> [NOT] CONTAINING <replaceable>&lt;value&gt;</replaceable>                                          
                </programlisting></para>
                </formalpara>

                <para>Оператор CONTAINING ищет строку или тип, подобный строке, отыскивая
                    последовательность символов, которая соответствует его аргументу. Он может быть
                    использован для алфавитно-цифрового (подобного строковому) поиска в числах и
                    датах. Поиск CONTAINING не чувствителен к регистру. Тем не менее, если
                    используется сортировка чувствительная к акцентам, то поиск будет чувствителен к
                    акцентам.</para>
                <para>При использовании оператора CONTAINING во внимание принимаются все символы
                    строки. Это касается так же начальных и конечных пробелов. Если операция
                    сравнения в запросе должна вернуть все строки, содержащие строки CONTAINING 'абв
                    ' (с символом пробела на конце), то строка, содержащая 'абв' (без пробела), не
                    будет возвращена.</para>
                <para>При использовании предиката CONTAINING в поисковых условиях DML запросов,
                    оптимизатор Firebird не может использовать индекс по искомому столбцу. </para>
                <informalexample>
                    <para>Поиск проектов в именах, которых присутствует подстрока
                        <quote>Map</quote>:</para>
                    <para>
                        <programlisting language="sql">  
SELECT *
FROM PROJECT
WHERE PROJ_NAME CONTAINING 'map';
</programlisting>
                    </para>
                    <para> В данном случае будет возвращены две строки с именами
                            <quote>AutoMap</quote> и <quote>MapBrowser port</quote>. </para>
                </informalexample>
                <informalexample>
                    <para>Поиск записей об изменении зарплат с датой содержащей число 84 (в данном
                        случае изменения, которые произошли в 1984 году):</para>
                    <para>
                        <programlisting language="sql">  
SELECT *
FROM SALARY_HISTORY
WHERE CHANGE_DATE CONTAINING 84;
</programlisting>
                    </para>
                </informalexample>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="common-predicats-othercompare-like">LIKE</link>. </para>
                </formalpara>
            </section>
            <section xml:id="common-predicats-othercompare-similar">
                <info>
                    <title>SIMILAR TO</title>
                    <keywordset>
                        <keyword>SIMILAR TO</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>SIMILAR TO</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
<replaceable>&lt;match value&gt;</replaceable> [NOT] SIMILAR TO <replaceable>&lt;pattern&gt;</replaceable> [ESCAPE <replaceable>&lt;escape character&gt;</replaceable>]                                           
                </programlisting></para>
                </formalpara>
                <para>
                    <table frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Параметры предиката SIMILAR TO</title>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>match value</replaceable></entry>
                                    <entry>
                                        <para>Выражение символьного типа.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>pattern</replaceable></entry>
                                    <entry>
                                        <para>Регулярное выражение SQL.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>escape character</replaceable></entry>
                                    <entry>
                                        <para>Символ экранирования.</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Оператор <database>SIMILAR TO</database> проверяет соответствие строки с
                    шаблоном регулярного выражения SQL. В отличие от некоторых других языков для
                    успешного выполнения шаблон должен соответствовать всей строке — соответствие
                    подстроки не достаточно. Если один из операндов имеет значение NULL, то и
                    результат будет NULL. В противном случае результат является TRUE или FALSE. </para>
                <section xml:id="common-predicats-othercompare-similar-regexsyn">
                    <title>Синтаксис регулярных выражений SQL</title>
                    <para>Следующий синтаксис определяет формат регулярного выражения SQL. Это
                        полное и корректное его определение. Он является весьма формальным и
                        довольно длинным и, вероятно, озадачивает тех, кто не имеет опыта работы с
                        регулярными выражениями. Не стесняйтесь пропустить его и начать читать
                        следующий раздел, <link linkend="common-regexp">Создание регулярных
                            выражений</link>, использующий подход от простого к сложному.</para>
                    <para><programlisting>
<replaceable>&lt;regular expression&gt;</replaceable> ::= <replaceable>&lt;regular term&gt;</replaceable> ['|' <replaceable>&lt;regular term&gt;</replaceable> ...]       

<replaceable>&lt;regular term&gt;</replaceable> ::= <replaceable>&lt;regular factor&gt;</replaceable> ...
       
<replaceable>&lt;regular factor&gt;</replaceable> ::= <replaceable>&lt;regular primary&gt;</replaceable> [<replaceable>&lt;quantifier&gt;</replaceable>]       

<replaceable>&lt;quantifier&gt;</replaceable> ::= ?                  
               | *                  
               | +                  
               | '{' <replaceable>&lt;m&gt;</replaceable> [,[<replaceable>&lt;n&gt;</replaceable>]] '}'       

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable> ::= целое положительное число с <replaceable>&lt;m&gt;</replaceable> &lt;= <replaceable>&lt;n&gt;</replaceable> если оба присутствуют           

<replaceable>&lt;regular primary&gt;</replaceable> ::= <replaceable>&lt;character&gt;</replaceable>                       
                    | <replaceable>&lt;character class&gt;</replaceable>                       
                    | %                       
                    | (<replaceable>&lt;regular expression&gt;</replaceable>)       

<replaceable>&lt;character&gt;</replaceable> ::= <replaceable>&lt;escaped character&gt;</replaceable>                 
              | <replaceable>&lt;non-escaped character&gt;</replaceable>       

<replaceable>&lt;escaped character&gt;</replaceable> ::= <replaceable>&lt;escape-char&gt;</replaceable> <replaceable>&lt;special character&gt;</replaceable>                         
                      | <replaceable>&lt;escape-char&gt;</replaceable> <replaceable>&lt;escape-char&gt;</replaceable>       

<replaceable>&lt;special character&gt;</replaceable> ::= любой из символов []()|^-+*%_?{       

<replaceable>&lt;non-escaped character&gt;</replaceable> ::= любой символ за исключением <replaceable>&lt;special character&gt;</replaceable> 
                            и не эквивалентный <replaceable>&lt;escape-char&gt;</replaceable> (если задан)       

<replaceable>&lt;character class&gt;</replaceable> ::= '_'                       
                    | '[' <replaceable>&lt;member&gt;</replaceable> ... ']'                       
                    | '[^' <replaceable>&lt;non-member&gt;</replaceable> ... ']'                       
                    | '[' <replaceable>&lt;member&gt;</replaceable> ... '^' <replaceable>&lt;non-member&gt;</replaceable> ... ']'       

<replaceable>&lt;member&gt;</replaceable>, <replaceable>&lt;non-member&gt;</replaceable> ::= <replaceable>&lt;character&gt;</replaceable>   
                         | <replaceable>&lt;range&gt;</replaceable>   
                         | <replaceable>&lt;predefined class&gt;</replaceable>   

<replaceable>&lt;range&gt;</replaceable> ::= <replaceable>&lt;character&gt;</replaceable>-<replaceable>&lt;character&gt;</replaceable>   

<replaceable>&lt;predefined class&gt;</replaceable> ::= '[:' <replaceable>&lt;predefined class name&gt;</replaceable> ':]'   

<replaceable>&lt;predefined class name&gt;</replaceable> ::= ALPHA | UPPER | LOWER | DIGIT 
                         |  ALNUM  |  SPACE  |  WHITESPACE                                             
                </programlisting></para>
                </section>
                <section xml:id="common-regexp">
                    <info>
                        <title>Создание регулярных выражений </title>
                    </info>
                    <simplesect xml:id="common-regexp-symbols">
                        <title>Символы</title>

                        <para>В регулярных выражениях большинство символов представляет сами себя,
                            за исключением специальных символов (special
                            character):<programlisting>
[ ] ( ) | ^ - + * % _ ? { }                       
</programlisting>
                            и управляющих символов, если они заданы.</para>
                        <para>Регулярному выражению, не содержащему специальных или управляющих
                            символов, соответствует только полностью идентичные строки (в
                            зависимости от используемой сортировки). То есть это функционирует точно
                            так же, как оператор <quote><command>=</command></quote>:</para>
                        <para><programlisting language="sql">
'Apple' SIMILAR TO 'Apple' -- TRUE
'Apples' SIMILAR TO 'Apple' -- FALSE
'Apple' SIMILAR TO 'Apples' -- FALSE
'APPLE' SIMILAR TO 'Apple' -- в зависимости от сортировки                            
                        </programlisting></para>
                    </simplesect>
                    <simplesect xml:id="common-regexp-patterns">
                        <title>Шаблоны</title>

                        <para>Известным SQL шаблонам _ и % соответствует любой единственный символ и
                            строка любой длины, соответственно:</para>
                        <para><programlisting language="sql">
'Birne' SIMILAR TO 'B_rne' -- TRUE
'Birne' SIMILAR TO 'B_ne' -- FALSE
'Birne' SIMILAR TO 'B%ne' -- TRUE
'Birne' SIMILAR TO 'Bir%ne%' -- TRUE
'Birne' SIMILAR TO 'Birr%ne' -- FALSE                            
                        </programlisting></para>
                        <para>Обратите внимание, что шаблон % также соответствует пустой
                            строке.</para>
                    </simplesect>
                    <simplesect xml:id="common-regexp-classes">
                        <title>Классы символов</title>

                        <para>Набор символов, заключённый в квадратные скобки определяют класс
                            символов. Символ в строке соответствует классу в шаблоне, если символ
                            является элементом класса:</para>
                        <para><programlisting language="sql">
'Citroen' SIMILAR TO 'Cit[arju]oen' -- TRUE
'Citroen' SIMILAR TO 'Ci[tr]oen' -- FALSE
'Citroen' SIMILAR TO 'Ci[tr][tr]oen' -- TRUE                            
                            </programlisting></para>
                        <para>Как видно из второй строки классу только соответствует единственный
                            символ, а не их последовательность.</para>
                        <para>Два символа, соединённые дефисом, в определении класса определяют
                            диапазон. Диапазон для активного сопоставления включает в себя эти два
                            конечных символа и все символы, находящиеся между ними. Диапазоны могут
                            быть помещены в любом месте в определении класса без специальных
                            разделителей, чтобы сохранить в классе и другие символы.</para>
                        <para><programlisting language="sql">
'Datte' SIMILAR TO 'Dat[q-u]e' -- TRUE
'Datte' SIMILAR TO 'Dat[abq-uy]e' -- TRUE
'Datte' SIMILAR TO 'Dat[bcg-km-pwz]e' -- FALSE                           
                            </programlisting></para>
                        <para><programlisting>
[:ALPHA:]</programlisting>Латинские буквы a...z и
                            A...Z. Этот класс также включает символы с диакритическими знаками при
                            нечувствительных к акцентам сортировках.</para>
                        <para><programlisting>
[:DIGIT:]</programlisting>Десятичные цифры
                            0...9.</para>
                        <para><programlisting>
[:ALNUM:]</programlisting>Объединение [:ALPHA:] и
                            [:DIGIT:].</para>
                        <para><programlisting>
[:UPPER:]</programlisting>Прописные (в верхнем
                            регистре) латинские буквы A...Z. Также включает в себя символы в нижнем
                            регистре при нечувствительных к регистру сортировках и символы с
                            диакритическими знаками при нечувствительных к акцентам
                            сортировках.</para>
                        <para><programlisting>
[:LOWER:]</programlisting>Строчные (в нижнем
                            регистре) латинские буквы a...z. Также включает в себя символы в верхнем
                            регистре при нечувствительных к регистру сортировках и символы с
                            диакритическими знаками при нечувствительных к акцентам
                            сортировках.</para>
                        <para><programlisting>
[:SPACE:]</programlisting>Символ пробела (ASCII
                            32).</para>
                        <para><programlisting>
[:WHITESPACE:]</programlisting>Горизонтальная
                            табуляция (ASCII 9), перевод строки (ASCII 10), вертикальная табуляция
                            (ASCII 11), разрыв страницы (ASCII 12), возврат каретки (ASCII 13) и
                            пробел (ASCII 32).</para>
                        <para>Включение в оператор SIMILAR TO предопределённого класса имеет тот же
                            эффект, как и включение всех его элементов. Использование
                            предопределённых классов допускается только в пределах определения
                            класса. Если вам нужно сопоставление только с предопределённым классом и
                            ничего больше, то поместите дополнительную пару скобок вокруг
                            него.</para>
                        <para><programlisting language="sql">
'Erdbeere' SIMILAR TO 'Erd[[:ALNUM:]]eere' -- TRUE
'Erdbeere' SIMILAR TO 'Erd[[:DIGIT:]]eere' -- FALSE
'Erdbeere' SIMILAR TO 'Erd[a[:SPACE:]b]eere' -- TRUE
'Erdbeere' SIMILAR TO '[[:ALPHA:]]' -- FALSE
'E' SIMILAR TO '[[:ALPHA:]]' -- TRUE                            
                        </programlisting></para>
                        <para>Если определение класса запускается со знаком вставки (^), то все, что
                            следует за ним, исключается из класса. Все остальные символы
                            проверяются.</para>
                        <para><programlisting language="sql">
'Framboise' SIMILAR TO 'Fra[^ck-p]boise' -- FALSE
'Framboise' SIMILAR TO 'Fr[^a][^a]boise' -- FALSE
'Framboise' SIMILAR TO 'Fra[^[:DIGIT:]]boise' -- TRUE                           
                        </programlisting></para>
                        <para>Если знак вставки (^) находится не в начале последовательности, то
                            класс включает в себя все символы до него и исключает символы после
                            него.</para>
                        <para><programlisting language="sql">
'Grapefruit' SIMILAR TO 'Grap[a-m^f-i]fruit' -- TRUE
'Grapefruit' SIMILAR TO 'Grap[abc^xyz]fruit' -- FALSE
'Grapefruit' SIMILAR TO 'Grap[abc^de]fruit' -- FALSE
'Grapefruit' SIMILAR TO 'Grap[abe^de]fruit' -- FALSE
'3' SIMILAR TO '[[:DIGIT:]^4-8]' -- TRUE
'6' SIMILAR TO '[[:DIGIT:]^4-8]' -- FALSE                          
                        </programlisting></para>
                        <para>Наконец, уже упомянутый подстановочный знак
                                    <quote><command>_</command></quote> является собственным классом
                            символов, соответствуя любому единственному символу.</para>
                    </simplesect>
                    <simplesect xml:id="common-regexp-quantors">
                        <title>Кванторы</title>

                        <para>Вопросительный знак сразу после символа или класса указывает на то,
                            что для соответствия предыдущий элемент должен встретиться 0 или 1
                            раз:<programlisting language="sql">
'Hallon' SIMILAR TO 'Hal?on' -- FALSE
'Hallon' SIMILAR TO 'Hal?lon' -- TRUE
'Hallon' SIMILAR TO 'Halll?on' -- TRUE
'Hallon' SIMILAR TO 'Hallll?on' -- FALSE
'Hallon' SIMILAR TO 'Halx?lon' -- TRUE
'Hallon' SIMILAR TO 'H[a-c]?llon[x-z]?' -- TRUE                                
                        </programlisting></para>
                        <para>Звёздочка (*) сразу после символа или класса указывает на то, что для
                            соответствия предыдущий элемент должен встретиться 0 или более
                            раз:<programlisting language="sql">
'Icaque' SIMILAR TO 'Ica*que' -- TRUE
'Icaque' SIMILAR TO 'Icar*que' -- TRUE
'Icaque' SIMILAR TO 'I[a-c]*que' -- TRUE
'Icaque' SIMILAR TO '_*' -- TRUE
'Icaque' SIMILAR TO '[[:ALPHA:]]*' -- TRUE
'Icaque' SIMILAR TO 'Ica[xyz]*e' -- FALSE                        
                            </programlisting></para>
                        <para>Знак плюс (+) сразу после символа или класса указывает на то, что для
                            соответствия предыдущий элемент должен встретиться 1 или более
                            раз:<programlisting language="sql">
'Jujube' SIMILAR TO 'Ju_+' -- TRUE
'Jujube' SIMILAR TO 'Ju+jube' -- TRUE
'Jujube' SIMILAR TO 'Jujuber+' -- FALSE
'Jujube' SIMILAR TO 'J[jux]+be' -- TRUE
'Jujube' SIMILAR TO 'J[[:DIGIT:]]+ujube' -- FALSE                        
                            </programlisting></para>
                        <para>Если символ или класс сопровождаются числом, заключённым в фигурные
                            скобки, то для соответствия необходимо повторение элемента точно это
                            число
                            раз:<programlisting language="sql">
'Kiwi' SIMILAR TO 'Ki{2}wi' -- FALSE
'Kiwi' SIMILAR TO 'K[ipw]{2}i' -- TRUE
'Kiwi' SIMILAR TO 'K[ipw]{2}' -- FALSE
'Kiwi' SIMILAR TO 'K[ipw]{3}' -- TRUE                                
                        </programlisting></para>
                        <para>Если число сопровождается запятой, то для соответствия необходимо
                            повторение элемента как минимум это число
                            раз:<programlisting language="sql">
'Limone' SIMILAR TO 'Li{2,}mone' –- FALSE
'Limone' SIMILAR TO 'Li{1,}mone' -- TRUE
'Limone' SIMILAR TOto 'Li[nezom]{2,}' -- TRUE                        
                            </programlisting></para>
                        <para>Если фигурные скобки содержат два числа (<replaceable>m</replaceable>
                            и <replaceable>n</replaceable>), разделённые запятой, и второе число
                            больше первого, то для соответствия элемент должен быть повторен, как
                            минимум, <replaceable>m</replaceable> раз и не больше
                                <replaceable>n</replaceable>
                            раз:<programlisting language="sql">
'Mandarijn' SIMILAR TO 'M[a-p]{2,5}rijn' -- TRUE
'Mandarijn' SIMILAR TO 'M[a-p]{2,3}rijn' -- FALSE
'Mandarijn' SIMILAR TO 'M[a-p]{2,3}arijn' -- TRUE                        
                            </programlisting></para>
                        <para>Кванторы ?, * и + сокращение для {0,1}, {0,} и {1,},
                            соответственно.</para>
                    </simplesect>
                    <simplesect xml:id="common-regexp-or">
                        <title>Термин ИЛИ</title>

                        <para>В условиях регулярных выражений можно использовать оператор ИЛИ (|).
                            Соответствие произошло, если строка параметра соответствует, по крайней
                            мере, одному из
                            условий:<programlisting language="sql">
'Nektarin' SIMILAR TO 'Nek|tarin' -- FALSE
'Nektarin' SIMILAR TO 'Nektarin|Persika' -- TRUE
'Nektarin' SIMILAR TO 'M_+|N_+|P_+' – TRUE                                
                        </programlisting></para>
                    </simplesect>
                    <simplesect xml:id="common-regexp-subexpr">
                        <title>Подвыражения</title>

                        <para>Одна или более частей регулярного выражения могут быть сгруппированы в
                            подвыражения (также называемые подмасками). Для этого их нужно заключить
                            в круглые
                            скобки:<programlisting language="sql">
'Orange' SIMILAR TO 'O(ra|ri|ro)nge' -- TRUE
'Orange' SIMILAR TO 'O(r[a-e])+nge' -- TRUE
'Orange' SIMILAR TO 'O(ra){2,4}nge' -- FALSE
'Orange' SIMILAR TO 'O(r(an|in)g|rong)?e' – TRUE                               
                        </programlisting></para>
                    </simplesect>
                    <simplesect xml:id="common-regexp-escape">
                        <title>Экранирование специальных символов</title>

                        <para>Для исключения из процесса сопоставления специальных символов (которые
                            часто встречаются в регулярных выражениях) их надо экранировать.
                            Специальных символов экранирования по умолчанию нет — их при
                            необходимости определяет
                            пользователь:<programlisting language="sql">
'Peer (Poire)' SIMILAR TO 'P[^ ]+ \(P[^ ]+\)' ESCAPE '\' -- TRUE
'Pera [Pear]' SIMILAR TO 'P[^ ]+ #[P[^ ]+#]' ESCAPE '#' -- TRUE
'Paron-Appledryck' SIMILAR TO 'P%$-A%' ESCAPE '$' -- TRUE
'Parondryck' SIMILAR TO 'P%--A%' ESCAPE '-' -- FALSE                             
                        </programlisting></para>
                    </simplesect>
                </section>
            </section>
            <section xml:id="common-predicats-othercompare-distinct">
                <info>
                    <title>IS DISTINCT FROM</title>
                    <keywordset>
                        <keyword>IS DISTINCT FROM</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>IS DISTINCT FROM</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting> 
<replaceable>op1</replaceable> IS [NOT] DISTINCT FROM <replaceable>op2</replaceable>                                          
                </programlisting></para>
                </formalpara>

                <para>Два операнда считают различными (DISTINCT), если они имеют различные значения,
                    или если одно из них — NULL, и другое нет. Они считаются NOT DISTINCT (равными),
                    если имеют одинаковые значения или оба имеют значение NULL. </para>
                <para>IS [NOT] DISTINCT FROM всегда возвращает TRUE или FALSE и никогда UNKNOWN
                    (NULL) (неизвестное значение). Операторы <quote><command>=</command></quote> и
                            <quote><command>&lt;&gt;</command></quote>, наоборот, вернут UNKNOWN
                    (NULL), если один или оба операнда имеют значение NULL. </para>
                <para>
                    <table frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Результаты выполнения различных операторов сравнения</title>
                        <tgroup cols="5">
                            <colspec colname="c1" colnum="1" colwidth="1.0*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="1.0*" align="center"/>
                            <colspec colname="c3" colnum="3" colwidth="1.0*" align="center"/>
                            <colspec colname="c4" colnum="4" colwidth="1.0*" align="center"/>
                            <colspec colname="c5" colnum="5" colwidth="1.0*" align="center"/>
                            <thead>
                                <row valign="middle">
                                    <entry morerows="1"> Характеристики операнда </entry>
                                    <entry namest="c2" nameend="c5"> Результаты различных операторов
                                    </entry>
                                </row>
                                <row valign="middle">
                                    <entry>=</entry>
                                    <entry>IS NOT DISTINCT FROM</entry>
                                    <entry> &lt;&gt; </entry>
                                    <entry>IS DISTINCT FROM</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row valign="middle">
                                    <entry> Одинаковые значения </entry>
                                    <entry> TRUE </entry>
                                    <entry> TRUE </entry>
                                    <entry> FALSE </entry>
                                    <entry> FALSE </entry>
                                </row>
                                <row valign="middle">
                                    <entry> Различные значения </entry>
                                    <entry> FALSE </entry>
                                    <entry> FALSE </entry>
                                    <entry> TRUE </entry>
                                    <entry> TRUE </entry>
                                </row>
                                <row valign="middle">
                                    <entry> Оба NULL </entry>
                                    <entry> UNKNOWN </entry>
                                    <entry> TRUE </entry>
                                    <entry> UNKNOWN </entry>
                                    <entry> FALSE </entry>
                                </row>
                                <row valign="middle">
                                    <entry> Одно NULL </entry>
                                    <entry> UNKNOWN </entry>
                                    <entry> FALSE </entry>
                                    <entry> UNKNOWN </entry>
                                    <entry> TRUE </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <informalexample>
                            <para><programlisting language="sql">
SELECT ID, NAME, TEACHER
FROM COURSES
WHERE START_DAY IS NOT DISTINCT FROM END_DAY

IF (NEW.JOB IS DISTINCT FROM OLD.JOB)
THEN POST_EVENT 'JOB_CHANGED';                        
                    </programlisting></para>
                        </informalexample>
                    </para>
                </formalpara>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="common-predicats-othercompare-is">IS</link>. </para>

                </formalpara>
            </section>
            <section xml:id="common-predicats-othercompare-is">
                <info>
                    <title>IS</title>
                    <keywordset>
                        <keyword>IS</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>IS</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting> 
<replaceable>&lt;value&gt;</replaceable> IS [NOT] {TRUE | FALSE | UNKNOWN | NULL}                                          
                </programlisting></para>
                </formalpara>

                <para>Оператор IS проверяет, что выражение в левой части является псевдо значением
                    NULL или соответствует логическому значению в правой части. Если в правой части
                    предиката использованы литерал TRUE, FALSE или UNKNOWN, то выражение в левой
                    части должно быть логического типа, иначе будет выдана ошибка.</para>
                <note>
                    <title>Замечание:</title>
                    <para> В правой части предиката могут быть использованы только литералы TRUE,
                        FALSE, UNKNOWN и NULL, но не выражения.</para>
                </note>
                <example>
                    <title>Предикат IS NULL</title>

                    <para>Поиск записей о продажах, для которых не установлена дата отгрузки:</para>
                    <para>
                        <programlisting language="sql">  
SELECT *
FROM SALES
WHERE SHIP_DATE IS NULL;
</programlisting>
                    </para>
                </example>
                <example>
                    <title>Использование оператора IS с логическим типом данных</title>
                    <para>
                        <programlisting language="sql">
-- Проверка FALSE значения 
SELECT * FROM TBOOL WHERE BVAL IS FALSE 
</programlisting>
                        <screen>
ID           BVAL 
============ ======= 
2            &lt;false&gt; 
</screen>
                        <programlisting language="sql">                        
-- Проверка UNKNOWN значения 
SELECT * FROM TBOOL WHERE BVAL IS UNKNOWN 
</programlisting>
                        <screen>                        
ID           BVAL 
============ ======= 
3            &lt;null&gt;                             
</screen>
                    </para>
                </example>
            </section>
        </section>
        <section xml:id="common-predicats-existence">
            <info>
                <title>Предикаты существования</title>
            </info>
            <para>В эту группу предикатов включены предикаты, которые используют подзапросы и
                передают значения для всех видов утверждений в условиях поиска. Предикаты
                существования называются так потому, что они различными способами проверяют
                существование или отсутствие результатов подзапросов.</para>
            <section xml:id="common-predicats-existence-exists">
                <info>
                    <title>EXISTS</title>
                    <keywordset>
                        <keyword>EXISTS</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>EXISTS</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL, ESQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>   
[NOT] EXISTS (<replaceable>&lt;select_stmt&gt;</replaceable>)                                          
                </programlisting></para>
                </formalpara>

                <para>Предикат EXISTS использует подзапрос в качестве аргумента. Если результат
                    подзапроса будет содержать хотя бы одну запись, то предикат оценивается как
                    истинный (TRUE), в противном случае предикат оценивается как ложный (FALSE). </para>
                <para>Результат подзапроса может содержать несколько столбцов, поскольку значения не
                    проверяются, а просто фиксируется факт наличия строк результата. Данный предикат
                    может принимать только два значения: истина (TRUE) и ложь (FALSE).</para>
                <para>Предикат NOT EXISTS возвращает FALSE, если результат подзапроса будет
                    содержать хотя бы одну запись, в противном случае предикат вернёт TRUE. </para>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Предикат EXISTS</title>

                            <para>Найти тех сотрудников, у которых есть проекты.</para>
                            <para>
                                <programlisting language="sql">  
SELECT *
FROM employee
WHERE EXISTS (SELECT *
              FROM
                employee_project ep
              WHERE
                ep.emp_no = employee.emp_no)
</programlisting>
                            </para>
                        </example>
                        <example>
                            <title>Предикат NOT EXISTS</title>

                            <para>Найти тех сотрудников, у которых нет проектов.</para>
                            <para>
                                <programlisting language="sql">  
SELECT *
FROM employee
WHERE NOT EXISTS (SELECT *
                  FROM
                    employee_project ep
                  WHERE
                    ep.emp_no = employee.emp_no)
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
            </section>
            <section xml:id="common-predicats-existence-in">
                <info>
                    <title>IN</title>
                    <keywordset>
                        <keyword>IN</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>IN</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL, ESQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>   
<replaceable>&lt;value&gt;</replaceable> [NOT] IN (<replaceable>&lt;select_stmt&gt;</replaceable> | <replaceable>&lt;value_list&gt;</replaceable>)       

<replaceable>&lt;value_list&gt;</replaceable> ::= <replaceable>&lt;value_1&gt;</replaceable> [, <replaceable>&lt;value_2&gt;</replaceable> ...]                                              
                </programlisting></para>
                </formalpara>

                <para>Предикат IN проверяет, присутствует ли значение выражения слева в указанном
                    справа наборе значений. Набор значений не может превышать 1500 элементов.
                    Предикат IN может быть переписан в следующей эквивалентной форме:
                    <programlisting>
(<replaceable>&lt;value&gt;</replaceable> = <replaceable>&lt;value_1&gt;</replaceable> [OR <replaceable>&lt;value&gt;</replaceable> = <replaceable>&lt;value_2&gt;</replaceable> ...])                    
                    </programlisting></para>
                <para>При использовании предиката IN в поисковых условиях DML запросов, оптимизатор
                    Firebird может использовать индекс по искомому столбцу, если он
                    определён.</para>
                <para>Во второй форме предикат IN проверяет, присутствует (или отсутствует, при
                    использовании NOT IN) ли значение выражения слева в результате выполнения
                    подзапроса справа. Результат подзапроса может содержать только один столбец,
                    иначе будет выдана ошибка <quote>count of column list and variable list do not
                        match</quote>. </para>
                <para>Запросы с использованием предиката IN с подзапросом, можно переписать на
                    аналогичный запрос с использованием предиката EXISTS. Например, следующий
                    запрос:<programlisting language="sql">
SELECT
  model, speed, hd
FROM PC
WHERE
  model IN (SELECT model
            FROM product
            WHERE maker = 'A');                
                    </programlisting></para>
                <para>Можно переписать на аналогичный запрос с использованием предиката
                    EXISTS:<programlisting language="sql">
SELECT
  model, speed, hd
FROM PC
WHERE
  EXISTS (SELECT *
          FROM product
          WHERE maker = 'A'
            AND product.model = PC.model);                
                    </programlisting></para>

                <para>Однако, запрос с использованием NOT IN не всегда даст тот же результат, что
                    запрос NOT EXISTS. Причина заключается в том, что предикат EXISTS всегда
                    возвращает TRUE или FALSE, тогда как предикат IN может вернуть NULL в следующих случаях:<orderedlist>
                        <listitem>
                            <para>Когда проверяемое значение равно NULL и список в IN не
                                пуст.</para>
                        </listitem>
                        <listitem>
                            <para>Когда проверяемое значение не имеет совпадений в списке IN и одно
                                из значений является NULL.</para>
                        </listitem>
                    </orderedlist></para>
                <para>В этих двух случаях предикат IN вернёт NULL, в то время как соответствующий
                    предикат EXISTS вернёт FALSE. В поисковых условиях или операторе IF оба
                    результата обозначают <quote>провал</quote> и обрабатываются одинаково.</para>
                <para>Однако на тех же данных NOT IN вернёт NULL, в то время как EXISTS вернёт TRUE,
                    что приведёт к противоположному результату.</para>

                <para>Это можно продемонстрировать следующим примером.</para>
                <para>Предположим у вас есть такой
                    запрос:<programlisting language="sql">
-- Ищем людей, которые не родились в тот же день, что
-- известные жители Нью-Йорка
SELECT P1.name AS NAME
FROM Personnel P1 
WHERE P1.birthday NOT IN (SELECT C1.birthday
                          FROM Celebrities C1 
                          WHERE С1.birthcity = 'New York');                
                </programlisting></para>
                <para>Можно предположить, что аналогичный результат даст запрос с использованием
                    предиката NOT
                    EXISTS:<programlisting language="sql">
-- Ищем людей, которые не родились в тот же день, что
-- известные жители Нью-Йорка
SELECT P1.name AS NAME
FROM Personnel P1
WHERE NOT EXISTS (SELECT *
                  FROM Celebrities C1
                  WHERE C1.birthcity = 'New York'
                    AND C1.birthday = P1.birthday);              
                    </programlisting></para>
                <para>Допустим, что в Нью-Йорке всего один известный житель, и его дата рождения
                    неизвестна. При использовании предиката EXISTS подзапрос внутри него не выдаст
                    результатов, так как при сравнении дат рождения с NULL результатом будет
                    UNKNOWN. Это приведёт к тому, что результат предиката NOT EXISTS будет истинен
                    для каждой строки основного запроса. В то время как результатом предиката NOT IN
                    будет UNKNOWN и ни одна строка не будет выведена.</para>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Предикат IN</title>

                            <para>Найти сотрудников с именами <quote>Pete</quote>,
                                    <quote>Ann</quote> и <quote>Roger</quote>:</para>
                            <para>
                                <programlisting language="sql">  
SELECT *
FROM EMPLOYEE
WHERE FIRST_NAME IN ('Pete', 'Ann', 'Roger');
</programlisting>
                            </para>
                        </example>
                        <example>
                            <title>Поисковый предикат IN</title>

                            <para>Найти все компьютеры, для которых существуют модели, производитель
                                которых начинается на букву <quote>A</quote>:</para>
                            <para>
                                <programlisting language="sql">  
SELECT
  model, speed, hd
FROM PC
WHERE
  model IN (SELECT model
            FROM product
            WHERE maker STARTING WITH 'A');
</programlisting>
                            </para>
                        </example>
                    </para>
                </formalpara>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="common-predicats-existence-exists">EXISTS</link>. </para>

                </formalpara>
            </section>
            <section xml:id="common-predicats-existence-singular">
                <info>
                    <title>SINGULAR</title>
                    <keywordset>
                        <keyword>SINGULAR</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>SINGULAR</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL, ESQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
[NOT] SINGULAR (<replaceable>&lt;select_stmt&gt;</replaceable>)                                          
                </programlisting></para>
                </formalpara>

                <para>Предикат SINGULAR использует подзапрос в качестве аргумента и оценивает его
                    как истинный, если подзапрос возвращает одну и только одну строку результата, в
                    противном случае предикат оценивается как ложный. Результат подзапроса может
                    содержать несколько столбцов, поскольку значения не проверяются. Данный предикат
                    может принимать только два значения: истина (TRUE) и ложь (FALSE). </para>
                <example>
                    <title>Предикат SINGULAR</title>

                    <para>Найти тех сотрудников, у которых есть только один проект.</para>
                    <para>
                        <programlisting language="sql">  
SELECT *
FROM employee
WHERE SINGULAR (SELECT *
                FROM
                  employee_project ep
                WHERE
                  ep.emp_no = employee.emp_no)
</programlisting>
                    </para>
                </example>
            </section>
        </section>
        <section xml:id="common-predicats-quantifier">
            <info>
                <title>Количественные предикаты подзапросов</title>
            </info>
            <para> Квантором называется логический оператор, задающий количество объектов, для
                которых данное утверждение истинно. Это логическое количество, а не числовое; оно
                связывает утверждение с полным множеством возможных объектов. Такие предикаты
                основаны на формальных логических квантификаторах общности и существования, которые
                в формальной логике записываются как <inlineequation>
                    <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML">
                        <mml:mrow>
                            <mml:mo>&#8704;</mml:mo>
                        </mml:mrow>
                    </mml:math>
                </inlineequation> и <inlineequation>
                    <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML">
                        <mml:mrow>
                            <mml:mo>&#8707;</mml:mo>
                        </mml:mrow>
                    </mml:math>
                </inlineequation>.</para>
            <para>В выражениях подзапросов количественные предикаты позволяют сравнивать отдельные
                значения с результатами подзапросов; их общая форма:
                <programlisting>  
<replaceable>&lt;value expression&gt;</replaceable> <replaceable>&lt;comp op&gt;</replaceable> <replaceable>&lt;quantifier&gt;</replaceable> <replaceable>&lt;subquery&gt;</replaceable>
</programlisting>
            </para>
            <section xml:id="common-predicats-quantifier-all">
                <info>
                    <title>ALL</title>
                    <keywordset>
                        <keyword>ALL</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>ALL</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
<replaceable>&lt;value&gt;</replaceable> <replaceable>&lt;op&gt;</replaceable> ALL (<replaceable>&lt;select_stmt&gt;</replaceable>)                                          
                </programlisting></para>
                </formalpara>

                <para>При использовании квантора ALL, предикат является истинным, если каждое
                    значение выбранное подзапросом удовлетворяет условию в предикате внешнего
                    запроса. Если подзапрос не возвращает ни одной строки, то предикат автоматически
                    считается верным. </para>
                <example>
                    <title>Квантор ALL</title>

                    <para>Вывести только тех заказчиков, чьи оценки выше, чем у каждого заказчика в
                        Париже.</para>
                    <para>
                        <programlisting language="sql">  
SELECT * 
FROM Customers 
WHERE rating &gt; ALL 
      (SELECT rating 
       FROM Customers 
       WHERE city = 'Paris')
</programlisting>
                    </para>
                </example>

                <important>
                    <para>Если подзапрос возвращает пустое множество, то предикат будет истинен для
                        каждого левостороннего значения, независимо от оператора. Это может
                        показаться странным и противоречивым, потому что в этом случае каждое
                        левостороннее значение рассматривается как одновременно больше, меньше,
                        равное и неравное любому значению из правого потока.</para>
                    <para>Тем не менее, это нормально согласуется с формальной логикой: если
                        множество пусто, то предикат верен 0 раз, т.е. для каждой строки в
                        множестве.</para>
                </important>
            </section>
            <section xml:id="common-predicats-quantifier-any">
                <info>
                    <title>ANY и SOME</title>
                    <keywordset>
                        <keyword>ANY</keyword>
                        <keyword>SOME</keyword>
                    </keywordset>
                </info>
                <indexterm><primary>ANY</primary></indexterm>
                <indexterm><primary>SOME</primary></indexterm>
                <formalpara>
                    <title>Доступно в:</title>

                    <para>DSQL, PSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
<replaceable>&lt;value&gt;</replaceable> <replaceable>&lt;op&gt;</replaceable> {ANY | SOME} (<replaceable>&lt;select_stmt&gt;</replaceable>)                                          
                </programlisting></para>
                </formalpara>
                <para>Эти два квантора идентичны по поведению. Очевидно, оба представлены в
                    стандарте SQL для взаимозаменяемого использования с целью улучшения читаемости
                    операторов. При использовании квантора ANY или SOME, предикат является истинным,
                    если любое из значений выбранное подзапросом удовлетворяет условию в предикате
                    внешнего запроса. Если подзапрос не возвращает ни одной строки, то предикат
                    автоматически считается ложным. </para>
                <example>
                    <title>Квантор ANY</title>

                    <para>Вывести только тех заказчиков, чьи оценки выше, чем у любого заказчика в
                        Риме.</para>
                    <para>
                        <programlisting language="sql">  
SELECT * 
FROM Customers 
WHERE rating &gt; ANY 
      (SELECT rating 
       FROM Customers 
       WHERE city = 'Rome')
</programlisting>
                    </para>
                </example>
            </section>
        </section>
    </section>
</chapter>
