<!DOCTYPE chapter>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="psql" xml:lang="ru">
    <info>
        <title>Процедурный язык PSQL</title>
    </info>

    <para>Procedural SQL (PSQL) — процедурное расширение языка SQL. Это подмножество языка
        используется для написания хранимых процедур, хранимых функций, пакетов, триггеров и PSQL
        блоков.</para>

    <para>Это расширение содержит все основные конструкции классических языков программирования.
        Кроме того, в него входят немного модифицированные DML операторы (SELECT, INSERT, UPDATE,
        DELETE и др.).</para>

    <section xml:id="psql-elements">
        <title>Элементы PSQL</title>

        <para>Процедурное расширение может содержать объявления локальных переменных и курсоров,
            операторы присваивания, условные операторы, операторы циклов, выброса пользовательского
            исключений, средства для обработки ошибок, отправки сообщений (событий) клиентским
            программам. Кроме того, в триггерах доступны специфичные контекстные переменные, такие
            как NEW и OLD.</para>
        <para>В PSQL не допустимы операторы модификации метаданных (DDL операторы).</para>

        <section xml:id="psql-elements-dml">
            <title>DML операторы с параметрами</title>

            <para>В DML (SELECT, INSERT, UPDATE, DELETE и др.) операторах допустимы только
                именованные параметры. Если DML операторы содержат именованные параметры, то они
                должны быть предварительно объявлены как локальные переменные в операторе DECLARE
                [VARIABLE] заголовка модуля или доступны во входных или выходных параметрах PSQL
                модуля.</para>
            <para>При использовании именованных параметров в DML операторах необходим префикс
                двоеточия <quote>:</quote>, однако в предложении INTO символ двоеточия не
                обязателен. Префикс двоеточия является необязательным в операторах специфичных для
                PSQL, таких как операторы ветвления или присваивания. Префикс двоеточия не требуется
                также при вызове хранимой процедуры с помощью оператора EXECUTE PROCEDURE из другого
                PSQL модуля.</para>
        </section>

        <section xml:id="psql-elements-transacs">
            <title>Транзакции</title>

            <para>Хранимые процедуры и функции (в том числе содержащиеся в пакетах) выполняются в
                контексте той транзакции, в которой они были запущены. Триггеры выполняются в
                контексте транзакции, в которой выполнялся DML оператор, вызвавший запуск триггера.
                Для триггеров на событие базы данных запускается отдельная транзакция.</para>
            <para>В PSQL не допустимы операторы старта и завершения транзакций, но существует
                возможность запуска оператора или блока операторов в автономной транзакции.</para>
        </section>

        <section xml:id="psql-elements-structure">
            <title>Структура модуля</title>

            <para>В синтаксисе PSQL модулей можно выделить заголовок и тело. DDL операторы для их
                объявления являются сложными операторами, т.е. состоят из единственного оператора,
                который включает в себя блоки нескольких операторов. Такие операторы начинаются с
                глагола (CREATE, ALTER, DROP, RECREATE, CREATE OR ALTER) и завершаются последним
                оператором END тела модуля.</para>

            <section xml:id="psql-elements-header">
                <title>Заголовок модуля</title>

                <para>Заголовок содержит имя модуля и описание локальных переменных. Для хранимых
                    процедур и PSQL блоков заголовок может содержать описание входных и выходных
                    параметров. Заголовок триггеров не может содержать входных и выходных
                    параметров.</para>
                <para>В заголовке триггера обязательно указывается событие (или комбинация событий),
                    при котором триггер будет вызван автоматически.</para>
            </section>

            <section xml:id="psql_elements-sql_security">
                <title>Привилегии выполнения PSQL кода</title>
                <indexterm>
                    <primary>SQL SECURITY</primary>
                </indexterm>
                <para>Необязательное предложение SQL SECURITY позволяет задать с какими привилегиями
                    выполняется PSQL модуль. Если выбрана опция INVOKER, то PSQL модуль выполняются
                    с привилегиями вызывающего пользователя. Если выбрана опция DEFINER, то PSQL
                    модуль выполняется с привилегиями определяющего пользователя (владельца). Эти
                    привилегии будут дополнены привилегиями выданные самому PSQL модулю с помощью
                    оператора GRANT. По умолчанию процедуры, функции выполняются с привилегиями
                    вызывающего пользователя, а триггеры наследуют привилегии безопасности указанные
                    для таблицы.</para>
                <para>Анонимные PSQL блоки (EXECUTE BLOCK) всегда выполняются с правами вызывающего
                    пользователя.</para>
            </section>

            <section xml:id="psql-elements-declare">
                <title>Секция деклараций</title>

                <para>Тело PSQL модуля начинается после ключевого слова AS. Тело модуля состоит из
                    секции деклараций и составного оператора.</para>

                <para>Секция деклараций может содержать объявления локальной переменной, курсора или
                    подпрограммы (подпроцедуры или подфункции). Каждый тип объявления будет
                    рассмотрен отдельно.</para>

                <formalpara>
                    <title>См. также:</title>
                    <para>
                        <link linkend="psql-statements-declare-var">DECLARE VARIABLE</link>, <link
                            linkend="psql-statements-declare-cursor">DECLARE CURSOR</link>, <link
                            linkend="psql-statements-declare-procedure">DECLARE PROCEDURE</link>,
                            <link linkend="psql-statements-declare-function">DECLARE FUNCTION</link>
                    </para>
                </formalpara>
            </section>

            <section xml:id="psql-elements-body">
                <title>Тело модуля</title>

                <para>После необязательной секции деклараций обязательно следует составной оператор,
                    содержащий описание выполняемых программой действий. Операторные скобки BEGIN
                    ... END определяют составной оператор или блок операторов, который выполняется
                    как одна единица кода. В самих программах возможно присутствие произвольного
                    количества блоков, как последовательных, так и вложенных друг в друга.
                    Максимальная глубина ограничена 512 уровнями вложенности блоков. Все операторы
                    за исключением блоков BEGIN ... END отделяются друг от друга точкой с запятой
                    (;). Никакой другой символ не является допустимым терминатором операторов
                    PSQL.</para>

                <sidebar xml:id="psql-setterm">
                    <title>Изменение терминатора в <application>isql</application></title>

                    <para>Здесь мы немного отвлечёмся для того, чтобы объяснить как переключить
                        терминатор в утилите <application>isql</application>. Это необходимо чтобы
                        иметь возможность определять в ней PSQL модули, не конфликтуя с самим
                            <application>isql</application>, который использует тот же самый символ,
                        точку с запятой (;), как разделитель операторов.</para>

                    <formalpara>
                        <title>isql команда SET TERM</title>
                        <para/>
                    </formalpara>
                    <formalpara>
                        <title>Назначение:</title>
                        <para>Изменение символа(ов) терминатора, чтобы избежать конфликта с
                            терминатором в PSQL операторах.</para>
                    </formalpara>
                    <formalpara>
                        <title>Доступно в:</title>

                        <para>ISQL.</para>
                    </formalpara>
                    <formalpara>
                        <title>Синтаксис:</title>

                        <para><programlisting>
SET TERM <replaceable>&lt;new_terminator&gt;</replaceable><replaceable>&lt;old_terminator&gt;</replaceable>
                </programlisting></para>
                    </formalpara>
                    <para>
                        <table frame="all">
                            <?dbfo keep-together='auto'?>
                            <title>Параметры оператора SET TERM</title>
                            <tgroup cols="2">
                                <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                                <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                                <thead>
                                    <row>
                                        <entry align="center">Параметр</entry>
                                        <entry align="center">Описание</entry>
                                    </row>
                                </thead>
                                <tbody>
                                    <row>
                                        <entry><replaceable>new_terminator</replaceable></entry>
                                        <entry>
                                            <para>Новый терминатор.</para>
                                        </entry>
                                    </row>
                                    <row>
                                        <entry><replaceable>old_terminator</replaceable></entry>
                                        <entry>
                                            <para>Старый терминатор.</para>
                                        </entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </table>
                    </para>

                    <para>При написании триггеров и хранимых процедур в текстах скриптов, создающих
                        требуемые программные объекты базы данных, во избежание двусмысленности
                        относительно использования символа завершения операторов (по нормам SQL это
                        точка с запятой) применяется оператор SET TERM, который, строго говоря, не
                        является оператором SQL, а является командой интерактивного инструмента
                            <application>isql</application>. При помощи этого оператора перед
                        началом создания триггера или хранимой процедуры задаётся символ или строка
                        символов, являющийся завершающим в конце текста триггера или хранимой
                        процедуры. После описания текста соответствующего программного объекта при
                        помощи того же оператора SET TERM значение терминатора возвращается к
                        обычному варианту — точка с запятой.</para>
                    <para>Альтернативный терминатор может быть любой произвольной строкой символов
                        за исключением точки с запятой, пробела и апострофа. Если вы используете
                        буквенный символ, то он будет чувствителен к регистру.</para>
                    <example>
                        <title>Задание альтернативного терминатора</title>
                        <para><programlisting language="sql">
SET TERM ^;

CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
BEGIN
  /* Тело хранимой процедуры */
END^

/* Другие хранимые процедуры и триггеры */

SET TERM ;^

/* Другие операторы DDL */
                </programlisting></para>
                    </example>
                </sidebar>
            </section>
        </section>
    </section>

    <section xml:id="psql-procedure">
        <info>
            <title>Хранимые процедуры</title>
        </info>

        <para>Хранимая процедура является программой, хранящейся в области метаданных базы данных и
            выполняющейся на стороне сервера. К хранимой процедуре могут обращаться хранимые
            процедуры (в том числе и сама к себе), триггеры и клиентские программы. Если хранимая
            процедура вызывает саму себя, то такая хранимая процедура называется рекурсивной.</para>

        <section xml:id="psql-procedure-benefits">
            <title>Преимущества хранимых процедур</title>

            <para>Хранимые процедуры имеют следующие преимущества: <orderedlist>
                    <listitem>
                        <formalpara>
                            <title>Модульность</title>
                            <para>Приложения, работающие с одной и той же базой данных, могут
                                использовать одну и ту же хранимую процедуру, тем самым уменьшив
                                размер кода приложения и устранив дублирование кода.</para>
                        </formalpara>
                    </listitem>
                    <listitem>
                        <formalpara>
                            <title>Упрощение поддержки приложений</title>
                            <para>При изменении хранимой процедуры, изменения отражаются сразу во
                                всех приложениях, без необходимости их перекомпиляции.</para>
                        </formalpara>
                    </listitem>
                    <listitem>
                        <formalpara>
                            <title>Увеличение производительности</title>
                            <para>Поскольку хранимые процедуры выполняются на стороне сервера, а не
                                клиента, то это уменьшает сетевой трафик, что повышает
                                производительность.</para>
                        </formalpara>
                    </listitem>
                </orderedlist></para>
        </section>

        <section xml:id="psql-procedure-types">
            <title>Типы хранимых процедур</title>

            <para>Существуют два вида хранимых процедур — выполняемые хранимые процедуры (executable
                stored procedures) и селективные процедуры (selectable stored procedures).</para>
            <simplesect xml:id="psql-procedure-types-executable">
                <title>Выполняемые хранимые процедуры</title>

                <para>Выполняемые хранимые процедуры, осуществляют обработку данных, находящихся в
                    базе данных. Эти процедуры могут получать входные параметры и возвращать
                    одиночный набор выходных (RETURNS) параметров. Такие процедуры выполняются с
                    помощью оператора <link linkend="dml-execproc">EXECUTE PROCEDURE</link>. См.
                        <link linkend="ddl-procedure-create-examples">пример</link> создания
                    выполняемой хранимой процедуры в конце раздела <link
                        linkend="ddl-procedure-create">CREATE PROCEDURE</link> главы
                        <quote>Операторы DDL</quote>.</para>
            </simplesect>
            <simplesect xml:id="psql-procedure-types-selectable">
                <title>Селективные хранимые процедуры</title>

                <para>Селективные хранимые процедуры обычно осуществляют выборку данных из базы
                    данных и возвращают при этом произвольное количество строк.</para>
                <para>Такие процедуры позволяют получать довольно сложные наборы данных, которые
                    зачастую невозможно или весьма затруднительно получить с помощью обычных DSQL
                    SELECT запросов. Обычно такие процедуры выполняют циклический процесс извлечения
                    данных, возможно преобразуя их, прежде чем заполнить выходные переменные
                    (параметры) новыми данными на каждой итерации цикла. Оператор <link
                        linkend="psql-statements-suspend">SUSPEND</link>, обычно расположенный в
                    конце каждой итерации, заполняет буфер и ожидает пока вызывающая сторона не
                    выберет (fetch) строку.</para>
                <para>Селективные процедуры могут иметь входные параметры и выходное множество,
                    заданное в предложении RETURNS заголовка процедуры.</para>
                <para>Обращение к селективной хранимой процедуре осуществляется при помощи оператора
                    SELECT (см. <link linkend="dml-select-from-sp">Выборка из селективной хранимой
                        процедуры</link>). См. <link linkend="ddl-procedure-create-examples"
                        >пример</link> создания селективной хранимой процедуры в конце раздела <link
                        linkend="ddl-procedure-create">CREATE PROCEDURE</link> главы
                        <quote>Операторы DDL</quote>.</para>
            </simplesect>
        </section>

        <section xml:id="psql-procedure-create">
            <title>Создание хранимой процедуры</title>

            <para>Синтаксис создания выполняемых хранимых процедур и селективных процедур ничем не
                отличается.</para>
            <formalpara>
                <title>Синтаксис (не полный):</title>

                <para><programlisting>
{CREATE [OR ALTER] | RECREATE} PROCEDURE <replaceable>procname</replaceable> 
[(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])   
<replaceable>&lt;routine body&gt;</replaceable>
      
<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>]

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'
                       </programlisting></para>
            </formalpara>

            <para>Заголовок хранимой процедуры обязательно содержит имя процедуры, которое должно
                быть уникальным среди имён хранимых процедур, таблиц и представлений. В нем так же
                может быть описано некоторое количество входных и выходных параметров. Входные
                параметры перечисляются после имени процедуры внутри пары скобок. Выходные
                параметры, которые являются обязательными для селективных процедур, перечисляются
                внутри пары скобок в предложении RETURNS.</para>

            <para>Тело хранимой процедуры может содержать объявление локальных переменных, курсоров
                и подпрограмм. После секции объявления следует основной блок BEGIN ... END, в
                который заключается PSQL код процедуры. В этом блоке могут содержаться DML и PSQL
                операторы, а также вложенные BEGIN ... END блоки. Любой из BEGIN ... END блоков
                может быть пустым, в том числе и главный блок. Это позволяет разрабатывать процедуры
                пошагово, методом сверху вниз.</para>

            <para>Хранимая процедура может быть расположена во внешнем модуле. В этом случае вместо
                тела процедуры указывается место её расположения во внешнем модуле с помощью
                предложения EXTERNAL NAME. Аргументом этого предложения является строка, в которой
                через разделитель указано имя внешнего модуля, имя процедуры внутри модуля и
                определённая пользователем информация. В предложении ENGINE указывается имя движка
                для обработки подключения внешних модулей. В Firebird для работы с внешними модулями
                используется движок UDR. После ключевого слова AS может быть указан строковый
                литерал — "тело" внешней процедуры, оно может быть использовано внешнем модулем для
                различных целей.</para>

            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-procedure-create">CREATE PROCEDURE</link>).</para>
        </section>

        <section xml:id="psql-procedure-alter">
            <title>Изменение хранимой процедуры</title>

            <para>В существующих хранимых процедурах можно изменять набор входных и выходных
                параметров и тело процедуры.</para>
            <formalpara>
                <title>Синтаксис (не полный):</title>

                <para><programlisting>
ALTER PROCEDURE <replaceable>procname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])    
<replaceable>&lt;routine body&gt;</replaceable>
        
<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>]

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'   
                       </programlisting></para>
            </formalpara>

            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-procedure-alter">ALTER PROCEDURE</link>).</para>
        </section>

        <section xml:id="psql-procedure-drop">
            <title>Удаление хранимой процедуры</title>

            <para>Для удаления хранимых процедур используется оператор DROP PROCEDURE.</para>
            <formalpara>
                <title>Синтаксис (полный):</title>

                <para><programlisting>
DROP PROCEDURE <replaceable>procname</replaceable>;  
                       </programlisting></para>
            </formalpara>
            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-procedure-drop">DROP PROCEDURE</link>).</para>
        </section>
    </section>
    <section xml:id="psql-function">
        <info>
            <title>Хранимые функции</title>
        </info>
        <para>Хранимая функция является программой, хранящейся в области метаданных базы данных и
            выполняющейся на стороне сервера. К хранимой функции могут обращаться хранимые
            процедуры, хранимые функции (в том числе и сама к себе), триггеры и клиентские
            программы. При обращении хранимой функции самой к себе такая хранимая функция называется
            рекурсивной.</para>
        <para>В отличие от хранимых процедур хранимые функции всегда возвращают одно скалярное
            значение. Для возврата значения из хранимой функции используется оператор RETURN,
            который немедленно прекращает выполнение функции.</para>
        <section xml:id="psql-function-create">
            <title>Создание хранимой функции</title>

            <formalpara>
                <title>Синтаксис (не полный):</title>

                <para><programlisting>
{CREATE [OR ALTER] | RECREATE} FUNCTION <replaceable>funcname</replaceable> 
[(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>]
[DETERMINISTIC]  
<replaceable>&lt;routine body&gt;</replaceable>

<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>]

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'   
 
                       </programlisting></para>
            </formalpara>
            <para>Заголовок хранимой функции обязательно содержит имя функции, которое должно быть
                уникальным среди имён хранимых функции. В нем так же может быть описано некоторое
                количество входных параметров и тип выходного результата. Входные параметры
                перечисляются после имени процедуры внутри пары скобок. Тип выходного результата
                указывается в предложении RETURNS.</para>
            <para>Тело хранимой функции может содержать объявление локальных переменных, курсоров и
                подпрограмм. После секции объявления следует основной блок BEGIN ... END, в который
                заключается PSQL код функции. В этом блоке могут содержаться DML и PSQL операторы, а
                также вложенные BEGIN ... END блоки. Любой из BEGIN ... END блоков может быть
                пустым, в том числе и главный блок. Это позволяет разрабатывать функции пошагово,
                методом сверху вниз.</para>
            <para>Хранимая функция может быть расположена во внешнем модуле. В этом случае вместо
                тела функции указывается место её расположения во внешнем модуле с помощью
                предложения EXTERNAL NAME. Аргументом этого предложения является строка, в которой
                через разделитель указано имя внешнего модуля, имя процедуры внутри модуля и
                определённая пользователем информация. В предложении ENGINE указывается имя движка
                для обработки подключения внешних модулей. В Firebird для работы с внешними модулями
                используется движок UDR. После ключевого слова AS может быть указан строковый
                литерал — "тело" внешней функции, оно может быть использовано внешнем модулем для
                различных целей.</para>
            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-function-create">CREATE FUNCTION</link>).</para>
        </section>

        <section xml:id="psql-function-alter">
            <title>Изменение хранимой функции</title>

            <para>В существующих хранимых функциях можно изменять набор входных параметров, тип
                результата и тело функции.</para>
            <formalpara>
                <title>Синтаксис (не полный):</title>

                <para><programlisting>
ALTER FUNCTION <replaceable>funcname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]   
RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
[DETERMINISTC]  
<replaceable>&lt;routine body&gt;</replaceable>  

<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>]

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'
    
                       </programlisting></para>
            </formalpara>

            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-function-alter">ALTER FUNCTION</link>).</para>
        </section>

        <section xml:id="psql-function-drop">
            <title>Удаление хранимой функции</title>

            <para>Для удаления хранимых функций используется оператор DROP FUNCTION.</para>
            <formalpara>
                <title>Синтаксис (полный):</title>

                <para><programlisting>
DROP FUNCTION <replaceable>funcname</replaceable>;  
                       </programlisting></para>
            </formalpara>
            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-function-drop">DROP FUNCTION</link>).</para>
        </section>
    </section>
    <section xml:id="psql-block">
        <info>
            <title>PSQL блоки</title>
        </info>

        <para>Для выполнения из декларативного SQL (DSQL) некоторых императивных действий
            используются анонимные (безымянные) PSQL блоки. Заголовок анонимного PSQL блока
            опциально может содержать входные и выходные параметры. Тело анонимного PSQL блока может
            содержать объявление локальных переменных, курсоров, подпрограмм и блок PSQL
            операторов.</para>
        <para>Анонимный PSQL блок не определяется и сохраняется как объект метаданных, в отличии от
            хранимых процедур и триггеров. Он не может обращаться сам к себе.</para>
        <para>Как и хранимые процедуры анонимные PSQL блоки могут использоваться для обработки
            данных или для осуществления выборки из базы данных.</para>

        <formalpara>
            <title>Синтаксис (полный):</title>

            <para><programlisting>
EXECUTE BLOCK
[(<replaceable>&lt;inparam&gt;</replaceable> = ? [, <replaceable>&lt;inparam&gt;</replaceable> = ? ...])]
[RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])]
AS
[<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
[<replaceable>&lt;PSQL_statements&gt;</replaceable>]
END

                       </programlisting></para>
        </formalpara>
        <para>
            <table frame="all">
                <?dbfo keep-together='auto'?>
                <title>Параметры оператора EXECUTE BLOCK</title>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                    <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                    <thead>
                        <row>
                            <entry align="center">Параметр</entry>
                            <entry align="center">Описание</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry><replaceable>inparam</replaceable></entry>
                            <entry>
                                <para>Описание входного параметра.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>outparam</replaceable></entry>
                            <entry>
                                <para>Описание выходного параметра.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>declarations</replaceable></entry>
                            <entry>
                                <para>Секция объявления локальных переменных, именованных курсоров и
                                    подпрограмм.</para>
                            </entry>
                        </row>
                        <row>
                            <entry><replaceable>PSQL_statments</replaceable></entry>
                            <entry>
                                <para>Операторы языка PSQL.</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </para>

        <formalpara>
            <title>См. также:</title>

            <para>
                <link linkend="dml-execblock">EXECUTE BLOCK</link>.</para>
        </formalpara>
    </section>

    <section xml:id="psql-package">
        <info>
            <title>Пакеты</title>
        </info>
        <para>Пакет — группа процедур и функций, которая представляет собой единый объект базы
            данных.</para>
        <para>Пакеты Firebird состоят из двух частей: заголовка (ключевое слово PACKAGE) и тела
            (ключевые слова PACKAGE BODY). Такое разделение очень сильно напоминает модули Delphi,
            заголовок соответствует интерфейсной части, а тело — части реализации.</para>
        <section xml:id="psql-package-benefits">
            <title>Преимущества пакетов</title>

            <para>Пакеты обладают следующими преимуществами: <itemizedlist>
                    <listitem>
                        <para><emphasis role="italic">Модульность</emphasis>.</para>
                        <para>Блоки взаимозависимого кода выделены в логические модули, как это
                            сделано в других языках программирования. В программировании существует
                            множество способов для группировки кода, например с помощью пространств
                            имен (namespaces), модулей (units) и классов. Со стандартными
                            процедурами и функциями базы данных это не возможно.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="italic">Упрощение отслеживания
                            зависимостей</emphasis>.</para>
                        <para>Пакеты упрощают механизм отслеживания зависимостей между набором
                            связанных процедур, а также между этим набором и другими процедурами,
                            как упакованными, так и неупакованными.</para>
                        <para>Каждый раз, когда упакованная подпрограмма определяет, что
                            используется некоторый объект базы данных, информации о зависимости от
                            этого объекта регистрируется в системных таблицах Firebird. После этого,
                            для того чтобы удалить или изменить этот объект, вы сначала должны
                            удалить, то что зависит от него. Поскольку зависимости от других
                            объектов существуют только для тела пакета, это тело пакета может быть
                            легко удалено, даже если какой-нибудь другой объект зависит от этого
                            пакета. Когда тело удаляется, заголовок остаётся, что позволяет
                            пересоздать это тело после того, как сделаны изменения связанные с
                            удалённым объектом.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="italic">Упрощение управления
                            разрешениями</emphasis>.</para>
                        <para>Поскольку Firebird выполняет подпрограммы с полномочиями вызывающей
                            стороны, то каждой вызывающей подпрограмме необходимо предоставить
                            полномочия на использования ресурсов, если эти ресурсы не являются
                            непосредственно доступными вызывающей стороне. Использование каждой
                            подпрограммы требует предоставления привилегий на её выполнение для
                            пользователей и/или ролей.</para>
                        <para>У упакованных подпрограмм нет отдельных привилегий. Привилегии
                            действуют на пакет в целом. Привилегии, предоставленные пакетам,
                            действительны для всех подпрограмм тела пакета, в том числе частных, и
                            сохраняются для заголовка пакета.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="italic">Частные области видимости</emphasis>.</para>
                        <para>Некоторые процедуры и функции могут быть частными (private), а именно
                            их использование разрешено только внутри определения пакета.</para>
                        <para>Все языки программирования имеют понятие области видимости
                            подпрограмм, которое невозможно без какой-либо формы группировки. Пакеты
                            Firebird в этом отношении подобны модулям Delphi. Если подпрограмма не
                            объявлена в заголовке пакета (interface), но реализована в теле
                            (implementation), то такая подпрограмма становится частной (private).
                            Частную подпрограмму возможно вызвать только из её пакета.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section xml:id="psql-package-create">
            <title>Создание пакета</title>

            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting>
{CREATE [OR ALTER] | RECREATE} PACKAGE <replaceable>package_name</replaceable>  
[<replaceable>&lt;rights clause&gt;</replaceable>]                        
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
END

{CREATE | RECREATE} PACKAGE BODY <replaceable>package_name</replaceable>  
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
  [<replaceable>&lt;package_body_item&gt;</replaceable> ...]                                                        
END

<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER} 

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]    
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                           

<replaceable>&lt;package_body_item&gt;</replaceable> ::=
    <replaceable>&lt;function_impl&gt;</replaceable> 
  | <replaceable>&lt;procedure_impl&gt;</replaceable>

<replaceable>&lt;function_impl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC] 
  <replaceable>&lt;routine body&gt;</replaceable> 
      
<replaceable>&lt;procedure_impl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                             
  <replaceable>&lt;routine body&gt;</replaceable>          

<replaceable>&lt;routine body&gt;</replaceable> ::= <replaceable>&lt;sql routine body&gt;</replaceable> | <replaceable>&lt;external body reference&gt;</replaceable>                   
    
<replaceable>&lt;sql routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                    

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME <replaceable>&lt;extname&gt;</replaceable> ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>]

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'  
                      
                                                    </programlisting>
                </para>
            </formalpara>

            <para>Сначала необходимо создать заголовок пакета (CREATE PACKAGE), а затем — его тело
                (CREATE PACKAGE BODY). В теле пакеты должны быть реализованы все подпрограммы, с той
                же сигнатурой, что и объявленные в заголовке и в начале тела пакета. Значения по
                умолчанию для параметров подпрограмм не могут быть переопределены. Это означает, что
                они могут быть определены в теле пакета только для частных подпрограмм, которые не
                были объявлены.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Простой пакет</title>
                        <para><programlisting language="sql">
SET TERM ^;
-- заголовок пакета, только объявления подпрограмм
CREATE OR ALTER PACKAGE TEST
AS
BEGIN
  PROCEDURE P1(I INT) RETURNS (O INT); -- публичная процедура
END^

-- package body, implementation
RECREATE PACKAGE BODY TEST
AS
BEGIN
  FUNCTION F1(I INT) RETURNS INT; -- частная функция

  PROCEDURE P1(I INT) RETURNS (O INT)
  AS
  BEGIN
  END

  FUNCTION F1(I INT) RETURNS INT
  AS
  BEGIN
    RETURN 0;
  END
END^  
                </programlisting></para>
                    </example>
                    <example>
                        <title>Пакет для работы с сессионными переменными</title>
                        <para><programlisting language="sql">
SET TERM ^;

CREATE PACKAGE APP_VAR
AS
BEGIN
  -- Возвращает дату начала периода
  -- Функция помечена как детерминированная, что позволяет
  -- рассматривать её как инвариант в запросах
  FUNCTION GetDateBegin() RETURNS DATE DETERMINISTIC;

  -- Возвращает дату окончания периода
  -- Функция помечена как детерминированная, что позволяет
  -- рассматривать её как инвариант в запросах
  FUNCTION GetDateEnd() RETURNS DATE DETERMINISTIC;

  -- Устанавливает диапазон дат рабочего периода
  PROCEDURE SetDateRange(ADateBegin DATE, ADateEnd DATE);
END^

CREATE PACKAGE BODY APP_VAR
AS
BEGIN
  -- Возвращает дату начала периода
  FUNCTION GetDateBegin() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEBEGIN');
  END

  -- Возвращает дату окончания периода
  FUNCTION GetDateEnd() RETURNS DATE
  AS
  BEGIN
    RETURN RDB$GET_CONTEXT('USER_SESSION', 'DATEEND');
  END

  -- Устанавливает диапазон дат рабочего периода
  PROCEDURE SetDateRange(ADateBegin DATE, ADateEnd DATE)
  AS
  BEGIN
    RDB$SET_CONTEXT('USER_SESSION', 'DATEBEGIN', ADateBegin);
    RDB$SET_CONTEXT('USER_SESSION', 'DATEEND', ADateEnd);
  END
END^

SET TERM ;^   
                </programlisting>
                            Использование:
                            <programlisting language="sql">
-- Установка рабочего периода
EXECUTE PROCEDURE APP_VAR.SetDateRange(
  date '01.01.2000', date '31.12.2000');

-- Использование в запросах
SELECT *
FROM SALES_ORDER
WHERE bydate BETWEEN APP_VAR.GetDateBegin() 
                 AND APP_VAR.GetDateEnd();                    
                </programlisting>
                        </para>
                    </example>
                    <example>
                        <title>Пакет объединяющий внешние подпрограммы</title>
                        <para><programlisting language="sql">
SET TERM ^;

CREATE OR ALTER PACKAGE REGEXP
AS
BEGIN
  PROCEDURE preg_match(
      APattern VARCHAR(8192), ASubject VARCHAR(8192))
    RETURNS (Matches VARCHAR(8192));

  FUNCTION preg_is_match(
      APattern VARCHAR(8192), ASubject VARCHAR(8192))
    RETURNS BOOLEAN;

  FUNCTION preg_replace(
      APattern VARCHAR(8192), 
      AReplacement VARCHAR(8192),
      ASubject VARCHAR(8192)) 
    RETURNS VARCHAR(8192);

  PROCEDURE preg_split(
      APattern VARCHAR(8192), 
      ASubject VARCHAR(8192))
    RETURNS (Lines VARCHAR(8192));

  FUNCTION preg_quote(
      AStr VARCHAR(8192), 
      ADelimiter CHAR(10) DEFAULT NULL)
    RETURNS VARCHAR(8192);
END^

RECREATE PACKAGE BODY REGEXP
AS
BEGIN
  PROCEDURE preg_match(
      APattern VARCHAR(8192), 
      ASubject VARCHAR(8192))
    RETURNS (Matches VARCHAR(8192))
    EXTERNAL NAME 'PCRE!preg_match' ENGINE UDR;

  FUNCTION preg_is_match(
      APattern VARCHAR(8192), 
      ASubject VARCHAR(8192))
    RETURNS BOOLEAN
  AS
  BEGIN
    RETURN EXISTS(
      SELECT * FROM preg_match(:APattern, :ASubject));
  END

  FUNCTION preg_replace(
      APattern VARCHAR(8192), 
      AReplacement VARCHAR(8192),
      ASubject VARCHAR(8192)) 
    RETURNS VARCHAR(8192)
    EXTERNAL NAME 'PCRE!preg_replace' ENGINE UDR;

  PROCEDURE preg_split(
      APattern VARCHAR(8192), 
      ASubject VARCHAR(8192))
    RETURNS (Lines VARCHAR(8192))
    EXTERNAL NAME 'PCRE!preg_split' ENGINE UDR;

  FUNCTION preg_quote(
      AStr VARCHAR(8192), 
      ADelimiter CHAR(10))
    RETURNS VARCHAR(8192)
    EXTERNAL NAME 'PCRE!preg_quote' ENGINE UDR;
END^

SET TERM ;^   
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="ddl-package-create">CREATE PACKAGE</link>, <link
                        linkend="ddl-package-body-create">CREATE PACKAGE BODY</link>. </para>
            </formalpara>
        </section>
        <section xml:id="psql-package-alter">
            <title>Модификация пакета</title>

            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting>
ALTER PACKAGE <replaceable>package_name</replaceable> 
[<replaceable>&lt;rights clause&gt;</replaceable>]                         
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
END

RECREATE PACKAGE BODY <replaceable>package_name</replaceable>  
AS
BEGIN
  [<replaceable>&lt;package_item&gt;</replaceable> ...]
  [<replaceable>&lt;package_body_item&gt;</replaceable> ...]                                                        
END

<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER} 

<replaceable>&lt;package_item&gt;</replaceable> ::=
    <replaceable>&lt;function_decl&gt;</replaceable>; 
  | <replaceable>&lt;procedure_decl&gt;</replaceable>;
                            
<replaceable>&lt;function_decl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC]    
                            
<replaceable>&lt;procedure_decl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                           

<replaceable>&lt;package_body_item&gt;</replaceable> ::=
    <replaceable>&lt;function_impl&gt;</replaceable> 
  | <replaceable>&lt;procedure_impl&gt;</replaceable>

<replaceable>&lt;function_impl&gt;</replaceable> ::=
  FUNCTION <replaceable>func_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] 
  [DETERMINISTIC] 
  <replaceable>&lt;routine body&gt;</replaceable> 
      
<replaceable>&lt;procedure_impl&gt;</replaceable> ::=
  PROCEDURE <replaceable>proc_name</replaceable> [(<replaceable>&lt;in_impl_params&gt;</replaceable>)] 
  [RETURNS (<replaceable>&lt;out_params&gt;</replaceable>)]                             
  <replaceable>&lt;routine body&gt;</replaceable>          

<replaceable>&lt;routine body&gt;</replaceable> ::= <replaceable>&lt;sql routine body&gt;</replaceable> | <replaceable>&lt;external body reference&gt;</replaceable>                   
    
<replaceable>&lt;sql routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                    

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>]

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]' 
                            
                </programlisting>
                </para>
            </formalpara>

            <para>После модификации/пересоздания заголовка пакета, исходный код тела пакета
                сохраняется. При этом код тела пакета может стать невалидным. Столбец
                RDB$PACKAGES.RDB$VALID_BODY_FLAG отображает состояние тела пакета.</para>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="ddl-package-alter">ALTER PACKAGE</link>, <link
                        linkend="ddl-package-body-recreate">RECREATE PACKAGE BODY</link>.</para>
            </formalpara>
        </section>

        <section xml:id="psql-package-drop">
            <title>Удаление пакета</title>

            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting>
DROP PACKAGE <replaceable>package_name</replaceable> 

DROP PACKAGE BODY <replaceable>package_name</replaceable>  
                </programlisting>
                </para>
            </formalpara>

            <para>Перед удалением заголовка пакета необходимо удалить тело пакета.</para>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="ddl-package-drop">DROP PACKAGE</link>, <link
                        linkend="ddl-package-body-drop">DROP PACKAGE BODY</link>.</para>
            </formalpara>
        </section>
    </section>

    <section xml:id="psql-triggers">
        <info>
            <title>Триггеры</title>
        </info>

        <para>Триггер является программой, которая хранится в области метаданных базы данных и
            выполняется на стороне сервера. Напрямую обращение к триггеру невозможно. Он вызывается
            автоматически при наступлении одного или нескольких событий, относящихся к одной
            конкретной таблице (к представлению), или при наступлении одного из событий базы
            данных.</para>
        <para>Триггер, вызываемый при наступлении события таблицы, связан с одной таблицей или
            представлением, с одним или более событиями для этой таблицы или представления (INSERT,
            UPDATE, DELETE) и ровно с одной фазой такого события (BEFORE или AFTER).</para>
        <para>Триггер выполняется в той транзакции, в контексте которой выполнялась программа,
            вызвавшая соответствующее событие. Исключением являются триггеры, реагирующие на события
            базы данных. Для некоторых из них запускается транзакция по умолчанию.</para>

        <section xml:id="psql-triggers-ordering">
            <title>Порядок срабатывания</title>
            <para>Для каждой комбинации фаза-событие может быть определено более одного триггера.
                Порядок, в котором они выполняются, может быть указан явно с помощью дополнительного
                аргумента POSITION в определении триггера. Максимальная позиция равна 32767.
                Триггеры с меньшей позицией вызываются первыми.</para>
            <para>Если предложение POSITION опущено или несколько триггеров с одинаковыми фазой и
                событием имеют одну и ту же позицию, то такие триггеры будут выполняться в
                алфавитном порядке их имен.</para>
        </section>

        <section xml:id="psql-triggers-dml">
            <title>DML триггеры</title>

            <para>DML триггеры вызываются при изменении состояния данных DML операциями:
                редактирование, добавление или удаление строк. Они могут быть определены и для
                таблиц и для представлений.</para>
            <section xml:id="psql-triggers-dml-options">
                <title>Варианты триггеров</title>
                <para>Существует шесть основных вариантов соотношения событие-фаза для таблицы
                    (представления): <informaltable xml:id="psql-tbl-dmltriggers" frame="none"
                        rowsep="1" colsep="1">
                        <?dbfo keep-together='auto'?>
                        <tgroup cols="2">
                            <colspec colname="colEvent" colwidth="*"/>
                            <colspec colname="colKeywords" colwidth="*"/>
                            <tbody>
                                <row>
                                    <entry>до добавления новой строки </entry>
                                    <entry>(BEFORE INSERT)</entry>
                                </row>
                                <row>
                                    <entry>после добавления новой строки</entry>
                                    <entry>(AFTER INSERT)</entry>
                                </row>
                                <row>
                                    <entry>до изменения строки</entry>
                                    <entry>(BEFORE UPDATE)</entry>
                                </row>
                                <row>
                                    <entry>после изменения строки</entry>
                                    <entry>(AFTER UPDATE)</entry>
                                </row>
                                <row>
                                    <entry>до удаления строки</entry>
                                    <entry>(BEFORE DELETE)</entry>
                                </row>
                                <row>
                                    <entry>после удаления строки</entry>
                                    <entry>(AFTER DELETE)</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para>Помимо базовых форм с единственной фазой и событием Firebird поддерживает
                    также формы с одной фазой и множеством событий, например BEFORE INSERT OR UPDATE
                    OR DELETE или AFTER UPDATE OR DELETE или любая другая комбинация на ваш
                    выбор.</para>
                <note>
                    <para>Триггеры с несколькими фазами, такие как BEFORE OR AFTER ... не
                        поддерживаются.</para>
                </note>
                <para>Контекстные переменные <link linkend="internalfunc-contextvar-inserting"
                        >INSERTING</link>, <link linkend="internalfunc-contextvar-updating"
                        >UPDATING</link> и <link linkend="internalfunc-contextvar-deleting"
                        >DELETING</link> логического типа могут быть использованы в теле триггера
                    для определения события, которое вызвало срабатывание триггера.</para>
            </section>

            <section xml:id="psql-triggers-dml-newold">
                <title>Контекстные переменные NEW и OLD</title>

                <para>В DML триггерах Firebird обеспечивает доступ к множеству контекстных
                    переменных NEW.* и OLD.* Каждое множество является массивом всей строки: OLD.* —
                    значение строки до изменения данных и NEW.* — требуемое ("новое") значение
                    строки. Операторы могут ссылаться на них использую следующие формы
                        NEW.<replaceable>columname</replaceable> и
                        OLD.<replaceable>columnname</replaceable>.
                        <replaceable>columnname</replaceable> может быть любым столбцом определённым
                    в таблице(представлении), а не только тем что был изменён.</para>
                <para>Контекстные переменные NEW и OLD подчиняются следующим правилам: <itemizedlist
                        spacing="compact">
                        <listitem>
                            <para>Во всех триггерах контекстные переменные OLD доступны только для
                                чтения;</para>
                        </listitem>
                        <listitem>
                            <para>В триггерах BEFORE UPDATE и BEFORE INSERT переменные NEW доступны
                                для чтения и записи, за исключением COMPUTED BY столбцов;</para>
                        </listitem>
                        <listitem>
                            <para>В INSERT триггерах ссылка на переменные OLD не допускается и
                                вызовет исключение;</para>
                        </listitem>
                        <listitem>
                            <para>В DELETE триггерах ссылка на переменные NEW не допускается и
                                вызовет исключение;</para>
                        </listitem>
                        <listitem>
                            <para>Во всех AFTER триггерах переменные NEW доступны только для
                                чтения.</para>
                        </listitem>
                    </itemizedlist></para>
            </section>
        </section>

        <section xml:id="psql-dbtriggers">
            <title>Триггеры на события базы данных</title>

            <para>Триггер, связанный с событиями базы данных, может вызываться при следующих
                событиях: <informaltable xml:id="psql-tbl-dbtriggers" frame="none" rowsep="1"
                    colsep="1">
                    <?dbfo keep-together='auto'?>
                    <tgroup cols="3">
                        <colspec colname="colEvent" colwidth="4*"/>
                        <colspec colname="colKeywords" colwidth="3*"/>
                        <colspec colname="colDesc" colwidth="5*"/>
                        <tbody>
                            <row valign="middle">
                                <entry align="left">При соединении с базой данных</entry>
                                <entry align="center"><database>(ON CONNECT)</database></entry>
                                <entry align="left">Перед выполнением триггера автоматически
                                    запускается транзакция по умолчанию</entry>
                            </row>
                            <row valign="middle">
                                <entry align="left">При отсоединении от базы данных</entry>
                                <entry align="center"><database>(ON DISCONNECT)</database></entry>
                                <entry align="left">Перед выполнением триггера автоматически
                                    запускается транзакция по умолчанию</entry>
                            </row>
                            <row valign="middle">
                                <entry align="left">При старте транзакции</entry>
                                <entry align="center"><database>(ON TRANSACTION
                                    START)</database></entry>
                                <entry align="left">Триггер выполняется в контексте текущей
                                    транзакции</entry>
                            </row>
                            <row valign="middle">
                                <entry align="left">При подтверждении транзакции</entry>
                                <entry align="center"><database>(ON TRANSACTION
                                    COMMIT)</database></entry>
                                <entry align="left">Триггер выполняется в контексте текущей
                                    транзакции</entry>
                            </row>
                            <row valign="middle">
                                <entry align="left">При отмене транзакции</entry>
                                <entry align="center"><database>(ON TRANSACTION
                                    ROLLBACK)</database></entry>
                                <entry align="left">Триггер выполняется в контексте текущей
                                    транзакции</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable></para>
        </section>

        <section xml:id="psql-triggers-ddl">
            <title>DDL триггеры</title>

            <para>DDL триггеры срабатывают на указанные события изменения метаданных в одной из фаз
                события. BEFORE триггеры запускаются до изменений в системных таблицах. AFTER
                триггеры запускаются после изменений в системных таблицах.</para>

            <section xml:id="psql-triggers-ddl-contextvar">
                <title>Переменные доступные в пространстве имён DDL_TRIGGER</title>

                <para>Во время работы DDL триггера доступно пространство имён DDL_TRIGGER для
                    использования в функции RDB$GET_CONTEXT. Его использование также допустимо в
                    хранимых процедурах и функциях, вызванных DDL триггерами.</para>
                <para>Контекст DDL_TRIGGER работает как стек. Перед возбуждением DDL триггера,
                    значения, относящиеся к выполняемой команде, помещаются в этот стек. После
                    завершения работы триггера значения выталкиваются. Таким образом, в случае
                    каскадных DDL операторов, когда каждая пользовательская DDL команда возбуждает
                    DDL триггер, и этот триггер запускает другие DDL команды, с помощью EXECUTE
                    STATEMENT, значения переменных в пространстве имен DDL_TRIGGER будут
                    соответствовать команде, которая вызвала последний DDL триггер в стеке
                    вызовов.</para>
                <para>
                    <itemizedlist>
                        <title>Переменные доступные в пространстве имён DDL_TRIGGER:</title>
                        <listitem>
                            <para>EVENT_TYPE — тип события (CREATE, ALTER, DROP)</para>
                        </listitem>
                        <listitem>
                            <para>OBJECT_TYPE — тип объекта (TABLE, VIEW и д.р.)</para>
                        </listitem>
                        <listitem>
                            <para>DDL_EVENT — имя события (<replaceable>&lt;ddl event
                                    item&gt;</replaceable>),</para>
                            <para>где <replaceable>&lt;ddl event item&gt;</replaceable> = EVENT_TYPE
                                || ' ' || OBJECT_TYPE</para>
                        </listitem>
                        <listitem>
                            <para>OBJECT_NAME — имя объекта метаданных</para>
                        </listitem>
                        <listitem>
                            <para>SQL_TEXT — текст SQL запроса</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
        </section>
        <section xml:id="psql-triggers-create">
            <title>Создание триггера</title>

            <formalpara>
                <title>Синтаксис (не полный):</title>

                <para><programlisting>
{CREATE [OR ALTER] | RECREATE} TRIGGER <replaceable>trigname</replaceable> {   
    <replaceable>&lt;relation_trigger_legacy&gt;</replaceable>
  | <replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>
  | <replaceable>&lt;database_trigger&gt;</replaceable> 
  | <replaceable>&lt;ddl_trigger&gt;</replaceable> }                     
<replaceable>&lt;routine body&gt;</replaceable>

<replaceable>&lt;relation_trigger_legacy&gt;</replaceable> ::= 
  FOR {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
  [POSITION <replaceable>number</replaceable>]

<replaceable>&lt;relation_trigger_sql2003&gt;</replaceable> ::= 
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
  ON {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
  [POSITION <replaceable>number</replaceable>]

<replaceable>&lt;database_trigger&gt;</replaceable> ::= 
  [ACTIVE | INACTIVE] 
  ON <replaceable>db_event</replaceable>
  [POSITION <replaceable>number</replaceable>]
                    
<replaceable>&lt;ddl_trigger&gt;</replaceable> ::=  
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <replaceable>&lt;ddl_events&gt;</replaceable>
  [POSITION <replaceable>number</replaceable>]                    

<replaceable>&lt;mutation_list&gt;</replaceable> ::= <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable>]]

<replaceable>&lt;mutation&gt;</replaceable> ::= { INSERT | UPDATE | DELETE }

<replaceable>&lt;db_event&gt;</replaceable> ::= { 
    CONNECT 
  | DISCONNECT 
  | TRANSACTION START 
  | TRANSACTION COMMIT 
  | TRANSACTION ROLLBACK 
}

<replaceable>&lt;ddl_events&gt;</replaceable> ::= {
    ANY DDL STATEMENT
  | <replaceable>&lt;ddl_event_item&gt;</replaceable> [{OR <replaceable>&lt;ddl_event_item&gt;</replaceable>} ...]
}

<replaceable>&lt;ddl_event_item&gt;</replaceable> ::=
    CREATE TABLE | ALTER TABLE | DROP TABLE
  | CREATE PROCEDURE | ALTER PROCEDURE | DROP PROCEDURE
  | CREATE FUNCTION | ALTER FUNCTION | DROP FUNCTION
  | CREATE TRIGGER | ALTER TRIGGER | DROP TRIGGER
  | CREATE EXCEPTION | ALTER EXCEPTION | DROP EXCEPTION
  | CREATE VIEW | ALTER VIEW | DROP VIEW
  | CREATE DOMAIN | ALTER DOMAIN | DROP DOMAIN
  | CREATE ROLE | ALTER ROLE | DROP ROLE
  | CREATE SEQUENCE | ALTER SEQUENCE | DROP SEQUENCE
  | CREATE USER | ALTER USER | DROP USER
  | CREATE INDEX | ALTER INDEX | DROP INDEX
  | CREATE COLLATION | DROP COLLATION
  | ALTER CHARACTER SET
  | CREATE PACKAGE | ALTER PACKAGE | DROP PACKAGE
  | CREATE PACKAGE BODY | DROP PACKAGE BODY
  | CREATE MAPPING | ALTER MAPPING | DROP MAPPING  
  
<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>

<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>]

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]' 
                    
                       </programlisting></para>
            </formalpara>

            <para>Заголовок триггера обязательно содержит имя триггера, которое должно быть
                уникальным среди имён триггеров, и событие при котором срабатывает триггер. Если
                триггер создаётся для события таблицы, то необходимо также указать фазу события и
                имя таблицы.</para>

            <para>Тело триггера может содержать объявление локальных переменных и курсоров. Оно
                также содержит блок операторов PSQL, который может быть пустым.</para>

            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-trigger-create">CREATE TRIGGER</link>).</para>
        </section>

        <section xml:id="psql-triggers-alter">
            <title>Изменение триггера</title>

            <para>В существующих триггерах можно изменить состояние активности, фазу события и
                событие (события) таблицы (представления), позицию триггера и его тело. Триггеры на
                событие (события) таблицы (представления) не могут быть изменены в триггеры на
                событие базы данных и наоборот. Если какой-либо элемент не указан, то он остаётся
                без изменений.</para>
            <formalpara>
                <title>Синтаксис (не полный):</title>

                <para><programlisting>
ALTER TRIGGER <replaceable>trigname</replaceable> 
[ACTIVE | INACTIVE]
[
    {{BEFORE | AFTER} {<replaceable>&lt;mutation_list&gt;</replaceable> | <replaceable>&lt;ddl_events&gt;</replaceable>}}
  | ON <replaceable>db_event</replaceable>                 
]
[POSITION <replaceable>number</replaceable>]                      
[<replaceable>&lt;routine body&gt;</replaceable>]
                  
<replaceable>&lt;mutation_list&gt;</replaceable> ::= <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable> [OR <replaceable>&lt;mutation&gt;</replaceable>]]

<replaceable>&lt;mutation&gt;</replaceable> ::= { INSERT | UPDATE | DELETE }

<replaceable>&lt;db_event&gt;</replaceable> ::= { 
    CONNECT 
  | DISCONNECT 
  | TRANSACTION START 
  | TRANSACTION COMMIT 
  | TRANSACTION ROLLBACK 
}

<replaceable>&lt;ddl_events&gt;</replaceable> ::= {
    ANY DDL STATEMENT
  | <replaceable>&lt;ddl_event_item&gt;</replaceable> [{OR <replaceable>&lt;ddl_event_item&gt;</replaceable>} ...]
}

<replaceable>&lt;ddl_event_item&gt;</replaceable> ::=
    CREATE TABLE | ALTER TABLE | DROP TABLE
  | CREATE PROCEDURE | ALTER PROCEDURE | DROP PROCEDURE
  | CREATE FUNCTION | ALTER FUNCTION | DROP FUNCTION
  | CREATE TRIGGER | ALTER TRIGGER | DROP TRIGGER
  | CREATE EXCEPTION | ALTER EXCEPTION | DROP EXCEPTION
  | CREATE VIEW | ALTER VIEW | DROP VIEW
  | CREATE DOMAIN | ALTER DOMAIN | DROP DOMAIN
  | CREATE ROLE | ALTER ROLE | DROP ROLE
  | CREATE SEQUENCE | ALTER SEQUENCE | DROP SEQUENCE
  | CREATE USER | ALTER USER | DROP USER
  | CREATE INDEX | ALTER INDEX | DROP INDEX
  | CREATE COLLATION | DROP COLLATION
  | ALTER CHARACTER SET
  | CREATE PACKAGE | ALTER PACKAGE | DROP PACKAGE
  | CREATE PACKAGE BODY | DROP PACKAGE BODY 
  
<replaceable>&lt;routine body&gt;</replaceable> ::=
    <replaceable>&lt;SQL routine spec&gt;</replaceable>
  | <replaceable>&lt;external body reference&gt;</replaceable>
                    
<replaceable>&lt;SQL routine spec&gt;</replaceable> ::=
  [<replaceable>&lt;rights clause&gt;</replaceable>] <replaceable>&lt;SQL routine body&gt;</replaceable>                    


<replaceable>&lt;rights clause&gt;</replaceable> ::=
  SQL SECURITY {DEFINER | INVOKER}                    

     
<replaceable>&lt;SQL routine body&gt;</replaceable> ::=  
  AS       
    [<replaceable>&lt;declarations&gt;</replaceable>]       
  BEGIN       
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]       
  END                      

<replaceable>&lt;declarations&gt;</replaceable> ::= <replaceable>&lt;declare_item&gt;</replaceable> [<replaceable>&lt;declare_item&gt;</replaceable> ...]

<replaceable>&lt;declare_item&gt;</replaceable> ::=      
    <replaceable>&lt;declare_var&gt;</replaceable>; 
  | <replaceable>&lt;declare_cursor&gt;</replaceable>; 
  | <replaceable>&lt;subroutine declaration&gt;</replaceable>;
  | <replaceable>&lt;subroutine implimentation&gt;</replaceable>  

<replaceable>&lt;subroutine declaration&gt;</replaceable> ::= <replaceable>&lt;subfunc_decl&gt;</replaceable> | <replaceable>&lt;subproc_decl&gt;</replaceable> 

<replaceable>&lt;subroutine implimentation&gt;</replaceable> ::= <replaceable>&lt;subfunc_impl&gt;</replaceable> | <replaceable>&lt;subproc_impl&gt;</replaceable>
<replaceable>&lt;external body reference&gt;</replaceable> ::=
  EXTERNAL NAME '<replaceable>&lt;extname&gt;</replaceable>' ENGINE <replaceable>&lt;engine&gt;</replaceable> [AS <replaceable>&lt;extbody&gt;</replaceable>] 

<replaceable>&lt;extname&gt;</replaceable> ::= '<replaceable>&lt;module name&gt;</replaceable>!<replaceable>&lt;routine name&gt;</replaceable>[!<replaceable>&lt;misc info&gt;</replaceable>]'    
 
                       </programlisting></para>
            </formalpara>

            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-trigger-alter">ALTER TRIGGER</link>).</para>
        </section>

        <section xml:id="psql-triggers-drop">
            <title>Удаление триггера</title>

            <para>Для удаления триггера используется оператор DROP TRIGGER.</para>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DROP TRIGGER <replaceable>trigname</replaceable>;
                       </programlisting></para>
            </formalpara>
            <para>Более подробная информация приведена в главе Операторы DDL (<link
                    linkend="ddl-trigger-drop">DROP TRIGGER</link>).</para>
        </section>
    </section>

    <section xml:id="psql-statements">
        <info>
            <title>Написание кода тела модуля</title>
        </info>

        <para>В этом разделе подробно рассматривается процедурные конструкции языка SQL и операторы
            доступные в теле хранимых процедур, триггеров и анонимных PSQL блоков.</para>

        <sidebar>
            <title>Маркер двоеточия (:)</title>
            <para>Маркер двоеточие (:) используется в PSQL, чтобы пометить ссылку на переменную в
                DML операторе. В остальных случаях маркер двоеточия необязателен перед именами
                переменных. Никогда не задавайте префикс двоеточия для контекстных
                переменных.</para>
        </sidebar>

        <section xml:id="psql-statements-assign">
            <title>Оператор присваивания</title>

            <formalpara>
                <title>Назначение:</title>

                <para>Присваивание переменной значения.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
<replaceable>varname</replaceable> = <replaceable>&lt;value_expr&gt;</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора присваивания</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>varname</replaceable></entry>
                                <entry>
                                    <para>Имя локальной переменной или параметра процедуры
                                        (функции).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>value_expr</replaceable></entry>
                                <entry>
                                    <para>Выражение, константа или переменная совместимая по типу
                                        данных с <replaceable>varname</replaceable>.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>PSQL использует символ равенства (=) в качестве своего оператора присваивания.
                Оператор присваивания устанавливает переменной слева от оператора значение SQL
                выражения справа. Выражением может быть любое правильное выражение SQL. Оно может
                содержать литералы, имена внутренних переменных, арифметические, логические и
                строковые операции, обращения к встроенным функциям и к функциям, определённым
                пользователем.</para>
            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование оператора присваивания</title>
                        <para>
                            <programlisting language="sql">
CREATE PROCEDURE MYPROC (
    a INTEGER,
    b INTEGER, 
    name VARCHAR (30)
)
RETURNS (
    c INTEGER,
    str VARCHAR(100))
AS
BEGIN
  -- присваиваем константу
  c = 0;
  str = '';
  SUSPEND;
  -- присваиваем значения выражений
  c = a + b;
  str = name || CAST(b AS VARCHAR(10));
  SUSPEND;
  -- присваиваем значение выражения
  -- построенного с использованием запроса
  c = (SELECT 1 FROM rdb$database);
  -- присваиваем значение из контекстной переменной
  str = CURRENT_USER;
  SUSPEND;
END                        
                    </programlisting>
                        </para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-declare-var">DECLARE VARIABLE</link>. </para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-declare-var">
            <info>
                <title>DECLARE VARIABLE</title>
                <keywordset>
                    <keyword>DECLARE VARIABLE</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>DECLARE</primary>
                <secondary>VARIABLE</secondary>
            </indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Объявление локальной переменной.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DECLARE [VARIABLE] <replaceable>varname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>] 
  [{= | DEFAULT} <replaceable>&lt;value&gt;</replaceable>] } 

<replaceable>&lt;value&gt;</replaceable> ::= {<replaceable>literal</replaceable> | NULL | <replaceable>context_var</replaceable>}

<replaceable>&lt;type&gt;</replaceable> ::= 
    <replaceable>&lt;datatype&gt;</replaceable>
  | [TYPE OF] <replaceable>domain</replaceable>
  | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>

<replaceable>&lt;datatype&gt;</replaceable> ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | BOOLEAN
  | {FLOAT | DOUBLE PRECISION}
  | DECFLOAT[({16 | 34})]
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(<replaceable>precision</replaceable> [, <replaceable>scale</replaceable>])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(<replaceable>size</replaceable>)]
    [CHARACTER SET <replaceable>charset</replaceable>]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(<replaceable>size</replaceable>)]
  | BLOB [SUB_TYPE {<replaceable>subtype_num</replaceable> | <replaceable>subtype_name</replaceable>}]
    [SEGMENT SIZE <replaceable>seglen</replaceable>] [CHARACTER SET <replaceable>charset</replaceable>]
  | BLOB [(<replaceable>seglen</replaceable> [, <replaceable>subtype_num</replaceable>])]
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора DECLARE VARIABLE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>varname</replaceable></entry>
                                <entry>
                                    <para>Имя локальной переменной.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>literal</replaceable></entry>
                                <entry>
                                    <para>Литерал.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>context_var</replaceable></entry>
                                <entry>
                                    <para>Любая контекстная переменная, тип которой совместим с
                                        типом локальной переменной.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>datatype</replaceable></entry>
                                <entry>
                                    <para>Тип данных SQL.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Порядок сортировки.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>domain</replaceable></entry>
                                <entry>
                                    <para>Домен.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>rel</replaceable></entry>
                                <entry>
                                    <para>Имя таблицы или представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>col</replaceable></entry>
                                <entry>
                                    <para>Имя столбца таблицы или представления.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>precision</replaceable></entry>
                                <entry>
                                    <para>Точность. От 1 до 38.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>scale</replaceable></entry>
                                <entry>
                                    <para>Масштаб. От 0 до 38, должно быть меньше или равно
                                            <replaceable>precision</replaceable>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>size</replaceable></entry>
                                <entry>
                                    <para>Максимальный размер строки в символах.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>charset</replaceable></entry>
                                <entry>
                                    <para>Набор символов.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_num</replaceable></entry>
                                <entry>
                                    <para>Номер подтипа BLOB.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>subtype_name</replaceable></entry>
                                <entry>
                                    <para>Мнемоника подтипа BLOB.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>seqlen</replaceable></entry>
                                <entry>
                                    <para>Размер сегмента, не может превышать 65535.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DECLARE [VARIBALE] объявляет локальную переменную. Ключевое слово
                VARIABLE можно опустить. В одном операторе разрешено объявлять только одну
                переменную. В процедурах и триггерах можно объявить произвольное число локальных
                переменных, используя при этом каждый раз, новый оператор DECLARE VARAIBLE.</para>
            <para>Имя локальной переменной должно быть уникально среди имён локальных переменных,
                входных и выходных параметров процедуры внутри программного объекта.</para>

            <section xml:id="psql-variables-type">
                <title>Типы данных для переменных</title>

                <para>В качестве типа данных локальной переменной может быть любой SQL тип, за
                    исключением массивов.</para>
                <para>В качестве типа переменной можно указать имя домена. В этом случае, переменная
                    будет наследовать все характеристики домена. Если перед названием домена
                    дополнительно используется предложение &quot;TYPE OF&quot;, то используется
                    только тип данных домена – не проверяется (не используется) его ограничение
                    (если оно есть в домене) на NOT NULL, CHECK ограничения и/или значения по
                    умолчанию. Если домен текстового типа, то всегда используется его набор символов
                    и порядок сортировки.</para>
                <para>Локальные переменные можно объявлять, используя тип данных столбцов
                    существующих таблиц и представлений. Для этого используется предложение TYPE OF
                    COLUMN, после которого указывается имя таблиц или представления и через точку
                    имя столбца. При использовании TYPE OF COLUMN наследуется только тип данных, а в
                    случае строковых типов ещё набор символов и порядок сортировки. Ограничения и
                    значения по умолчанию столбца никогда не используются.</para>
                <para>Для локальных переменных можно указать ограничение NOT NULL, тем самым
                    запретив передавать в него значение NULL. Для переменной строкового типа
                    существует возможность задать порядок сортировки с помощью предложения
                    COLLATE.</para>
                <para>Локальной переменной можно устанавливать инициализирующее (начальное)
                    значение. Это значение устанавливается с помощью предложения DEFAULT или
                    оператора &quot;=&quot;. В качестве значения по умолчанию может быть
                    использовано значение NULL, литерал и любая контекстная переменная совместимая
                    по типу данных.</para>
                <important>
                    <para>Обязательно используйте инициализацию начальным значением для любых
                        переменных объявленных с ограничением NOT NULL, если они не получают
                        значение по умолчанию иным способом.</para>
                </important>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Различные способы объявления локальных переменных</title>
                            <para><programlisting language="sql">
CREATE OR ALTER PROCEDURE SOME_PROC
AS
  -- Объявление переменной типа INT
  DECLARE I INT;
  -- Объявление переменной типа INT не допускающей значение NULL
  DECLARE VARIABLE J INT NOT NULL;
  -- Объявление переменной типа INT со значением по умолчанию 0
  DECLARE VARIABLE K INT DEFAULT 0;
  -- Объявление переменной типа INT со значением по умолчанию 1
  DECLARE VARIABLE L INT = 1;
  -- Объявление переменной на основе домена COUNTRYNAME
  DECLARE FARM_COUNTRY COUNTRYNAME;
  -- Объявление переменной с типом равным типу домена COUNTRYNAME
  DECLARE FROM_COUNTRY TYPE OF COUNTRYNAME;
  -- Объявление переменной с типом столбца CAPITAL таблицы COUNTRY
  DECLARE CAPITAL TYPE OF COLUMN COUNTRY.CAPITAL;
BEGIN
  /* Операторы PSQL */
END
                </programlisting></para>
                        </example>
                    </para>
                </formalpara>
                <formalpara>
                    <title>См. также:</title>
                    <para><link linkend="types">Типы и подтипы данных</link>, <link
                            linkend="types-domain">Пользовательские типы данных — домены</link>,
                            <link linkend="ddl-domain-create"><database>CREATE
                            DOMAIN</database></link>
                    </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="psql-statements-declare-cursor">
            <info>
                <title>DECLARE CURSOR</title>
                <keywordset>
                    <keyword>DECLARE CURSOR</keyword>
                </keywordset>
            </info>
            <indexterm>
                <primary>DECLARE</primary>
                <secondary>CURSOR</secondary>
            </indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Объявление курсора.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DECLARE [VARIABLE] <replaceable>cursor_name</replaceable> [SCROLL | NO SCROLL]
CURSOR FOR (<replaceable>&lt;select_statement&gt;</replaceable>);
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора DECLARE CURSOR</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>cursor_name</replaceable></entry>
                                <entry>
                                    <para>Имя курсора.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_statement</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DECLARE ... CURSOR FOR объявляет именованный курсор, связывая его с
                набором данных, полученным в операторе SELECT, указанном в предложении CURSOR FOR. В
                дальнейшем курсор может быть открыт, использоваться для обхода результирующего
                набора данных, и снова быть закрытым. Также поддерживаются позиционированные
                обновления и удаления при использовании WHERE CURRENT OF в операторах UPDATE и
                DELETE.</para>
            <para>Имя курсора можно использовать в качестве ссылки на курсор, как на переменные типа
                запись. Текущая запись доступна через имя курсора, что делает необязательным
                предложение INTO в операторе FETCH.</para>

            <section xml:id="psql-cursor-forward_and_scrolable">
                <title>Однонаправленные и прокручиваемые курсоры</title>

                <para>Курсор может быть однонаправленными прокручиваемым. Необязательное предложение
                    SCROLL делает курсор двунаправленным (прокручиваемым), предложение NO SCROLL —
                    однонаправленным. По умолчанию курсоры являются однонаправленными.</para>
                <para>Однонаправленные курсоры позволяют двигаться по набору данных только вперёд.
                    Двунаправленные курсоры позволяют двигаться по набору данных не только вперёд,
                    но и назад, а также на N позиций относительно текущего положения.</para>
                <warning>
                    <para>Прокручиваемые курсоры материализуются внутри как временный набор данных,
                        таким образом, они потребляют дополнительные ресурсы памяти/диска, поэтому
                        пользуйтесь ими только тогда, когда это действительно необходимо.</para>
                </warning>
            </section>

            <section xml:id="psql-idio-cursor">
                <title>Особенности использования курсора</title>

                <para><itemizedlist spacing="compact">
                        <listitem>
                            <para>Предложение &quot;FOR UPDATE&quot; разрешено использовать в
                                операторе SELECT, но оно не требуется для успешного выполнения
                                позиционированного обновления или удаления;</para>
                        </listitem>
                        <listitem>
                            <para>Удостоверьтесь, что объявленные имена курсоров не совпадают, ни с
                                какими именами, определёнными позже в предложениях AS CURSOR;</para>
                        </listitem>
                        <listitem>
                            <para>Если курсор требуется только для прохода по результирующему набору
                                данных, то практически всегда проще (и менее подвержено ошибкам)
                                использовать оператор FOR SELECT с предложением AS CURSOR.
                                Объявленные курсоры должны быть явно открыты, использованы для
                                выборки данных и закрыты. Кроме того, вы должны проверить
                                контекстную переменную ROW_COUNT после каждой выборки и выйти из
                                цикла, если её значение ноль. Предложение FOR SELECT делает эту
                                проверку автоматически. Однако объявленные курсоры дают большие
                                возможности для контроля над последовательными событиями и позволяют
                                управлять несколькими курсорами параллельно;</para>
                        </listitem>
                        <listitem>
                            <para>Оператор SELECT может содержать параметры, например: &quot;SELECT
                                NAME || :SFX FROM NAMES WHERE NUMBER = :NUM&quot;. Каждый параметр
                                должен быть заранее объявлен как переменная PSQL (это касается также
                                входных и выходных параметров). При открытии курсора параметру
                                присваивается текущее значение переменной;</para>
                        </listitem>
                        <listitem>
                            <para>Если опция прокрутки опущена, то по умолчанию принимается NO
                                SCROLL (т.е курсор открыт для движения только вперёд). Это означает,
                                что могут быть использованы только команды FETCH [NEXT FROM]. Другие
                                команды будут возвращать ошибки.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <warning>
                    <para>Если значение переменной PSQL, используемой в операторе SELECT, изменяется
                        во время выполнения цикла, то её новое значение может (но не всегда)
                        использоваться при выборке следующих строк. Лучше избегать таких ситуаций.
                        Если вам действительно требуется такое поведение, то необходимо тщательно
                        протестировать код и убедиться, что вы точно знаете, как изменения
                        переменной влияют на результаты выборки. Особо отмечу, что поведение может
                        зависеть от плана запроса, в частности, от используемых индексов. В
                        настоящее время нет строгих правил для таких ситуаций, но в новых версиях
                        Firebird это может измениться.</para>
                </warning>
            </section>
            <section xml:id="psql-cursor-examples">
                <title>Примеры использования именованного курсора</title>

                <example>
                    <title>Объявление именованного курсора</title>
                    <para><programlisting language="sql">
CREATE OR ALTER TRIGGER TBU_STOCK
BEFORE UPDATE ON STOCK
AS
  -- Объявление именованного курсора
  DECLARE C_COUNTRY CURSOR FOR (
    SELECT
      COUNTRY,
      CAPITAL
    FROM COUNTRY
  );
BEGIN
  /* Операторы PSQL */
END
                </programlisting></para>
                </example>
                <example>
                    <title>Объявление прокручиваемого курсора</title>
                    <para><programlisting language="sql">
EXECUTE BLOCK
RETURNS (
  N INT,
  RNAME CHAR(63))
AS
  -- Объявление прокручиваемого курсора
  DECLARE C SCROLL CURSOR FOR (
    SELECT
      ROW_NUMBER() OVER(ORDER BY RDB$RELATION_NAME) AS N,
      RDB$RELATION_NAME
    FROM RDB$RELATIONS
    ORDER BY RDB$RELATION_NAME);
BEGIN
  /* Операторы PSQL */
END
                </programlisting></para>
                </example>
                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="psql-statements-open">OPEN</link>, <link
                            linkend="psql-statements-fetch">FETCH</link>, <link
                            linkend="psql-statements-close">CLOSE</link>, <link
                            linkend="psql-statements-forselect">FOR SELECT</link>. </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="psql-statements-declare-procedure">
            <info>
                <title>DECLARE PROCEDURE</title>
                <keywordset>
                    <keyword>DECLARE PROCEDURE</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>DECLARE</primary>
                <secondary>PROCEDURE</secondary>
            </indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Объявление и реализация подпроцедуры.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting><replaceable>&lt;subproc declaration&gt;</replaceable> ::=
  DECLARE PROCEDURE <replaceable>subprocname</replaceable> [(<replaceable>&lt;input parameters&gt;</replaceable>)]
  [RETURNS (<replaceable>&lt;output parameters&gt;</replaceable>)];

<replaceable>&lt;subproc implimentation&gt;</replaceable> ::=
  DECLARE PROCEDURE <replaceable>subprocname</replaceable> [(<replaceable>&lt;input parameters&gt;</replaceable>)]
  [RETURNS (<replaceable>&lt;output parameters&gt;</replaceable>)]
  AS
    [<replaceable>&lt;declarations&gt;</replaceable>]
  BEGIN
    [<replaceable>&lt;PSQL_statements&gt;</replaceable>]
  END   

<replaceable>&lt;input parameters&gt;</replaceable> ::= <replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...]   

<replaceable>&lt;output parameters&gt;</replaceable> ::= <replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...]                 
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора DECLARE PROCEDURE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>subprocname</replaceable></entry>
                                <entry>
                                    <para>Имя подпроцедуры.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>inparam</replaceable></entry>
                                <entry>
                                    <para>Описание входного параметра.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>outparam</replaceable></entry>
                                <entry>
                                    <para>Описание выходного параметра.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declarations</replaceable></entry>
                                <entry>
                                    <para>Секция объявления локальных переменных, именованных
                                        курсоров.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>PSQL_statements</replaceable></entry>
                                <entry>
                                    <para>PSQL операторы.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DECLARE PROCEDURE объявляет или реализует подпроцедуру. На подпроцедуру
                накладываются следующие ограничения: <itemizedlist spacing="compact">
                    <listitem>
                        <para>Подпрограмма не может быть вложена в другую подпрограмму. Они
                            поддерживаются только в основном модуле (хранимой процедуре, хранимой
                            функции, триггере и анонимном PSQL блоке);</para>
                    </listitem>
                    <listitem>
                        <para>В настоящее время подпрограмма не имеет прямого доступа для
                            использования переменных, курсоров из основного модуля. Это может быть
                            разрешено в будущем.</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>Одна подпрограмма может вызывать и другую подпрограмму, в том числе рекурсивно. В
                ряде случаев может потребоваться предварительное объявление подпрограммы. Общее
                правило: одна подпрограмма может вызвать другую подпрограмму, если последняя
                объявлена выше точки вызова. Все объявленные подпрограммы должны быть реализованы с
                той же сигнатурой. Значения по умолчанию для параметров подпрограмм не могут быть
                переопределены. Это означает, что они могут быть определены в реализации только тех
                подпрограмм, которые не были объявлены ранее.</para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование подпроцедуры</title>
                        <para><programlisting language="sql">
SET TERM ^;
--
-- Подпроцедуры в EXECUTE BLOCK
--
EXECUTE BLOCK
RETURNS (
    name VARCHAR(63))
AS
  -- Подпроцедура, возвращающая список таблиц
  DECLARE PROCEDURE get_tables
  RETURNS(table_name VARCHAR(63))
  AS
  BEGIN
    FOR
      SELECT
        rdb$relation_name
      FROM
        rdb$relations
      WHERE
        rdb$view_blr IS NULL
      INTO table_name
    DO SUSPEND;
  END

  -- Подпроцедура, возвращающая список представлений
  DECLARE PROCEDURE get_views
  RETURNS(view_name  VARCHAR(63))
  AS
  BEGIN
    FOR
      SELECT
        rdb$relation_name
      FROM
        rdb$relations
      WHERE
        rdb$view_blr IS NOT NULL
      INTO view_name
    DO SUSPEND;
  END

BEGIN
  FOR
    SELECT
        table_name
    FROM
        get_tables
    UNION ALL
    SELECT
        view_name
    FROM
        get_views
    INTO name
  DO SUSPEND;
END^
                </programlisting></para>
                    </example>
                    <example>
                        <title>Использование подпроцедур с предварительным объявлением</title>
                        <para><programlisting language="sql">
<![CDATA[
EXECUTE BLOCK RETURNS (o INTEGER)
AS
  -- Предварительное объявление P1.
  DECLARE PROCEDURE p1(i INTEGER = 1) RETURNS (o INTEGER);

  -- Предварительное объявление P2.
  DECLARE PROCEDURE p2(i INTEGER) RETURNS (o INTEGER);

  -- Реализация P1. Вы не должны переопределять значение параметра по умолчанию
  DECLARE PROCEDURE p1(i INTEGER) RETURNS (o INTEGER)
  AS
  BEGIN
    EXECUTE PROCEDURE p2(i) RETURNING_VALUES o;
  END

  DECLARE PROCEDURE p2(i INTEGER) RETURNS (o INTEGER)
  AS
  BEGIN
    o = i;
  END
BEGIN
  EXECUTE PROCEDURE p1 RETURNING_VALUES o;
  SUSPEND;
END!
]]>
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-declare-function">DECLARE FUNCTION</link>, <link
                        linkend="ddl-procedure-create">CREATE PROCEDURE</link>.</para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-declare-function">
            <info>
                <title>DECLARE FUNCTION</title>
                <keywordset>
                    <keyword>DECLARE PROCEDURE</keyword>
                </keywordset>
            </info>

            <indexterm>
                <primary>DECLARE</primary>
                <secondary>FUNCTION</secondary>
            </indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Объявление и реализация подфункции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
DECLARE FUNCTION <replaceable>subfuncname</replaceable> [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]
RETURNS <replaceable>&lt;type&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] [DETERMINISTIC]
AS
  [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
  [<replaceable>&lt;PSQL_statements&gt;</replaceable>]
END                        
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора DECLARE FUNCTION</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>subfuncname</replaceable></entry>
                                <entry>
                                    <para>Имя подфункции.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>inparam</replaceable></entry>
                                <entry>
                                    <para>Описание входного параметра.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>type</replaceable></entry>
                                <entry>
                                    <para>Тип выходного результата.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>collation</replaceable></entry>
                                <entry>
                                    <para>Порядок сортировки.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>declarations</replaceable></entry>
                                <entry>
                                    <para>Секция объявления локальных переменных, именованных
                                        курсоров.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>PSQL_statements</replaceable></entry>
                                <entry>
                                    <para>PSQL операторы.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор DECLARE FUNCTION объявляет подфункцию. На подфункцию накладываются
                следующие ограничения: <itemizedlist spacing="compact">
                    <listitem>
                        <para>Подпрограмма не может быть вложена в другую подпрограмму. Они
                            поддерживаются только в основном модуле (хранимой процедуре, хранимой
                            функции, триггере и анонимном PSQL блоке);</para>
                    </listitem>
                    <listitem>
                        <para>В настоящее время подпрограмма не имеет прямого доступа для
                            использования переменных, курсоров из основного модуля. Это может быть
                            разрешено в будущем.</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>Одна подпрограмма может вызывать и другую подпрограмму, в том числе рекурсивно. В
                ряде случаев может потребоваться предварительное объявление подпрограммы. Общее
                правило: одна подпрограмма может вызвать другую подпрограмму, если последняя
                объявлена выше точки вызова. Все объявленные подпрограммы должны быть реализованы с
                той же сигнатурой. Значения по умолчанию для параметров подпрограмм не могут быть
                переопределены. Это означает, что они могут быть определены в реализации только тех
                подпрограмм, которые не были объявлены ранее.</para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование подфункции</title>
                        <para><programlisting language="sql">
--
-- Подфункция внутри хранимой функции
--
CREATE OR ALTER FUNCTION FUNC1 (n1 INTEGER, n2 INTEGER)
  RETURNS INTEGER
AS
  -- Подфункция
  DECLARE FUNCTION SUBFUNC (n1 INTEGER, n2 INTEGER)
    RETURNS INTEGER
  AS
  BEGIN
    RETURN n1 + n2;
  END
  
BEGIN
  RETURN SUBFUNC(n1, n2);
END ^
                </programlisting></para>
                    </example>
                    <example>
                        <title>Использование рекурсивной подфункции</title>
                        <para><programlisting language="sql">
<![CDATA[
EXECUTE BLOCK RETURNS (i INTEGER, o INTEGER)
AS
  -- Рекусривная подпрограмма-функция без предварительного объявления.
  DECLARE FUNCTION fibonacci(n INTEGER) RETURNS INTEGER
  AS
  BEGIN
    IF (n = 0 OR n = 1) THEN
      RETURN n;
    ELSE
      RETURN fibonacci(n - 1) + fibonacci(n - 2);
  END
BEGIN
  i = 0;

  WHILE (i < 10)
  DO
  BEGIN
    o = fibonacci(i);
    SUSPEND;
    i = i + 1;
  END
END!
]]>
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-declare-procedure">DECLARE PROCEDURE</link>,
                        <link linkend="ddl-function-create">CREATE FUNCTION</link>.</para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-beginend">
            <info>
                <title>BEGIN ... END</title>
                <keywordset>
                    <keyword>BEGIN</keyword>
                    <keyword>END</keyword>
                </keywordset>
            </info>

            <indexterm><primary>BEGIN</primary></indexterm>
            <indexterm><primary>END</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Обозначение составного оператора.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
<replaceable>&lt;block&gt;</replaceable> ::=
  BEGIN
    <replaceable>&lt;compound_statement&gt;</replaceable>
    [<replaceable>&lt;compound_statement&gt;</replaceable> ...]
  END

<replaceable>&lt;compound_statement&gt;</replaceable> ::= {<replaceable>&lt;block&gt;</replaceable> | <replaceable>&lt;statement&gt;</replaceable>;}
                </programlisting></para>
            </formalpara>

            <para>Операторные скобки BEGIN ... END определяют составной оператор или блок
                операторов, который выполняется как одна единица кода. Каждый блок начинается
                оператором BEGIN и завершается оператором END. Блоки могут быть вложенными.
                Максимальная глубина ограничена 512 уровнями вложенности блоков. Составной оператор
                может быть пустым, что позволяет использовать его как заглушку, позволяющую избежать
                написания фиктивных операторов.</para>
            <para>После операторов BEGIN и END точка с запятой не ставится. Однако утилита командной
                строки <application>isql</application> требует, чтобы после последнего оператора END
                в определении PSQL модуля следовал символ терминатора, установленного командой <link
                    linkend="psql-setterm">SET TERM</link>. Терминатор не является частью синтаксиса
                PSQL.</para>
            <para>Последний оператор END в триггере завершает работу триггера. Последний оператор
                END в хранимой процедуре работает в зависимости от типа процедуры: <itemizedlist
                    spacing="compact">
                    <listitem>
                        <para>В селективной процедуре последний оператор END возвращает управление
                            приложению и устанавливает значение SQLCODE равным 100, что означает,
                            что больше нет строк для извлечения;</para>
                    </listitem>
                    <listitem>
                        <para>В выполняемой процедуре последний оператор END возвращает управление и
                            текущие значения выходных параметров, если таковые имеются, вызывающему
                            приложению.</para>
                    </listitem>
                </itemizedlist>
            </para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование BEGIN ... END</title>
                        <para><programlisting language="sql">
SET TERM ^;
CREATE OR ALTER PROCEDURE DEPT_BUDGET (
    DNO CHAR(3))
RETURNS (
    TOT DECIMAL(12,2))
AS
    DECLARE VARIABLE SUMB DECIMAL(12,2);
    DECLARE VARIABLE RDNO CHAR(3);
    DECLARE VARIABLE CNT  INTEGER;
BEGIN
  TOT = 0;

  SELECT
      BUDGET
  FROM
      DEPARTMENT
  WHERE DEPT_NO = :DNO
  INTO :TOT;

  SELECT
      COUNT(BUDGET)
  FROM
      DEPARTMENT
  WHERE HEAD_DEPT = :DNO
  INTO :CNT;

  IF (CNT = 0) THEN
    SUSPEND;

  FOR
      SELECT
          DEPT_NO
      FROM
          DEPARTMENT
      WHERE HEAD_DEPT = :DNO
      INTO :RDNO
  DO
  BEGIN
    EXECUTE PROCEDURE DEPT_BUDGET(:RDNO)
    RETURNING_VALUES :SUMB;
    TOT = TOT + SUMB;
  END

  SUSPEND;
END^
SET TERM ;^    
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-exit">EXIT</link>, <link
                        linkend="psql-statements-leave">LEAVE</link>, <link linkend="psql-setterm"
                        >SET TERM</link>.</para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-if">
            <info>
                <title>IF ... THEN ... ELSE</title>
                <keywordset>
                    <keyword>IF</keyword>
                    <keyword>THEN</keyword>
                    <keyword>ELSE</keyword>
                </keywordset>
            </info>

            <indexterm><primary>IF</primary></indexterm>
            <indexterm><primary>THEN</primary></indexterm>
            <indexterm><primary>ELSE</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Условный переход.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
IF (<replaceable>&lt;condition&gt;</replaceable>)
THEN <replaceable>&lt;compound_statement&gt;</replaceable>
[ELSE <replaceable>&lt;compound_statement&gt;</replaceable>]
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора IF ... THEN ... ELSE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>condition</replaceable></entry>
                                <entry>
                                    <para>Логическое условие возвращающее TRUE, FALSE или
                                        UNKNOWN.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>compound_statement</replaceable></entry>
                                <entry>
                                    <para>Составной оператор (оператор или блок операторов).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор условного перехода IF используется для выполнения ветвления процесса
                обработки данных в PSQL. Если условие возвращает значение TRUE, то выполняется
                составной оператор или после ключевого слова THEN. Иначе (если условие возвращает
                FALSE или UNKNOWN) выполняется составной оператор после ключевого слова ELSE, если
                оно присутствует. Условие всегда заключается в круглые скобки.</para>
            <sidebar>
                <title>Оператор ветвления</title>

                <para>В языке PSQL отсутствует оператор ветвления CASE (SWITCH). Однако в нем
                    доступен поисковый оператор CASE из DSQL.</para>
                <para>
                    <programlisting>
CASE <replaceable>&lt;test_expr&gt;</replaceable>
  WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable>
  [WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable> ...]
  [ELSE <replaceable>&lt;defaultresult&gt;</replaceable>]
END

CASE
  WHEN <replaceable>&lt;bool_expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable>
  [WHEN <replaceable>&lt;bool_expr&gt;</replaceable> THEN <replaceable>&lt;result&gt;</replaceable> ...]
  [ELSE <replaceable>&lt;defaultresult&gt;</replaceable>]
END
                    </programlisting>
                </para>
                <para>Пример использования в PSQL.
                    <programlisting language="sql">
...
C = CASE
      WHEN A=2 THEN 1
      WHEN A=1 THEN 3
      ELSE 0
    END;
...
                    </programlisting>
                </para>
            </sidebar>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование оператора IF</title>
                        <para><programlisting language="sql">
...
IF (FIRST IS NOT NULL) THEN
  LINE2 = FIRST || ' ' || LAST;
ELSE
  LINE2 = LAST;
...      
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-while">WHILE ... DO</link>, <link
                        linkend="common-expr-cond-case">CASE</link>.</para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-while">
            <info>
                <title>WHILE ... DO</title>
                <keywordset>
                    <keyword>WHILE</keyword>
                    <keyword>DO</keyword>
                </keywordset>
            </info>

            <indexterm><primary>WHILE ... DO</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Циклическое выполнение операторов.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
WHILE (<replaceable>&lt;condition&gt;</replaceable>) DO
  <replaceable>&lt;compound_statement&gt;</replaceable>
                </programlisting></para>
            </formalpara>
            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора WHILE ... DO</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>condition</replaceable></entry>
                                <entry>
                                    <para>Логическое условие возвращающее TRUE, FALSE или
                                        UNKNOWN.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>compound_statement</replaceable></entry>
                                <entry>
                                    <para>Составной оператор (оператор или блок операторов).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор WHILE используется для организации циклов в PSQL. Составной оператор
                будет выполняться до тех пор, пока условие истинно (возвращает TRUE). Циклы могут
                быть вложенными, глубина вложения не ограничена.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование оператора WHILE ... DO</title>
                        <para>Процедура расчёта суммы от 1 до I для демонстрации использования
                            цикла:
                            <programlisting language="sql">
CREATE PROCEDURE SUM_INT (I INTEGER) 
RETURNS (S INTEGER)
AS
BEGIN
  s = 0;
  WHILE (i > 0) DO
  BEGIN
    s = s + i;
    i = i - 1;
  END
END       
                </programlisting>
                            При выполнении в <application>isql</application>
                            <programlisting language="sql">
EXECUTE PROCEDURE SUM_INT(4);      
                </programlisting>
                            результат будет следующий
                            <screen>
S
==========
10                    
                </screen>
                        </para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-forselect">FOR SELECT</link>, <link
                        linkend="psql-statements-forexec">FOR EXECUTE STATEMENT</link>, <link
                        linkend="psql-statements-leave">LEAVE</link>, <link
                        linkend="psql-statements-continue">CONTINUE</link>.</para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-break">
            <info>
                <title>BREAK</title>
                <keywordset>
                    <keyword>BREAK</keyword>
                </keywordset>
            </info>

            <indexterm><primary>BREAK</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Выход из цикла.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
{FOR <replaceable>&lt;select_stmt&gt;</replaceable> | WHILE (<replaceable>&lt;condition&gt;</replaceable>)} DO
BEGIN
  ...
  BREAK;
  ...
END
                </programlisting></para>

            </formalpara>

            <para>Оператор BREAK моментально прекращает работу внутреннего цикла операторов WHILE
                или FOR.</para>

            <note>
                <para>Этот оператор считается устаревшим. Начиная с Firebird 1.5 рекомендуется
                    использовать SQL-99 совместимый оператор <link linkend="psql-statements-leave"
                        >LEAVE</link>.</para>
            </note>
        </section>
        <section xml:id="psql-statements-leave">
            <info>
                <title>LEAVE</title>
                <keywordset>
                    <keyword>LEAVE</keyword>
                </keywordset>
            </info>

            <indexterm><primary>LEAVE</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Выход из цикла.</para>
            </formalpara>
            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
[<replaceable>label</replaceable>:]
{FOR <replaceable>&lt;select_stmt&gt;</replaceable> | WHILE (<replaceable>&lt;condition&gt;</replaceable>)} DO
BEGIN
  ...
  LEAVE [<replaceable>label</replaceable>];
  ...
END
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора LEAVE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>label</replaceable></entry>
                                <entry>
                                    <para>Метка.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_stmt</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>condition</replaceable></entry>
                                <entry>
                                    <para>Логическое условие возвращающее TRUE, FALSE или
                                        UNKNOWN.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор LEAVE моментально прекращает работу внутреннего цикла операторов WHILE
                или FOR. С использованием опционального параметра метки LEAVE также может выйти и из
                внешних циклов, при этом выполнение кода продолжается с первого оператора,
                следующего после прекращения блока внешнего цикла.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование оператора LEAVE</title>
                        <para><programlisting language="sql">
/*
 * Выход из цикла при возникновении ошибки вставки в таблицу NUMBERS. 
 * Код продолжается со строки C = 0.
 */                    
...
WHILE (B &lt; 10) DO
BEGIN
    INSERT INTO NUMBERS(B)
    VALUES (:B);
    B = B + 1;
    WHEN ANY DO
    BEGIN
        EXECUTE PROCEDURE LOG_ERROR (
             CURRENT_TIMESTAMP,
             'ERROR IN B LOOP');
        LEAVE;
    END
END
C = 0;
...        
                </programlisting></para>
                    </example>
                    <example>
                        <title>Использование оператора LEAVE с меткой</title>
                        <para><programlisting language="sql">
/*
 * &quot;LEAVE LOOPA&quot; завершает внешний цикл, а &quot;LEAVE LOOPB&quot; - внутренний. 
 * Обратите внимание: простого оператора &quot;LEAVE&quot; также было бы достаточно, 
 * чтобы завершить внутренний цикл.
 */                    
...
STMT1 = 'SELECT NAME FROM FARMS';
LOOPA:
FOR EXECUTE STATEMENT :STMT1
INTO :FARM DO
BEGIN
  STMT2 = 'SELECT NAME ' || 'FROM ANIMALS WHERE FARM = ''';
  LOOPB:
  FOR EXECUTE STATEMENT :STMT2 || :FARM || '''' 
  INTO :ANIMAL DO
  BEGIN
    IF (ANIMAL = 'FLUFFY') THEN
      LEAVE LOOPB;
    ELSE IF (ANIMAL = FARM) THEN
      LEAVE LOOPA;
    ELSE
      SUSPEND;
  END
END
...      
                </programlisting></para>
                    </example>
                </para>
            </formalpara>
            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-exit">EXIT</link>, <link
                        linkend="psql-statements-continue">CONTINUE</link>.</para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-continue">
            <info>
                <title>CONTINUE</title>
                <keywordset>
                    <keyword>CONTINUE</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CONTINUE</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Досрочное начало новой итерации цикла.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
[<replaceable>label</replaceable>:]
{FOR <replaceable>&lt;select_stmt&gt;</replaceable> | WHILE (<replaceable>&lt;condition&gt;</replaceable>)} DO
BEGIN
  ...
  CONTINUE [<replaceable>label</replaceable>];
  ...
END
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора CONTINUE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>label</replaceable></entry>
                                <entry>
                                    <para>Метка.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>select_stmt</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>condition</replaceable></entry>
                                <entry>
                                    <para>Логическое условие возвращающее TRUE, FALSE или
                                        UNKNOWN.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор CONTINUE моментально начинает новую итерацию внутреннего цикла операторов
                WHILE или FOR. С использованием опционального параметра метки CONTINUE также может
                начинать новую итерацию для внешних циклов.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Использование оператора CONTINUE</title>
                        <para><programlisting language="sql">
FOR 
  SELECT A, D FROM ATABLE INTO :achar, :ddate
DO BEGIN
  IF (ddate &lt; current_data - 30) THEN
    CONTINUE;
  ELSE
    /* do stuff */
  ...
END      
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-leave">LEAVE</link>.</para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-exit">
            <info>
                <title>EXIT</title>
                <keywordset>
                    <keyword>EXIT</keyword>
                </keywordset>
            </info>

            <indexterm><primary>EXIT</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Завершение работы процедуры, функции или триггера.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
EXIT
                </programlisting></para>
            </formalpara>

            <para>Оператор EXIT позволяет из любой точки триггера или хранимой процедуры перейти на
                последний оператор END, то есть завершить выполнение программы.</para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование оператора EXIT в селективной хранимой
                            процедуре.</title>
                        <para><programlisting language="sql">
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END       
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-leave">LEAVE</link>, <link
                        linkend="psql-statements-suspend">SUSPEND</link>.</para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-suspend">
            <info>
                <title>SUSPEND</title>
                <keywordset>
                    <keyword>SUSPEND</keyword>
                </keywordset>
            </info>

            <indexterm><primary>SUSPEND</primary></indexterm>

            <para>Передача значений параметров в буфер и приостановка выполнения процедуры (PSQL
                блока) до тех пор, пока вызывающая сторона не получит результат.</para>
            <formalpara>
                <title>Доступно в:</title>


                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
SUSPEND
                </programlisting></para>
            </formalpara>

            <para>Оператор SUSPEND передаёт значения выходных параметров в буфер и приостанавливает
                выполнение хранимой процедуры (PSQL блока). Выполнение остаётся приостановленным до
                тех пор, пока вызывающая сторона не получит содержимое буфера. Выполнение
                возобновляется с оператора, следующего непосредственно после оператора SUSPEND. Чаще
                всего это будет новой итерацией циклического процесса.</para>

            <note>
                <para><orderedlist>
                        <listitem>
                            <para>Приложения, использующие API интерфейсы, обычно делают выборку из
                                хранимых процедур прозрачно.</para>
                        </listitem>
                        <listitem>
                            <para>Если оператор SUSPEND выдаётся в исполняемой (executable) хранимой
                                процедуре, то это равносильно выполнению оператора EXIT, в
                                результате чего завершается работа процедуры.</para>
                        </listitem>
                        <listitem>
                            <para>Оператор SUSPEND &quot;разрывает&quot; атомарность блока, внутри
                                которого он находится. В случае возникновения ошибки в селективной
                                процедуре, операторы, выполненные после последнего оператора
                                SUSPEND, будут откачены. Операторы, выполненные до последнего
                                оператора SUSPEND, не будут откачены, если не будет выполнен откат
                                транзакции.</para>
                        </listitem>
                    </orderedlist></para>
            </note>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование оператора SUSPEND в селективной хранимой
                            процедуре.</title>
                        <para><programlisting language="sql">
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END        
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-exit">EXIT</link>.</para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-execstmt">
            <info>
                <title>EXECUTE STATEMENT</title>
                <keywordset>
                    <keyword>EXECUTE STATEMENT</keyword>
                </keywordset>
            </info>

            <indexterm><primary>EXECUTE STATEMENT</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Выполнение динамически созданных SQL операторов.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
<replaceable>&lt;execute_statement&gt;</replaceable> ::= 
  EXECUTE STATEMENT <replaceable>&lt;argument&gt;</replaceable>
    [<replaceable>&lt;option&gt;</replaceable> ...]
    [INTO <replaceable>&lt;variables&gt;</replaceable>]

<replaceable>&lt;argument&gt;</replaceable> ::= 
    <replaceable>paramless_stmt</replaceable>
  | (<replaceable>paramless_stmt</replaceable>)
  | (<replaceable>&lt;stmt_with_params&gt;</replaceable>) (<replaceable>&lt;param_values&gt;</replaceable>)

<replaceable>&lt;param_values&gt;</replaceable> ::= <replaceable>&lt;named_values&gt;</replaceable> | <replaceable>&lt;positional_values&gt;</replaceable>

<replaceable>&lt;named_values&gt;</replaceable> ::= 
  [EXCESS] <replaceable>paramname</replaceable> := <replaceable>value_expr</replaceable> 
  [, [EXCESS] <replaceable>paramname</replaceable> := <replaceable>value_expr</replaceable> ...]

<replaceable>&lt;positional_values&gt;</replaceable> ::= <replaceable>value_expr</replaceable> [, <replaceable>value_expr</replaceable> ...]

<replaceable>&lt;option&gt;</replaceable> ::= 
    WITH {AUTONOMOUS | COMMON} TRANSACTION
  | WITH CALLER PRIVILEGES
  | AS USER <replaceable>user</replaceable>
  | PASSWORD <replaceable>password</replaceable>
  | ROLE <replaceable>role</replaceable>
  | ON EXTERNAL [DATA SOURCE] <replaceable>&lt;connect_string&gt;</replaceable>

<replaceable>&lt;connect_string&gt;</replaceable> ::= [<replaceable>&lt;hostspec&gt;</replaceable>] {<replaceable>filepath</replaceable> | <replaceable>db_alias</replaceable>}

<replaceable>&lt;hostspec&gt;</replaceable> ::= 
    <replaceable>host</replaceable>[\<replaceable>port</replaceable> | <replaceable>service</replaceable>]: 
  | \\<replaceable>host</replaceable>[@<replaceable>port</replaceable> | <replaceable>service</replaceable>]\ 
  | <replaceable>&lt;protocol&gt;</replaceable>://[<replaceable>host</replaceable>[:<replaceable>port</replaceable> | <replaceable>service</replaceable>]/]

<replaceable>&lt;protocol&gt;</replaceable> = inet | inet4 | inet6 | wnet | xnet

<replaceable>&lt;variables&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора EXECUTE STATEMENT</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>paramless_stmt</replaceable></entry>
                                <entry>
                                    <para>Строки или переменная, содержащая не параметризованный SQL
                                        запрос.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>stmt_with_params</replaceable></entry>
                                <entry>
                                    <para>Строки или переменная, содержащая параметризованный SQL
                                        запрос.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>paramname</replaceable></entry>
                                <entry>
                                    <para>Имя параметра SQL запроса.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>value_expr</replaceable></entry>
                                <entry>
                                    <para>Выражение.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>user</replaceable></entry>
                                <entry>
                                    <para>Имя пользователя. Может быть строкой или
                                        переменной.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>password</replaceable></entry>
                                <entry>
                                    <para>Пароль. Может быть строкой или переменной.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>role</replaceable></entry>
                                <entry>
                                    <para>Роль. Может быть строкой или переменной.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>connection_string</replaceable></entry>
                                <entry>
                                    <para>Строка соединения. Может быть строкой или
                                        переменной.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>filepath</replaceable></entry>
                                <entry>
                                    <para>Путь к первичному файлу базы данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>db_alias</replaceable></entry>
                                <entry>
                                    <para>Псевдоним базы данных.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>host</replaceable></entry>
                                <entry>
                                    <para>Имя компьютера или IP адрес.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>port</replaceable></entry>
                                <entry>
                                    <para>Номер порта, который слушает удалённый сервер (параметр
                                            <parameter>RemoteServicePort</parameter> файла
                                            <filename>firebird.conf</filename>).</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>service</replaceable></entry>
                                <entry>
                                    <para>Имя сервиса. Должно совпадать со значением параметра
                                            <parameter>RemoteServiceName</parameter> файла
                                            <filename>firebird.conf</filename>.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>protocol</replaceable></entry>
                                <entry>
                                    <para>Наименование протокола.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>varname</replaceable></entry>
                                <entry>
                                    <para>Переменная.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор EXECUTE STATEMENT принимает строковый параметр и выполняет его, как будто
                это оператор DSQL. Если оператор возвращает данные, то с помощью предложения INTO их
                можно передать в локальные переменные.</para>
            <section xml:id="psql-statements-execstmt-wparams">
                <title>Параметризованные операторы</title>

                <para>В DSQL операторе можно использовать параметры. Параметры могут быть
                    именованными и позиционными (безымянные). Значение должно быть присвоено каждому
                    параметру.</para>
                <section xml:id="psql-statements-execstmt-wparams01">
                    <title>Особенности использования параметризованных операторов</title>
                    <para><orderedlist spacing="compact">
                            <listitem>
                                <para>Одновременное использование именованных и позиционных
                                    параметров в одном запросе запрещено;</para>
                            </listitem>
                            <listitem>
                                <para>Если у оператора есть параметры, они должны быть помещены в
                                    круглые скобки при вызове EXECUTE STATEMENT, независимо от вида
                                    их представления: непосредственно в виде строки, как имя
                                    переменной или как выражение;</para>
                            </listitem>
                            <listitem>
                                <para>Именованным параметрам должно предшествовать двоеточие (:) в
                                    самом операторе, но не при присвоении значения параметру;</para>
                            </listitem>
                            <listitem>
                                <para>Передача значений безымянным параметрам должна происходить в
                                    том же порядке, в каком они встречаются в тексте запроса;</para>
                            </listitem>
                            <listitem>
                                <para>Присвоение значений параметров должно осуществляться при
                                    помощи специального оператора &quot;:=&quot;, аналогичного
                                    оператору присваивания языка Pascal;</para>
                            </listitem>
                            <listitem>
                                <para>Каждый именованный параметр может использоваться в операторе
                                    несколько раз, но только один раз при присвоении
                                    значения;</para>
                            </listitem>
                            <listitem>
                                <para>Для позиционных параметров число подставляемых значений должно
                                    точно равняться числу параметров (вопросительных знаков) в
                                    операторе;</para>
                            </listitem>
                            <listitem>
                                <para>Необязательное ключевое слово EXCESS обозначает, что данный
                                    именованный параметр необязательно должен упоминаться в тексте
                                    запроса. Обратите внимание, что все не EXCESS параметры должны
                                    присутствовать в запросе.</para>
                            </listitem>
                        </orderedlist></para>
                    <formalpara>
                        <title>Примеры:</title>
                        <para>
                            <example>
                                <title>С именованными параметрами:</title>
                                <para>
                                    <programlisting language="sql">
...
DECLARE license_num VARCHAR(15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = :driver AND location = :loc';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  INTO connect_string;
  ...
  FOR
    SELECT id
    FROM drivers
    INTO current_driver
   DO
   BEGIN
     FOR
       SELECT location
       FROM driver_locations
       WHERE driver_id = :current_driver
       INTO current_location
     DO
     BEGIN
       ...
       EXECUTE STATEMENT (stmt)
       (driver := current_driver,
        loc := current_location)
       ON EXTERNAL connect_string 
       INTO license_num;
       ...
                                    </programlisting>
                                </para>
                            </example>
                            <example>
                                <title>С позиционными параметрами:</title>
                                <para>
                                    <programlisting language="sql">
DECLARE license_num VARCHAR (15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = ? AND location = ?';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  INTO connect_string;
  ...
  FOR SELECT id
      FROM drivers
      INTO current_driver
  DO
  BEGIN
    FOR
      SELECT location
      FROM driver_locations
      WHERE driver_id = :current_driver
      INTO current_location
    DO
    BEGIN
      ...
      EXECUTE STATEMENT (stmt)
      (current_driver, current_location)
      ON EXTERNAL connect_string
      INTO license_num;
      ...                                        
                                    </programlisting>
                                </para>
                            </example>
                            <example>
                                <title>С избыточными (EXCESS) параметрами:</title>
                                <para>
                                    <programlisting language="sql">
<![CDATA[                                        
CREATE PROCEDURE P_EXCESS (A_ID INT, A_TRAN INT = NULL, A_CONN INT = NULL)
  RETURNS (ID INT, TRAN INT, CONN INT)
AS
DECLARE S VARCHAR(255);
DECLARE W VARCHAR(255) = '';
BEGIN
  S = 'SELECT * FROM TTT WHERE ID = :ID';

  IF (A_TRAN IS NOT NULL)
  THEN W = W || ' AND TRAN = :a';

  IF (A_CONN IS NOT NULL)
  THEN W = W || ' AND CONN = :b';

  IF (W <> '')
  THEN S = S || W;

  -- could raise error if TRAN or CONN is null
  -- FOR EXECUTE STATEMENT (:S) (a := :A_TRAN, b := A_CONN, id := A_ID)

  -- OK in all cases
  FOR EXECUTE STATEMENT (:S) (EXCESS a := :A_TRAN, EXCESS b := A_CONN, id := A_ID)
      INTO :ID, :TRAN, :CONN
      DO SUSPEND;
END           
]]>
                                    </programlisting>
                                </para>
                            </example>
                        </para>
                    </formalpara>
                </section>
            </section>
            <section xml:id="psql-statements-execstmt-wautonomous">
                <info>
                    <title>WITH {AUTONOMOUS | COMMON} TRANSACTION</title>
                    <keywordset>
                        <keyword>WITH AUTONOMOUS TRANSACTION</keyword>
                        <keyword>WITH COMMON TRANSACTION</keyword>
                    </keywordset>
                </info>

                <indexterm>
                    <primary>EXECUTE STATEMENT</primary>
                    <secondary>WITH AUTONOMOUS TRANSACTION</secondary>
                </indexterm>

                <indexterm>
                    <primary>EXECUTE STATEMENT</primary>
                    <secondary>WITH COMMON TRANSACTION</secondary>
                </indexterm>

                <para>По умолчанию оператор выполняется в контексте текущей транзакции. При
                    использовании предложения WITH AUTONOMOUS TRANSACTION запускается новая
                    транзакция с такими же параметрами, как и текущая. Она будет подтверждена, если
                    оператор выполнился без ошибок и отменена (откачена) в противном случае. С
                    предложением WITH COMMON TRANSACTION по возможности используется текущая
                    транзакция.</para>
                <para>Если оператор должен работать в отдельном соединении, то используется уже
                    запущенная в этом соединении транзакция (если таковая транзакция имеется). В
                    противном случае стартует новая транзакция с параметрами текущей транзакции.
                    Любые новые транзакции, запущенные в режиме &quot;COMMON&quot;, подтверждаются
                    или откатываются вместе с текущей транзакцией.</para>
            </section>
            <section xml:id="psql-statements-execstmt-wcaller">
                <info>
                    <title>WITH CALLER PRIVILEGES</title>
                    <keywordset>
                        <keyword>WITH CALLER PRIVILEGES</keyword>
                    </keywordset>
                </info>

                <indexterm>
                    <primary>EXECUTE STATEMENT</primary>
                    <secondary>WITH CALLER PRIVILEGES</secondary>
                </indexterm>

                <para>По умолчанию операторы SQL выполняются с правами текущего пользователя.
                    Спецификация WITH CALLER PRIVILEGES добавляет к ним привилегии для вызова
                    хранимой процедуры или триггера, так же, как если бы оператор выполнялся
                    непосредственно подпрограммой. WITH CALLER PRIVILEGES не имеет никакого эффекта,
                    если также присутствует предложение ON EXTERNAL.</para>
            </section>
            <section xml:id="psql-statements-execstmt-onexternal">
                <info>
                    <title>ON EXTERNAL [DATA SOURCE]</title>
                    <keywordset>
                        <keyword>ON EXTERNAL</keyword>
                    </keywordset>
                </info>

                <indexterm>
                    <primary>EXECUTE STATEMENT</primary>
                    <secondary>ON EXTERNAL</secondary>
                </indexterm>

                <para>С предложением ON EXTERNAL DATA SOURCE оператор выполняется в отдельном
                    соединении с той же или другой базой данных, возможно даже на другом сервере.
                    Если строка подключения имеет значение NULL или '' (пустая строка), предложение
                    ON EXTERNAL считается отсутствующим и оператор выполняется для текущей базы
                    данных. Строка подключения подробно описана в операторе CREATE DATABASE см.
                        <link linkend="ddl-database-create-remotely">Создание БД на удалённом
                        сервере</link>.</para>
                <para>При выполнении оператора в отдельном соединении используется пул соединений и
                    пул транзакций.</para>

                <section xml:id="psql-statements-execstmt-ext-connpool">
                    <title>Пул внешних подключений (External connection pool)</title>

                    <para>Чтобы избежать задержек при частом использовании внешних соединений,
                        подсистема внешних источников данных (EDS) использует пул внешних
                        подключений. Пул сохраняет неиспользуемые внешние соединения в течении
                        некоторого времени, что позволяет избежать затрат на подключение/отключение
                        для часто используемых строк подключения.</para>

                    <para>Как работает пул соединений:<itemizedlist>
                            <listitem>
                                <para>каждое внешнее соединение связывается с пулом при
                                    создании;</para>
                            </listitem>
                            <listitem>
                                <para>пул имеет два списка: неиспользуемых соединений и активных
                                    соединений;</para>
                            </listitem>
                            <listitem>
                                <para>когда соединение становится неиспользуемым (т. е. у него нет
                                    активных запросов и нет активных транзакций), то оно
                                    сбрасывается и помещается в список ожидающих (при успешном
                                    завершении сброса) или закрывается (если при сбросе произошла
                                    ошибка). Соединение сбрасывается при помощи инструкции
                                        <code>ALTER SESSION RESET</code>. Сброс считается успешным,
                                    если не возникла ошибка. <note>
                                        <para>Если внешний источник данных не поддерживает оператор
                                                <code>ALTER SESSION RESET</code>, то это не
                                            считается ошибкой, и такое соединение будет помещено в
                                            пул.</para>
                                    </note>
                                </para>
                            </listitem>
                            <listitem>
                                <para>если пул достиг максимального размера, то самое старое
                                    бездействующее соединение закрывается;</para>
                            </listitem>
                            <listitem>
                                <para>когда Firebird просит создать новое внешнее соединение, то пул
                                    сначала ищет кандидата в списке простаивающих соединений. Поиск
                                    основан на 4 параметрах:<itemizedlist spacing="compact">
                                        <listitem>
                                            <para>строка подключения;</para>
                                        </listitem>
                                        <listitem>
                                            <para>имя пользователя;</para>
                                        </listitem>
                                        <listitem>
                                            <para>пароль;</para>
                                        </listitem>
                                        <listitem>
                                            <para>роль.</para>
                                        </listitem>
                                    </itemizedlist></para>
                                <para>Поиск чувствителен к регистру;</para>
                            </listitem>
                            <listitem>
                                <para>если подходящее соединение найдено, то проверятся живое ли
                                    оно;</para>
                            </listitem>
                            <listitem>
                                <para>если соединение не прошло проверку, то оно удаляется и поиск
                                    повторяется (ошибка не возвращается пользователю);</para>
                            </listitem>
                            <listitem>
                                <para>найденное (и живое) соединение перемещается из списка
                                    простаивающих соединение в список активных соединений и
                                    возвращается вызывающему;</para>
                            </listitem>
                            <listitem>
                                <para>если имеется несколько подходящих соединений, то будет выбрано
                                    наиболее часто используемое;</para>
                            </listitem>
                            <listitem>
                                <para>если нет подходящего соединения, то создаётся новое и
                                    помещается в список активных соединений;</para>
                            </listitem>
                            <listitem>
                                <para>когда время жизни простаивающего соединения истекло, то оно
                                    удаляется из пула и закрывается.</para>
                            </listitem>
                        </itemizedlist></para>

                    <para>Основные характеристики:<itemizedlist>
                            <listitem>
                                <para>отсутствие "вечных" внешних соединений;</para>
                            </listitem>
                            <listitem>
                                <para>ограниченное количество неактивных (простаивающих) внешних
                                    соединений в пуле;</para>
                            </listitem>
                            <listitem>
                                <para>поддерживает быстрый поиск среди соединений (по 4 параметрам
                                    указанным выше);</para>
                            </listitem>
                            <listitem>
                                <para>пул является общим для всех внешних баз данных;</para>
                            </listitem>
                            <listitem>
                                <para>пул является общим для всех локальных соединений,
                                    обрабатываемых данным процессом Firebird.</para>
                            </listitem>
                        </itemizedlist></para>
                    <para>Параметры пула внешних соединений:<itemizedlist>
                            <listitem>
                                <para>время жизни соединения: временной интервал с момента
                                    последнего использования соединения, после истечении которого он
                                    будет принудительно закрыт. Параметр ExtConnPoolLifeTime в
                                        <filename>firebird.conf</filename>. По умолчанию равен 7200
                                    секунд;</para>
                            </listitem>
                            <listitem>
                                <para>размер пула: максимально допустимое количество незанятых
                                    соединений в пуле. Параметр ExtConnPoolSize в
                                        <filename>firebird.conf</filename>. По умолчанию равен 0,
                                    т.е. пул внешних соединений отключен.</para>
                            </listitem>
                        </itemizedlist></para>

                    <para>Пулом внешних соединений, а также его параметрами можно управлять с
                        помощью специальных операторов. Подробнее см. <link
                            linkend="session-extconnpool">ALTER EXTERNAL CONNECTIONS
                        POOL</link>.</para>

                    <para>Состояние пула внешних подключений можно запросить с использованием
                        контекстных переменных в пространстве имен SYSTEM: <table frame="all">
                            <title>Переменные пространства имён SYSTEM для контроля пула внешних
                                соединений</title>
                            <tgroup cols="2">
                                <colspec colname="c1" colnum="1" colwidth="1.3*" align="left"/>
                                <colspec colname="c2" colnum="2" colwidth="2.0*" align="justify"/>
                                <thead>
                                    <row>
                                        <entry align="center"> Переменная </entry>
                                        <entry align="center"> Описание </entry>
                                    </row>
                                </thead>
                                <tbody>
                                    <row>
                                        <entry>EXT_CONN_POOL_SIZE</entry>
                                        <entry>Размер пула.</entry>
                                    </row>
                                    <row>
                                        <entry>EXT_CONN_POOL_LIFETIME</entry>
                                        <entry>Время жизни неактивных соединений.</entry>
                                    </row>
                                    <row>
                                        <entry>EXT_CONN_POOL_IDLE_COUNT</entry>
                                        <entry>Текущее количество неактивных соединений в
                                            пуле.</entry>
                                    </row>
                                    <row>
                                        <entry>EXT_CONN_POOL_ACTIVE_COUNT</entry>
                                        <entry>Текущее количество активных соединений в
                                            пуле.</entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </table>
                    </para>
                </section>

                <section xml:id="psql-statements-execstmt-onext-connpool">
                    <title>Особенности внешних подключений</title>

                    <para><orderedlist spacing="compact">
                            <listitem>
                                <para>Внешние соединения используют по умолчанию предложение WITH
                                    COMMON TRANSACTION и остаются открытыми до закрытия текущей
                                    транзакции. Они могут быть снова использованы при последующих
                                    вызовах оператора EXECUTE STATEMENT, но только если строка
                                    подключения точно такая же. Если включен пул внешних соединений,
                                    то вместо закрытия соединения, такие соединения будут попадать в
                                    список неактивных (простаивающих) соединений;</para>
                            </listitem>
                            <listitem>
                                <para>Внешние соединения, созданные с использованием предложения
                                    WITH AUTONOMOUS TRANSACTION, закрываются после выполнения
                                    оператора или попадают в список неактивных соединений пула (если
                                    он включен);</para>
                            </listitem>
                            <listitem>
                                <para>Операторы WITH AUTONOMOUS TRANSACTION могут использовать
                                    соединения, которые ранее были открыты операторами WITH COMMON
                                    TRANSACTION. В этом случае использованное соединение остаётся
                                    открытым и после выполнения оператора, т.к. у этого соединения
                                    есть, по крайней мере, одна не закрытая транзакция. Если включен
                                    пул внешних соединений, то вместо закрытия соединения, такие
                                    соединения будут попадать в список неактивных (простаивающих)
                                    соединений;</para>
                            </listitem>
                            <listitem>
                                <para>Если локальная транзакция запущена в режиме изолированности
                                        <code>READ COMMITTED READ CONSISTENCY</code> и внешний
                                    источник данных не поддерживает данный режим изолированности, то
                                    внешняя транзакция будет запущена в режиме изолированности
                                    SNAPSHOT (CONCURRENCY). </para>
                            </listitem>

                        </orderedlist>
                    </para>
                </section>

                <section xml:id="psql-statements-execstmt-onext-tranpool">
                    <title>Особенности пула транзакций (Transaction pooling)</title>
                    <para><orderedlist spacing="compact">
                            <listitem>
                                <para>При использовании предложения WITH COMMON TRANSACTION
                                    транзакции будут снова использованы как можно дольше. Они будут
                                    подтверждаться или откатываться вместе с текущей
                                    транзакцией;</para>
                            </listitem>
                            <listitem>
                                <para>При использовании предложения WITH AUTONOMOUS TRANSACTION
                                    всегда запускается новая транзакция. Она будет подтверждена или
                                    отменена сразу же после выполнения оператора;</para>
                            </listitem>
                        </orderedlist>
                    </para>
                </section>
                <section xml:id="psql-statements-execstmt-onext-errhandling">
                    <title>Особенности обработки исключений</title>
                    <para>При использовании предложения ON EXTERNAL дополнительное соединение всегда
                        делается через так называемого внешнего провайдера, даже если это соединение
                        к текущей базе данных. Одним из последствий этого является то, что вы не
                        можете обработать исключение привычными способами. Каждое исключение,
                        вызванное оператором, возвращает eds_connection или eds_statement ошибки.
                        Для обработки исключений в коде PSQL вы должны использовать WHEN GDSCODE
                        eds_connection, WHEN GDSCODE eds_statement или WHEN ANY.</para>
                    <note>
                        <para>Если предложение ON EXTERNAL не используется, то исключения
                            перехватываются в обычном порядке, даже если это дополнительное
                            соединение с текущей базой данных.</para>
                    </note>
                </section>
                <section xml:id="psql-statements-execstmt-onext-morenotes">
                    <title>Другие замечания</title>
                    <para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>Набор символов, используемый для внешнего соединения,
                                    совпадает с используемым набором для текущего соединения.</para>
                            </listitem>
                            <listitem>
                                <para>Двухфазные транзакции не поддерживаются.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </section>
            </section>
            <section xml:id="psql-statements-execstmt-asuser">
                <info>
                    <title>AS USER, PASSWORD и ROLE</title>
                    <keywordset>
                        <keyword>AS USER</keyword>
                        <keyword>PASSWORD</keyword>
                        <keyword>ROLE</keyword>
                    </keywordset>
                </info>

                <para>Необязательные предложения AS USER, PASSWORD и ROLE позволяют указывать от
                    имени какого пользователя, и с какой ролью будет выполняться SQL оператор. То,
                    как авторизуется пользователь и открыто ли отдельное соединение, зависит от
                    присутствия и значений параметров ON EXTERNAL [DATA SOURCE], AS USER, PASSWORD и
                    ROLE. <itemizedlist>
                        <listitem>
                            <para>При использовании предложения ON EXTERNAL открывается новое
                                соединение и: <itemizedlist spacing="compact">
                                    <listitem>
                                        <para>Если присутствует, по крайней мере, один из параметров
                                            AS USER, PASSWORD и ROLE, то будет предпринята попытка
                                            нативной аутентификации с указанными значениями
                                            параметров (в зависимости от строки соединения —
                                            локально или удалённо). Для недостающих параметров не
                                            используются никаких значений по умолчанию;</para>
                                    </listitem>
                                    <listitem>
                                        <para>Если все три параметра отсутствуют, и строка
                                            подключения не содержит имени сервера (или IP адреса),
                                            то новое соединение устанавливается к локальному серверу
                                            с пользователем и ролью текущего соединения. Термин
                                            'локальный' означает 'компьютер, где установлен сервер
                                            Firebird'. Это совсем не обязательно компьютер
                                            клиента;</para>
                                    </listitem>
                                    <listitem>
                                        <para>Если все три параметра отсутствуют, но строка
                                            подключения содержит имя сервера (или IP адреса), то
                                            будет предпринята попытка доверенной (trusted)
                                            авторизации к удалённому серверу. Если авторизация
                                            прошла, то удалённая операционная система назначит
                                            пользователю имя — обычно это учётная запись, под
                                            которой работает сервер Firebird.</para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                        </listitem>
                        <listitem>
                            <para>Если предложение ON EXTERNAL отсутствует: <itemizedlist
                                    spacing="compact">
                                    <listitem>
                                        <para>Если присутствует, по крайней мере, один из параметров
                                            AS USER, PASSWORD и ROLE, то будет открыто соединение к
                                            текущей базе данных с указанными значениями параметров.
                                            Для недостающих параметров не используются никаких
                                            значений по умолчанию;</para>
                                    </listitem>
                                    <listitem>
                                        <para>Если все три параметра отсутствуют, то оператор
                                            выполняется в текущем соединении.</para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
                <important>
                    <para>Если значение параметра NULL или '', то весь параметр считается
                        отсутствующим. Кроме того, если параметр считается отсутствующим, то AS USER
                        принимает значение CURRENT_USER, а ROLE — CURRENT_ROLE. Сравнение при
                        авторизации сделано чувствительным к регистру: в большинстве случаев это
                        означает, что имена пользователя и роли должны быть написаны в верхнем
                        регистре.</para>
                </important>
            </section>
            <section xml:id="psql-statements-execstmt-warn">
                <title>Предостережения</title>

                <para>
                    <orderedlist spacing="compact">
                        <listitem>
                            <para>Не существует способа проверить синтаксис выполняемого SQL
                                оператора;</para>
                        </listitem>
                        <listitem>
                            <para>Нет никаких проверок зависимостей для обнаружения удалённых
                                столбцов в таблице или самой таблицы;</para>
                        </listitem>
                        <listitem>
                            <para>Выполнение оператора с помощью оператора EXECUTE STATEMENT
                                значительно медленнее, чем при непосредственном выполнении;</para>
                        </listitem>
                        <listitem>
                            <para>Возвращаемые значения строго проверяются на тип данных во
                                избежание непредсказуемых исключений преобразования типа. Например,
                                строка '1234' преобразуется в целое число 1234, а строка 'abc'
                                вызовет ошибку преобразования.</para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>В целом эта функция должна использоваться очень осторожно, а вышеупомянутые
                    факторы всегда должны приниматься во внимание. Если такого же результата можно
                    достичь с использованием PSQL и/или DSQL, то это всегда предпочтительнее.</para>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="psql-statements-forexec">FOR EXECUTE STATEMENT</link>.
                    </para>
                </formalpara>
            </section>
        </section>
        <section xml:id="psql-statements-forselect">
            <info>
                <title>FOR SELECT</title>
                <keywordset>
                    <keyword>FOR</keyword>
                </keywordset>
            </info>

            <indexterm><primary>FOR SELECT</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Цикл по строкам результата выполнения оператора SELECT.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
FOR 
  <replaceable>&lt;select_stmt&gt;</replaceable> 
  [INTO <replaceable>&lt;variables&gt;</replaceable>]
  [AS CURSOR <replaceable>cursorname</replaceable>]
DO <replaceable>&lt;compound_statement&gt;</replaceable>
 
<replaceable>&lt;variables&gt;</replaceable> ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]     
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора FOR SELECT</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>select_stmt</replaceable></entry>
                                <entry>
                                    <para>Оператор SELECT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>cursorname</replaceable></entry>
                                <entry>
                                    <para>Имя курсора. Должно быть уникальным среди имён переменных
                                        и курсоров PSQL модуля.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>varname</replaceable></entry>
                                <entry>
                                    <para>Имя локальной переменной или входного/выходного
                                        параметра.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>compound_statement</replaceable></entry>
                                <entry>
                                    <para>Составной оператор (оператор или блок операторов).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор FOR SELECT выбирает очередную строку из таблицы (представления,
                селективной хранимой процедуры), после чего выполняется составной оператор. В каждой
                итерации цикла значения полей текущей строки копируются в локальные переменные.
                Добавление предложения AS CURSOR делает возможным позиционное удаление и обновление
                данных. Операторы FOR SELECT могут быть вложенными.</para>
            <para>Оператор FOR SELECT может содержать именованные параметры, которые должны быть
                предварительно объявлены в операторе DECLARE VARIABLE, или во входных (выходных)
                параметрах процедуры (PSQL блока).</para>
            <para>Оператор FOR SELECT должен содержать предложение INTO, которое располагается в
                конце этого оператора, или предложение AS CURSOR. На каждой итерации цикла в список
                переменных указанных в предложении INTO копируются значения полей текущей строки
                запроса. Цикл повторяется, пока не будут прочитаны все строки. После этого
                происходит выход из цикла. Цикл также может быть завершён до прочтения всех строк
                при использовании оператора LEAVE.</para>

            <section xml:id="psql-statements-forselect-cursor">
                <title>Необъявленный курсор</title>
                <para>Необязательное предложение AS CURSOR создаёт именованный курсор, на который
                    можно ссылаться (с использованием предложения WHERE CURRENT OF) внутри
                    составного оператора следующего после предложения DO, для того чтобы удалить или
                    модифицировать текущую строку. Кроме того, позволяется использовать ссылки на
                    курсоры, как на переменные типа запись. Текущая запись доступна через имя
                    курсора. Использование предложение AS CURSOR делает предложение INTO
                    необязательным.</para>
                <para><emphasis role="italic">Правила</emphasis>: <itemizedlist>
                        <listitem>
                            <para>Для разрешения неоднозначности при доступе к переменной курсора
                                перед именем курсора необходим префикс двоеточие;</para>
                        </listitem>
                        <listitem>
                            <para>К переменной курсора можно получить доступ без префикса двоеточия,
                                но в этом случае, в зависимости от области видимости контекстов,
                                существующих в запросе, имя может разрешиться как контекст запроса
                                вместо курсора;</para>
                        </listitem>
                        <listitem>
                            <para>Переменные курсора доступны только для чтения;</para>
                        </listitem>
                        <listitem>
                            <para>В операторе FOR SELECT без предложения AS CURSOR необходимо
                                использовать предложение INTO. Если указано предложение AS CURSOR,
                                предложение INTO не требуется, но разрешено;</para>
                        </listitem>
                        <listitem>
                            <para>Чтение из переменной курсора возвращает текущие значения полей.
                                Это означает, что оператор UPDATE (с предложением WHERE CURRENT OF)
                                обновит также и значения полей в переменной курсора для последующих
                                чтений. Выполнение оператора DELETE (с предложением WHERE CURRENT
                                OF) установит NULL для значений полей переменной курсора для
                                последующих чтений.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <note>
                    <para>
                        <itemizedlist spacing="compact">
                            <listitem>
                                <para>Над курсором, объявленным с помощью предложения AS CURSOR
                                    нельзя выполнять операторы OPEN, FETCH и CLOSE;</para>
                            </listitem>
                            <listitem>
                                <para>Убедитесь, что имя курсора, определённое здесь, не совпадает
                                    ни с какими именами, созданными ранее оператором DECLARE
                                    VARIABLE;</para>
                            </listitem>
                            <listitem>
                                <para>Предложение FOR UPDATE, разрешённое для использования в
                                    операторе SELECT, не является обязательным для успешного
                                    выполнения позиционного обновления или удаления.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </note>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Использование оператора FOR SELECT</title>
                            <para><programlisting language="sql">
CREATE PROCEDURE SHOWNUMS
RETURNS (
  AA INTEGER,
  BB INTEGER,
  SM INTEGER,
  DF INTEGER)
AS
BEGIN
  FOR SELECT DISTINCT A, B
      FROM NUMBERS
    ORDER BY A, B
    INTO AA, BB 
  DO
  BEGIN
    SM = AA + BB;
    DF = AA - BB;
    SUSPEND;
  END
END     
                </programlisting></para>
                        </example>
                        <example>
                            <title>Вложенный FOR SELECT</title>
                            <para><programlisting language="sql">
CREATE PROCEDURE RELFIELDS
RETURNS (
  RELATION CHAR(32),
  POS INTEGER,
  FIELD CHAR(32))
AS
BEGIN
  FOR SELECT RDB$RELATION_NAME
      FROM RDB$RELATIONS
      ORDER BY 1
      INTO :RELATION 
  DO
  BEGIN
    FOR SELECT
          RDB$FIELD_POSITION + 1,
          RDB$FIELD_NAME
        FROM RDB$RELATION_FIELDS
        WHERE
          RDB$RELATION_NAME = :RELATION
        ORDER BY RDB$FIELD_POSITION
        INTO :POS, :FIELD 
    DO
    BEGIN
      IF (POS = 2) THEN
        RELATION = ' "';
      -- Для исключения повтора имён таблиц и представлений
      SUSPEND;
    END
  END
END   
                </programlisting></para>
                        </example>
                        <example>
                            <title>Использование предложения AS CURSOR для позиционного удаления
                                записи</title>
                            <para><programlisting language="sql">
CREATE PROCEDURE DELTOWN (
  TOWNTODELETE VARCHAR(24))
RETURNS (
  TOWN VARCHAR(24),
  POP INTEGER)
AS
BEGIN
  FOR SELECT TOWN, POP
      FROM TOWNS
      INTO :TOWN, :POP 
      AS CURSOR TCUR 
  DO
  BEGIN
    IF (:TOWN = :TOWNTODELETE) THEN
      -- Позиционное удаление записи
      DELETE FROM TOWNS
      WHERE CURRENT OF TCUR;
    ELSE
      SUSPEND;
  END
END   
                </programlisting></para>
                        </example>
                        <example>
                            <title>Использование неявно объявленного курсора как курсорной
                                переменной</title>
                            <para><programlisting language="sql">
EXECUTE BLOCK
RETURNS (
    o CHAR(63))
AS
BEGIN
  FOR 
      SELECT
          rdb$relation_name AS name
      FROM
          rdb$relations AS CURSOR c
  DO
  BEGIN
    o = c.name;
    SUSPEND;
  END
END 
                </programlisting></para>
                        </example>
                        <example>
                            <title>Разрешение неоднозначностей курсорной переменной внутри
                                запросов</title>
                            <para><programlisting language="sql">
EXECUTE BLOCK
RETURNS (
    o1 CHAR(63),
    o2 CHAR(63))
AS
BEGIN
  FOR
      SELECT
          rdb$relation_name
      FROM
          rdb$relations
      WHERE
          rdb$relation_name = 'RDB$RELATIONS' AS CURSOR c
  DO
  BEGIN
    FOR
        SELECT
            -- с префиксом разрешается как курсор
            :c.rdb$relation_name x1,
            -- без префикса как псевдоним таблицы rdb$relations
            c.rdb$relation_name x2
        FROM
            rdb$relations c
        WHERE
            rdb$relation_name = 'RDB$DATABASE' AS CURSOR d
    DO
    BEGIN
      o1 = d.x1;
      o2 = d.x2;
      SUSPEND;
    END
  END
END  
                </programlisting></para>
                        </example>
                    </para>
                </formalpara>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="dml-select">SELECT</link>, <link
                            linkend="psql-statements-declare-cursor">DECLARE ... CURSOR</link>,
                            <link linkend="psql-statements-open">OPEN</link>, <link
                            linkend="psql-statements-close">CLOSE</link>, <link
                            linkend="psql-statements-fetch">FETCH</link>.</para>
                </formalpara>
            </section>
        </section>
        <section xml:id="psql-statements-forexec">
            <info>
                <title>FOR EXECUTE STATEMENT</title>
                <keywordset>
                    <keyword>FOR</keyword>
                </keywordset>
            </info>

            <indexterm><primary>FOR EXECUTE STATEMENT</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Выполнение динамически созданных SQL операторов с возвратом нескольких строк
                    данных.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
FOR <replaceable>&lt;execute_statement&gt;</replaceable> DO <replaceable>&lt;compound_statement&gt;</replaceable>
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора FOR EXECUTE STATEMENT</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>execute_statement</replaceable></entry>
                                <entry>
                                    <para>Оператор EXECUTE STATEMENT.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>compound_statement</replaceable></entry>
                                <entry>
                                    <para>Составной оператор (оператор или блок операторов).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор FOR EXECUTE STATEMENT используется (по аналогии с конструкцией FOR
                SELECT) для операторов SELECT или EXECUTE BLOCK, возвращающих более одной
                строки.</para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование оператора EXECUTE STATEMENT.</title>
                        <para><programlisting language="sql">
CREATE PROCEDURE DynamicSampleThree (
   Q_FIELD_NAME VARCHAR(100),
   Q_TABLE_NAME VARCHAR(100)
) RETURNS(
  LINE VARCHAR(32000)
)
AS
  DECLARE VARIABLE P_ONE_LINE VARCHAR(100);
BEGIN
  LINE = '';
  FOR 
    EXECUTE STATEMENT 
      'SELECT T1.' || :Q_FIELD_NAME || ' FROM ' || :Q_TABLE_NAME || ' T1 '
    INTO :P_ONE_LINE
  DO
    IF (:P_ONE_LINE IS NOT NULL) THEN
      LINE = :LINE || :P_ONE_LINE || ' ';
  SUSPEND;
END     
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-execstmt">EXECUTE STATEMENT</link>. </para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-open">
            <info>
                <title>OPEN</title>
                <keywordset>
                    <keyword>OPEN</keyword>
                </keywordset>
            </info>

            <indexterm><primary>OPEN</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Открытие курсора.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
OPEN <replaceable>cursor_name</replaceable>;
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора OPEN</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>cursor_name</replaceable></entry>
                                <entry>
                                    <para>Имя курсора. Курсор с таким именем должен быть
                                        предварительно объявлен с помощью оператора DECLARE ...
                                        CURSOR.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор OPEN открывает ранее объявленный курсор, выполняет объявленный в нем
                оператор SELECT и получает записи из результирующего набора данных. Оператор OPEN
                применим только к курсорам, объявленным в операторе <link
                    linkend="psql-statements-declare-cursor">DECLARE ... CURSOR</link>.</para>

            <note>
                <para>Если в операторе SELECT курсора имеются параметры, то они должны быть
                    объявлены как локальные переменные или входные (выходные) параметры до того как
                    объявлен курсор. При открытии курсора параметру присваивается текущее значение
                    переменной.</para>
            </note>

            <formalpara>
                <title>Примеры:</title>
                <para>См. примеры в операторе <link linkend="psql-statements-fetch"
                    >FETCH</link>.</para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-fetch">FETCH</link>, <link
                        linkend="psql-statements-close">CLOSE</link>, <link
                        linkend="psql-statements-declare-cursor">DECLARE ... CURSOR</link>. </para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-fetch">
            <info>
                <title>FETCH</title>
                <keywordset>
                    <keyword>FETCH</keyword>
                </keywordset>
            </info>

            <indexterm><primary>FETCH</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Чтение записи из набора данных, связанного с курсором.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para>
                    <programlisting>
FETCH <replaceable>cursor_name</replaceable> [INTO [:]<replaceable>var_name</replaceable> [, [:]<replaceable>var_name</replaceable> ...]];
                </programlisting>
                    или
                    <programlisting>
FETCH {
    NEXT 
  | PRIOR 
  | FIRST 
  | LAST 
  | ABSOLUTE <replaceable>&lt;n&gt;</replaceable> 
  | RELATIVE <replaceable>&lt;n&gt;</replaceable>
} FROM <replaceable>cursor_name</replaceable> [INTO [:]<replaceable>var_name</replaceable> [,[:]<replaceable>var_name</replaceable> ...]];
                </programlisting>
                </para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора FETCH</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>cursor_name</replaceable></entry>
                                <entry>
                                    <para>Имя курсора. Курсор с таким именем должен быть
                                        предварительно объявлен с помощью оператора DECLARE ...
                                        CURSOR.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>var_name</replaceable></entry>
                                <entry>
                                    <para>PSQL переменная.</para>
                                </entry>
                            </row>
                            <row>
                                <entry><replaceable>n</replaceable></entry>
                                <entry>
                                    <para>Целое число.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор FETCH выбирает следующую строку данных из результирующего набора данных
                курсора и присваивает значения столбцов в переменные PSQL. Оператор FETCH применим
                только к курсорам, объявленным в операторе DECLARE VARIABLE.</para>
            <para>Во второй версии оператора FETCH вы можете указывать в каком направлении и на
                сколько записей продвинется позиция курсора. Предложение NEXT указывает, что
                указатель курсора должен продвинуться на 1 запись вперёд. Это предложение допустимо
                использовать как с прокручиваемыми, там и не прокручиваемыми курсорами. Остальные
                предложения допустимо использовать только с прокручиваемыми курсорами. Предложение
                PRIOR указывает, что указатель курсора должен продвинуться на 1 запись назад.
                Предложение FIRST позволяет переместить позицию курсора на первую запись, а
                предложение LAST – на последнюю. Предложение ABSOLTE позволяет указать номер
                позиции, на которую будет установлен курсор. Номер позиции должен быть в диапазоне
                от 1 до максимального количества записей извлекаемых запросом курсора. Предложение
                RELATIVE позволяет указать, на какое количество записей относительно текущей позиции
                необходимо переместить указатель курсора. Если указано положительное число, то
                курсор перемещает вперёд на N позиций, если отрицательное, то назад.</para>
            <para>Необязательное предложение INTO помещает данные из текущей строки курсора в PSQL
                переменные.</para>
            <para>Позволяется использовать ссылки на курсоры, как на переменные типа запись. Текущая
                запись доступна через имя курсора.</para>
            <para><emphasis role="italic"> Правила</emphasis>: <itemizedlist>
                    <listitem>
                        <para>Для разрешения неоднозначности при доступе к переменной курсора перед
                            именем курсора необходим префикс двоеточие;</para>
                    </listitem>
                    <listitem>
                        <para>К переменной курсора можно получить доступ без префикса двоеточия, но
                            в этом случае, в зависимости от области видимости контекстов,
                            существующих в запросе, имя может разрешиться как контекст запроса
                            вместо курсора;</para>
                    </listitem>
                    <listitem>
                        <para>Переменные курсора доступны только для чтения;</para>
                    </listitem>
                    <listitem>
                        <para>Чтение из переменной курсора возвращает текущие значения полей. Это
                            означает, что оператор UPDATE (с предложением WHERE CURRENT OF) обновит
                            также и значения полей в переменной курсора для последующих чтений.
                            Выполнение оператора DELETE (с предложением WHERE CURRENT OF) установит
                            NULL для значений полей переменной курсора для последующих
                            чтений.</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>Для проверки того, что записи набора данных исчерпаны, используется контекстная
                переменная ROW_COUNT, которая возвращает количество строк выбранных оператором. Если
                произошло чтение очередной записи из набора данных, то ROW_COUNT равняется единице,
                иначе нулю.</para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использования оператора FETCH</title>
                        <para><programlisting language="sql">
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES 
RETURNS (
  RNAME CHAR(63)
) 
AS
  DECLARE C CURSOR FOR (SELECT RDB$RELATION_NAME FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^

SET TERM ;^            
                </programlisting></para>
                    </example>
                    <example>
                        <title>Использования оператора FETCH со вложенными курсорами</title>
                        <para><programlisting language="sql">
EXECUTE BLOCK
RETURNS (
    SCRIPT BLOB SUB_TYPE TEXT)
AS
DECLARE VARIABLE FIELDS VARCHAR(8191);
DECLARE VARIABLE FIELD_NAME TYPE OF RDB$FIELD_NAME;
DECLARE VARIABLE RELATION RDB$RELATION_NAME;
DECLARE VARIABLE SRC   TYPE OF COLUMN RDB$RELATIONS.RDB$VIEW_SOURCE;
-- Объявление именованного курсора
DECLARE VARIABLE CUR_R      CURSOR FOR (
    SELECT
        RDB$RELATION_NAME,
        RDB$VIEW_SOURCE
    FROM
        RDB$RELATIONS
    WHERE
        RDB$VIEW_SOURCE IS NOT NULL);
-- Объявление именованного курсора, в котором
-- используется локальная переменная
DECLARE CUR_F      CURSOR FOR (
    SELECT
        RDB$FIELD_NAME
    FROM
        RDB$RELATION_FIELDS
    WHERE
        -- Важно переменная должна быть объявлена ранее
        RDB$RELATION_NAME = :RELATION);
BEGIN
  OPEN CUR_R;
  WHILE (1 = 1) DO
  BEGIN
    FETCH CUR_R
    INTO :RELATION, :SRC;
    IF (ROW_COUNT = 0) THEN
      LEAVE;

    FIELDS = NULL;
    -- Курсор CUR_F будет использовать значение
    -- переменной RELATION инициализированной выше
    OPEN CUR_F;
    WHILE (1 = 1) DO
    BEGIN
      FETCH CUR_F
      INTO :FIELD_NAME;
      IF (ROW_COUNT = 0) THEN
        LEAVE;
      IF (FIELDS IS NULL) THEN
        FIELDS = TRIM(FIELD_NAME);
      ELSE
        FIELDS = FIELDS || ', ' || TRIM(FIELD_NAME);
    END
    CLOSE CUR_F;

    SCRIPT = 'CREATE VIEW ' || RELATION;

    IF (FIELDS IS NOT NULL) THEN
      SCRIPT = SCRIPT || ' (' || FIELDS || ')';

    SCRIPT = SCRIPT || ' AS ' || ASCII_CHAR(13);
    SCRIPT = SCRIPT || SRC;

    SUSPEND;
  END
  CLOSE CUR_R;
END           
                </programlisting></para>
                    </example>
                    <example>
                        <title>Пример использования оператора FETCH с прокручиваемым
                            курсором</title>
                        <para><programlisting language="sql">
EXECUTE BLOCK
RETURNS (
  N INT,
  RNAME CHAR(63))
AS
  DECLARE C SCROLL CURSOR FOR (
    SELECT
      ROW_NUMBER() OVER(ORDER BY RDB$RELATION_NAME) AS N,
      RDB$RELATION_NAME
    FROM RDB$RELATIONS
    ORDER BY RDB$RELATION_NAME);
BEGIN
  OPEN C;
  -- перемещаемся на первую запись (N=1)
  FETCH FIRST FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  -- перемещаемся на 1 запись вперёд (N=2)
  FETCH NEXT FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  -- перемещаемся на пятую запись (N=5)
  FETCH ABSOLUTE 5 FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  -- перемещаемся на 1 запись назад (N=4)
  FETCH PRIOR FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  -- перемещаемся на 3 записи вперёд (N=7)
  FETCH RELATIVE 3 FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  -- перемещаемся на 5 записей назад (N=2)
  FETCH RELATIVE -5 FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  -- перемещаемся на первую запись (N=1)
  FETCH FIRST FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  -- перемещаемся на последнюю запись
  FETCH LAST FROM C;
  RNAME = C.RDB$RELATION_NAME;
  N = C.N;
  SUSPEND;
  CLOSE C;
END
                </programlisting></para>
                    </example>
                    <example>
                        <title>Использование неявно объявленного курсора как курсорной
                            переменной</title>
                        <para><programlisting language="sql">
EXECUTE BLOCK
RETURNS (
    o CHAR(63))
AS
BEGIN
  FOR
      SELECT
          rdb$relation_name AS name
      FROM
          rdb$relations
      AS CURSOR c
  DO
  BEGIN
    o = c.name;
    SUSPEND;
  END
END           
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-open">OPEN</link>, <link
                        linkend="psql-statements-close">CLOSE</link>, <link
                        linkend="psql-statements-declare-cursor">DECLARE ... CURSOR</link>. </para>
            </formalpara>
        </section>
        <section xml:id="psql-statements-close">
            <info>
                <title>CLOSE</title>
                <keywordset>
                    <keyword>CLOSE</keyword>
                </keywordset>
            </info>

            <indexterm><primary>CLOSE</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Закрытие курсора.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>

            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
CLOSE <replaceable>cursor_name</replaceable>;
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора CLOSE</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>cursor_name</replaceable></entry>
                                <entry>
                                    <para>Имя открытого курсора. Курсор с таким именем должен быть
                                        предварительно объявлен с помощью оператора DECLARE ...
                                        CURSOR.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор CLOSE закрывает открытый курсор. Любые все ещё открытые курсоры будут
                автоматически закрыты после выполнения кода триггера, хранимой процедуры, функции
                или анонимного PSQL блока, в пределах кода которого он был открыт. Оператор CLOSE
                применим только к курсорам, объявленным в операторе <link
                    linkend="psql-statements-declare-cursor">DECLARE ... CURSOR</link>.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>См. примеры в операторе <link linkend="psql-statements-fetch"
                    >FETCH</link>.</para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="psql-statements-fetch">FETCH</link>, <link
                        linkend="psql-statements-open">OPEN</link>, <link
                        linkend="psql-statements-declare-cursor">DECLARE ... CURSOR</link>. </para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-antonomous">
            <info>
                <title>IN AUTONOMOUS TRANSACTION</title>
                <keywordset>
                    <keyword>IN AUTONOMOUS TRANSACTION</keyword>
                </keywordset>
            </info>

            <indexterm><primary>IN AUTONOMOUS TRANSACTION</primary></indexterm>

            <formalpara>
                <title>Назначение:</title>

                <para>Выполнение составного оператора в автономной транзакции.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
IN AUTONOMOUS TRANSACTION DO <replaceable>&lt;compound_statement&gt;</replaceable>
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора IN AUTONOMOUS TRANSACTION</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>compound_statement</replaceable></entry>
                                <entry>
                                    <para>Составной оператор (оператор или блок операторов).</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор IN AUTONOMOUS TRANSACTION позволяет выполнить составной оператор в
                автономной транзакции. Код, работающий в автономной транзакции, будет подтверждаться
                сразу же после успешного завершения независимо от состояния родительской транзакции.
                Это бывает нужно, когда определённые действия не должны быть отменены, даже в случае
                возникновения ошибки в родительской транзакции.</para>
            <para>Автономная транзакция имеет тот же уровень изоляции, что и родительская
                транзакция. Любое исключение, вызванное или появившееся в блоке кода автономной
                транзакции, приведёт к откату автономной транзакции и отмене всех внесённых
                изменений. Если код будет выполнен успешно, то автономная транзакция будет
                подтверждена.</para>

            <formalpara>
                <title>Примеры:</title>

                <para>
                    <example>
                        <title>Использование автономных транзакций</title>
                        <para><programlisting language="sql">
/**
 * Использование автономной транзакции в триггере на событие подключения к базе 
 * данных для регистрации всех попыток соединения, в том числе и неудачных.
 */
CREATE TRIGGER TR_CONNECT ON CONNECT
AS
BEGIN
  -- Все попытки соединения с БД сохраняем в журнал
  IN AUTONOMOUS TRANSACTION DO
    INSERT INTO LOG(MSG)
    VALUES ('USER ' || CURRENT_USER || ' CONNECTS.');
  IF (CURRENT_USER IN (SELECT
                           USERNAME
                       FROM
                           BLOCKED_USERS)) THEN
  BEGIN
    -- Сохраняем в журнал, что попытка соединения
    -- с БД оказалась неудачной
    -- и отправляем сообщение о событии
    IN AUTONOMOUS TRANSACTION DO
    BEGIN
      INSERT INTO LOG(MSG)
      VALUES ('USER ' || CURRENT_USER || ' REFUSED.');
      POST_EVENT 'CONNECTION ATTEMPT' || ' BY BLOCKED USER!';
    END
    -- теперь вызываем исключение
    EXCEPTION EX_BADUSER;
  END
END      
                </programlisting></para>
                    </example>
                </para>
            </formalpara>

            <formalpara>
                <title>См. также:</title>

                <para>
                    <link linkend="transaction">Управление транзакциями</link>.</para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-post">
            <info>
                <title>POST_EVENT</title>
                <keywordset>
                    <keyword>POST_EVENT</keyword>
                </keywordset>
            </info>
            <indexterm><primary>POST_EVENT</primary></indexterm>
            <formalpara>
                <title>Назначение:</title>

                <para>Посылка события (сообщения) клиентским приложениям.</para>
            </formalpara>

            <formalpara>
                <title>Доступно в:</title>

                <para>PSQL.</para>
            </formalpara>
            <formalpara>
                <title>Синтаксис:</title>

                <para><programlisting>
POST_EVENT <replaceable>event_name</replaceable>
                </programlisting></para>
            </formalpara>

            <para>
                <table frame="all">
                    <?dbfo keep-together='auto'?>
                    <title>Параметры оператора POST_EVENT</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                        <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                        <thead>
                            <row>
                                <entry align="center">Параметр</entry>
                                <entry align="center">Описание</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry><replaceable>event_name</replaceable></entry>
                                <entry>
                                    <para>Имя события, ограничено 63 символами.</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </para>

            <para>Оператор POST_EVENT сообщает о событии менеджеру событий, который сохраняет его в
                таблице событий. При подтверждении транзакции менеджер событий информирует
                приложения, ожидающие это событие.</para>
            <para>Имя события это своего рода код или короткое сообщение, выбор за вами, т.к. это
                просто строка длинной до 127 байт.</para>
            <para>В качестве имени события может быть использован строковый литерал, переменная или
                любое правильное SQL выражение.</para>

            <formalpara>
                <title>Примеры:</title>
                <para>
                    <example>
                        <title>Оповещение приложения о вставке записи в таблицу SALES</title>

                        <para><programlisting language="sql"> 
SET TERM ^;
CREATE TRIGGER POST_NEW_ORDER FOR SALES
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
  POST_EVENT 'new_order';
END^
SET TERM ;^
                </programlisting>
                        </para>
                    </example>
                </para>
            </formalpara>
        </section>

        <section xml:id="psql-statements-handleexceptions">
            <info>
                <title>Обработка ошибок</title>
            </info>
            <para>В Firebird существуют PSQL операторы для обработки ошибок и исключений в модулях.
                Существует множество встроенных исключений, которые возникают в случае возникновения
                стандартных ошибок при работе с DML и DDL операторами. </para>
            <section xml:id="psql-sysexcept">
                <title>Системные исключения</title>
                <para>Исключение представляет собой сообщение, которое генерируется, когда возникает
                    ошибка.</para>
                <para>Все обрабатываемые Firebird исключения имеют заранее определённые числовые
                    (символьные) значение для контекстных переменных и связанные с ними тексты
                    сообщений. Сообщения об ошибке написаны по умолчанию на английском языке.
                    Существуют и локализованные сборки СУБД, в которых сообщения об ошибках
                    переведены на другие языки.</para>

                <para>Полный список системных исключений вы можете найти в приложении <link
                        linkend="error">Обработка ошибок, коды и сообщения</link>: <itemizedlist>
                        <listitem>
                            <para><link linkend="error-sqlstate">Коды ошибок SQLSTATE и их
                                    описание</link></para>
                        </listitem>
                        <listitem>
                            <para><link linkend="error-gdscode">Коды ошибок GDSCODE их описание, и
                                    SQLCODE</link></para>
                        </listitem>
                    </itemizedlist>
                </para>

            </section>

            <section xml:id="psql-custexcept">
                <title>Пользовательские исключения</title>
                <para>Пользовательские исключения могут быть объявлены в базе данных как постоянные
                    объекты и вызваны из PSQL кода для сообщения об ошибке при нарушении некоторых
                    бизнес правил. Текст пользовательского исключения ограничен 1021 байтом.
                    Подробности см. <link linkend="ddl-exception-create">CREATE
                    EXCEPTION</link>.</para>
                <para>В коде PSQL исключения обрабатываются при помощи оператора WHEN. Если
                    исключение будет обработано в вашем коде, то вы обеспечите исправление или обход
                    ошибки и позволите продолжить выполнение, — то клиенту не возвращается никакого
                    сообщения об исключении.</para>
                <para>Исключение приводит к прекращению выполнения в блоке. Вместо того чтобы
                    передать выполнение на конечный оператор END, теперь процедура отыскивает уровни
                    во вложенных блоках, начиная с блока где была вызвана ошибка, и переходит на
                    внешние блоки, чтобы найти код обработчика, который &quot;знает&quot; о таком
                    исключении. Она отыскивает первый оператор WHEN, который может обработать эту
                    ошибку. </para>
            </section>

            <section xml:id="psql-statements-exception">
                <info>
                    <title>EXCEPTION</title>
                    <keywordset>
                        <keyword>EXCEPTION</keyword>
                    </keywordset>
                </info>

                <indexterm><primary>EXCEPTION</primary></indexterm>

                <formalpara>
                    <title>Назначение:</title>

                    <para>Возбуждение пользовательского исключения или повторный вызов
                        исключения.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>PSQL.</para>
                </formalpara>

                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
EXCEPTION <replaceable>exception_name</replaceable> [<replaceable>custom_message</replaceable> | USING (<replaceable>&lt;value_list&gt;</replaceable>)]
                    
<replaceable>&lt;value_list&gt;</replaceable> ::=  <replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> [, <replaceable>&lt;val&gt;</replaceable> ...]]                   
                </programlisting></para>
                </formalpara>

                <para>
                    <table frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Параметры оператора EXCEPTION</title>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>exception_name</replaceable></entry>
                                    <entry>
                                        <para>Имя исключения.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>custom_message</replaceable></entry>
                                    <entry>
                                        <para>Альтернативный текст сообщения, выдаваемый при
                                            возникновении исключения. Максимальная длина текстового
                                            сообщения составляет 1021 байт.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>val</replaceable></entry>
                                    <entry>
                                        <para>Значения, которыми заменяются слоты в тексте сообщения
                                            исключения.</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Оператор EXCEPTION возбуждает пользовательское исключение с указанным именем.
                    При возбуждении исключения можно также указать альтернативный текст сообщения,
                    который заменит текст сообщения заданным при создании исключения.</para>
                <para>Текст сообщения исключения может содержать слоты для параметров, которые
                    заполняются при возбуждении исключения. Для передачи значений параметров в
                    исключение используется предложение USING. Параметры рассматриваются слева
                    направо. Каждый параметр передаётся в оператор возбуждающий исключение как N-ый,
                    N начинается с 1: <itemizedlist spacing="compact">
                        <listitem>
                            <para>Если N-ый параметр не передан, его слот не заменяется;</para>
                        </listitem>
                        <listitem>
                            <para>Если передано значение NULL, слот будет заменён на строку
                                '***null***';</para>
                        </listitem>
                        <listitem>
                            <para>Если количество передаваемых параметров будет больше, чем
                                содержится в сообщении исключения, то лишние будут
                                проигнорированы;</para>
                        </listitem>
                        <listitem>
                            <para>Максимальный номер параметра равен 9;</para>
                        </listitem>
                        <listitem>
                            <para>Общая длина сообщения, включая значения параметров, ограничена
                                1053 байтами.</para>
                        </listitem>
                    </itemizedlist>
                </para>

                <note>
                    <para>Статус вектор генерируется, используя комбинацию кодов
                            <replaceable>isc_except</replaceable>, <replaceable>&lt;exception
                            number&gt;</replaceable>,
                            <replaceable>isc_formatted_exception</replaceable>,
                            <replaceable>&lt;formatted exception message&gt;</replaceable>,
                            <replaceable>&lt;exception parameters&gt;</replaceable>.</para>
                    <para>Поскольку используется новый код ошибки
                            (<replaceable>isc_formatted_exception</replaceable>), клиент должен быть
                        версии 3.0 или по крайней мере использовать firebird.msg от версии 3.0 для
                        того чтобы правильно преобразовать статус вектор в строку.</para>
                </note>

                <warning>
                    <para>Если в тексте сообщения, встретится номер слота параметра больше 9, то
                        второй и последующий символ будут восприняты как литералы. Например, @10
                        будет воспринято как @1 после которого следует литерал 0.</para>

                    <formalpara>
                        <title>Пример:</title>

                        <para>
                            <informalexample>
                                <para>
                                    <programlisting language="sql">
CREATE EXCEPTION ex1 
'something wrong in @1 @2 @3 @4 @5 @6 @7 @8 @9 @10 @11';

EXECUTE BLOCK AS
BEGIN
  EXCEPTION ex1 USING ('a','b','c','d','e','f','g','h','i');
END^                           
                        </programlisting>
                                    <screen>
Statement failed, SQLSTATE = HY000
exception 1
-EX1
-something wrong in a b c d e f g h i a0 a1                            
                        </screen>
                                </para>
                            </informalexample>
                        </para>
                    </formalpara>
                </warning>

                <para>Исключение может быть обработано в операторе <link
                        linkend="psql-statements-when">WHEN ... DO</link>. Если пользовательское
                    исключение не было обработано в триггере или в хранимой процедуре, то действия,
                    выполненные внутри этой хранимой процедуры (триггера) отменяются, а вызвавшая
                    программа получает текст, заданный при создании исключения или альтернативный
                    текст сообщения.</para>
                <para>В блоке обработки исключений (и только в нем), вы можете повторно вызвать
                    пойманное исключение или ошибку, вызывая оператор EXCEPTION без параметров. Вне
                    блока с исключением такой вызов не имеет никакого эффекта.</para>

                <formalpara>
                    <title>Примеры:</title>

                    <para>
                        <example>
                            <title>Вызов исключения</title>
                            <para><programlisting language="sql">
CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
DECLARE VARIABLE ord_stat  CHAR(7);
DECLARE VARIABLE hold_stat CHAR(1);
DECLARE VARIABLE cust_no   INTEGER;
DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
      s.order_status,
      c.on_hold,
      c.cust_no
  FROM
      sales s, customer c
  WHERE
      po_number = :po_num AND
      s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  /* Этот заказ уже отправлен на поставку. */
  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped;
  /* Другие операторы */
END       
                </programlisting></para>
                        </example>
                        <example>
                            <title>Вызов исключения с заменой исходного сообщения
                                альтернативным</title>
                            <para><programlisting language="sql">
CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
DECLARE VARIABLE ord_stat  CHAR(7);
DECLARE VARIABLE hold_stat CHAR(1);
DECLARE VARIABLE cust_no   INTEGER;
DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
      s.order_status,
      c.on_hold,
      c.cust_no
  FROM
      sales s, customer c
  WHERE
      po_number = :po_num AND
      s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  /* Этот заказ уже отправлен на поставку. */
  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped 'Order status is "' || ord_stat || '"';
  /* Другие операторы */
END        
                </programlisting></para>
                        </example>
                        <example>
                            <title>Использование параметризованного исключения</title>
                            <para><programlisting language="sql">
CREATE EXCEPTION EX_BAD_SP_NAME
  'Name of procedures must start with ''@1'' : ''@2''';
...
CREATE TRIGGER TRG_SP_CREATE BEFORE CREATE PROCEDURE
AS
  DECLARE SP_NAME VARCHAR(255);
BEGIN
  SP_NAME = RDB$GET_CONTEXT('DDL_TRIGGER', 'OBJECT_NAME');
  IF (SP_NAME NOT STARTING 'SP_') THEN
    EXCEPTION EX_BAD_SP_NAME USING ('SP_', SP_NAME);
END^         
                </programlisting></para>
                        </example>
                    </para>
                </formalpara>

                <formalpara>
                    <title>См. также:</title>

                    <para>
                        <link linkend="ddl-exception-create">CREATE EXCEPTION</link>, <link
                            linkend="psql-statements-when">WHEN ... DO</link>.</para>
                </formalpara>
            </section>

            <section xml:id="psql-statements-when">
                <info>
                    <title>WHEN ... DO</title>
                    <keywordset>
                        <keyword>WHEN</keyword>
                        <keyword>DO</keyword>
                    </keywordset>
                </info>

                <indexterm><primary>WHEN ... DO</primary></indexterm>

                <formalpara>
                    <title>Назначение:</title>

                    <para>Обработка ошибок.</para>
                </formalpara>

                <formalpara>
                    <title>Доступно в:</title>

                    <para>PSQL.</para>
                </formalpara>
                <formalpara>
                    <title>Синтаксис:</title>

                    <para><programlisting>
WHEN {<replaceable>&lt;error&gt;</replaceable> [, <replaceable>&lt;error&gt;</replaceable> ...] | ANY}
DO <replaceable>&lt;compound_statement&gt;</replaceable>

<replaceable>&lt;error&gt;</replaceable> ::= {
    EXCEPTION <replaceable>exception_name</replaceable> 
  | SQLCODE <replaceable>number</replaceable> 
  | GDSCODE <replaceable>errcode</replaceable> 
  | SQLSTATE '<replaceable>sqlstate_code</replaceable>'
}                                                        
                </programlisting></para>
                </formalpara>

                <para>
                    <table frame="all">
                        <?dbfo keep-together='auto'?>
                        <title>Параметры оператора WHEN ... DO</title>
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1" colwidth="1.2*" align="left"/>
                            <colspec colname="c2" colnum="2" colwidth="2.8*" align="justify"/>
                            <thead>
                                <row>
                                    <entry align="center">Параметр</entry>
                                    <entry align="center">Описание</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry><replaceable>exception_name</replaceable></entry>
                                    <entry>
                                        <para>Имя исключения.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>number</replaceable></entry>
                                    <entry>
                                        <para>Код ошибки SQLCODE.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>errcode</replaceable></entry>
                                    <entry>
                                        <para>Символическое имя ошибки GDSCODE.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>sqlstate_code</replaceable></entry>
                                    <entry>
                                        <para>Код ошибки SQLSTATE.</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry><replaceable>compound_statement</replaceable></entry>
                                    <entry>
                                        <para>Составной оператор (оператор или блок
                                            операторов).</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </para>

                <para>Оператор WHEN ... DO используется для обработки ошибочных ситуаций и
                    пользовательских исключений. Оператор перехватывает все ошибки и
                    пользовательские исключения, перечисленные после ключевого слова WHEN. Если
                    после ключевого слова WHEN указано ключевое слово ANY, то оператор перехватывает
                    любые ошибки и пользовательские исключения, даже если они уже были обработаны в
                    вышестоящем WHEN блоке.</para>
                <para>Оператор WHEN ... DO должен находиться в самом конце блока операторов перед
                    оператором END.</para>
                <para>После ключевого слова DO следует составной оператор, в котором можно
                    произвести обработку ошибки или исключения. Составной оператор — это оператор
                    или блок операторов, заключённый в операторные скобки BEGIN и END. В этом
                    операторе доступны контекстные переменные <link
                        linkend="internalfunc-contextvar-gdscode">GDSCODE</link>, <link
                        linkend="internalfunc-contextvar-sqlcode">SQLCODE</link>, <link
                        linkend="internalfunc-contextvar-sqlstate">SQLSTATE</link>. Для получения
                    имени активного пользовательского исключения или текста интерпретированного
                    сообщения об ошибке вы можете воспользоваться системной функцией <link
                        linkend="internalfunc-func-error-rdberror">RDB$ERROR</link>. В этом же блоке
                    доступен оператор повторного вызова ошибки или исключительной ситуации EXCEPTION
                    (без параметров).</para>
                <important>
                    <para>После предложения WHEN GDSCODE вы должны использовать символьные имена -
                        такие, как <replaceable>grant_obj_notfound</replaceable> и т.д. Но в
                        составном операторе после ключевого слова DO доступна контекстная переменная
                        GDSCODE, которая содержит целое число. Для сравнения его с определённой
                        ошибкой вы должны использовать числовое значение, например, 335544551 для
                            <replaceable>grant_obj_notfound</replaceable>.</para>
                </important>
                <para>Оператор WHEN ... DO вызывается только в том случае, если произошло одно из
                    указанных в его условии событий. В случае выполнения оператора (даже если в нем
                    фактически не было выполнено никаких действий) ошибка или пользовательское
                    исключение не прерывает и не отменяет действий триггера или хранимой процедуры,
                    где был выдан этот оператор, работа продолжается, как если бы никаких
                    исключительных ситуаций не было. Однако в этом случае будет отменено действие
                    DML оператора (SELECT, INSERT, UPDATE, DELETE, MERGE), который вызвал ошибку и
                    все ниже находящиеся операторы в том же блоке операторов не будут
                    выполнены.</para>
                <important>
                    <para>Если ошибка вызвана не одним из DML операторов (SELECT, INSERT, UPDATE,
                        DELETE, MERGE), то будет отменен не только оператор вызвавший ошибку, а весь
                        блок операторов. Кроме того, действия в операторе WHEN ... DO так же будут
                        откачены. Это относится также и к оператору выполнения хранимой процедуры
                        EXECUTE PROCEDURE. Подробнее смотри в <link
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://tracker.firebirdsql.org/browse/CORE-4483"
                            >CORE-4483</link>.</para>
                </important>

                <section xml:id="psql-statements-whendo-scope">
                    <title>Область действия оператора WHEN ... DO</title>

                    <para>Оператор перехватывает ошибки и исключения в текущем блоке операторов. Он
                        также перехватывает подобные ситуации во вложенных блоках, если эти ситуации
                        не были в них обработаны.</para>
                    <para>Оператор WHEN ... DO видит все изменения, произведённые до оператора
                        вызвавшего ошибку. Однако если вы попытаетесь запротоколировать их в
                        автономной транзакции, то эти изменения будут не доступны, поскольку на
                        момент старта автономной транзакции, транзакция, в которой произошли эти
                        изменения, не подтверждена.</para>

                    <formalpara>
                        <title>Примеры:</title>

                        <para>
                            <example>
                                <title>Замена стандартной ошибки своей.</title>

                                <para><programlisting language="sql"> 
CREATE EXCEPTION COUNTRY_EXIST '';
SET TERM ^;
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country, currency)
  VALUES (:ACountryName, :ACurrency);
  
  WHEN SQLCODE -803 DO 
    EXCEPTION COUNTRY_EXIST 'Такая страна уже добавлена!';
END^
SET TERM ^;
                </programlisting>
                                </para>
                            </example>
                            <example>
                                <title>Регистрация ошибке в журнале и повторное её возбуждение в
                                    блоке WHEN.</title>

                                <para><programlisting language="sql"> 
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country,
                       currency)
  VALUES (:ACountryName,
          :ACurrency);
  WHEN ANY DO
  BEGIN
    -- Записываем ошибку в журнал
    IN AUTONOMOUS TRANSACTION DO
      INSERT INTO ERROR_LOG (PSQL_MODULE,
                             ERROR_TEXT,
                             EXCEPTION_NAME,  
                             GDS_CODE,
                             SQL_CODE,
                             SQL_STATE)
      VALUES ('ADD_COUNTRY',
              RDB$ERROR(MESSAGE), -- текст сообщения об ошибке
              RDB$ERROR(EXCEPTION), -- имя пользовательского исключения
              GDSCODE, 
              SQLCODE,
              SQLSTATE 
      );
    -- Повторно возбуждаем ошибку
    EXCEPTION;
  END
END
                </programlisting>
                                </para>
                            </example>
                            <example>
                                <title>Обработка в одном WHEN … DO блоке нескольких ошибок</title>

                                <para><programlisting language="sql"> 
...
WHEN GDSCODE GRANT_OBJ_NOTFOUND,
	   GDSCODE GRANT_FLD_NOTFOUND,
	   GDSCODE GRANT_NOPRIV,
	   GDSCODE GRANT_NOPRIV_ON_BASE
DO
BEGIN
	EXECUTE PROCEDURE LOG_GRANT_ERROR(GDSCODE);
	EXIT;
END
...
                </programlisting>
                                </para>
                            </example>
                            <example>
                                <title>Перехват ошибок по коду SQLSTATE.</title>

                                <para><programlisting language="sql"> 
EXECUTE BLOCK
AS
    DECLARE VARIABLE I INT;
BEGIN
  BEGIN
    I = 1 / 0;
    WHEN SQLSTATE '22003' DO
      EXCEPTION E_CUSTOM_EXCEPTION 
        'Numeric value out of range.';
    WHEN SQLSTATE '22012' DO
      EXCEPTION E_CUSTOM_EXCEPTION 'Division by zero.';
    WHEN SQLSTATE '23000' DO
      EXCEPTION E_CUSTOM_EXCEPTION 
        'Integrity constraint violation.';
  END
END
                </programlisting>
                                </para>
                            </example>
                        </para>
                    </formalpara>

                    <formalpara>
                        <title>См. также:</title>

                        <para>
                            <link linkend="ddl-exception">Оператор EXCEPTION</link>, <link
                                linkend="error-sqlstate">Коды ошибок SQLSTATE и их описание</link>,
                                <link linkend="error-gdscode">Коды ошибок GDSCODE и SQLCODE и их
                                описание</link>.</para>
                    </formalpara>
                </section>
                <!-- Scope of WHEN ... Do -->
            </section>
            <!-- WHEN ... DO -->
        </section>
        <!-- handling errors and exceptions -->
    </section>
</chapter>
