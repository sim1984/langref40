[[fblangref_ddl_table]]
= TABLE

Firebird -- это реляционная СУБД.
Данные в таких базах хранятся в таблицах.
Таблица -- это плоская двухмерная структура, содержащая произвольное количество строк (row). Строки таблицы часто называют записями (record). Все строки таблицы имеют одинаковую структуру и состоят из столбцов (column). Столбцы таблицы часто называют полями (fields). Таблица должна иметь хотя бы один столбец.
С каждым столбцом связан определённый тип данных SQL. 

В данном разделе рассматриваются вопросы создания, модификации и удаления таблиц базы данных. 

[[fblangref-ddl-table-create]]
== `CREATE TABLE`

.Назначение
Создание новой таблицы.
(((CREATE TABLE)))

.Доступно в
DSQL, ESQL

[[fblangref-ddl-tbl-create-syntax]]
.Синтаксис
[listing,subs="+quotes,macros"]
----
CREATE [GLOBAL TEMPORARY] TABLE _tablename_
  [EXTERNAL [FILE] '_filespec_']
  (<col_def> [, <col_def> | <tconstraint> ...])  
  [ON COMMIT {DELETE | PRESERVE} ROWS]
  [SQL SECURITY {DEFINER | INVOKER}] 
  [{ENABLE | DISABLE} PUBLICATION]  

<col_def> ::=
    <regular_col_def>
  | <computed_col_def>
  | <identity_col_def>
                    
<regular_col_def> ::= 
  colname { <datatype> | _domain_name_ }
  [DEFAULT {<literal> | NULL | <context_var>}] 
  [NOT NULL]
  [<col_constraint>]
  [COLLATE _collation_name_]
  
                    
<computed_col_def> ::= 
  _colname_ [{ <datatype> | _domain_name_ }]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>) 
                    
<identity_col_def> ::= 
  _colname_ [<datatype>]
  GENERATED {ALWAYS | BY DEFAULT} AS IDENTITY [(<identity column options>)] 
  [<col_constraint>]  
                    
<identity column options> ::=     
  <identity column option> [<identity column option>]

<identity column option> ::=
    START WITH startvalue
  | INCREMENT [BY] incrementvalue
                    
                    
<datatype> ::= 
    <scalar_datatype> | <blob_datatype> | <array_datatype>                    
                    
<scalar_datatype> ::=  См. <<fblangref-datatypes-syntax-scalar,Синтаксис скалярных типов данных>>

<blob_datatype> ::= См. <<fblangref-datatypes-syntax-blob,Синтаксис типа данных BLOB>>

<array_datatype> ::= См. <<fblangref-datatypes-syntax-array,Синтаксис массивов>>
                    
<col_constraint> ::= [CONSTRAINT _constr_name_]
{   UNIQUE [<using_index>] 
  | PRIMARY KEY [<using_index>] 
  | REFERENCES _other_table_ [(_other_col_)]
      [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
      [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
      [<using_index>]
  | CHECK (<check_condition>) 
}          

<tconstraint> ::= [CONSTRAINT _constr_name_]
{   UNIQUE (<col_list>) [<using_index>] 
  | PRIMARY KEY (<col_list>) [<using_index>] 
  | FOREIGN KEY (<col_list>) 
    REFERENCES _other_table_ [(<col_list>)]
      [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
      [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
      [<using_index>]
  | CHECK (<check_condition>) 
}    

<col_list> ::= _colname_ [, _colname_ ...]

<using_index> ::= USING [ASC[ENDING] | DESC[ENDING]] INDEX _indexname_

<check_condition> ::=  
    <val> <operator> <val> 
  | <val> [NOT] BETWEEN <val> AND <val> 
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>) 
  | <val> IS [NOT] NULL 
  | <val> IS [NOT] DISTINCT <val> 
  | <val> IS [NOT] {TRUE | FALSE | UNKNOWN}
  | <val> [NOT] CONTAINING <val> 
  | <val> [NOT] STARTING [WITH] <val> 
  | <val> [NOT] LIKE <val> [ESCAPE <val>] 
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>] 
  | <val> <operator> {ALL | SOME | ANY} (<select_list>) 
  | [NOT] EXISTS (<select_expr>) 
  | [NOT] SINGULAR (<select_expr>)   
  | (<check_condition>)   
  | NOT <check_condition>   
  | <check_condition> OR <check_condition>   
  | <check_condition> AND <check_condition> 
    
 
<operator> ::= 
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>    
                    
<val> ::=  
    _colname_ ['['<array_idx> [, <array_idx> ...]']']
  | <literal>   
  | <context_var>   
  | <expression>   
  | NULL   
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <cast_type>)   
  | (<select_one>)   
  | _func_(<val> [, <val> ...])
     
<cast_type> ::=
   <datatype> 
  | [TYPE OF] _domain_name_
  | TYPE OF COLUMN _rel_._colname_
----


[[fblangref-ddl-tbl-createtbl]]
.Параметры оператора `CREATE TABLE`
[cols="<1,<3", options="header",stripes="none"]
|===
^|Параметр
^|Описание

|tablename
|Имя таблицы, может содержать до 63 символов.

|filespec
|Спецификация файла (только для внешних таблиц).

|colname
|Имя столбца таблицы, может содержать до 63 символов.

|datatype
|Тип данных SQL.

|domain_name
|Имя домена.

|startvalue
|Начальное значение столбца идентификации.

|identityvalue
|Приращение столбца идентификации. Не может быть равно 0.

|col_constraint
|Ограничение столбца.

|tconstraint
|Ограничение таблицы.

|constr_name
|Имя ограничения, может содержать до 63 символов.

|other_table
|Имя таблицы, на которую ссылается внешний ключ.

|other_col
|Столбец таблицы, на которую ссылается внешний ключ.

|using_index
|Позволяет задать имя автоматически создаваемого индекса для ограничения, и опционально определить, какой это будет индекс -- по возрастанию (по умолчанию) или по убыванию.

|literal
|Литерал.

|context_var
|Любая контекстная переменная, тип которой совместим с типом данных столбца.

|check_condition
|Условие проверки ограничения.
Выполняется, если оценивается как `TRUE` или NULL/UNKNOWN.

|collation_name
|Порядок сортировки.
Необходимо указывать если вы хотите чтобы порядок сортировки для столбца отличался от порядка сортировки для набора символов по умолчанию этого столбца. 

|select_one
|Оператор `SELECT` выбирающий один столбец и возвращающий только одну строку.

|select_list
|Оператор `SELECT` выбирающий один столбец и возвращающий ноль и более строк.

|select_expr
|Оператор `SELECT` выбирающий несколько столбцов и возвращающий ноль и более строк.

|experssion
|Выражение.

|genname
|Имя последовательности (генератора).

|func
|Скалярная функция.
|===

Оператор `CREATE TABLE` создаёт новую таблицу.
Имя таблицы должно быть уникальным среди имён всех таблиц, представлений (VIEWs) и хранимых процедур базы данных. 

Таблица может содержать, по меньшей мере, один столбец и произвольное количество ограничений таблицы.

Имя столбца должно быть уникальным для создаваемой таблицы.
Для столбца обязательно должен быть указан либо тип данных, либо имя домена, характеристики которого будут скопированы для столбца, либо должно быть указано, что столбец является вычисляемым.

В качестве типа столбца можно использовать любой тип данных SQL. 

[[fblangref-ddl-table-create-column-character]]
=== Символьные столбцы

Для типов `CHAR`, `VARCHAR` и `BLOB` с подтипом TEXT можно указать набор символов в предложении `CHARACTER SET`.
Если набор символов не указан, то по умолчанию принимается тот набор символов, что был указан при создании базы данных.
Если же при создании базы данных не был указан набор символов, то по умолчанию принимается набор символов NONE.
В этом случае данные хранятся и извлекаются, так как они были поданы.
В столбец можно загружать данные в любой кодировке, но невозможно загрузить эти данные в столбец с другой кодировкой.
Транслитерация между исходными и конечными кодировками не выполняется, что может приводить к ошибкам.

Необязательное предложение `COLLATE` позволяет задать порядок сортировки для строковых типов данных (за исключением `BLOB`). Если порядок сортировки не указан, то по умолчанию принимается порядок сортировки по умолчанию для указанного набора сортировки.

[[_fblangref_ddl_table_create_column_nullable]]
=== Ограничение `NOT NULL`

(((CREATE TABLE, NOT NULL)))
По умолчанию столбец может принимать значение `NULL`.

Необязательное предложение `NOT NULL` указывает, что столбцу не может быть присвоено значение NULL.

[[_fblangref_ddl_table_create_column_default]]
=== Значение по умолчанию

(((CREATE TABLE, DEFAULT)))
Необязательное предложение `DEFAULT` позволяет указать значение по умолчанию для столбца таблицы.
Это значение будет помещено в столбец таблицы при выполнении оператора `INSERT`, если значение не будет указано для этого столбца.
В качестве значения по умолчанию может быть литерал совместимый по типу, неизвестное значение `NULL` или контекстная переменная, тип которой совместим с типом столбца.
Если значение по умолчанию явно не устанавливается, то подразумевается пустое значение, `NULL`.
Использование выражений в значении по умолчанию недопустимо.

[[_fblangref_ddl_table_create_column_domain]]
=== Столбцы основанные на домене

Для определения столбца, можно воспользоваться ранее описанным доменом.
Если определение столбца основано на домене, оно может включать новое значение по умолчанию, дополнительные ограничения `CHECK`, предложение `COLLATE`, которые перекрывают значения указанные при определении домена.
Определение такого столбца может включать дополнительные ограничения столбца, например NOT NULL, если домен его ещё не содержит.

[IMPORTANT]
====
Следует обратить внимание на то, что если в определении домена было указано `NOT NULL`, на уровне столбца невозможно определить допустимость использования в нем значения `NULL`.
Если вы хотите чтобы на основе домена можно было определять столбцы допускающие псевдозначение `NULL` и не допускающее его, то хорошей практикой является создание домена допускающего `NULL` и указание ограничения `NOT NULL` у столбцов таблицы там где это необходимо.
====

[[fblangref-ddl-table-create-column-identity]]
=== Столбцы идентификации (автоинкремент)

(((CREATE TABLE, IDENTITY)))
Столбец идентификации представляет собой столбец, связанный с внутренним генератором последовательностей.
Столбцы идентификации могут быть определены либо с помощью предложения `GENERATED BY DEFAULT AS IDENTITY`, либо предложения `GENERATED ALWAYS AS IDENTITY`.

Если столбец идентификации задан как `GENERATED BY DEFAULT`(((CREATE TABLE, IDENTITY, GENERATED BY DEFAULT))), то его значение будет увеличиваться и использовано как значение по умолчанию при каждой вставке, только в том случае, если значение этого столбца не задано явно.

Чтобы использовать сгенерированное по умолчанию значение, необходимо либо указать ключевое слово `DEFAULT` при вставке в столбец идентификации, или просто не упоминать столбец идентификации в списке столбцов для вставки.
В противном случае будет использовано указанное вами значение.

.Столбец определённый как `GENERATED BY DEFAULT AS IDENTITY`
[example]
====
[source,sql]
----
                    
CREATE TABLE greetings (
  id INT GENERATED BY DEFAULT AS IDENTITY, 
  name CHAR(50));
	
-- specify value "1":
INSERT INTO greetings VALUES (1, 'hi');

-- use generated default
INSERT INTO greetings VALUES (DEFAULT, 'salut');

-- use generated default
INSERT INTO greetings(ch) VALUES ('bonjour');
----
====

[NOTE]
====
Это поведение может быть изменено в операторе INSERT если указана директива `OVERRIDING USER VALUE`.
Подробнее см. <<fblangref-dml-insert-overriding,Директива OVERRIDING>>.
====

Если столбец идентификации задан как `GENERATED ALWAYS`(((CREATE TABLE, IDENTITY, GENERATED ALWAYS))), то его значение будет увеличиваться при каждой вставке.
При попытке явно присвоить значение столбца идентификации в операторе `INSERT`, будет выдано сообщение об ошибке.
В операторе `INSERT` вы можете указать ключевое слово `DEFAULT` вместо значения для столбца идентификации.

[example]
====
[source,sql]
----
                    
create table greetings (
  id INT GENERATED ALWAYS AS IDENTITY, 
  name CHAR(50));
	
INSERT INTO greetings VALUES (DEFAULT, 'hello');

INSERT INTO greetings(ch) VALUES ('bonjour');
----
====

[NOTE]
====
Это поведение может быть изменено в операторе `INSERT` если указана директива `OVERRIDING SYSTEM VALUE`.
Подробнее см. <<fblangref-dml-insert-overriding,Директива `OVERRIDING`>>.
====

Необязательное предложение `START WITH`(((CREATE TABLE, IDENTITY, START WITH))) позволяет указать начальное значение отличное от нуля.
Предложение `INCREMENT [BY]`(((CREATE TABLE, IDENTITY, INCREMENT BY))) устанавливает значение приращения.
Значение приращения должно быть отлично от 0.
По умолчанию значение приращения равно 1.

.Правила
* Тип данных столбца идентификации должен быть целым числом с нулевым масштабом. Допустимыми типами являются `SMALLINT`, `INTEGER`, `BIGINT`, `NUMERIC(x,0)` и `DECIMAL(x,0)`;
* Идентификационный столбец не может иметь `DEFAULT` и `COMPUTED` значений.


[NOTE]
====
* Идентификационный столбец может быть изменён, чтобы стать обычным столбцом. Обычный столбец не может быть изменён, чтобы стать идентификационным.
* Идентификационные столбцы неявно являются `NOT NULL` столбцами.
* Уникальность не обеспечивается автоматически. Ограничения `UNIQUE` или `PRIMARY KEY` требуются для гарантии уникальности.
====

.См. также:
<<fblangref-dml-insert-overriding,Директива OVERRIDING>>.

[[fblangref-ddl-table-create-column-computed]]
=== Вычисляемые поля

(((CREATE TABLE, COMPUTED BY))) (((CREATE TABLE, GENERATED ALWAYS AS)))
Вычисляемые поля могут быть определены с помощью предложения `COMPUTED [BY]` или `GENERATED ALWAYS AS` (согласно стандарту SQL-2003). Они эквивалентны по смыслу.
Для вычисляемых полей не требуется описывать тип данных (но допустимо), СУБД вычисляет подходящий тип в результате анализа выражения.
В выражении требуется указать корректную операцию для типов данных столбцов, входящих в его состав.
При явном указании типа столбца для вычисляемого поля результат вычисления приводится к указанному типу, то есть, например, результат числового выражения можно вывести как строку.
Вычисление выражения происходит для каждой строки выбранных данных, если в операторе выборки данных `SELECT`, присутствует такой столбец.

[TIP]
====
Вместо использования вычисляемого столбца в ряде случаев имеет смысл использовать обычный столбец, значение которого рассчитывается в триггерах на добавление и обновление данных.
Это может снизить производительность вставки/модификации записей, но повысит производительность выборки данных.
====

[[fblangref-ddl-table-create-column-array]]
=== Столбцы типа массив

Для любого типа данных кроме `BLOB` можно указать размерность массива, если столбец должен быть массивом.
Размерность массива указывается в квадратных скобках.
Чтобы не перепутать их с символами, означающими необязательные элементы, они выделены жирным шрифтом.
При указании размерности массива указываются два числа через двоеточие.
Первое число означает начальный номер элемента массива, второе -- конечный.
Если указано только одно число, то оно означает последний номер в элементе массива, а первым номером считается 1.
Для многомерного массива размерности массива перечисляются через запятую.

[[fblangref-ddl-table-create-constraints]]
=== Ограничения

Существуют четыре вида ограничений:

* первичный ключ (`PRIMARY KEY`);
* уникальный ключ (`UNIQUE`);
* внешний ключ (`REFERENCES` или `FOREIGN KEY`);
* проверочное ограничение (`CHECK`).

Ограничения могут быть указаны на уровне столбца ("`ограничения столбцов`") или на уровне таблицы ("`табличные ограничения`").
Ограничения уровня таблицы необходимы, когда ключи (ограничение уникальности, первичный ключ или внешний ключ) должны быть сформированы по нескольким столбцам, или, когда ограничение `CHECK` включает несколько столбцов, т.е.
действует на уровне записи.
Синтаксис для некоторых типов ограничений может незначительно отличаться в зависимости от того определяется ограничение на уровне столбца или на уровне таблицы.

* Ограничение на уровне столбца указывается после определения других характеристик столбца. Оно может включать только столбец указанный в этом определении.
* Ограничения на уровне таблицы указываются после определений всех столбцов. Ограничения таблицы являются более универсальным способом записи ограничений, поскольку позволяют ограничение более чем для одного столбца таблицы.
* Вы можете смешивать ограничения столбцов и ограничения таблиц в одном операторе `CREATE TABLE`.

Системой автоматически создаётся индекс для первичного ключа (`PRIMARY KEY`), уникального ключа (`UNIQUE KEY`) и внешнего ключа (`REFERENCES` для ограничения уровня столбца, и `FOREIGN KEY REFERENCES` для ограничения уровня таблицы).

[[fblangref-ddl-table-create-constraints-named-index]]
==== Имена для ограничений и их индексов

Если имя ограничения не задано, то оно автоматически будет сгенерировано системой. 

Ограничения уровня столбца и их индексы автоматически именуются следующим образом: 

* Имена ограничений имеют следующий вид `INTEG_<n>`, где _n_ представлено одним или несколькими числами;
* Имена индексов имеют вид `RDB$PRIMARY<n>` (для индекса первичного ключа), `RDB$FOREIGN<n>` (для индекса внешнего ключа) или `RDB$<n>` (для индекса уникального ключа), где _n_ представлено одним или несколькими числами;

Схемы автоматического формирования имён для ограничений уровня таблицы и их индексов одинаковы.

[[fblangref-ddl-table-create-constraints-named]]
===== Именованные ограничения

(((CREATE TABLE, CONSTRAINT)))
Имя ограничения можно задать явно, если указать его в необязательном предложении `CONSTRAINT`.
По умолчанию имя индекса ограничения будет тем же самым, что и самого ограничения.
Если для индекса необходимо задать другое имя, то его можно указать в предложении `USING`.

[[_fblangref_ddl_table_create_constraints_using]]
===== Предложение USING

Предложение `USING` позволяет задать определённое пользователем имя автоматически создаваемого индекса для ограничения, и опционально определить, какой это будет индекс -- по возрастанию (по умолчанию) или по убыванию.

[[_fblangref_ddl_table_create_constraints_pk]]
==== Первичный ключ (PRIMARY KEY)

(((CREATE TABLE, PRIMARY KEY)))
Ограничение первичного ключа `PRIMARY KEY` строится на поле с заданным ограничением `NOT NULL` и требует уникальности значений столбца.
Таблица может иметь только один первичный ключ. 

* Первичный ключ по единственному столбцу может быть определён как на уровне столбца, так и на уровне таблицы.
* Первичный ключ по нескольким столбцам может быть определён только на уровне таблицы.


[[fblangref-ddl-table-create-constraints-unique]]
==== Ограничение уникальности (UNIQUE)

(((CREATE TABLE, UNIQUE)))
Ограничение уникального ключа `UNIQUE` задаёт для значений столбца требование уникальности содержимого.
Таблица может содержать любое количество уникальных ключей.

Как и первичный ключ, ограничение уникальности может быть определено на нескольких столбцах.
В этом случае вы должны определять его как ограничение уровня таблицы.

[[fblangref-ddl-table-create-constraints-unique-null]]
===== NULL в уникальных ключах

Согласно стандарту SQL-99 Firebird допускает одно или более значений `NULL` в столбце на который наложено ограничение `UNIQUE`.
Это позволяет определить ограничение `UNIQUE` на столбцах, которые не имеют ограничения `NOT NULL`.

Для уникальных ключей, содержащих несколько столбцов, логика немного сложнее:

* Разрешено множество записей со значением NULL во всех столбцах ключа;
* Разрешено множество записей с различными комбинациями null и not-null значений в ключах;
* Разрешено множество записей, в которых в одном из столбцов уникального ключа содержится значение NULL, а остальные столбцы заполнены значениями и эти значения различны хотя бы в одном из них;
* Разрешено множество записей, в которых в одном из столбцов уникального ключа содержится значение NULL, а остальные столбцы заполнены значениями, и эти значения имеют совпадения хотя бы в одном из них.

Это можно резюмировать следующим примером:

[source,sql]
----
RECREATE TABLE t( x int, y int, z int, unique(x,y,z));
INSERT INTO t values( NULL, 1, 1 );
INSERT INTO t values( NULL, NULL, 1 );
INSERT INTO t values( NULL, NULL, NULL );
INSERT INTO t values( NULL, NULL, NULL ); -- Разрешено
INSERT INTO t values( NULL, NULL, 1 ); -- Запрещено
----

[[fblangref-ddl-table-create-constraints-fk]]
==== Внешний ключ (FOREIGN KEY)

(((CREATE TABLE, FOREIGN KEY)))
Ограничение внешнего ключа гарантирует, что столбец (столбцы) участник может содержать только те значения, которые существуют в указанном столбце (столбцах) главной таблицы.
Эти ссылочные столбцы часто называют столбцами назначения.
Они должны быть первичным ключом или уникальным ключом в целевой таблице.
Они могут не иметь ограничения `NOT NULL`, если они входят в ограничение уникального ключа.

Столбцы внешнего ключа не требуют ограничения `NOT NULL`.

На уровне столбца ограничение внешнего ключа определяется с использованием ключевого слова `REFERENCES`.

[source,sql]
----
... ,
ARTIFACT_ID INTEGER REFERENCES COLLECTION (ARTIFACT_ID),
----

В этом примере столбец ARTIFACT_ID ссылается на столбец с тем же именем в таблице COLLECTION.

На уровне таблицы могут быть определены внешний ключ над одним или несколькими столбцами.
Внешние ключи над несколькими столбцами можно определить только на уровне таблицы.

Синтаксис определения внешнего ключа на уровне таблицы несколько отличается.
После определения всех столбцов, с их ограничения уровня столбца, вы можете определить именованное ограничение внешнего ключа уровня таблицы, используя ключевые слова `FOREIGN KEY` и имён столбцов для которых оно применяется:

[source,sql]
----
... ,
CONSTRAINT FK_ARTSOURCE FOREIGN KEY(DEALER_ID, COUNTRY)
  REFERENCES DEALER (DEALER_ID, COUNTRY),
----

Обратите внимание на то, что имена столбцов в целевой (master) таблице могут отличаться от тех что указаны во внешнем ключе.

[NOTE]
====
Если целевые столбцы не указаны, то внешний ключ автоматически ссылается на столбцы первичного ключа целевой таблицы.
====

[[fblangref-ddl-table-create-constraints-fk-actions]]
===== Действия внешнего ключа

Для обеспечения дополнительной целостности данных можно указать необязательные опции, которые обеспечат согласованность данных между родительскими и дочерними таблицами по заданным правилам:

* Предложение `ON UPDATE` определяет, что произойдёт с записями подчинённой таблицы при изменении значения первичного/уникального ключа в строке главной таблицы.
* Предложение `ON DELETE` определяет, что произойдёт с записями подчинённой таблицы при удалении соответствующей строки главной таблицы.

Для обеспечения ссылочной целостности внешнего ключа, когда изменяется или удаляется значение связанного первичного или уникального ключа, могут быть выполнены следующие действия:


* `NO ACTION` (по умолчанию) -- не будет выполнено никаких действий;
* `CASCADE` -- при изменении или удалении значения первичного ключа над значением внешнего ключа будут произведены те же действия. При выполнении удаления строки в главной таблице в подчинённой таблице должны быть удалены все записи, имеющие те же значения внешнего ключа, что и значение первичного (уникального) ключа удалённой строки главной таблицы. При выполнении обновления записи главной таблицы в подчинённой таблице должны быть изменены все значения внешнего ключа, имеющие те же значения, что и значение первичного (уникального) ключа изменяемой строки главной таблицы;
* `SET DEFAULT` -- значения внешнего ключа всех соответствующих строк в подчинённой таблице устанавливаются в значение по умолчанию, заданное в предложении DEFAULT для этого столбца;
* `SET NULL` -- значения внешнего ключа всех соответствующих строк в подчинённой таблице устанавливаются в пустое значение NULL.


.Внешний ключ с каскадным обновлением и установкой NULL при удалении
[example]
====
[source,sql]
----
                                        
CONSTRAINT FK_ORDERS_CUST
FOREIGN KEY (CUSTOMER) REFERENCES CUSTOMERS (ID)
ON UPDATE CASCADE ON DELETE SET NULL
----
====

[[fblangref-ddl-table-create-constraints-check]]
==== Ограничение CHECK

(((CREATE TABLE, CHECK)))
Ограничение `CHECK` задаёт условие, которому должны удовлетворять значения, помещаемые в данный столбец.
Условие -- это логическое выражение, называемое также предикат, которое может возвращать значения `TRUE` (истина), `FALSE` (ложь) и `UNKNOWN` (неизвестно). Условие считается выполненным, если предикат возвращает значение `TRUE` или `UNKNOWN` (эквивалент `NULL`). Если предикат возвращает `FALSE`, то значение не будет принято.
Это условие используется при добавлении в таблицу новой строки (оператор `INSERT`) и при изменении существующего значения столбца таблицы (оператор `UPDATE`), а также операторов, в которых может произойти одно из этих действий (`UPDATE OR INSERT`, `MERGE`).

[IMPORTANT]
====
При использовании предложения `CHECK` для столбца, базирующегося на домене, следует помнить, что выражение в `CHECK` лишь дополняет условие проверки, которое может уже быть определено в домене.
====

На уровне столбца или таблицы выражение в предложении `CHECK` ссылается на входящее значения с помощью с помощью идентификаторов столбцов, в отличие от доменов, где в ограничении `CHECK` для этих целей используется ключевое слово `VALUE`.

.CHECK ограничения уровня столбца и уровня таблицы
[example]
====
[source,sql]
----

CREATE TABLE PLACES (
  ...
  LAT DECIMAL(9, 6) CHECK (ABS(LAT) <= 90),
  LON DECIMAL(9, 6) CHECK (ABS(LON) <= 180),
  ...
  CONSTRAINT CHK_POLES CHECK (ABS(LAT) < 90 OR LON = 0)
);
----
====

[[fblangref-ddl-table-create-sql-security]]
=== Привилегии выполнения

(((CREATE TABLE, SQL SECURITY)))
Необязательное предложение `SQL SECURITY` в спецификации таблицы позволяет задать с какими привилегиями вычисляются вычисляемые столбцы.
Если выбрана опция `INVOKER`, то вычисляемые столбцы вычисляются с привилегиями вызывающего пользователя.
Если выбрана опция `DEFINER`, то вычисляемые столбцы вычисляются с привилегиями определяющего пользователя (владельца). По умолчанию вычисляемые столбцы вычисляются с привилегиями вызывающего пользователя.
Кроме триггеры наследуют привилегии выполнения таблицы, если они не переопределены у самих триггеров.

[TIP]
====
Привилегии выполнения по умолчанию для вновь создаваемых объектов метаданных можно изменить с помощью оператора

[listing]
----
ALTER DATABASE SET DEFAULT SQL SECURITY {DEFINER | INVOKER}
----
====

[[fblangref-ddl-table-create-publication]]
=== Управление репликацией

(((CREATE TABLE, ENABLE PUBLICATION)))
Необязательное предложение `ENABLE PUBLICATION` включает таблицу в набор репликации (публикацию).
Если ранее был выполнен оператор `ALTER DATABASE ADD ALL TO PUBLICATION`, то таблица будет включена в публикацию
даже если предложение `ENABLE PUBLICATION` не указано.

(((CREATE TABLE, DISABLE PUBLICATION)))
Необязательное предложение `DISABLE PUBLICATION` исключает таблицу из набора репликации (публикации). Это предложение имеет смысл указывать только если ранее был выполнен оператор `ALTER DATABASE ADD ALL TO PUBLICATION`, который автоматически добавляет вновь созданные таблицы в публикацию.

[[fblangref-ddl-table-create-who]]
=== Кто может создать таблицу?

Выполнить оператор `CREATE TABLE` могут: 

* <<fblangref-security-administrators,Администраторы>>
* Пользователи с привилегией `CREATE TABLE`.

Пользователь, создавший таблицу, становится её владельцем.

[[fblangref-ddl-table-create-examples]]
=== Примеры

.Создание таблицы
[example]
====
[source,sql]
----
CREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);
----
====

.Создание таблицы с заданием именованного первичного и уникального ключей
[example]
====
[source,sql]
----
CREATE TABLE STOCK (
  MODEL SMALLINT NOT NULL CONSTRAINT PK_STOCK PRIMARY KEY,
  MODELNAME CHAR(10) NOT NULL,
  ITEMID INTEGER NOT NULL,
  CONSTRAINT MOD_UNIQUE UNIQUE (MODELNAME, ITEMID));
----
====

.Создание таблицы с добавлением её в набор репликации
[example]
====
[source,sql]
----
CREATE TABLE STOCK (
  MODEL SMALLINT NOT NULL CONSTRAINT PK_STOCK PRIMARY KEY,
  MODELNAME CHAR(10) NOT NULL,
  ITEMID INTEGER NOT NULL,
  CONSTRAINT MOD_UNIQUE UNIQUE (MODELNAME, ITEMID))
ENABLE PUBLICATION;
----
====

.Таблица с полем массивом
[example]
====
[source,sql]
----
CREATE TABLE JOB (
    JOB_CODE         JOBCODE NOT NULL,
    JOB_GRADE        JOBGRADE NOT NULL,
    JOB_COUNTRY      COUNTRYNAME,
    JOB_TITLE        VARCHAR(25) NOT NULL,
    MIN_SALARY       NUMERIC(18, 2) DEFAULT 0 NOT NULL,
    MAX_SALARY       NUMERIC(18, 2) NOT NULL,
    JOB_REQUIREMENT  BLOB SUB_TYPE 1,
    LANGUAGE_REQ     VARCHAR(15) [1:5],
    PRIMARY KEY (JOB_CODE, JOB_GRADE, JOB_COUNTRY),
    FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY)
      ON UPDATE CASCADE
      ON DELETE SET NULL,
    CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY) 
);
----
====

.Создание таблицы с ограничением первичного, внешнего и уникального ключа для которых заданы пользовательские имена индексов
[example]
====
[source,sql]
----
CREATE TABLE PROJECT (
    PROJ_ID    PROJNO NOT NULL,
    PROJ_NAME  VARCHAR(20) NOT NULL UNIQUE 
      USING DESC INDEX IDX_PROJNAME,
    PROJ_DESC    BLOB SUB_TYPE 1,
    TEAM_LEADER  EMPNO,
    PRODUCT      PRODTYPE,
    CONSTRAINT PK_PROJECT PRIMARY KEY (PROJ_ID) 
      USING INDEX IDX_PROJ_ID,
    FOREIGN KEY (TEAM_LEADER) REFERENCES EMPLOYEE (EMP_NO) 
      USING INDEX IDX_LEADER
);
----
====

.Создание таблицы со столбцом идентификации BY DEFAULT
[example]
====
[source,sql]
----
CREATE TABLE objects (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(15)
);

INSERT INTO objects (name) VALUES ('Table');
INSERT INTO objects (name) VALUES ('Book');
INSERT INTO objects (id, name) VALUES (10, 'Computer');

SELECT * FROM objects;
----

[listing]
----

ID           NAME
============ ===============
           1 Table
           2 Book
          10 Computer
----
====

.Создание таблицы со столбцом идентификации ALWAYS
[example]
====
[source,sql]
----
CREATE TABLE objects (
  id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name VARCHAR(15)
);

INSERT INTO objects (name) VALUES ('Table');
INSERT INTO objects (name) VALUES ('Book');
INSERT INTO objects (id, name) VALUES (DEFAULT, 'Computer');

SELECT * FROM objects;
----

[listing]
----

ID           NAME
============ ===============
           1 Table
           2 Book
           3 Computer
----
====

.Создание таблицы со столбцом идентификации с начальным значением равным 10 и приращением равным 2
[example]
====
[source,sql]
----

CREATE TABLE objects (
  id INTEGER GENERATED BY DEFAULT AS IDENTITY (STER WITH 10 INCREMENT BY 2) PRIMARY KEY,
  name VARCHAR(15)
);

INSERT INTO objects (name) VALUES ('Table');
INSERT INTO objects (name) VALUES ('Book');
----
----

ID           NAME
============ ===============
          12 Table
          14 Book
----
====

.Создание таблицы с вычисляемыми полями
====
[source,sql]
----

CREATE TABLE SALARY_HISTORY (
    EMP_NO          EMPNO NOT NULL,
    CHANGE_DATE     TIMESTAMP DEFAULT 'NOW' NOT NULL,
    UPDATER_ID      VARCHAR(20) NOT NULL,
    OLD_SALARY      SALARY NOT NULL,
    PERCENT_CHANGE  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    SALARY_CHANGE   GENERATED ALWAYS AS 
      (OLD_SALARY * PERCENT_CHANGE / 100),
    NEW_SALARY      COMPUTED BY 
      (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
);
----

Поле SALARY_CHANGE объявлено согласно стандарту SQL::2003, поле NEW_SALARY в классическом стиле объявления вычисляемых полей в Firebird.


[source,sql]
----
CREATE TABLE SALARY_HISTORY 
(
    EMP_NO          EMPNO NOT NULL,
    CHANGE_DATE     TIMESTAMP DEFAULT 'NOW' NOT NULL,
    UPDATER_ID      VARCHAR(20) NOT NULL,
    OLD_SALARY      SALARY NOT NULL,
    PERCENT_CHANGE  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    SALARY_CHANGE   GENERATED ALWAYS AS 
      (OLD_SALARY * PERCENT_CHANGE / 100),
    NEW_SALARY      COMPUTED BY 
      (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
)
SQL SECURITY DEFINER;
----

То же самое, но вычисляемые столбцы вычисляются с правами определяющего пользователя (владельца таблицы). Кроме триггеры наследуют привилегии выполнения таблицы, если они не переопределены у самих триггеров.
====

[[fblangref-ddl-table-create-gtt]]
=== Глобальные временные таблицы (GTT)

(((CREATE GLOBAL TEMPORARY TABLE)))
Глобальные временные таблицы (в дальнейшем сокращённо "`GTT`") так же, как и обычные таблицы, являются постоянными метаданными, но данные в них ограничены по времени существования транзакцией (значение по умолчанию) или соединением с БД.
Каждая транзакция или соединение имеет свой собственный экземпляр GTT с данными, изолированный от всех остальных.
Экземпляры создаются только при условии обращения к GTT, и данные в ней удаляются при завершении транзакции или отключении от БД.
Метаданные GTT могут быть изменены или удалены с помощью инструкций `ALTER TABLE` и `DROP TABLE`.

.Синтаксис
[listing,subs=+quotes]
----
CREATE GLOBAL TEMPORARY TABLE name
  (<column_def> [, {<column_def> | <table_constraint>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS] 
  [SQL SECURITY {DEFINER | INVOKER}]
----

(((CREATE GLOBAL TEMPORARY TABLE, ON COMMIT DELETE ROWS))) (((CREATE GLOBAL TEMPORARY TABLE, ON COMMIT PRESERVE ROWS)))
Если в операторе создания глобальной временной таблицы указано необязательное предложение `ON COMMIT DELETE ROWS`, то будет создана GTT транзакционного уровня (по умолчанию). При указании предложения `ON COMMIT PRESERVE ROWS` -- будет создана GTT уровня соединения с базой данных.

Предложение `EXTERNAL [FILE]` нельзя использовать для глобальной временной таблицы.

[NOTE]
====
Операторы `COMMIT RETAINING` и `ROLLBACK RETAINING` сохраняют данные в глобальных временных таблицах объявленных как `ON COMMIT DELETE ROWS`.
В Firebird 2.x была ошибка: `COMMIT RETAINING` и `ROLLBACK RETAINING` делали записи не видимыми для текущей транзакции.
Для возврата поведения 2.x установить параметр [parameter]``ClearGTTAtRetaining`` равным 1 в [path]_firebird.conf_.
Этот параметр может быть удалён в Firebird 5.0.
====

==== Ограничения GTT

GTT обладают всеми атрибутами обычных таблиц (ключи, внешние ключи, индексы и триггеры), но имеют ряд ограничений:

* GTT и обычные таблицы не могут ссылаться друг на друга;
* GTT уровня соединения ("`PRESERVE ROWS`") GTT не могут ссылаться на GTT транзакционного уровня ("`DELETE ROWS`");
* Ограничения домена не могут ссылаться на любую GTT;
* Уничтожения экземпляра GTT в конце своего жизненного цикла не вызывает срабатывания триггеров до/после удаления.


[TIP]
====
В существующей базе данных не всегда легко отличить обычную таблицу от GTT, или GTT транзакционного уровня от GTT уровня соединения.
Используйте следующий запрос для определения типа таблицы:

[source,sql]
----
SELECT t.rdb$type_name
FROM rdb$relations r
JOIN rdb$types t ON r.rdb$relation_type = t.rdb$type
WHERE t.rdb$field_name = 'RDB$RELATION_TYPE'
  AND r.rdb$relation_name = 'TABLENAME'
----

Для просмотра информации о типах всех таблиц используйте запрос:

[source,sql]
----
SELECT r.rdb$relation_name, t.rdb$type_name
FROM rdb$relations r
JOIN rdb$types t ON r.rdb$relation_type = t.rdb$type
WHERE t.rdb$field_name = 'RDB$RELATION_TYPE'
  AND coalesce (r.rdb$system_flag, 0) = 0
----

Поле RDB$TYPE_NAME будет отображать PERSISTENT для обычной таблицы, VIEW для представления, GLOBAL_TEMPORARY_PRESERVE для GTT уровня соединения, и GLOBAL_TEMPORARY_DELETE для GTT уровня транзакции.
====

[[fblangref-ddl-table-create-gtt-examples]]
==== Примеры

.Создание глобальной временной таблицы уровня соединения
[example]
====
[source,sql]
----
CREATE GLOBAL TEMPORARY TABLE MYCONNGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
ON COMMIT PRESERVE ROWS;
----
====

.Создание глобальной временной таблицы уровня транзакции ссылающейся внешним ключом на глобальную временную таблицу уровня соединения.
[example]
====
[source,sql]
----
CREATE GLOBAL TEMPORARY TABLE MYTXGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    PARENT_ID INTEGER NOT NULL REFERENCES MYCONNGTT(ID),
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP);
----
====

[[fblangref-ddl-table-create-external]]
=== Внешние таблицы

(((CREATE TABLE, EXTERNAL FILE)))
Необязательное предложение `EXTERNAL [FILE]` указывает, что таблица хранится вне базы данных во внешнем текстовом файле.
Столбцы таблицы, хранящейся во внешнем файле, могут быть любого типа за исключением BLOB и массивов с любым типом данных. 

Над таблицей, хранящейся во внешнем файле, допустимы только операции добавления новых строк (`INSERT`) и выборки (`SELECT`) данных.
Операции же изменения существующих данных (`UPDATE`) или удаления строк такой таблицы (`DELETE`) не могут быть выполнены.

Внешняя таблица не может содержать ограничений первичного, внешнего и уникального ключа.
Для полей такой таблицы невозможно создать индексы. 

Файл с внешней таблицей должен располагаться на устройстве хранения, физически расположенном на сервере, на котором расположена СУБД.
Если параметр [parameter]``ExternalFileAccess`` в файле конфигурации [path]_firebird.conf_ содержит `Restrict`, то файл внешней таблицы должен находится в одном из каталогов, указанных в качестве аргумента `Restrict`.
Если при обращении к таблице Firebird не находит файла, то он создаёт его при первом обращении. 

[IMPORTANT]
====
Возможность использования для таблиц внешних файлов зависит от установки значения параметра [parameter]``ExternalFileAccess`` в файле конфигурации [path]_firebird.conf_: 

* Если он установлен в значение `None`, то запрещён любой доступ к внешнему файлу.
* Значение `Restrict` рекомендуется для ограничения доступа к внешним файлам только каталогами, созданными специально для этой цели администратором сервера. Например: 
+
** `ExternalFileAccess = Restrict _externalfiles_` ограничит доступ директорией [path]_externalfiles_ корневого каталога Firebird.
** `ExternalFileAccess = Restrict d:\databases\outfiles; e:\infiles` ограничит доступ только двумя директориями Windows. Обратите внимание, что любые пути являющиеся отображением сетевых путей не будут работать. Также не будут работать пути заключённые в одинарные или двойные кавычки.
* Значение `Full` позволяет доступ к внешним файлам в любом месте файловой системы хоста. Это создаёт уязвимость и не рекомендуется к использованию.

====

[[fblangref-ddl-table-ext-format]]
==== Формат внешних файлов

Внешняя таблица имеет формат "`строк`" с фиксированной длинной.
Нет никаких разделителей полей: границы полей и строк определяются максимальными размерами в байтах в определении каждого поля.
Это необходимо помнить и при определении структуры внешней таблицы, и при проектировании входного файла для внешней таблицы, в которую должны импортироваться данные из другого приложения.
Например, широко распространённый формат "`.csv`", не может быть использован в качестве входного файла, и не может быть получен непосредственно как внешний файл.

Самым полезным типом данных для столбцов внешних таблиц является тип CHAR с фиксированной длинной, длинна должна подходить под данные с которыми необходимо работать.
Числовые типы и даты легко преобразуются в них, строки получаются как есть, в то время как, если данные не читаются другой базой данных Firebird, то родные типы могут быть нераспознаваемыми дня внешних приложений и являться для них "`абракадаброй`".

Конечно, существуют способы манипулирования типами данных так, чтобы создавать выходные файлы из Firebird, которые могут быть непосредственно прочитаны как входные файлы в других приложениях, используя хранимые процедуры с использованием внешних таблиц или без них.
Описания этих методов выходит за рамки данного руководства.
Здесь мы приведём лишь некоторые рекомендации и советы для создания и работы с простыми текстовыми файлами, поскольку внешняя таблица часто используется как простой способ для создания или чтения транзакционно-независимого журнала.
Эти файлы могут быть прочитаны в оффлайн режиме текстовым редактором или приложением аудита.

[[fblangref-ddl-table-ext-format-delimiter]]
===== Разделитель строк

Как правило, внешние файлы более удобны если строки разделены разделителем, в виде последовательности "новой строки", которая может быть распознана приложением на предназначенной платформе.
Для Windows -- это двухбайтная 'CRLF' последовательность, возврат каретки (ASCII код 13) и перевод строки (ASCII код 10).
Для POSIX -- LF обычно самодостаточен, в некоторых MacOS X приложениях она может быть LFCR.
Существуют различные способы для автоматического заполнения столбца разделителя.
В нашем примере это сделано с помощью `BEFORE INSERT` триггера и встроенной функции `ASCII_CHAR`.

[[fblangref-ddl-table-create-external-examples]]
==== Примеры использования внешних таблиц

В нашем примере мы будем определять внешнюю таблицу журнала, которая может быть использована в обработчике исключений внутри хранимой процедуры или триггера.
Внешняя таблица выбрана потому, что сообщения из любых обрабатываемых исключений будут сохранены в журнале, даже если транзакция, в которой был запущен процесс, будет откачена из-за другого необработанного исключения.
В целях демонстрации наша таблица содержит всего два столбца: метку времени и текстовое сообщение.
Третий столбец хранит разделитель строки:

[source,sql]
----
CREATE TABLE ext_log
EXTERNAL FILE 'd:\externals\log_me.txt' (
   stamp   CHAR(24), 
   message CHAR(100),
   crlf    CHAR(2) -- Для Windows
);   

COMMIT;
----

Теперь создадим триггер, для автоматического сохранения метки времени и разделителя строки, каждый раз когда сообщение записывается в таблицу:

[source,sql]
----
SET TERM ^;
CREATE TRIGGER bi_ext_log FOR ext_log
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (NEW.stamp IS NULL) THEN
    NEW.stamp = CAST (CURRENT_TIMESTAMP AS CHAR(24));
  NEW.crlf = ASCII_CHAR(13) || ASCII_CHAR(10);
END ^
COMMIT ^
SET TERM ;^
----

Вставка некоторых записей (это может быть сделано в обработчике исключения):

[source,sql]
----
INSERT INTO ext_log (message)
VALUES('Shall I compare thee to a summer''s day?');
INSERT INTO ext_log (message)
VALUES('Thou art more lovely and more temperate');
----

Содержимое внешнего файла:

----
2015-10-07 15:19:03.4110Shall I compare thee to a summer's day?
2015-10-07 15:19:58.7600Thou art more lovely and more temperate
----

.См. также:
<<fblangref-ddl-table-alter,ALTER TABLE>>, <<fblangref-ddl-table-alter,DROP TABLE>>, <<fblangref-ddl-domain-create,CREATE DOMAIN>>.

[[fblangref-ddl-table-alter]]
== `ALTER TABLE`

.Назначение
Изменение структуры таблицы.
(((ALTER TABLE)))

.Доступно в
DSQL, ESQL.

.Синтаксис
[listing,subs="+quotes,attributes,macros"]
----
ALTER TABLE tablename 
  <operation> [, <operation>];

<operation> ::=
    ADD <col_def> 
  | ADD <tconstraint> 
  | DROP _colname_
  | DROP CONSTRAINT _constr_name_
  | DROP SQL SECURITY
  | ALTER [COLUMN] colname <col_mod>
  | ALTER SQL SECURITY {DEFINER | INVOKER}
  | {ENABLE | DISABLE} PUBLICATION
                        
<col_def> ::= 
    <regular_col_def> 
  | <computed_col_def> 
  | <identity_col_def>                        

<regular_col_def> ::= 
  colname { <datatype> | _domainname_ }
  [DEFAULT {literal | NULL | <context_var>}]
  [NOT NULL]
  [<col_constraint>]
  [COLLATE _collation_name_]


<computed_col_def>  ::=   
  _colname_ [<datatype>]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>)
                        
<identity_col_def> ::= 
  _colname_ [<datatype>] {ALWAYS | GENERATED BY} DEFAULT AS IDENTITY
  [(START WITH startvalue)] [<col_constraint>]                          

<col_mod> ::= 
     TO _newname_
  |  POSITION _newpos_
  | <regular_col_mod> 
  | <computed_col_mod> 
  | <identity_col_mod> 

<regular_col_mod> ::=                      
  |  TYPE { <datatype>  | _domain_name_ }
  |  SET DEFAULT {_literal_ | NULL | <context_var>}
  |  DROP DEFAULT 
  |  SET NOT NULL
  |  DROP NOT NULL  

<computed_col_mod> ::=
  [TYPE <datatype>] {GENERATED ALWAYS AS | COMPUTED [BY]} (<expression>)  

<identity_col_mod> ::=  
     <alter identity column option> ...
  |  SET GENERATED { ALWAYS | BY DEFAULT } [<alter identity column option> ...]
  |  DROP INDENITY
          
<alter identity column option> ::=
     RESTART [ WITH _startvalue_ ]
  |  SET INCREMENT [BY] _incrementvalue_

<datatype> ::= 
    <scalar_datatype> | <blob_datatype> | <array_datatype>                    
                    
<scalar_datatype> ::=  См. <<fblangref-datatypes-syntax-scalar,Синтаксис скалярных типов данных>>

<blob_datatype> ::= См. <<fblangref-datatypes-syntax-blob,Синтаксис типа данных BLOB>>

<array_datatype> ::= См. <<fblangref-datatypes-syntax-array,Синтаксис массивов>>
                    
<col_constraint> ::= 
  [CONSTRAINT _constr_name_]
  {   UNIQUE [<using_index>] 
    | PRIMARY KEY [<using_index>] 
    | REFERENCES other_table [(other_col)]  
        [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
        [<using_index>]
    | CHECK (<check_condition>) 
  }          

<tconstraint> ::= 
  [CONSTRAINT _constr_name_]
  {   UNIQUE (<col_list>) [<using_index>] 
    | PRIMARY KEY (<col_list>) [<using_index>] 
    | FOREIGN KEY (<col_list>) 
      REFERENCES other_table [(<col_list>)]  
        [ON DELETE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
        [ON UPDATE { NO ACTION | CASCADE | SET DEFAULT | SET NULL}] 
        [<using_index>]
    | CHECK (<check_condition>) 
  }    

<col_list> ::= _colname_ [, _colname_ ...]

<using_index> ::= USING [ASC[ENDING] | DESC[ENDING]] INDEX indexname   

<check_condition> ::=  
    <val> <operator> <val> 
  | <val> [NOT] BETWEEN <val> AND <val> 
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>) 
  | <val> IS [NOT] NULL 
  | <val> IS [NOT] DISTINCT <val> 
  | <val> IS [NOT] {TRUE | FALSE | UNKNOWN}
  | <val> [NOT] CONTAINING <val> 
  | <val> [NOT] STARTING [WITH] <val> 
  | <val> [NOT] LIKE <val> [ESCAPE <val>] 
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>] 
  | <val> <operator> {ALL | SOME | ANY} (<select_list>) 
  | [NOT] EXISTS (<select_expr>) 
  | [NOT] SINGULAR (<select_expr>)   
  | (<check_condition>)   
  | NOT <check_condition>   
  | <check_condition> OR <check_condition>   
  | <check_condition> AND <check_condition> 
    
 
<operator> ::= 
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>       
                    
<val> ::=  
    _colname_ [[<array_idx> [, <array_idx> ...]]]
  | _literal_
  | <context_var>   
  | <expression>   
  | NULL   
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)   
  | (<select_one>)   
  | func(<val> [, <val> ...])   
                       

<cast_type> ::=
   <datatype> 
  | [TYPE OF] _domain_name_
  | TYPE OF COLUMN _rel_._colname_
----

[[fblangref-ddl-tbl-altertbl]]
.Параметры оператора `ALTER TABLE`
[cols="<1,<3", options="header",stripes="none"]
|===
^|Параметр
^|Описание

|tablename
|Имя таблицы.

|operation
|Одна из допустимых операций по изменению структуры таблицы.

|colname
|Имя столбца таблицы, может содержать до 63 символов.
Должно быть уникальным внутри таблицы. 

|newname
|Новое имя столбца таблицы, может содержать до 63 символов.
Должно быть уникальным внутри таблицы. 

|gencolname
|Имя вычисляемого столбца таблицы.

|idencolname
|Имя столбца идентификации.

|newpos
|Новая позиция столбца в таблице.
Целое число в диапазоне от 1 до количества столбцов таблицы. 

|datatype
|Тип данных SQL.

|domain_name
|Имя домена.

|startvalue
|Начальное значение столбца идентификации.

|incrementvalue
|Значение приращения для столбца идентификации.
Должно быть отлично от 0.

|col_constraint
|Ограничение столбца.

|tconstraint
|Ограничение таблицы.

|constr_name
|Имя ограничения, может содержать до 63 символов.

|other_table
|Имя таблицы, на которую ссылается внешний ключ.

|other_col
|Столбец таблицы, на которую ссылается внешний ключ.

|using_index
|Позволяет задать имя автоматически создаваемого индекса для ограничения, и опционально определить, какой это будет индекс -- по возрастанию (по умолчанию) или по убыванию.

|literal
|Литерал.

|context_var
|Любая контекстная переменная, тип которой совместим с типом данных столбца.

|check_condition
|Условие проверки ограничения.
Выполняется, если оценивается как `TRUE` или NULL/UNKNOWN.

|collation_name
|Имя порядка сортировки.
Необходимо указывать если вы хотите чтобы порядок сортировки для столбца отличался от порядка сортировки для набора символов по умолчанию этого столбца. 

|select_one
|Оператор `SELECT` выбирающий один столбец и возвращающий только одну строку.

|select_list
|Оператор `SELECT` выбирающий один столбец и возвращающий ноль и более строк.

|select_expr
|Оператор `SELECT` выбирающий несколько столбцов и возвращающий ноль и более строк.

|experssion
|Выражение.

|genname
|Имя последовательности (генератора).

|func
|Скалярная функция.
|===

Оператор `ALTER TABLE` изменяет структуру существующей таблицы.
Одиночный оператор `ALTER TABLE` позволяет производить множество операций добавления/удаления столбцов и ограничений, а также модификаций столбцов.
Список операций выполняемых при модификации таблицы разделяется запятой. 

[[fblangref-ddl-table-alter-versinc]]
=== Счётчик форматов

Некоторые изменения структуры таблицы увеличивают счётчик форматов, закреплённый за каждой таблицей.
Количество форматов для каждой таблицы ограничено значением 255.
После того как счётчик форматов достигнет этого значения, вы не сможете больше менять структуру таблицы.

[sidebar]
.Сброс счётчика форматов
Для сброса счётчика форматов необходимо сделать резервное копирование и восстановление базы данных (утилитой [app]``gbak``). 

[[fblangref-ddl-table-alter-add]]
=== Предложение `ADD`

(((ALTER TABLE, ADD)))
Предложение `ADD` позволяет добавить новый столбец или новое ограничение таблицы.
Синтаксис определения столбца и синтаксис описания ограничения таблицы полностью совпадают с синтаксисом, описанным в операторе <<fblangref-ddl-table-create,CREATE TABLE>>.

.Воздействие на счётчик форматов:
* При каждом добавлении нового столбца номер формата увеличивается на единицу. 
* Добавление нового ограничения таблицы не влечёт за собой увеличение номера формата.

.Добавление столбца в таблицу
[example]
====
[source,sql]
----
ALTER TABLE COUNTRY
ADD CAPITAL VARCHAR(25);
----
====

.Добавление столбца с ограничением `NOT NULL`
[example]
====
[source,sql]
----
ALTER TABLE OBJECTS
ADD QUANTITY INT DEFAULT 1 NOT NULL;
----
====

[IMPORTANT]
====
Обратите внимание на предложение `DEFAULT`, которое обязательно при добавлении ограничения `NOT NULL`, если в таблице есть данные.
Дело в том, что в этом случае также происходит проверка данных на допустимость.
А поскольку при добавлении нового столбца, он для всех строк таблицы содержит значение `NULL`, будет сгенерировано исключение.
====

.Добавление столбца с ограничением уникальности и удаление другого столбца
[example]
====
[source,sql]
----
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25) UNIQUE,
  DROP CURRENCY;
----
====

(((ALTER TABLE, ADD CONSTRAINT)))
Для добавления ограничений уровня таблицы необходимо использовать предложение `ADD [CONSTRAINT]`.

.Добавление проверочного ограничения и внешнего ключа
[example]
====
[source,sql]
----
ALTER TABLE JOB
ADD CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY),
ADD FOREIGN KEY (JOB_COUNTRY) 
REFERENCES COUNTRY (COUNTRY);
----
====

[WARNING]
====
Будьте осторожны, при добавлении нового ограничения `CHECK` не осуществляется проверка соответствия ему ранее внесённых данных.
Поэтому перед добавлением такого ограничения рекомендуем производить предварительную проверку данных в таблице. 
====

[[fblangref-ddl-table-alter-drop]]
=== Предложение `DROP`

(((ALTER TABLE, DROP)))
Предложение `DROP` удаляет указанный столбец таблицы.
Столбец таблицы не может быть удалён, если от него существуют зависимости.
Другими словами для успешного удаления столбца на него должны отсутствовать ссылки.
Ссылки на столбец могут содержаться: 

* в ограничениях столбцов или таблицы;
* в индексах;
* в хранимых процедурах и триггерах;
* в представлениях.

При каждом удалении столбца номер формата увеличивается на единицу. 

[[fblangref-ddl-tablealter-drop-constraint]]
=== Предложение `DROP CONSTRAINT`

(((ALTER TABLE, DROP CONSTRAINT)))
Предложение `DROP CONSTRAINT` удаляет указанное ограничение столбца или таблицы.
Ограничение первичного ключа или уникального ключа не могут быть удалены, если они используются в ограничении внешнего ключа другой таблицы.
В этом случае необходимо удалить ограничение `FOREIGN KEY` до удаления `PRIMARY KEY` или `UNIQUE` ключа, на которые оно ссылается.

Удаление ограничения столбца или ограничения таблицы не влечёт за собой увеличение номера формата. 

[[fblangref-ddl-table-alter-drop-sql-security]]
=== Предложение `DROP SQL SECURITY`

(((ALTER TABLE, DROP SQL SECURITY)))
Предложение `DROP SQL SECURITY` удаляет привилегии выполнения для таблицы.
После удаления привилегий выполнения вычисляемые столбцы таблицы будут вычисляться с привилегиями вызывающего пользователя.
Триггеры также будут выполняться с привилегиями вызывающего пользователя, если их привилегии выполнения не переопределены в триггере явно.

[[fblangref-ddl-table-alter-alter-column]]
=== Предложение `ALTER [COLUMN]`

(((ALTER TABLE, ALTER [COLUMN])))
Предложение `ALTER [COLUMN]` позволяет изменить следующие характеристики существующих столбцов:

* изменение имени (не изменяет номер формата);
* изменение типа данных (увеличивает номер формата на единицу);
* изменение позиции столбца в списке столбцов таблицы (не изменяет номер формата);
* удаление значения по умолчанию столбца (не изменяет номер формата);
* добавление значения по умолчанию столбца (не изменяет номер формата);
* изменение типа и выражения для вычисляемого столбца (не изменяет номер формата);
* добавление ограничения `NOT NULL` (не изменяет номера формата);
* удаление ограничения `NOT NULL` (не изменяет номера формата).


[[fblangref-ddl-table-alter-alter-column-to]]
==== Переименование столбца

(((ALTER TABLE, ALTER [COLUMN], TO)))
Ключевое слово `TO` переименовывает существующий столбец.
Новое имя столбца не должно присутствовать в таблице. 

Невозможно изменение имени столбца, если этот столбец включён в какое-либо ограничение -- первичный или уникальный ключ, внешний ключ, ограничение столбца или проверочное ограничение таблицы `CHECK`.
Имя столбца также нельзя изменить, если этот столбец таблицы используется в каком-либо триггере, в хранимой процедуре или представлении. 

.Переименование столбца таблицы
[example]
====
[source,sql]
----
ALTER TABLE STOCK
ALTER COLUMN MODELNAME TO NAME;
----
====

[[fblangref-ddl-table-alter-alter-column-type]]
==== Изменение типа столбца

(((ALTER TABLE, ALTER [COLUMN], TYPE)))
Ключевое слово `TYPE` изменяет тип существующего столбца на другой допустимый тип.
Не допустимы любые изменения типа, которые могут привести к потере данных.
Например, количество символов в новом типе для столбца не может быть меньше, чем было установлено ранее. 

Если столбец был объявлен как массив, то изменить ни его тип, ни размерность нельзя.

Нельзя изменить тип данных у столбца, который принимает участие в связке внешний ключ / первичный (уникальный) ключ.

.Изменение типа столбца таблицы
[example]
====
[source,sql]
----
ALTER TABLE STOCK
ALTER COLUMN ITEMID TYPE BIGINT;
----
====

[[fblangref-ddl-table-alter-alter-column-position]]
==== Изменение позиции столбца

(((ALTER TABLE, ALTER [COLUMN], POSITION)))
Ключевое слово `POSITION` изменяет позицию существующего столбца.
Позиции столбцов нумеруются с единицы.

* Если будет задан номер позиции меньше 1, то будет выдано соответствующее сообщение об ошибке.
* Если будет задан номер позиции, превышающий количество столбцов в таблице, то изменения не будут выполнены, но ни ошибки, ни предупреждения не последуют.


.Изменение позиции столбца таблицы
[example]
====
[source,sql]
----
ALTER TABLE STOCK
ALTER COLUMN ITEMID POSITION 5;
----
====

[[fblangref-ddl-table-alter-alter-column-default]]
==== Установка и удаление значения по умолчанию

(((ALTER TABLE, ALTER [COLUMN], DROP DEFAULT)))
Предложение `DROP DEFAULT` удаляет значение по умолчанию для столбца таблицы. 

* Если столбец основан на домене со значением по умолчанию -- доменное значение перекроет это удаление.
* Если удаление значения по умолчанию производится над столбцом, у которого нет значения по умолчанию, или чьё значение по умолчанию основано на домене, то это приведёт к ошибке выполнения данного оператора.


.Удаление значения по умолчанию для столбца
[example]
====
[source,sql]
----
ALTER TABLE STOCK
ALTER COLUMN MODEL DROP DEFAULT;
----
====

(((ALTER TABLE, ALTER [COLUMN], SET DEFAULT)))
Предложение `SET DEFAULT` устанавливает значение по умолчанию для столбца таблицы.
Если столбец уже имел значение по умолчанию, то оно будет заменено новым.
Значение по умолчанию для столбца всегда перекрывает доменное значение по умолчанию.

.Установка значения по умолчанию для столбца
[example]
====
[source,sql]
----
ALTER TABLE STOCK
ALTER COLUMN MODEL SET DEFAULT 1;
----
====

[[fblangref-ddl-table-alter-alter-column-nullable]]
==== Установка и удаление ограничения NOT NULL

(((ALTER TABLE, ALTER [COLUMN], SET NOT NULL)))
Предложение `SET NOT NULL` добавляет ограничение `NOT NULL` для столбца таблицы.

[NOTE]
====
Успешное добавление ограничения `NOT NULL` происходит, только после полной проверки данных таблицы, для того чтобы убедится, что столбец не содержит значений NULL.

Явное ограничение `NOT NULL` на столбце, базирующегося на домене, преобладает над установками домена.
В этом случае изменение домена для допустимости значения NULL, не распространяется на столбец таблицы. 
====

.Добавление ограничения `NOT NULL`
[example]
====
[source,sql]
----
ALTER TABLE STOCK
ALTER COLUMN PROPID SET NOT NULL;
----
====

(((ALTER TABLE, ALTER [COLUMN], DROP NOT NULL)))
Предложение `DROP NOT NULL` удаляет ограничение `NOT NULL` для столбца таблицы.
Если столбец основан на домене с ограничением `NOT NULL`, то ограничение домена перекроет это удаление.

.Удаление ограничения `NOT NULL`
[example]
====
[source,sql]
----
ALTER TABLE STOCK
ALTER COLUMN ITEMID DROP NOT NULL;
----
====

[[fblangref-ddl-table-alter-alter-column-identity]]
==== Изменение столбцов идентификации

(((ALTER TABLE, ALTER [COLUMN], SET GENERATED)))
Для столбцов идентификации позволено изменять способ генерации, начальное значение и значение приращения. 

Предложение `SET GENERATED` позволяет изменить способ генерации столбца идентификации.
Существует два способа генерации столбца идентификации:

* `BY DEFAULT` столбцы позволяют переписать сгенерированное системой значение в операторах `INSERT`, `UPDATE OR INSERT`, `MERGE` просто указав значение этого столбца в списке значений.
* `ALWAYS` столбцы не позволяют переписать сгенерированное системой значение, при попытке переписать значение такого столбца идентификации будет выдана ошибка. Переписать значение этого столбца в операторе INSERT можно только при указании директивы <<fblangref-dml-insert-overriding,OVERRIDING SYSTEM VALUE>>.


.Изменение способа генерации столбца идентификации
[example]
====
[source,sql]
----
ALTER TABLE objects
ALTER ID SET GENERATED ALWAYS;
----
====

(((ALTER TABLE, ALTER [COLUMN], RESTART))) (((ALTER TABLE, ALTER [COLUMN], RESTART WITH)))
Если указано только предложение `RESTART`, то происходит сброс значения генератора в ноль.
Необязательное предложение `WITH` позволяет указать для нового значения внутреннего генератора отличное от нуля значение.

.Изменение текущего значения генератора для столбца идентификации
[example]
====
[source,sql]
----
ALTER TABLE objects
ALTER ID RESTART WITH 100;
----
====

(((ALTER TABLE, ALTER [COLUMN], SET INCREMENT)))
Предложение `SET INCREMENT [BY]` позволяет изменить значение приращения столбца идентификации.
Значение приращения должно быть отлично от 0.

.Изменение приращения столбца идентификации
[example]
====
[source,sql]
----
ALTER TABLE objects
ALTER ID SET INCREMENT BY 2;
----
====

В одном операторе можно изменить сразу несколько свойств столбца идентификации, например:

.Изменение нескольких свойств столбца идентификации
[example]
====
[source,sql]
----
ALTER TABLE objects
ALTER ID SET GENERATED ALWAYS RESTART SET INCREMENT BY 2;
----
====

(((ALTER TABLE, ALTER [COLUMN], DROP IDENTITY)))
Предложение `DROP IDENTITY` удаляет связанный со столбцом идентификации системную последовательность и преобразует его в обычный столбец.

.Превращение столбца идентификации в обычный столбец
[example]
====
[source,sql]
----
ALTER TABLE objects
ALTER ID DROP INDENTITY;
----
====

[[fblangref-ddl-table-alter-alter-column-computed]]
==== Изменение вычисляемых столбцов

(((ALTER TABLE, ALTER [COLUMN], GENERATED ALWAYS AS))) (((ALTER TABLE, ALTER [COLUMN], COMPUTED BY)))
Для вычисляемых столбцов (`GENERATED ALWAYS AS` или `COMPUTED BY`) позволяется изменить тип и выражение вычисляемого столбца.
Невозможно изменить обычный столбец на вычисляемый и наоборот. 

.Изменение вычисляемых столбцов
[example]
====
[source,sql]
----
ALTER TABLE SALARY_HISTORY
ALTER NEW_SALARY GENERATED ALWAYS 
AS (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100),
ALTER SALARY_CHANGE COMPUTED 
BY (OLD_SALARY * PERCENT_CHANGE / 100);
----
====

[[fblangref-ddl-table-alter-alter-column-cannot]]
==== Не изменяемые атрибуты

На данный момент не существует возможности изменить сортировку по умолчанию. 

[[fblangref-ddl-table-alter-sql-security]]
=== Предложение `ALTER SQL SECURITY`

(((ALTER TABLE, ALTER SQL SECURITY)))
Предложение `ALTER SQL SECURITY` позволяет изменить привилегии с которыми вычисляются вычисляемые столбцы.
Если выбрана опция `INVOKER`, то вычисляемые столбцы вычисляются с привилегиями вызывающего пользователя.
Если выбрана опция `DEFINER`, то вычисляемые столбцы вычисляются с привилегиями определяющего пользователя (владельца). По умолчанию вычисляемые столбцы вычисляются с привилегиями вызывающего пользователя.
Кроме того триггеры наследуют привилегии выполнения у таблицы, если они не переопределены у самих триггеров.

[example]
====
[source,sql]
----
ALTER TABLE COUNTRY
ALTER SQL SECURITY DEFINER;
----
====

[[fblangref-ddl-table-alter-publication]]
=== Управление репликацией

(((ALTER TABLE, ENABLE PUBLICATION))) (((ALTER TABLE, DISABLE PUBLICATION)))
Предложение `ENABLE PUBLICATION` включает таблицу в набор репликации (публикацию). Соответственно предложение `DISABLE PUBLICATION` исключает таблицу из набора репликации.

.Добавление таблицы в набор репликации
[example]
====
[source,sql]
----
ALTER TABLE COUNTRY
ENABLE PUBLICATION;
----
====

[[fblangref-ddl-table-alter-who]]
=== Кто может изменить таблицу?

Выполнить оператор `ALTER TABLE` могут: 

* <<fblangref-security-administrators,Администраторы>>
* Владелец таблицы; 
* Пользователи с привилегией `ALTER ANY TABLE`.

.См. также:
<<fblangref-ddl-table-create,CREATE TABLE>>, <<fblangref-ddl-table-recreate,RECREATE TABLE>>.

[[fblangref-ddl-table-drop]]
== `DROP TABLE`

.Назначение
Удаление существующей таблицы.
(((DROP TABLE)))

.Доступно в
DSQL, ESQL.

.Синтаксис
[listing,subs="+quotes"]
----
DROP TABLE _tablename_
----

.Параметры оператора `DROP TABLE`
[cols="<1,<3", options="header",stripes="none"]
|===
^|Параметр
^|Описание

|tablename
|Имя таблицы.
|===

Оператор `DROP TABLE` удаляет существующую таблицу.
Если таблица имеет зависимости, то удаление не будет произведено.
При удалении таблицы будут также удалены все триггеры на её события и индексы, построенные для её полей.

.Удаление таблицы
[example]
====
[source,sql]
----
DROP TABLE COUNTRY;
----
====

[[fblangref-ddl-table-drop-who]]
=== Кто может удалить таблицу?

Выполнить оператор `DROP TABLE` могут: 

* <<fblangref-security-administrators,Администраторы>>
* Владелец таблицы; 
* Пользователи с привилегией `DROP ANY TABLE`.


.См. также:
<<fblangref-ddl-table-create,CREATE TABLE>>, <<fblangref-ddl-table-recreate,RECREATE TABLE>>.

[[fblangref-ddl-table-recreate]]
== `RECREATE TABLE`

.Назначение
Создание новой таблицы или пересоздание существующей.
(((RECREATE TABLE)))

.Доступно в
DSQL.

.Синтаксис
[listing,subs="+quotes"]
----
RECREATE [GLOBAL TEMPORARY] TABLE _tablename_
  [EXTERNAL [FILE] '_filespec_']
  (<col_def> [, <col_def> | <tconstraint> ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
  [SQL SECURITY {DEFINER | INVOKER}]
----

Полное описание определений столбцов и ограничений таблицы смотрите в разделе <<fblangref-ddl-table-create,CREATE TABLE>>.

Создаёт или пересоздаёт таблицу.
Если таблица с таким именем уже существует, то оператор `RECREATE TABLE` попытается удалить её и создать новую.
Оператор `RECREATE TABLE` не выполнится, если существующая таблица имеет зависимости.

[[fblangref-ddl-table-recreate-examples]]
=== Примеры

.Создание или пересоздание таблицы
[example]
====
[source,sql]
----
RECREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);
----
====

.См. также:
<<fblangref-ddl-table-create,CREATE TABLE>>, <<fblangref-ddl-table-drop,DROP TABLE>>.
